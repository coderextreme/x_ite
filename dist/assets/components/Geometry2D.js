/* X_ITE v7.0.0 *//******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DConstants.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let
   browserEvent = 0,
   loadState    = 0,
   fieldType    = 0;

const X3DConstants =
{
   // Browser event

   CONNECTION_ERROR:  browserEvent ++,
   BROWSER_EVENT:     browserEvent ++,
   INITIALIZED_EVENT: browserEvent ++,
   SHUTDOWN_EVENT:    browserEvent ++,
   INITIALIZED_ERROR: browserEvent ++,

   // Load state

   NOT_STARTED_STATE: loadState ++,
   IN_PROGRESS_STATE: loadState ++,
   COMPLETE_STATE:    loadState ++,
   FAILED_STATE:      loadState ++,

   // Access type

   initializeOnly: 0b001,
   inputOnly:      0b010,
   outputOnly:     0b100,
   inputOutput:    0b111,

   // X3DField

   SFBool:      fieldType ++,
   SFColor:     fieldType ++,
   SFColorRGBA: fieldType ++,
   SFDouble:    fieldType ++,
   SFFloat:     fieldType ++,
   SFImage:     fieldType ++,
   SFInt32:     fieldType ++,
   SFMatrix3d:  fieldType ++,
   SFMatrix3f:  fieldType ++,
   SFMatrix4d:  fieldType ++,
   SFMatrix4f:  fieldType ++,
   SFNode:      fieldType ++,
   SFRotation:  fieldType ++,
   SFString:    fieldType ++,
   SFTime:      fieldType ++,
   SFVec2d:     fieldType ++,
   SFVec2f:     fieldType ++,
   SFVec3d:     fieldType ++,
   SFVec3f:     fieldType ++,
   SFVec4d:     fieldType ++,
   SFVec4f:     fieldType ++,

   VrmlMatrix:  fieldType ++,

   // X3DArrayField

   MFBool:      fieldType ++,
   MFColor:     fieldType ++,
   MFColorRGBA: fieldType ++,
   MFDouble:    fieldType ++,
   MFFloat:     fieldType ++,
   MFImage:     fieldType ++,
   MFInt32:     fieldType ++,
   MFMatrix3d:  fieldType ++,
   MFMatrix3f:  fieldType ++,
   MFMatrix4d:  fieldType ++,
   MFMatrix4f:  fieldType ++,
   MFNode:      fieldType ++,
   MFRotation:  fieldType ++,
   MFString:    fieldType ++,
   MFTime:      fieldType ++,
   MFVec2d:     fieldType ++,
   MFVec2f:     fieldType ++,
   MFVec3d:     fieldType ++,
   MFVec3f:     fieldType ++,
   MFVec4d:     fieldType ++,
   MFVec4f:     fieldType ++,

   // Abstract node

   X3DBaseNode: 0,
};

/* harmony default export */ const Base_X3DConstants = (X3DConstants);

;// CONCATENATED MODULE: ./src/x_ite/InputOutput/Generator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function Generator_Generator ()
{
   this .indent              = "";
   this .indentChar          = "  ";
   this .precision           = 6;
   this .doublePrecision     = 14;
   this .removeTrailingZeros = /\.?0*(?=$|[eE])/;

   this .executionContextStack = [ null ];
   this .importedNodesIndex    = new Map ();
   this .exportedNodesIndex    = new Map ();
   this .nodes                 = new Set ();
   this .names                 = new Map ();
   this .namesByNode           = new Map ();
   this .importedNames         = new Map ();
   this .routeNodes            = new Set ();
   this .level                 = 0;
   this .newName               = 0;
   this .containerFields       = [ ];
   this .units                 = true;
   this .unitCategories        = [ ];

   this .names .set (null, new Map ());
}

Generator_Generator .prototype =
{
   constructor: Generator_Generator,
   Indent: function ()
   {
      return this .indent;
   },
   IncIndent: function ()
   {
      this .indent += this .indentChar;
   },
   DecIndent: function ()
   {
      this .indent = this .indent .substr (0, this .indent .length - this .indentChar .length);
   },
   PadRight: function (string, pad)
   {
      for (let i = 0, length = pad - string .length; i < length; ++ i)
         string += " ";

      return string;
   },
   Precision: function (value)
   {
      return Math .fround (value) .toPrecision (this .precision) .replace (this .removeTrailingZeros, "");
   },
   DoublePrecision: function (value)
   {
      return value .toPrecision (this .doublePrecision) .replace (this .removeTrailingZeros, "");
   },
   PushExecutionContext: function (executionContext)
   {
      this .executionContextStack .push (executionContext);

      if (! this .names .has (executionContext))
         this .names .set (executionContext, new Map ());

      if (! this .importedNodesIndex .has (executionContext))
         this .importedNodesIndex .set (executionContext, new Set ());

      if (! this .exportedNodesIndex .has (executionContext))
         this .exportedNodesIndex .set (executionContext, new Set ());
   },
   PopExecutionContext: function ()
   {
      this .executionContextStack .pop ();

      if (this .ExecutionContext ())
         return;

      this .importedNodesIndex .clear ();
      this .exportedNodesIndex .clear ();
   },
   ExecutionContext: function ()
   {
      return this .executionContextStack .at (-1);
   },
   EnterScope: function ()
   {
      if (this .level === 0)
         this .newName = 0;

      ++ this .level;
   },
   LeaveScope: function ()
   {
      -- this .level;

      if (this .level === 0)
      {
         this .nodes         .clear ();
         this .namesByNode   .clear ();
         this .importedNames .clear ();
      }
   },
   ExportedNodes: function (exportedNodes)
   {
      const index = this .exportedNodesIndex .get (this .ExecutionContext ());

      exportedNodes .forEach (function (exportedNode)
      {
         try
         {
            index .add (exportedNode .getLocalNode ())
         }
         catch (error)
         { }
      });
   },
   ImportedNodes: function (importedNodes)
   {
      const index = this .importedNodesIndex .get (this .ExecutionContext ());

      importedNodes .forEach (function (importedNode)
      {
         try
         {
            index .add (importedNode .getInlineNode ());
         }
         catch (error)
         { }
      });
   },
   AddImportedNode: function (exportedNode, importedName)
   {
      this .importedNames .set (exportedNode, importedName);
   },
   AddRouteNode: function (routeNode)
   {
      this .routeNodes .add (routeNode);
   },
   ExistsRouteNode: function (routeNode)
   {
      return this .routeNodes .has (routeNode);
   },
   IsSharedNode: function (baseNode)
   {
      return this .ExecutionContext () !== baseNode .getExecutionContext ();
   },
   AddNode: function (baseNode)
   {
      this .nodes .add (baseNode);

      this .AddRouteNode (baseNode);
   },
   ExistsNode: function (baseNode)
   {
      return this .nodes .has (baseNode);
   },
   Name: (function ()
   {
      const _TrailingNumbers = /_\d+$/;

      return function (baseNode)
      {
         // Is the node already in index

         const name = this .namesByNode .get (baseNode);

         if (name !== undefined)
         {
            return name;
         }
         else
         {
            const names = this .names .get (this .ExecutionContext ());

            // The node has no name

            if (baseNode .getName () .length === 0)
            {
               if (this .NeedsName (baseNode))
               {
                  const name = this .UniqueName ();

                  names .set (name, baseNode);
                  this .namesByNode .set (baseNode, name);

                  return name;
               }

               // The node doesn't need a name

               return baseNode .getName ();
            }

            // The node has a name

            let   name      = baseNode .getName ();
            const hasNumber = name .match (_TrailingNumbers) !== null;

            name = name .replace (_TrailingNumbers, "");

            if (name .length === 0)
            {
               if (this .NeedsName (baseNode))
                  name = this .UniqueName ();

               else
                  return "";
            }
            else
            {
               let
                  i       = 0,
                  newName = hasNumber ? name + '_' + (++ i) : name;

               while (names .has (newName))
               {
                  newName = name + '_' + (++ i);
               }

               name = newName;
            }

            names .set (name, baseNode);
            this .namesByNode .set (baseNode, name);

            return name;
         }
      };
   })(),
   NeedsName: function (baseNode)
   {
      if (baseNode .getCloneCount () > 1)
         return true;

      if (baseNode .hasRoutes ())
         return true;

      const
         executionContext = baseNode .getExecutionContext (),
         index            = this .importedNodesIndex .get (executionContext);

      if (index)
      {
         if (index .has (baseNode))
            return true;
      }
      else
      {
         const index = this .exportedNodesIndex .get (executionContext);

         if (index)
         {
            if (index .has (baseNode))
               return true;
         }

         return false;
      }
   },
   UniqueName: function ()
   {
      const names = this .names .get (this .ExecutionContext ());

      for (; ;)
      {
         const name = '_' + (++ this .newName);

         if (names .has (name))
            continue;

         return name;
      }
   },
   LocalName: function (baseNode)
   {
      const importedName = this .importedNames .get (baseNode);

      if (importedName !== undefined)
         return importedName;

      if (this .ExistsNode (baseNode))
         return this .Name (baseNode);

      throw new Error ("Couldn't get local name for node '" + baseNode .getTypeName () + "'.");
   },
   PushContainerField: function (field)
   {
      this .containerFields .push (field);
   },
   PopContainerField: function ()
   {
      this .containerFields .pop ();
   },
   ContainerField: function ()
   {
      if (this .containerFields .length)
         return this .containerFields [this .containerFields .length - 1];

      return null;
   },
   AccessType: function (accessType)
   {
      switch (accessType)
      {
         case Base_X3DConstants.initializeOnly:
            return "initializeOnly";
         case Base_X3DConstants.inputOnly:
            return "inputOnly";
         case Base_X3DConstants.outputOnly:
            return "outputOnly";
         case Base_X3DConstants.inputOutput:
            return "inputOutput";
      }
   },
   SetUnits: function (value)
   {
      this .units = value;
   },
   GetUnits: function ()
   {
      return this .units;
   },
   PushUnitCategory: function (category)
   {
      this .unitCategories .push (category);
   },
   PopUnitCategory: function ()
   {
      this .unitCategories .pop ();
   },
   Unit: function (category)
   {
      if (this .unitCategories .length == 0)
         return category;

      return this .unitCategories .at (-1);
   },
   ToUnit: function (category, value)
   {
      if (this .units)
      {
         const executionContext = this .ExecutionContext ();

         if (executionContext)
            return executionContext .toUnit (category, value);
      }

      return value;
   },
   XMLEncode: function (string)
   {
      return string
         .replace (/&/g, "&amp;")
         .replace (/\\/g, "&#92;")
         .replace (/\t/g, "&#x9;")
         .replace (/\n/g, "&#xA;")
         .replace (/\r/g, "&#xD;")
         .replace (/</g, "&lt;")
         .replace (/>/g, "&gt;")
         .replace (/'/g, "&apos;")
         .replace (/"/g, "\\\"");
   },
   escapeCDATA: function (string)
   {
      return string .replace (/\]\]\>/g, "\\]\\]\\>");
   },
};

for (const key of Reflect .ownKeys (Generator_Generator .prototype))
   Object .defineProperty (Generator_Generator .prototype, key, { enumerable: false });

Generator_Generator .Get = function (stream)
{
   if (! stream .generator)
      stream .generator = new Generator_Generator ();

   return stream .generator;
};

/* harmony default export */ const InputOutput_Generator = (Generator_Generator);

;// CONCATENATED MODULE: ./src/standard/Utility/MapUtilities.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const MapUtilities = {
   assign: (function ()
   {
      function callback (value, key)
      {
         this .set (key, value);
      }

      return function (m1, m2)
      {
         m1 .clear ();
         m2 .forEach (callback, m1);

         return m1;
      };
   })(),
   values: (function ()
   {
      function callback (value)
      {
         this .push (value);
      }

      return function (a, m)
      {
         a .length = 0;

         m .forEach (callback, a);

         return a;
      };
   })(),
};

/* harmony default export */ const Utility_MapUtilities = (MapUtilities);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   _name      = Symbol (),
   _interests = Symbol (),
   _values    = Symbol ();

function X3DObject () { }

X3DObject .prototype =
{
   constructor: X3DObject,
   [_name]: "",
   [_interests]: new Map (),
   [_values]: [ ],
   getId: function ()
   {
      return X3DObject .getId (this);
   },
   getTypeName: function ()
   {
      return "X3DObject";
   },
   setName: function (value)
   {
      this [_name] = value;
   },
   getName: function ()
   {
      return this [_name];
   },
   getDisplayName: function ()
   {
      return this [_name];
   },
   getInterestId: function (callbackName, object)
   {
      return X3DObject .getId (object) + "." + String (callbackName);
   },
   hasInterest: function (callbackName, object)
   {
      return this [_interests] .has (this .getInterestId (callbackName, object));
   },
   addInterest: function (callbackName, object)
   {
      if (this [_interests] === X3DObject .prototype [_interests])
      {
         this [_interests] = new Map ();
         this [_values]    = [ ];
      }

      const
         interestId = this .getInterestId (callbackName, object),
         callback   = object [callbackName];

      if (arguments .length > 2)
      {
         const args = Array .prototype .slice .call (arguments, 2);

         args .unshift (object);
         args .push (this);

         this [_interests] .set (interestId, Function .prototype .bind .apply (callback, args));
      }
      else
      {
         this [_interests] .set (interestId, callback .bind (object, this));
      }
   },
   removeInterest: function (callbackName, object)
   {
      this [_interests] .delete (this .getInterestId (callbackName, object));
   },
   getInterests: function ()
   {
      return this [_interests];
   },
   processInterests: function ()
   {
      if (this [_interests] .size)
      {
         for (const interest of Utility_MapUtilities.values (this [_values], this [_interests]))
            interest ();
      }
   },
   toString: function (scene)
   {
      const stream = { string: "" };

      if (scene)
         InputOutput_Generator.Get (stream) .PushExecutionContext (scene);

      this .toStream (stream);

      return stream .string;
   },
   toVRMLString: function ()
   {
      const stream = { string: "" };

      this .toVRMLStream (stream);

      return stream .string;
   },
   toXMLString: function ()
   {
      const stream = { string: "" };

      this .toXMLStream (stream);

      return stream .string;
   },
   toJSONString: function ()
   {
      const stream = { string: "" };

      this .toVRMLStream (stream); // TODO.

      return stream .string;
   },
   toStream: function (stream)
   {
      stream .string = "[object " + this .getTypeName () + "]";
   },
   dispose: function () { },
};

for (const key of Reflect .ownKeys (X3DObject .prototype))
   Object .defineProperty (X3DObject .prototype, key, { enumerable: false });

X3DObject .getId = (function ()
{
   const map = new WeakMap ();

   let counter = 0;

   return function (object)
   {
      const id = map .get (object);

      if (id !== undefined)
         return id;

      map .set (object, ++ counter);

      return counter;
   };
})();

/* harmony default export */ const Base_X3DObject = (X3DObject);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DChildObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _modificationTime = Symbol (),
   _tainted          = Symbol (),
   _parents          = Symbol ();

function X3DChildObject ()
{
   Base_X3DObject.call (this);
}

X3DChildObject .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: X3DChildObject,
   [_modificationTime]: 0,
   [_tainted]: false,
   [_parents]: new Set (),
   setModificationTime: function (value)
   {
      this [_modificationTime] = value;
   },
   getModificationTime: function ()
   {
      return this [_modificationTime];
   },
   setTainted: function (value)
   {
      this [_tainted] = value;
   },
   isTainted: function ()
   {
      return this [_tainted];
   },
   addEvent: function ()
   {
      this .setModificationTime (performance .now ());

      for (const parent of this [_parents])
         parent .addEvent (this);
   },
   addEventObject: function (field, event)
   {
      this .setModificationTime (performance .now ());

      for (const parent of this [_parents])
         parent .addEventObject (this, event);
   },
   addParent: function (parent)
   {
      if (this [_parents] === X3DChildObject .prototype [_parents])
         this [_parents] = new Set ();

      this [_parents] .add (parent);
   },
   removeParent: function (parent)
   {
      this [_parents] .delete (parent);
   },
   getParents: function ()
   {
      return this [_parents];
   },
   dispose: function ()
   {
      this [_parents] .clear ();

      Base_X3DObject.prototype.dispose.call (this);
   },
});

for (const key of Reflect .ownKeys (X3DChildObject .prototype))
   Object .defineProperty (X3DChildObject .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DChildObject = (X3DChildObject);

;// CONCATENATED MODULE: ./src/x_ite/Base/Events.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const _stack = Symbol ();

function Events ()
{
   this [_stack] = [ ];
}

Events .prototype =
{
   create: function (field)
   {
      if (this [_stack] .length)
      {
         const event = this [_stack] .pop ();

         event .field = field;
         event .clear ();

         return event;
      }

      const event = new Set ();

      event .field = field;

      return event;
   },
   copy: function (event)
   {
      if (this [_stack] .length)
      {
         const copy = this [_stack] .pop ();

         copy .field = event .field;
         copy .clear ();

         for (const source of event)
         {
            copy .add (source);
         }

         return copy;
      }

      const copy = new Set (event);

      copy .field = event .field;

      return copy;
   },
   push: function (event)
   {
      this [_stack] .push (event);
   },
   clear: function ()
   {
      this [_stack] .length = 0;
   },
};

for (const key of Reflect .ownKeys (Events .prototype))
   Object .defineProperty (Events .prototype, key, { enumerable: false });

/* harmony default export */ const Base_Events = (new Events ());

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DField.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _value               = Symbol (),
   _accessType          = Symbol (),
   _unit                = Symbol (),
   _references          = Symbol (),
   _referencesCallbacks = Symbol (),
   _fieldInterests      = Symbol (),
   _fieldCallbacks      = Symbol (),
   _inputRoutes         = Symbol (),
   _outputRoutes        = Symbol (),
   _routeCallbacks      = Symbol (),
   _uniformLocation     = Symbol .for ("X3DField.uniformLocation");

function X3DField (value)
{
   Base_X3DChildObject.call (this);

   this [_value] = value;

   return this;
}

X3DField .prototype = Object .assign (Object .create (Base_X3DChildObject.prototype),
{
   constructor: X3DField,
   [_value]: null,
   [_accessType]: Base_X3DConstants.initializeOnly,
   [_unit]: null,
   [_uniformLocation]: null,
   [_references]: new Set (),
   [_referencesCallbacks]: new Map (),
   [_fieldInterests]: new Set (),
   [_fieldCallbacks]: new Map (),
   [_inputRoutes]: new Set (),
   [_outputRoutes]: new Set (),
   [_routeCallbacks]: new Map (),
   create: function ()
   {
      return new (this .constructor) ();
   },
   equals: function (field)
   {
      return this [_value] === field .valueOf ();
   },
   assign: function (field)
   {
      // Assigns field to this field.
      this .set (field .getValue ());
      this .addEvent ();
   },
   set: function (value)
   {
      // Sets internal value without generating event.
      this [_value] = value;
   },
   setValue: function (value)
   {
      // Sets internal value and generates event.
      this .set (value instanceof this .constructor ? value .getValue () : value);
      this .addEvent ();
   },
   getValue: function ()
   {
      return this [_value];
   },
   setAccessType: function (value)
   {
      this [_accessType] = value;
   },
   getAccessType: function ()
   {
      return this [_accessType];
   },
   isInitializable: function ()
   {
      return this [_accessType] & Base_X3DConstants.initializeOnly;
   },
   isInput: function ()
   {
      return this [_accessType] & Base_X3DConstants.inputOnly;
   },
   isOutput: function ()
   {
      return this [_accessType] & Base_X3DConstants.outputOnly;
   },
   isReadable: function ()
   {
      return this [_accessType] !== Base_X3DConstants.inputOnly;
   },
   isWritable: function ()
   {
      return this [_accessType] !== Base_X3DConstants.initializeOnly;
   },
   setUnit: function (value)
   {
      this [_unit] = value;
   },
   getUnit: function ()
   {
      return this [_unit];
   },
   hasReferences: function ()
   {
      return this [_references] .size !== 0;
   },
   isReference: function (accessType)
   {
      return accessType === this [_accessType] || accessType === Base_X3DConstants.inputOutput;
   },
   addReference: function (reference)
   {
      const references = this .getReferences ();

      if (references .has (reference))
         return;

      references .add (reference);

      // Create IS relationship

      switch (this .getAccessType () & reference .getAccessType ())
      {
         case Base_X3DConstants.initializeOnly:
            reference .addFieldInterest (this);
            this .assign (reference);
            break;
         case Base_X3DConstants.inputOnly:
            reference .addFieldInterest (this);
            break;
         case Base_X3DConstants.outputOnly:
            this .addFieldInterest (reference);
            break;
         case Base_X3DConstants.inputOutput:
            reference .addFieldInterest (this);
            this .addFieldInterest (reference);
            this .assign (reference);
            break;
      }

      this .processReferencesCallbacks ();
   },
   removeReference: function (reference)
   {
      this .getReferences () .delete (reference);

      // Create IS relationship

      switch (this .getAccessType () & reference .getAccessType ())
      {
         case Base_X3DConstants.initializeOnly:
            reference .removeFieldInterest (this);
            break;
         case Base_X3DConstants.inputOnly:
            reference .removeFieldInterest (this);
            break;
         case Base_X3DConstants.outputOnly:
            this .removeFieldInterest (reference);
            break;
         case Base_X3DConstants.inputOutput:
            reference .removeFieldInterest (this);
            this .removeFieldInterest (reference);
            break;
      }

      this .processReferencesCallbacks ();
   },
   getReferences: function ()
   {
      if (this [_references] === X3DField .prototype [_references])
         this [_references] = new Set ();

      return this [_references];
   },
   addReferencesCallback: function (key, object)
   {
      if (this [_referencesCallbacks] === X3DField .prototype [_referencesCallbacks])
         this [_referencesCallbacks] = new Map ();

      this [_referencesCallbacks] .set (key, object);
   },
   removeReferencesCallback: function (key)
   {
      this [_referencesCallbacks] .delete (key);
   },
   getReferencesCallbacks: function ()
   {
      return this [_referencesCallbacks];
   },
   processReferencesCallbacks: (function ()
   {
      const referencesCallbacksTemp = [ ];

      return function ()
      {
         if (this [_referencesCallbacks] .size)
         {
            for (const referencesCallback of Utility_MapUtilities.values (referencesCallbacksTemp, this [_referencesCallbacks]))
               referencesCallback ();
         }
      };
   })(),
   addFieldInterest: function (field)
   {
      if (this [_fieldInterests] === X3DField .prototype [_fieldInterests])
         this [_fieldInterests] = new Set ();

      this [_fieldInterests] .add (field);
   },
   removeFieldInterest: function (field)
   {
      this [_fieldInterests] .delete (field);
   },
   getFieldInterests: function ()
   {
      return this [_fieldInterests];
   },
   addFieldCallback: function (key, object)
   {
      if (this [_fieldCallbacks] === X3DField .prototype [_fieldCallbacks])
         this [_fieldCallbacks] = new Map ();

      this [_fieldCallbacks] .set (key, object);
   },
   removeFieldCallback: function (key)
   {
      this [_fieldCallbacks] .delete (key);
   },
   getFieldCallbacks: function ()
   {
      return this [_fieldCallbacks];
   },
   addInputRoute: function (route)
   {
      if (this [_inputRoutes] === X3DField .prototype [_inputRoutes])
         this [_inputRoutes] = new Set ();

      this [_inputRoutes] .add (route);

      this .processRouteCallbacks ();
   },
   removeInputRoute: function (route)
   {
      this [_inputRoutes] .delete (route);

      this .processRouteCallbacks ();
   },
   getInputRoutes: function ()
   {
      return this [_inputRoutes];
   },
   addOutputRoute: function (route)
   {
      if (this [_outputRoutes] === X3DField .prototype [_outputRoutes])
         this [_outputRoutes] = new Set ();

      this [_outputRoutes] .add (route);

      this .processRouteCallbacks ();
   },
   removeOutputRoute: function (route)
   {
      this [_outputRoutes] .delete (route);

      this .processRouteCallbacks ();
   },
   getOutputRoutes: function ()
   {
      return this [_outputRoutes];
   },
   addRouteCallback: function (key, object)
   {
      // Processed if routes are changed.

      if (this [_routeCallbacks] === X3DField .prototype [_routeCallbacks])
         this [_routeCallbacks] = new Map ();

      this [_routeCallbacks] .set (key, object);
   },
   removeRouteCallback: function (key)
   {
      this [_routeCallbacks] .delete (key);
   },
   getRouteCallbacks: function ()
   {
      return this [_routeCallbacks];
   },
   processRouteCallbacks: (function ()
   {
      const routeCallbacksTemp = [ ];

      return function ()
      {
         if (this [_routeCallbacks] .size)
         {
            for (const routeCallback of Utility_MapUtilities.values (routeCallbacksTemp, this [_routeCallbacks]))
               routeCallback ();
         }
      };
   })(),
   processEvent: (function ()
   {
      const fieldCallbacksTemp = [ ];

      return function (event = Base_Events.create (this))
      {
         if (event .has (this))
            return;

         event .add (this);

         this .setTainted (false);

         const field = event .field;

         if (field !== this)
            this .set (field .getValue (), field .length);

         // Process interests

         this .processInterests ();

         // Process routes

         let first = true;

         if (this [_fieldInterests] .size)
         {
            for (const fieldInterest of this [_fieldInterests] .values ())
            {
               if (first)
               {
                  first = false;
                  fieldInterest .addEventObject (this, event);
               }
               else
                  fieldInterest .addEventObject (this, Base_Events.copy (event));
            }
         }

         if (first)
            Base_Events.push (event);

         // Process field callbacks

         if (this [_fieldCallbacks] .size)
         {
            for (const fieldCallback of Utility_MapUtilities.values (fieldCallbacksTemp, this [_fieldCallbacks]))
               fieldCallback (this .valueOf ());
         }
      };
   })(),
   addCloneCount: Function .prototype,
   removeCloneCount: Function .prototype,
   valueOf: function ()
   {
      return this;
   },
   fromString: function (string, scene)
   {
      const
         X3D        = window [Symbol .for ("X_ITE.X3D-7.0.0")],
         VRMLParser = X3D .require ("VRMLParser"),
         parser     = new VRMLParser (scene);

      parser .setUnits (!!scene);
      parser .setInput (string);

      if (parser .fieldValue (this))
         return;

      throw new Error ("Couldn't read value for field '" + this .getName () + "'.");
   },
   dispose: function ()
   {
      for (const route of new Set (this [_inputRoutes]))
         route .dispose ();

      for (const route of new Set (this [_outputRoutes]))
         route .dispose ();

      Base_X3DChildObject.prototype.dispose.call (this);
   }
});

for (const key of Reflect .ownKeys (X3DField .prototype))
   Object .defineProperty (X3DField .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DField = (X3DField);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFTime.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function SFTime (value)
{
   return Base_X3DField.call (this, arguments .length ? +value : 0);
}

SFTime .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFTime,
   copy: function ()
   {
      return new SFTime (this .getValue ());
   },
   getTypeName: function ()
   {
      return "SFTime";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFTime;
   },
   isDefaultValue: function ()
   {
      return this .getValue () === 0;
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, +value);
   },
   valueOf: Base_X3DField.prototype.getValue,
   toStream: function (stream)
   {
      stream .string += this .getValue ();
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFTime .prototype))
   Object .defineProperty (SFTime .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFTime = (SFTime);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DEventObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const _browser = Symbol .for ("X3DEventObject.browser");

function X3DEventObject (browser)
{
   Base_X3DChildObject.call (this);

   this [_browser] = browser;
}

X3DEventObject .prototype = Object .assign (Object .create (Base_X3DChildObject.prototype),
{
   constructor: X3DEventObject,
   getBrowser: function ()
   {
      return this [_browser];
   },
   getExtendedEventHandling: function ()
   {
      return true;
   },
   addEvent: function (field)
   {
      if (field .isTainted ())
         return;

      field .setTainted (true);

      this .addEventObject (field, Base_Events.create (field));
   },
   addEventObject: function (field, event)
   {
      const browser = this .getBrowser ();

      // Register for processEvent

      browser .addBrowserEvent ();
      browser .addTaintedField (field, event);

      // Register for eventsProcessed

      if (this .isTainted ())
         return;

      if (field .isInput () || (this .getExtendedEventHandling () && ! field .isOutput ()))
      {
         this .addNodeEvent ();
      }
   },
   addNodeEvent: function ()
   {
      if (this .isTainted ())
         return;

      const browser = this .getBrowser ();

      this .setTainted (true);
      browser .addTaintedNode (this);
      browser .addBrowserEvent ();
   },
   processEvents: function ()
   {
      this .setTainted (false);
      this .processInterests ();
   },
});

for (const key of Reflect .ownKeys (X3DEventObject .prototype))
   Object .defineProperty (X3DEventObject .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DEventObject = (X3DEventObject);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DFieldDefinition.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function X3DFieldDefinition (accessType, name, value)
{
   this .accessType  = accessType;
   this .dataType    = value .getType ();
   this .name        = name;
   this .value       = value;
}

X3DFieldDefinition .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: X3DFieldDefinition,
   getTypeName: function ()
   {
      return "X3DFieldDefinition";
   },
});

for (const key of Reflect .ownKeys (X3DFieldDefinition .prototype))
   Object .defineProperty (X3DFieldDefinition .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DFieldDefinition = (X3DFieldDefinition);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DInfoArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _array = Symbol (),
   _index = Symbol ();

const handler =
{
   get: function (target, key)
   {
      const value = target [key];

      if (value !== undefined)
         return value;

      if (typeof key === "string")
      {
         const index = +key;

         if (Number .isInteger (index))
            return target [_array] [index];

         return;
      }
   },
   set: function (target, key, value)
   {
      if (target [key] === undefined)
         return false;

      target [key] = value;
      return true;
   },
   has: function (target, key)
   {
      if (Number .isInteger (+key))
         return key < target [_array] .length;

      return key in target;
   },
   ownKeys: function (target)
   {
      return Object .keys (target [_array]);
   },
   getOwnPropertyDescriptor: function (target, key)
   {
      if (typeof key !== "string")
         return;

      const index = +key;

      if (Number .isInteger (index) && index < target [_array] .length)
      {
         const propertyDescriptor = Object .getOwnPropertyDescriptor (target [_array], key);

         if (propertyDescriptor)
            propertyDescriptor .writable = false;

         return propertyDescriptor;
      }
   },
};

function X3DInfoArray (values)
{
   this [_array]           = [ ];
   this [_index]           = new Map ();
   this [Symbol .iterator] = this [_array] [Symbol .iterator];

   if (values)
   {
      for (const value of values)
         this .add (value .name, value);
   }

   return new Proxy (this, handler);
}

X3DInfoArray .prototype = {
   constructor: X3DInfoArray,
   equals: function (array)
   {
      const
         a      = this [_array],
         b      = array [_array] || array,
         length = a .length;

      if (a === b)
         return true;

      if (length !== b .length)
         return false;

      for (let i = 0; i < length; ++ i)
      {
         if (a [i] !== b [i])
            return false;
      }

      return true;
   },
   has: function (key)
   {
      return this [_index] .has (key);
   },
   get: function (key)
   {
      return this [_index] .get (key);
   },
   add: function (key, value)
   {
      this [_array] .push (value);
      this [_index] .set (key, value);
   },
   addAlias: function (alias, key)
   {
      this [_index] .set (alias, this [_index] .get (key));
   },
   update: function (oldKey, newKey, value)
   {
      const oldValue = this [_index] .get (oldKey);

      if (oldKey !== newKey)
         this .remove (newKey);

      this [_index] .delete (oldKey);
      this [_index] .set (newKey, value);

      if (oldValue !== undefined)
      {
         const index = this [_array] .indexOf (oldValue);

         if (index > -1)
            this [_array] [index] = value;
      }
      else
      {
         this [_array] .push (value);
      }
   },
   remove: function (key)
   {
      const value = this [_index] .get (key);

      if (value === undefined)
         return;

      const index = this [_array] .indexOf (value);

      this [_index] .delete (key);

      if (index > -1)
         this [_array] .splice (index, 1);
   },
   at: Array .prototype .at,
   concat: Array .prototype .concat,
   //entries: function () { return iterator -> [index, value]; },
   every: Array .prototype .every,
   fill: Array .prototype .fill,
   filter: Array .prototype .filter,
   find: Array .prototype .find,
   findIndex: Array .prototype .findIndex,
   forEach: Array .prototype .forEach,
   includes: Array .prototype .includes,
   indexOf: Array .prototype .indexOf,
   join: Array .prototype .join,
   keys: function () { return Array (this .length) .keys (); },
   lastIndexOf: Array .prototype .lastIndexOf,
   map: Array .prototype .map,
   reduce: Array .prototype .reduce,
   reduceRight: Array .prototype .reduceRight,
   slice: Array .prototype .slice,
   some: Array .prototype .some,
   values: function () { return this [Symbol .iterator]; },
   toString: function (scene)
   {
      const stream = { string: "" };

      if (scene)
         Generator .Get (stream) .PushExecutionContext (scene);

      this .toStream (stream);

      return stream .string;
   },
   toVRMLStream: function (stream)
   {
      for (const value of this [_array])
      {
         try
         {
            value .toVRMLStream (stream);

            stream .string += "\n";

            if (value instanceof Base_X3DBaseNode)
               stream .string += "\n";
         }
         catch (error)
         {
            console .error (error);
         }
      }
   },
   toXMLStream: function (stream)
   {
      for (const value of this [_array])
      {
         try
         {
            value .toXMLStream (stream);

            stream .string += "\n";
         }
         catch (error)
         {
            console .error (error);
         }
      }
   },
   toStream: function (stream)
   {
      stream .string = "[object " + this .getTypeName () + "]";
   },
};

for (const key of Reflect .ownKeys (X3DInfoArray .prototype))
   Object .defineProperty (X3DInfoArray .prototype, key, { enumerable: false });

Object .defineProperty (X3DInfoArray .prototype, "length",
{
   get: function () { return this [_array] .length; },
   enumerable: false,
   configurable: false,
});

/* harmony default export */ const Base_X3DInfoArray = (X3DInfoArray);

;// CONCATENATED MODULE: ./src/x_ite/Base/FieldDefinitionArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function FieldDefinitionArray (values)
{
   return Base_X3DInfoArray.call (this, values);
}

FieldDefinitionArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: FieldDefinitionArray,
   getTypeName: function ()
   {
      return "FieldDefinitionArray";
   },
});

for (const key of Reflect .ownKeys (FieldDefinitionArray .prototype))
   Object .defineProperty (FieldDefinitionArray .prototype, key, { enumerable: false });

/* harmony default export */ const Base_FieldDefinitionArray = (FieldDefinitionArray);

;// CONCATENATED MODULE: ./src/x_ite/Base/FieldArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function FieldArray ()
{
   return Base_X3DInfoArray.call (this);
}

FieldArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: FieldArray,
   getTypeName: function ()
   {
      return "FieldArray";
   },
});

for (const key of Reflect .ownKeys (FieldArray .prototype))
   Object .defineProperty (FieldArray .prototype, key, { enumerable: false });

/* harmony default export */ const Base_FieldArray = (FieldArray);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFBool.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function SFBool (value)
{
   return Base_X3DField.call (this, !! value);
}

SFBool .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFBool,
   copy: function ()
   {
      return new SFBool (this .getValue ());
   },
   isDefaultValue: function ()
   {
      return this .getValue () === false;
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, !! value);
   },
   getTypeName: function ()
   {
      return "SFBool";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFBool;
   },
   valueOf: function ()
   {
      return this .getValue ();
   },
   toStream: function (stream)
   {
      stream .string += this .getValue () ? "TRUE" : "FALSE";
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      stream .string += this .getValue () ? "true" : "false";
   },
});

for (const key of Reflect .ownKeys (SFBool .prototype))
   Object .defineProperty (SFBool .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFBool = (SFBool);

;// CONCATENATED MODULE: ./src/standard/Math/Algorithm.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function Algorithm () { }

Algorithm .prototype =
{
   constructor: Algorithm,
   radians: function (value)
   {
      return value * (Math .PI / 180);
   },
   degrees: function (value)
   {
      return value * (180 / Math .PI);
   },
   random: function (min, max)
   {
      return min + Math .random () * (max - min);
   },
   fract: function (value)
   {
      return value % 1;
   },
   clamp: function (value, min, max)
   {
      // http://jsperf.com/math-clamp
      // http://jsperf.com/clamping-methods/2
      return Math .min (Math .max (value, min), max);
   },
   interval: function (value, low, high)
   {
      if (value >= high)
         return ((value - low) % (high - low)) + low;

      if (value < low)
         return ((value - high) % (high - low)) + high;

      return value;
   },
   lerp: function (source, destination, t)
   {
      return source + t * (destination - source);
   },
   slerp: function (source, destination, t)
   {
      let cosom = source .dot (destination);

      // if (cosom <= -1) ... vectors are inverse colinear.

      if (cosom >= 1) // Both normal vectors are equal.
         return source;

      if (cosom < 0)
      {
         // Reverse signs so we travel the short way round.
         cosom = -cosom;
         destination .negate ();
      }

      const
         omega  = Math .acos (cosom),
         sinom  = Math .sin  (omega),
         scale0 = Math .sin ((1 - t) * omega) / sinom,
         scale1 = Math .sin (t * omega) / sinom;

      source .x = source .x * scale0 + destination .x * scale1;
      source .y = source .y * scale0 + destination .y * scale1;
      source .z = source .z * scale0 + destination .z * scale1;
      source .w = source .w * scale0 + destination .w * scale1;

      return source;
   },
   simpleSlerp: function (source, destination, t)
   {
      const cosom = source .dot (destination);

      // if (cosom <= -1) ... vectors are inverse colinear.

      if (cosom >= 1) // Both normal vectors are equal.
         return source;

      const
         omega  = Math .acos (cosom),
         sinom  = Math .sin  (omega),
         scale0 = Math .sin ((1 - t) * omega) / sinom,
         scale1 = Math .sin (t * omega) / sinom;

      source .x = source .x * scale0 + destination .x * scale1;
      source .y = source .y * scale0 + destination .y * scale1;
      source .z = source .z * scale0 + destination .z * scale1;
      source .w = source .w * scale0 + destination .w * scale1;

      return source;
   },
   isPowerOfTwo: function (n)
   {
      return ((n - 1) & n) === 0;
   },
   nextPowerOfTwo: function (n)
   {
      ///  Returns the next power of two of @a n. If n is a power of two, n is returned.

      if (this .isPowerOfTwo (n))
         return n;

      return 1 << 32 - Math .clz32 (n);
   },
   cmp: function (lhs, rhs)
   {
      return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
   },
   less: function (lhs, rhs)
   {
      return lhs < rhs;
   },
   greater: function (lhs, rhs)
   {
      return lhs > rhs;
   },
   lowerBound: function (array, first, last, value, comp = this .less)
   {
      // http://en.cppreference.com/w/cpp/algorithm/lower_bound

      let
         index = 0,
         step  = 0,
         count = last - first;

      while (count > 0)
      {
         step  = count >>> 1;
         index = first + step;

         if (comp (array [index], value))
         {
            first  = ++ index;
            count -= step + 1;
         }
         else
            count = step;
      }

      return first;
   },
   upperBound: function (array, first, last, value, comp = this .less)
   {
      // http://en.cppreference.com/w/cpp/algorithm/upper_bound

      let
         index = 0,
         step  = 0,
         count = last - first;

      while (count > 0)
      {
         step  = count >>> 1;
         index = first + step;

         if (comp (value, array [index]))
            count = step;

         else
         {
            first  = ++ index;
            count -= step + 1;
         }
      }

      return first;
   },
   set_difference: function (lhs, rhs, result)
   {
      for (const key of lhs)
      {
         if (rhs .has (key))
            continue;

         result .add (key);
      }

      return result;
   },
};

/* harmony default export */ const Math_Algorithm = (new Algorithm ());

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Color3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const clamp = Math_Algorithm.clamp;

const
   _r = Symbol .for ("X_ITE.Color3.r"),
   _g = Symbol .for ("X_ITE.Color3.g"),
   _b = Symbol .for ("X_ITE.Color3.b");

function Color3 (r, g, b)
{
   if (arguments .length)
   {
      this [_r] = clamp (r, 0, 1);
      this [_g] = clamp (g, 0, 1);
      this [_b] = clamp (b, 0, 1);
   }
   else
   {
      this [_r] = 0;
      this [_g] = 0;
      this [_b] = 0;
   }
}

Color3 .prototype =
{
   constructor: Color3,
   length: 3,
   [Symbol .iterator]: function* ()
   {
      yield this [_r];
      yield this [_g];
      yield this [_b];
   },
   copy: function ()
   {
      const copy = Object .create (Color3 .prototype);
      copy [_r] = this [_r];
      copy [_g] = this [_g];
      copy [_b] = this [_b];
      return copy;
   },
   assign: function (color)
   {
      this [_r] = color [_r];
      this [_g] = color [_g];
      this [_b] = color [_b];
   },
   set: function (r, g, b)
   {
      this [_r] = clamp (r, 0, 1);
      this [_g] = clamp (g, 0, 1);
      this [_b] = clamp (b, 0, 1);
   },
   equals: function (color)
   {
      return this [_r] === color [_r] &&
             this [_g] === color [_g] &&
             this [_b] === color [_b];
   },
   getHSV: function (result)
   {
      let h, s, v;

      const min = Math .min (this [_r], this [_g], this [_b]);
      const max = Math .max (this [_r], this [_g], this [_b]);
      v = max; // value

      const delta = max - min;

      if (max !== 0 && delta !== 0)
      {
         s = delta / max; // s

         if (this [_r] === max)
            h =     (this [_g] - this [_b]) / delta;  // between yellow & magenta
         else if (this [_g] === max)
            h = 2 + (this [_b] - this [_r]) / delta;  // between cyan & yellow
         else
            h = 4 + (this [_r] - this [_g]) / delta;  // between magenta & cyan

         h *= Math .PI / 3;  // radiants
         if (h < 0)
            h += Math .PI * 2;
      }
      else
         s = h = 0;         // s = 0, h is undefined

      result [0] = h;
      result [1] = s;
      result [2] = v;

      return result;
   },
   setHSV: function (h, s, v)
   {
      s = clamp (s, 0, 1),
      v = clamp (v, 0, 1);

      // H is given on [0, 2 * Pi]. S and V are given on [0, 1].
      // RGB are each returned on [0, 1].

      if (s === 0)
      {
         // achromatic (grey)
         this [_r] = this [_g] = this [_b] = v;
      }
      else
      {
         const w = Math_Algorithm.degrees (Math_Algorithm.interval (h, 0, Math .PI * 2)) / 60;     // sector 0 to 5

         const i = Math .floor (w);
         const f = w - i;                      // factorial part of h
         const p = v * ( 1 - s );
         const q = v * ( 1 - s * f );
         const t = v * ( 1 - s * ( 1 - f ) );

         switch (i % 6)
         {
            case 0:  this [_r] = v; this [_g] = t; this [_b] = p; break;
            case 1:  this [_r] = q; this [_g] = v; this [_b] = p; break;
            case 2:  this [_r] = p; this [_g] = v; this [_b] = t; break;
            case 3:  this [_r] = p; this [_g] = q; this [_b] = v; break;
            case 4:  this [_r] = t; this [_g] = p; this [_b] = v; break;
            default: this [_r] = v; this [_g] = p; this [_b] = q; break;
         }
      }
   },
   toString: function ()
   {
      return this [_r] + " " +
             this [_g] + " " +
             this [_b];
   },
};

const r = {
   get: function () { return this [_r]; },
   set: function (value) { this [_r] = clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

const g = {
   get: function () { return this [_g]; },
   set: function (value) { this [_g] = clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

const b = {
   get: function () { return this [_b]; },
   set: function (value) { this [_b] = clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

Object .defineProperty (Color3 .prototype, "r", r);
Object .defineProperty (Color3 .prototype, "g", g);
Object .defineProperty (Color3 .prototype, "b", b);

r .enumerable = false;
g .enumerable = false;
b .enumerable = false;

Object .defineProperty (Color3 .prototype, "0", r);
Object .defineProperty (Color3 .prototype, "1", g);
Object .defineProperty (Color3 .prototype, "2", b);

Object .assign (Color3,
{
   HSV: function (h, s, v)
   {
      const color = Object .create (this .prototype);
      color .setHSV (h, s, v);
      return color;
   },
   lerp: function (a, b, t, r)
   {
      // Linearely interpolate in HSV space between source color @a a and destination color @a b by an amount of @a t.
      // Source and destination color must be in HSV space. The resulting HSV color is stored in @a r.

      let
         ha = a [0], hb = b [0];

      const
         sa = a [1], sb = b [1],
         va = a [2], vb = b [2];

      if (sa === 0)
         ha = hb;

      if (sb === 0)
         hb = ha;

      const range = Math .abs (hb - ha);

      if (range <= Math .PI)
      {
         r [0] = ha + t * (hb - ha);
         r [1] = sa + t * (sb - sa);
         r [2] = va + t * (vb - va);
         return r;
      }

      const
         PI2  = Math .PI * 2,
         step = (PI2 - range) * t;

      let h = ha < hb ? ha - step : ha + step;

      if (h < 0)
         h += PI2;

      else if (h > PI2)
         h -= PI2;

      r [0] = h;
      r [1] = sa + t * (sb - sa);
      r [2] = va + t * (vb - va);
      return r;
   },
});

/* harmony default export */ const Numbers_Color3 = (Color3);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFColor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function SFColor (r, g, b)
{
   switch (arguments .length)
   {
      case 0:
         return Base_X3DField.call (this, new Numbers_Color3 ());

      case 1:
         return Base_X3DField.call (this, arguments [0]);

      case 3:
         return Base_X3DField.call (this, new Numbers_Color3 (+r, +g, +b));
   }

   throw new Error ("Invalid arguments.");
}

SFColor .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFColor,
   [Symbol .iterator]: function* ()
   {
      yield* this .getValue ();
   },
   copy: function ()
   {
      return new SFColor (this .getValue () .copy ());
   },
   getTypeName: function ()
   {
      return "SFColor";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFColor;
   },
   equals: function (color)
   {
      return this .getValue () .equals (color .getValue ());
   },
   isDefaultValue: function ()
   {
      return (
         this .getValue () .r === 0 &&
         this .getValue () .g === 0 &&
         this .getValue () .b === 0);
   },
   set: function (value)
   {
      this .getValue () .assign (value);
   },
   getHSV: function ()
   {
      return this .getValue () .getHSV ([ ]);
   },
   setHSV: function (h, s, v)
   {
      this .getValue () .setHSV (h, s, v);
      this .addEvent ();
   },
   lerp: (function ()
   {
      const
         s = [ ],
         d = [ ],
         r = [ ];

      return function (destination, t)
      {
         const result = new SFColor ();

         this .getValue () .getHSV (s),
         destination .getValue () .getHSV (d),
         Numbers_Color3.lerp (s, d, t, r),

         result .setHSV (r [0], r [1], r [2], r [3]);

         return result;
      };
   })(),
   toStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         value     = this .getValue (),
         last      = value .length - 1;

      for (let i = 0; i < last; ++ i)
      {
         stream .string += generator .Precision (value [i]);
         stream .string += " ";
      }

      stream .string += generator .Precision (value [last]);
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFColor .prototype))
   Object .defineProperty (SFColor .prototype, key, { enumerable: false });

const SFColor_r = {
   get: function ()
   {
      return this .getValue () .r;
   },
   set: function (value)
   {
      this .getValue () .r = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFColor_g = {
   get: function ()
   {
      return this .getValue () .g;
   },
   set: function (value)
   {
      this .getValue () .g = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFColor_b = {
   get: function ()
   {
      return this .getValue () .b;
   },
   set: function (value)
   {
      this .getValue () .b = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

Object .defineProperty (SFColor .prototype, "r", SFColor_r);
Object .defineProperty (SFColor .prototype, "g", SFColor_g);
Object .defineProperty (SFColor .prototype, "b", SFColor_b);

SFColor_r .enumerable = false;
SFColor_g .enumerable = false;
SFColor_b .enumerable = false;

Object .defineProperty (SFColor .prototype, "0", SFColor_r);
Object .defineProperty (SFColor .prototype, "1", SFColor_g);
Object .defineProperty (SFColor .prototype, "2", SFColor_b);

/* harmony default export */ const Fields_SFColor = (SFColor);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Color4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const Color4_clamp = Math_Algorithm.clamp;

const
   Color4_r = Symbol .for ("X_ITE.Color3.r"),
   Color4_g = Symbol .for ("X_ITE.Color3.g"),
   Color4_b = Symbol .for ("X_ITE.Color3.b"),
   _a = Symbol ();

function Color4 (r, g, b, a)
{
   if (arguments .length)
   {
      this [Color4_r] = Color4_clamp (r, 0, 1);
      this [Color4_g] = Color4_clamp (g, 0, 1);
      this [Color4_b] = Color4_clamp (b, 0, 1);
      this [_a] = Color4_clamp (a, 0, 1);
   }
   else
   {
      this [Color4_r] = 0;
      this [Color4_g] = 0;
      this [Color4_b] = 0;
      this [_a] = 0;
   }
}

Color4 .prototype =
{
   constructor: Color4,
   length: 4,
   [Symbol .iterator]: function* ()
   {
      yield this [Color4_r];
      yield this [Color4_g];
      yield this [Color4_b];
      yield this [_a];
   },
   copy: function ()
   {
      const copy = Object .create (Color4 .prototype);
      copy [Color4_r] = this [Color4_r];
      copy [Color4_g] = this [Color4_g];
      copy [Color4_b] = this [Color4_b];
      copy [_a] = this [_a];
      return copy;
   },
   assign: function (color)
   {
      this [Color4_r] = color [Color4_r];
      this [Color4_g] = color [Color4_g];
      this [Color4_b] = color [Color4_b];
      this [_a] = color [_a];
   },
   set: function (r, g, b, a)
   {
      this [Color4_r] = Color4_clamp (r, 0, 1);
      this [Color4_g] = Color4_clamp (g, 0, 1);
      this [Color4_b] = Color4_clamp (b, 0, 1);
      this [_a] = Color4_clamp (a, 0, 1);
   },
   equals: function (color)
   {
      return this [Color4_r] === color [Color4_r] &&
             this [Color4_g] === color [Color4_g] &&
             this [Color4_b] === color [Color4_b] &&
             this [_a] === color [_a];
   },
   getHSVA: function (result)
   {
      Numbers_Color3.prototype.getHSV.call (this, result);

      result [3] = this [_a];

      return result;
   },
   setHSVA: function (h, s, v, a)
   {
      Numbers_Color3.prototype.setHSV.call (this, h, s, v);

      this [_a] = Color4_clamp (a, 0, 1);
   },
   toString: function ()
   {
      return this [Color4_r] + " " +
             this [Color4_g] + " " +
             this [Color4_b] + " " +
             this [_a];
   },
};

const Numbers_Color4_r = {
   get: function () { return this [Color4_r]; },
   set: function (value) { this [Color4_r] = Color4_clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

const Numbers_Color4_g = {
   get: function () { return this [Color4_g]; },
   set: function (value) { this [Color4_g] = Color4_clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

const Numbers_Color4_b = {
   get: function () { return this [Color4_b]; },
   set: function (value) { this [Color4_b] = Color4_clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

const a = {
   get: function () { return this [_a]; },
   set: function (value) { this [_a] = Color4_clamp (value, 0, 1); },
   enumerable: true,
   configurable: false
};

Object .defineProperty (Color4 .prototype, "r", Numbers_Color4_r);
Object .defineProperty (Color4 .prototype, "g", Numbers_Color4_g);
Object .defineProperty (Color4 .prototype, "b", Numbers_Color4_b);
Object .defineProperty (Color4 .prototype, "a", a);

Numbers_Color4_r .enumerable = false;
Numbers_Color4_g .enumerable = false;
Numbers_Color4_b .enumerable = false;
a .enumerable = false;

Object .defineProperty (Color4 .prototype, "0", Numbers_Color4_r);
Object .defineProperty (Color4 .prototype, "1", Numbers_Color4_g);
Object .defineProperty (Color4 .prototype, "2", Numbers_Color4_b);
Object .defineProperty (Color4 .prototype, "3", a);

Object .assign (Color4,
{
   HSVA: function (h, s, v, a)
   {
      const color = Object .create (this .prototype);
      color .setHSVA (h, s, v, a);
      return color;
   },
   lerp: function (a, b, t, r)
   {
      // Linearely interpolate in HSVA space between source color @a a and destination color @a b by an amount of @a t.
      // Source and destination color must be in HSVA space. The resulting HSVA color is stored in @a r.
      const aa = a [3];
      Numbers_Color3.lerp (a, b, t, r);
      r [3] = aa + t * (b [3] - aa);
      return r;
   },
});

/* harmony default export */ const Numbers_Color4 = (Color4);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFColorRGBA.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function SFColorRGBA (r, g, b, a)
{
   switch (arguments .length)
   {
      case 0:
         return Base_X3DField.call (this, new Numbers_Color4 ());

      case 1:
         return Base_X3DField.call (this, arguments [0]);

      case 4:
         return Base_X3DField.call (this, new Numbers_Color4 (+r, +g, +b, +a));
   }

   throw new Error ("Invalid arguments.");
}

SFColorRGBA .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFColorRGBA,
   [Symbol .iterator]: function* ()
   {
      yield* this .getValue ();
   },
   copy: function ()
   {
      return new SFColorRGBA (this .getValue () .copy ());
   },
   getTypeName: function ()
   {
      return "SFColorRGBA";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFColorRGBA;
   },
   equals: Fields_SFColor.prototype.equals,
   isDefaultValue: function ()
   {
      return (
         this .getValue () .r === 0 &&
         this .getValue () .g === 0 &&
         this .getValue () .b === 0 &&
         this .getValue () .a === 0);
   },
   set: Fields_SFColor.prototype.set,
   getHSVA: function ()
   {
      return this .getValue () .getHSVA ([ ]);
   },
   setHSVA: function (h, s, v, a)
   {
      this .getValue () .setHSVA (h, s, v, a);
      this .addEvent ();
   },
   lerp: (function ()
   {
      const
         s = [ ],
         d = [ ],
         r = [ ];

      return function (destination, t)
      {
         const result = new SFColorRGBA ();

         this .getValue () .getHSVA (s),
         destination .getValue () .getHSVA (d),
         Numbers_Color4.lerp (s, d, t, r),

         result .setHSVA (r [0], r [1], r [2], r [3]);

         return result;
      };
   })(),
   toStream: Fields_SFColor.prototype.toStream,
   toVRMLStream: Fields_SFColor.prototype.toVRMLStream,
   toXMLStream: Fields_SFColor.prototype.toXMLStream,
});

for (const key of Reflect .ownKeys (SFColorRGBA .prototype))
   Object .defineProperty (SFColorRGBA .prototype, key, { enumerable: false });

const SFColorRGBA_r = {
   get: function ()
   {
      return this .getValue () .r;
   },
   set: function (value)
   {
      this .getValue () .r = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFColorRGBA_g = {
   get: function ()
   {
      return this .getValue () .g;
   },
   set: function (value)
   {
      this .getValue () .g = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFColorRGBA_b = {
   get: function ()
   {
      return this .getValue () .b;
   },
   set: function (value)
   {
      this .getValue () .b = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFColorRGBA_a = {
   get: function ()
   {
      return this .getValue () .a;
   },
   set: function (value)
   {
      this .getValue () .a = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

Object .defineProperty (SFColorRGBA .prototype, "r", SFColorRGBA_r);
Object .defineProperty (SFColorRGBA .prototype, "g", SFColorRGBA_g);
Object .defineProperty (SFColorRGBA .prototype, "b", SFColorRGBA_b);
Object .defineProperty (SFColorRGBA .prototype, "a", SFColorRGBA_a);

SFColorRGBA_r .enumerable = false;
SFColorRGBA_g .enumerable = false;
SFColorRGBA_b .enumerable = false;
SFColorRGBA_a .enumerable = false;

Object .defineProperty (SFColorRGBA .prototype, "0", SFColorRGBA_r);
Object .defineProperty (SFColorRGBA .prototype, "1", SFColorRGBA_g);
Object .defineProperty (SFColorRGBA .prototype, "2", SFColorRGBA_b);
Object .defineProperty (SFColorRGBA .prototype, "3", SFColorRGBA_a);

/* harmony default export */ const Fields_SFColorRGBA = (SFColorRGBA);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFDouble.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function SFDouble (value)
{
   return Base_X3DField.call (this, arguments .length ? +value : 0);
}

SFDouble .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFDouble,
   copy: function ()
   {
      return new SFDouble (this .getValue ());
   },
   getTypeName: function ()
   {
      return "SFDouble";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFDouble;
   },
   isDefaultValue: function ()
   {
      return this .getValue () === 0;
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, +value);
   },
   valueOf: Base_X3DField.prototype.getValue,
   toStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         category  = generator .Unit (this .getUnit ());

      stream .string += generator .DoublePrecision (generator .ToUnit (category, this .getValue ()));
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFDouble .prototype))
   Object .defineProperty (SFDouble .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFDouble = (SFDouble);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFFloat.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function SFFloat (value)
{
   return Base_X3DField.call (this, arguments .length ? +value : 0);
}

SFFloat .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFFloat,
   copy: function ()
   {
      return new SFFloat (this .getValue ());
   },
   getTypeName: function ()
   {
      return "SFFloat";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFFloat;
   },
   isDefaultValue: function ()
   {
      return this .getValue () === 0;
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, +value);
   },
   valueOf: Base_X3DField.prototype.getValue,
   toStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         category  = generator .Unit (this .getUnit ());

      stream .string += generator .Precision (generator .ToUnit (category, this .getValue ()));
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFFloat .prototype))
   Object .defineProperty (SFFloat .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFFloat = (SFFloat);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFInt32.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function SFInt32 (value)
{
   return Base_X3DField.call (this, ~~value);
}

SFInt32 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFInt32,
   copy: function ()
   {
      return new SFInt32 (this .getValue ());
   },
   getTypeName: function ()
   {
      return "SFInt32";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFInt32;
   },
   isDefaultValue: function ()
   {
      return this .getValue () === 0;
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, ~~value);
   },
   valueOf: Base_X3DField.prototype.getValue,
   toStream: function (stream, base)
   {
      stream .string += this .getValue () .toString (base);
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      stream .string += this .getValue () .toString ();
   },
});

for (const key of Reflect .ownKeys (SFInt32 .prototype))
   Object .defineProperty (SFInt32 .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFInt32 = (SFInt32);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFMatrixPrototypeTemplate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ function SFMatrixPrototypeTemplate(Matrix, SFVec, double)
{
   return Object .assign (Object .create (Base_X3DField.prototype),
   {
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new (this .constructor) (this .getValue () .copy ());
      },
      equals: function (matrix)
      {
         return this .getValue () .equals (matrix .getValue ());
      },
      isDefaultValue: function ()
      {
         return this .getValue () .equals (Matrix .Identity);
      },
      set: function (value)
      {
         this .getValue () .assign (value);
      },
      setTransform: function (translation, rotation, scale, scaleOrientation, center)
      {
         translation      = translation      ? translation      .getValue () : null;
         rotation         = rotation         ? rotation         .getValue () : null;
         scale            = scale            ? scale            .getValue () : null;
         scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
         center           = center           ? center           .getValue () : null;

         this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
      },
      getTransform: function (translation, rotation, scale, scaleOrientation, center)
      {
         translation      = translation      ? translation      .getValue () : null;
         rotation         = rotation         ? rotation         .getValue () : null;
         scale            = scale            ? scale            .getValue () : null;
         scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
         center           = center           ? center           .getValue () : null;

         this .getValue () .get (translation, rotation, scale, scaleOrientation, center);
      },
      determinant: function ()
      {
         return this .getValue () .determinant ();
      },
      transpose: function ()
      {
         return new (this .constructor) (Matrix .transpose (this .getValue ()));
      },
      inverse: function ()
      {
         return new (this .constructor) (Matrix .inverse (this .getValue ()));
      },
      multLeft: function (matrix)
      {
         return new (this .constructor) (Matrix .multLeft (this .getValue (), matrix .getValue ()));
      },
      multRight: function (matrix)
      {
         return new (this .constructor) (Matrix .multRight (this .getValue (), matrix .getValue ()));
      },
      multVecMatrix: function (vector)
      {
         return new SFVec (this .getValue () .multVecMatrix (vector .getValue () .copy ()));
      },
      multMatrixVec: function (vector)
      {
         return new SFVec (this .getValue () .multMatrixVec (vector .getValue () .copy ()));
      },
      multDirMatrix: function (vector)
      {
         return new SFVec (this .getValue () .multDirMatrix (vector .getValue () .copy ()));
      },
      multMatrixDir: function (vector)
      {
         return new SFVec (this .getValue () .multMatrixDir (vector .getValue () .copy ()));
      },
      toStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            value     = this .getValue (),
            last      = value .length - 1;

         for (let i = 0; i < last; ++ i)
         {
            stream .string += double ? generator .DoublePrecision (value [i]) : generator .Precision (value [i]);
            stream .string += " ";
         }

         stream .string += double ? generator .DoublePrecision (value [last]) : generator .Precision (value [last]);
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });
};

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFVecPrototypeTemplate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





/* harmony default export */ function SFVecPrototypeTemplate(Type, double)
{
   return Object .assign (Object .create (Base_X3DField.prototype),
   {
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new (this .constructor) (this .getValue () .copy ());
      },
      equals: function (vector)
      {
         return this .getValue () .equals (vector .getValue ());
      },
      isDefaultValue: function ()
      {
         return this .getValue () .equals (Type .Zero);
      },
      set: function (value)
      {
         this .getValue () .assign (value);
      },
      abs: function ()
      {
         return new (this .constructor) (Type .abs (this .getValue ()));
      },
      add: function (vector)
      {
         return new (this .constructor) (Type .add (this .getValue (), vector .getValue ()));
      },
      distance: function (vector)
      {
         return this .getValue () .distance (vector .getValue ());
      },
      divide: function (value)
      {
         return new (this .constructor) (Type .divide (this .getValue (), value));
      },
      divVec: function (vector)
      {
         return new (this .constructor) (Type .divVec (this .getValue (), vector .getValue ()));
      },
      dot: function (vector)
      {
         return this .getValue () .dot (vector .getValue ());
      },
      inverse: function ()
      {
         return new (this .constructor) (Type .inverse (this .getValue ()));
      },
      length: function ()
      {
         return this .getValue () .magnitude ();
      },
      lerp: function (destination, t)
      {
         return new (this .constructor) (Type .lerp (this .getValue (), destination, t));
      },
      max: function (vector)
      {
         return new (this .constructor) (Type .max (this .getValue (), vector .getValue ()));
      },
      min: function (vector)
      {
         return new (this .constructor) (Type .min (this .getValue (), vector .getValue ()));
      },
      multiply: function (value)
      {
         return new (this .constructor) (Type .multiply (this .getValue (), value));
      },
      multVec: function (vector)
      {
         return new (this .constructor) (Type .multVec (this .getValue (), vector .getValue ()));
      },
      negate: function ()
      {
         return new (this .constructor) (Type .negate (this .getValue ()));
      },
      normalize: function (vector)
      {
         return new (this .constructor) (Type .normalize (this .getValue ()));
      },
      subtract: function (vector)
      {
         return new (this .constructor) (Type .subtract (this .getValue (), vector .getValue ()));
      },
      toStream: function (stream)
      {
         const
            generator = InputOutput_Generator.Get (stream),
            value     = this .getValue (),
            category  = generator .Unit (this .getUnit ()),
            last      = value .length - 1;

         for (let i = 0; i < last; ++ i)
         {
            stream .string += double ? generator .DoublePrecision (generator .ToUnit (category, value [i])) : generator .Precision (generator .ToUnit (category, value [i]));
            stream .string += " ";
         }

         stream .string += double ? generator .DoublePrecision (generator .ToUnit (category, value [last])) : generator .Precision (generator .ToUnit (category, value [last]));
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });
};

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Vector2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function Vector2 (x, y)
{
   this .x = x;
   this .y = y;
}

Vector2 .prototype =
{
   constructor: Vector2,
   length: 2,
   [Symbol .iterator]: function* ()
   {
      yield this .x;
      yield this .y;
   },
   copy: function ()
   {
      const copy = Object .create (Vector2 .prototype);
      copy .x = this .x;
      copy .y = this .y;
      return copy;
   },
   assign: function (vector)
   {
      this .x = vector .x;
      this .y = vector .y;
      return this;
   },
   set: function (x, y)
   {
      this .x = x;
      this .y = y;
      return this;
   },
   equals: function (vector)
   {
      return this .x === vector .x &&
             this .y === vector .y;
   },
   negate: function ()
   {
      this .x = -this .x;
      this .y = -this .y;
      return this;
   },
   inverse: function ()
   {
      this .x = 1 / this .x;
      this .y = 1 / this .y;
      return this;
   },
   add: function (vector)
   {
      this .x += vector .x;
      this .y += vector .y;
      return this;
   },
   subtract: function (vector)
   {
      this .x -= vector .x;
      this .y -= vector .y;
      return this;
   },
   multiply: function (value)
   {
      this .x *= value;
      this .y *= value;
      return this;
   },
   multVec: function (vector)
   {
      this .x *= vector .x;
      this .y *= vector .y;
      return this;
   },
   divide: function (value)
   {
      this .x /= value;
      this .y /= value;
      return this;
   },
   divVec: function (vector)
   {
      this .x /= vector .x;
      this .y /= vector .y;
      return this;
   },
   normalize: function ()
   {
      const length = Math .hypot (this .x, this .y);

      if (length)
      {
         this .x /= length;
         this .y /= length;
      }

      return this;
   },
   dot: function (vector)
   {
      return this .x * vector .x +
             this .y * vector .y;
   },
   norm: function ()
   {
      const
         x = this .x,
         y = this .y;

      return x * x +
             y * y;
   },
   magnitude: function ()
   {
      return Math .hypot (this .x, this .y);
   },
   distance: function (vector)
   {
      return Math .hypot (this .x - vector .x,
                          this .y - vector .y);
   },
   lerp: function (destination, t)
   {
      const
         x = this .x,
         y = this .y;

      this .x = x + t * (destination .x - x);
      this .y = y + t * (destination .y - y);
      return this;
   },
   abs: function ()
   {
      this .x = Math .abs (this .x);
      this .y = Math .abs (this .y);
      return this;
   },
   min: function (vector)
   {
      let
         x = this .x,
         y = this .y;

      for (const vector of arguments)
      {
         x = Math .min (x, vector .x);
         y = Math .min (y, vector .y);
      }

      this .x = x;
      this .y = y;
      return this;
   },
   max: function (vector)
   {
      let
         x = this .x,
         y = this .y;

      for (const vector of arguments)
      {
         x = Math .max (x, vector .x);
         y = Math .max (y, vector .y);
      }

      this .x = x;
      this .y = y;
      return this;
   },
   toString: function ()
   {
      return this .x + " " +
             this .y;
   }
};

Object .defineProperty (Vector2 .prototype, "0",
{
   get: function () { return this .x; },
   set: function (value) { this .x = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector2 .prototype, "1",
{
   get: function () { return this .y; },
   set: function (value) { this .y = value; },
   enumerable: false,
   configurable: false
});

Object .assign (Vector2,
{
   Zero: new Vector2 (0, 0),
   One: new Vector2 (1, 1),
   xAxis: new Vector2 (1, 0),
   yAxis: new Vector2 (0, 1),
   negate: function (vector)
   {
      return vector .copy () .negate ();
   },
   inverse: function (vector)
   {
      return vector .copy () .inverse ();
   },
   add: function (lhs, rhs)
   {
      return lhs .copy () .add (rhs);
   },
   subtract: function (lhs, rhs)
   {
      return lhs .copy () .subtract (rhs);
   },
   multiply: function (lhs, rhs)
   {
      return lhs .copy () .multiply (rhs);
   },
   multVec: function (lhs, rhs)
   {
      return lhs .copy () .multVec (rhs);
   },
   divide: function (lhs, rhs)
   {
      return lhs .copy () .divide (rhs);
   },
   divVec: function (lhs, rhs)
   {
      return lhs .copy () .divVec (rhs);
   },
   normalize: function (vector)
   {
      return vector .copy () .normalize ();
   },
   dot: function (lhs, rhs)
   {
      return lhs .dot (rhs);
   },
   magnitude: function (vector)
   {
      return vector .magnitude ();
   },
   distance: function (lhs, rhs)
   {
      return lhs .distance (rhs);
   },
   lerp: function (source, destination, t)
   {
      return source .copy () .lerp (destination, t);
   },
   abs: function (vector)
   {
      return vector .copy () .abs ();
   },
   min: function (lhs, rhs)
   {
      return this .prototype .min .apply (lhs .copy (), arguments);
   },
   max: function (lhs, rhs)
   {
      return this .prototype .max .apply (lhs .copy (), arguments);
   },
});

/* harmony default export */ const Numbers_Vector2 = (Vector2);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFVec2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function SFVec2Template (TypeName, Type, double)
{
   function SFVec2 (x, y)
   {
      switch (arguments .length)
      {
         case 0:
            return Base_X3DField.call (this, new Numbers_Vector2 (0, 0));

         case 1:
            return Base_X3DField.call (this, arguments [0]);

         case 2:
            return Base_X3DField.call (this, new Numbers_Vector2 (+x, +y));
      }

      throw new Error ("Invalid arguments.");
   }

   SFVec2 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
      SFVecPrototypeTemplate (Numbers_Vector2, double),
   {
      constructor: SFVec2,
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
   });

   for (const key of Reflect .ownKeys (SFVec2 .prototype))
      Object .defineProperty (SFVec2 .prototype, key, { enumerable: false });

   const x = {
      get: function ()
      {
         return this .getValue () .x;
      },
      set: function (value)
      {
         this .getValue () .x = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const y = {
      get: function ()
      {
         return this .getValue () .y;
      },
      set: function (value)
      {
         this .getValue () .y = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFVec2 .prototype, "x", x);
   Object .defineProperty (SFVec2 .prototype, "y", y);

   x .enumerable = false;
   y .enumerable = false;

   Object .defineProperty (SFVec2 .prototype, "0", x);
   Object .defineProperty (SFVec2 .prototype, "1", y);

   return SFVec2;
}

/* harmony default export */ const SFVec2 = ({
   SFVec2d: SFVec2Template ("SFVec2d", Base_X3DConstants.SFVec2d, true),
   SFVec2f: SFVec2Template ("SFVec2f", Base_X3DConstants.SFVec2f, false),
});

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Vector3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function Vector3 (x, y, z)
{
   this .x = x;
   this .y = y;
   this .z = z;
}

Vector3 .prototype =
{
   constructor: Vector3,
   length: 3,
   [Symbol .iterator]: function* ()
   {
      yield this .x;
      yield this .y;
      yield this .z;
   },
   copy: function ()
   {
      const copy = Object .create (Vector3 .prototype);
      copy .x = this .x;
      copy .y = this .y;
      copy .z = this .z;
      return copy;
   },
   assign: function (vector)
   {
      this .x = vector .x;
      this .y = vector .y;
      this .z = vector .z;
      return this;
   },
   set: function (x, y, z)
   {
      this .x = x;
      this .y = y;
      this .z = z;
      return this;
   },
   equals: function (vector)
   {
      return this .x === vector .x &&
             this .y === vector .y &&
             this .z === vector .z;
   },
   negate: function ()
   {
      this .x = -this .x;
      this .y = -this .y;
      this .z = -this .z;
      return this;
   },
   inverse: function ()
   {
      this .x = 1 / this .x;
      this .y = 1 / this .y;
      this .z = 1 / this .z;
      return this;
   },
   add: function (vector)
   {
      this .x += vector .x;
      this .y += vector .y;
      this .z += vector .z;
      return this;
   },
   subtract: function (vector)
   {
      this .x -= vector .x;
      this .y -= vector .y;
      this .z -= vector .z;
      return this;
   },
   multiply: function (value)
   {
      this .x *= value;
      this .y *= value;
      this .z *= value;
      return this;
   },
   multVec: function (vector)
   {
      this .x *= vector .x;
      this .y *= vector .y;
      this .z *= vector .z;
      return this;
   },
   divide: function (value)
   {
      this .x /= value;
      this .y /= value;
      this .z /= value;
      return this;
   },
   divVec: function (vector)
   {
      this .x /= vector .x;
      this .y /= vector .y;
      this .z /= vector .z;
      return this;
   },
   cross: function (vector)
   {
      const
         ax = this   .x, ay = this   .y, az = this   .z,
         bx = vector .x, by = vector .y, bz = vector .z;

      this .x = ay * bz - az * by;
      this .y = az * bx - ax * bz;
      this .z = ax * by - ay * bx;

      return this;
   },
   normalize: function ()
   {
      const length = Math .hypot (this .x, this .y, this .z);

      if (length)
      {
         this .x /= length;
         this .y /= length;
         this .z /= length;
      }

      return this;
   },
   dot: function (vector)
   {
      return this .x * vector .x +
             this .y * vector .y +
             this .z * vector .z;
   },
   norm: function ()
   {
      let
         x = this .x,
         y = this .y,
         z = this .z;

      return x * x +
             y * y +
             z * z;
   },
   magnitude: function ()
   {
      return Math .hypot (this .x, this .y, this .z);
   },
   distance: function (vector)
   {
      return Math .hypot (this .x - vector .x,
                          this .y - vector .y,
                          this .z - vector .z);
   },
   lerp: function (destination, t)
   {
      const
         x = this .x,
         y = this .y,
         z = this .z;

      this .x = x + t * (destination .x - x);
      this .y = y + t * (destination .y - y);
      this .z = z + t * (destination .z - z);
      return this;
   },
   slerp: (function ()
   {
      const tmp = new Vector3 (0, 0, 0);

      return function (destination, t)
      {
         return Math_Algorithm.simpleSlerp (this, tmp .assign (destination), t);
      };
   })(),
   abs: function ()
   {
      this .x = Math .abs (this .x);
      this .y = Math .abs (this .y);
      this .z = Math .abs (this .z);
      return this;
   },
   min: function (vector)
   {
      let
         x = this .x,
         y = this .y,
         z = this .z;

      for (const vector of arguments)
      {
         x = Math .min (x, vector .x);
         y = Math .min (y, vector .y);
         z = Math .min (z, vector .z);
      }

      this .x = x;
      this .y = y;
      this .z = z;
      return this;
   },
   max: function (vector)
   {
      let
         x = this .x,
         y = this .y,
         z = this .z;

      for (const vector of arguments)
      {
         x = Math .max (x, vector .x);
         y = Math .max (y, vector .y);
         z = Math .max (z, vector .z);
      }

      this .x = x;
      this .y = y;
      this .z = z;
      return this;
   },
   toString: function ()
   {
      return this .x + " " +
             this .y + " " +
             this .z;
   }
};

Object .defineProperty (Vector3 .prototype, "0",
{
   get: function () { return this .x; },
   set: function (value) { this .x = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector3 .prototype, "1",
{
   get: function () { return this .y; },
   set: function (value) { this .y = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector3 .prototype, "2",
{
   get: function () { return this .z; },
   set: function (value) { this .z = value; },
   enumerable: false,
   configurable: false
});

Object .assign (Vector3,
{
   Zero: new Vector3 (0, 0, 0),
   One: new Vector3 (1, 1, 1),
   xAxis: new Vector3 (1, 0, 0),
   yAxis: new Vector3 (0, 1, 0),
   zAxis: new Vector3 (0, 0, 1),
   negate: function (vector)
   {
      return vector .copy () .negate ();
   },
   inverse: function (vector)
   {
      return vector .copy () .inverse ();
   },
   add: function (lhs, rhs)
   {
      return lhs .copy () .add (rhs);
   },
   subtract: function (lhs, rhs)
   {
      return lhs .copy () .subtract (rhs);
   },
   multiply: function (lhs, rhs)
   {
      return lhs .copy () .multiply (rhs);
   },
   multVec: function (lhs, rhs)
   {
      return lhs .copy () .multVec (rhs);
   },
   divide: function (lhs, rhs)
   {
      return lhs .copy () .divide (rhs);
   },
   divVec: function (lhs, rhs)
   {
      return lhs .copy () .divVec (rhs);
   },
   cross: function (lhs, rhs)
   {
      return lhs .copy () .cross (rhs);
   },
   normalize: function (vector)
   {
      return vector .copy () .normalize ();
   },
   dot: function (lhs, rhs)
   {
      return lhs .dot (rhs);
   },
   magnitude: function (vector)
   {
      return vector .magnitude ();
   },
   distance: function (lhs, rhs)
   {
      return lhs .distance (rhs);
   },
   lerp: function (source, destination, t)
   {
      return source .copy () .lerp (destination, t);
   },
   slerp: function (source, destination, t)
   {
      return source .copy () .slerp (destination, t);
   },
   abs: function (vector)
   {
      return vector .copy () .abs ();
   },
   min: function (lhs, rhs)
   {
      return this .prototype .min .apply (lhs .copy (), arguments);
   },
   max: function (lhs, rhs)
   {
      return this .prototype .max .apply (lhs .copy (), arguments);
   },
});

/* harmony default export */ const Numbers_Vector3 = (Vector3);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Matrix2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function Matrix2 ()
{
   if (arguments .length)
   {
      this [0] = arguments [0];
      this [1] = arguments [1];
      this [2] = arguments [2];
      this [3] = arguments [3];
   }
   else
   {
      this .identity ();
   }
}

Matrix2 .prototype =
{
   constructor: Matrix2,
   order: 2,
   length: 4,
   [Symbol .iterator]: function* ()
   {
      const length = this .length;

      for (let i = 0; i < length; ++ i)
         yield this [i];
   },
   copy: function ()
   {
      const copy = Object .create (Matrix2 .prototype);
      copy [0] = this [0];
      copy [1] = this [1];
      copy [2] = this [2];
      copy [3] = this [3];
      return copy;
   },
   assign: function (matrix)
   {
      this [0] = matrix [0];
      this [1] = matrix [1];
      this [2] = matrix [2];
      this [3] = matrix [3];
      return this;
   },
   equals: function (matrix)
   {
      return this [0] === matrix [0] &&
             this [1] === matrix [1] &&
             this [2] === matrix [2] &&
             this [3] === matrix [3];
   },
   set1: function (r, c, value)
   {
      this [r * this .order + c] = value;
   },
   get1: function (r, c)
   {
      return this [r * this .order + c];
   },
   set: function ()
   {
      switch (arguments .length)
      {
         case 0:
         {
            this .identity ();
            break;
         }
         case 4:
         {
            this [0] = arguments [0];
            this [1] = arguments [1];
            this [2] = arguments [2];
            this [3] = arguments [3];
            break;
         }
      }

      return this;
   },
   determinant1: function ()
   {
      return this [0];
   },
   determinant: function ()
   {
      return this [0] * this [3] -
             this [1] * this [2];
   },
   transpose: function ()
   {
      const tmp = this [1];

      this [1] = this [2];
      this [2] = tmp;

      return this;
   },
   inverse: function ()
   {
      const
         A = this [0],
         B = this [1],
         C = this [2],
         D = this [3],
         d = A * D - B * C;

      // if (d === 0) ... determinant is zero.

      this [0] =  D / d;
      this [1] = -B / d;
      this [2] = -C / d;
      this [3] =  A / d;

      return this;
   },
   multLeft: function (matrix)
   {
      const
         a0 = this [0], a1 = this [1],
         a2 = this [2], a3 = this [3],
         b0 = matrix [0], b1 = matrix [1],
         b2 = matrix [2], b3 = matrix [3];

      this [0] = a0 * b0 + a2 * b1;
      this [1] = a1 * b0 + a3 * b1;
      this [2] = a0 * b2 + a2 * b3;
      this [3] = a1 * b2 + a3 * b3;

      return this;
   },
   multRight: function (matrix)
   {
      const
         a0 = this [0], a1 = this [1],
         a2 = this [2], a3 = this [3],
         b0 = matrix [0], b1 = matrix [1],
         b2 = matrix [2], b3 = matrix [3];

      this [0] = b0 * a0 + b2 * a1;
      this [1] = b1 * a0 + b3 * a1;
      this [2] = b0 * a2 + b2 * a3;
      this [3] = b1 * a2 + b3 * a3;

      return this;
   },
   multVecMatrix: function (vector)
   {
      if (typeof vector === "number")
      {
         const
            x = vector,
            w = x * this [2] + this [3];

         return (x * this [0] + this [1]) / w;
      }

      const
         x = vector .x,
         y = vector .y;

      vector .x = x * this [0] + y * this [2];
      vector .y = x * this [1] + y * this [3];

      return vector;
   },
   multMatrixVec: function (vector)
   {
      if (typeof vector === "number")
      {
         const
            x = vector,
            w = x * this [2] + this [3];

         return (x * this [0] + this [1]) / w;
      }

      const
         x = vector .x,
         y = vector .y;

      vector .x = x * this [0] + y * this [1];
      vector .y = x * this [2] + y * this [3];

      return vector;
   },
   identity: function ()
   {
      this [0] = 1;
      this [1] = 0;
      this [2] = 0;
      this [3] = 1;
   },
   toString: function ()
   {
      return this [0] + " " + this [1] + " " +
             this [2] + " " + this [3]
   },
};

Object .defineProperty (Matrix2 .prototype, "x",
{
   get: (function ()
   {
      const vector = new Numbers_Vector2 (0, 0);

      return function () { return vector .set (this [0], this [1]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix2 .prototype, "y",
{
   get: (function ()
   {
      const vector = new Numbers_Vector2 (0, 0);

      return function () { return vector .set (this [2], this [3]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix2 .prototype, "xAxis",
{
   get: function () { return this [0]; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix2 .prototype, "origin",
{
   get: function () { return this [2]; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix2 .prototype, "submatrix",
{
   get: function () { return this [0]; },
   enumerable: false,
   configurable: false
});

Object .assign (Matrix2,
{
   Identity: new Matrix2 (),
});

/* harmony default export */ const Numbers_Matrix2 = (Matrix2);

;// CONCATENATED MODULE: ./src/standard/Math/Algorithms/eigen_decomposition.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const eigen_decomposition_a = [ ]; // more scratch
const eigen_decomposition_b = [ ]; // more scratch
const z = [ ]; // more scratch

// Calculate eigenvalues and eigenvectors.
// This is from SGI Inventor Matrix.cpp.
/* harmony default export */ function eigen_decomposition(matrix, result)
{
   const
      ORDER   = matrix .order,
      values  = result .values,
      vectors = result .vectors;

   let
      sm,                // smallest entry
      theta,             // angle for Jacobi rotation
      c, s, t,           // cosine, sine, tangent of theta
      tau,               // sine / (1 + cos)
      h, g,              // two scrap values
      thresh,            // threshold below which no rotation done
      p, q, i, j,
      SIZE = matrix .length;

   // initializations
   for (i = 0; i < ORDER; ++ i)
   {
      eigen_decomposition_a [i] = eigen_decomposition_a [i] || new Array (ORDER);
      eigen_decomposition_b [i] = values [i] = matrix .get1 (i, i);
      z [i] = 0;

      for (j = 0; j < ORDER; ++ j)
      {
         vectors [i] [j] = (i === j) ? 1 : 0;
         eigen_decomposition_a [i] [j] = matrix .get1 (j, i);
      }
   }

   // Why 50? I don't know--it's the way the folks who wrote the
   // algorithm did it:
   for (i = 0; i < 50; ++ i)
   {
      sm = 0;

      for (p = 0; p < ORDER - 1; ++ p)
      {
         for (q = p + 1; q < ORDER; ++ q)
            sm += Math .abs (eigen_decomposition_a [p] [q]);
      }

      if (sm === 0)
         break;

      thresh = i < 3 ?
         0.2 * sm / SIZE :
         0;

      for (p = 0; p < ORDER - 1; ++ p)
      {
         for (q = p + 1; q < ORDER; ++ q)
         {
            g = 100 * Math .abs (eigen_decomposition_a [p] [q]);

            if (i > 3
                && (Math .abs (values [p]) + g === Math .abs (values [p]))
                && (Math .abs (values [q]) + g === Math .abs (values [q]))
            )
            {
               eigen_decomposition_a [p] [q] = 0;
            }

            else if (Math .abs (eigen_decomposition_a [p] [q]) > thresh)
            {
               h = values [q] - values [p];

               if (Math .abs (h) + g === Math .abs (h))
               {
                  t = eigen_decomposition_a [p] [q] / h;
               }
               else
               {
                  theta = 0.5 * h / eigen_decomposition_a [p] [q];
                  t     = 1 / (Math .abs (theta) + Math .sqrt (1 + theta * theta));

                  if (theta < 0)  t = -t;
               }
               // End of computing tangent of rotation angle

               c           = 1 / Math .sqrt (1 + t * t);
               s           = t * c;
               tau         = s / (1 + c);
               h           = t * eigen_decomposition_a [p] [q];
               z [p]      -= h;
               z [q]      += h;
               values [p] -= h;
               values [q] += h;
               eigen_decomposition_a [p] [q]   = 0;

               for (j = 0; j < p; ++ j)
               {
                  g = eigen_decomposition_a [j] [p];
                  h = eigen_decomposition_a [j] [q];
                  eigen_decomposition_a [j] [p] = g - s * (h + g * tau);
                  eigen_decomposition_a [j] [q] = h + s * (g - h * tau);
               }

               for (j = p + 1; j < q; ++ j)
               {
                  g = eigen_decomposition_a [p] [j];
                  h = eigen_decomposition_a [j] [q];
                  eigen_decomposition_a [p] [j] = g - s * (h + g * tau);
                  eigen_decomposition_a [j] [q] = h + s * (g - h * tau);
               }

               for (j = q + 1; j < ORDER; ++ j)
               {
                  g = eigen_decomposition_a [p] [j];
                  h = eigen_decomposition_a [q] [j];
                  eigen_decomposition_a [p] [j] = g - s * (h + g * tau);
                  eigen_decomposition_a [q] [j] = h + s * (g - h * tau);
               }

               for (j = 0; j < ORDER; ++ j)
               {
                  g = vectors [j] [p];
                  h = vectors [j] [q];
                  vectors [j] [p] = g - s * (h + g * tau);
                  vectors [j] [q] = h + s * (g - h * tau);
               }
            }
         }
      }

      for (p = 0; p < ORDER; ++ p)
      {
         values [p] = eigen_decomposition_b [p] += z [p];
         z [p] = 0;
      }
   }

   return result;
};

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Matrix3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function Matrix3 ()
{
   if (arguments .length)
   {
      this [0] = arguments [0];
      this [1] = arguments [1];
      this [2] = arguments [2];
      this [3] = arguments [3];
      this [4] = arguments [4];
      this [5] = arguments [5];
      this [6] = arguments [6];
      this [7] = arguments [7];
      this [8] = arguments [8];
   }
   else
   {
      this .identity ();
   }
}

Matrix3 .prototype =
{
   constructor: Matrix3,
   order: 3,
   length: 9,
   [Symbol .iterator]: function* ()
   {
      const length = this .length;

      for (let i = 0; i < length; ++ i)
         yield this [i];
   },
   copy: function ()
   {
      const copy = Object .create (Matrix3 .prototype);
      copy [0] = this [0];
      copy [1] = this [1];
      copy [2] = this [2];
      copy [3] = this [3];
      copy [4] = this [4];
      copy [5] = this [5];
      copy [6] = this [6];
      copy [7] = this [7];
      copy [8] = this [8];
      return copy;
   },
   assign: function (matrix)
   {
      this [0] = matrix [0];
      this [1] = matrix [1];
      this [2] = matrix [2];
      this [3] = matrix [3];
      this [4] = matrix [4];
      this [5] = matrix [5];
      this [6] = matrix [6];
      this [7] = matrix [7];
      this [8] = matrix [8];
      return this;
   },
   equals: function (matrix)
   {
      return this [0] === matrix [0] &&
             this [1] === matrix [1] &&
             this [2] === matrix [2] &&
             this [3] === matrix [3] &&
             this [4] === matrix [4] &&
             this [5] === matrix [5] &&
             this [6] === matrix [6] &&
             this [7] === matrix [7] &&
             this [8] === matrix [8];
   },
   rotation: function ()
   {
      return math .atan2 (this [1], this [0]);
   },
   set1: function (r, c, value)
   {
      this [r * this .order + c] = value;

      return this;
   },
   get1: function (r, c)
   {
      return this [r * this .order + c];
   },
   set: (function ()
   {
      const invCenter = new Numbers_Vector2 (0, 0);

      return function (translation, rotation, scale, scaleOrientation, center)
      {
         switch (arguments .length)
         {
            case 0:
            {
               this .identity ();
               break;
            }
            case 1:
            {
               if (translation === null) translation = Numbers_Vector2.Zero;

               this .identity ();
               this .translate (translation);
               break;
            }
            case 2:
            {
               if (translation === null) translation = Numbers_Vector2.Zero;
               if (rotation    === null) rotation    = 0;

               this .identity ();
               this .translate (translation);

               if (rotation !== 0)
                  this .rotate (rotation);

               break;
            }
            case 3:
            {
               if (translation === null) translation = Numbers_Vector2.Zero;
               if (rotation    === null) rotation    = 0;
               if (scale       === null) scale       = Numbers_Vector2.One;

               this .identity ();
               this .translate (translation);

               if (rotation !== 0)
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector2.One))
                  this .scale  (scale);

               break;
            }
            case 4:
            {
               if (translation      === null) translation      = Numbers_Vector2.Zero;
               if (rotation         === null) rotation         = 0;
               if (scale            === null) scale            = Numbers_Vector2.One;
               if (scaleOrientation === null) scaleOrientation = 0;

               this .identity ();
               this .translate (translation);

               if (rotation !== 0)
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector2.One))
               {
                  const hasScaleOrientation = scaleOrientation !== 0;

                  if (hasScaleOrientation)
                  {
                     this .rotate (scaleOrientation);
                     this .scale (scale);
                     this .rotate (-scaleOrientation);
                  }
                  else
                     this .scale (scale);
               }

               break;
            }
            case 5:
            {
               if (translation      === null) translation      = Numbers_Vector2.Zero;
               if (rotation         === null) rotation         = 0;
               if (scale            === null) scale            = Numbers_Vector2.One;
               if (scaleOrientation === null) scaleOrientation = 0;
               if (center           === null) center           = Numbers_Vector2.Zero;

               // P' = T * C * R * SR * S * -SR * -C * P
               this .identity ();
               this .translate (translation);

               const hasCenter = ! center .equals (Numbers_Vector2.Zero);

               if (hasCenter)
                  this .translate (center);

               if (rotation !== 0)
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector2.One))
               {
                  if (scaleOrientation !== 0)
                  {
                     this .rotate (scaleOrientation);
                     this .scale (scale);
                     this .rotate (-scaleOrientation);
                  }
                  else
                     this .scale (scale);
               }

               if (hasCenter)
                  this .translate (invCenter .assign (center) .negate ());

               break;
            }
            case 9:
            {
               this [0] = arguments [0];
               this [1] = arguments [1];
               this [2] = arguments [2];
               this [3] = arguments [3];
               this [4] = arguments [4];
               this [5] = arguments [5];
               this [6] = arguments [6];
               this [7] = arguments [7];
               this [8] = arguments [8];
               break;
            }
         }

         return this;
      };
   })(),
   get: (function ()
   {
      const
         dummyTranslation      = new Numbers_Vector2 (0, 0),
         dummyRotation         = new Numbers_Vector3 (0, 0, 0),
         dummyScale            = new Numbers_Vector2 (0, 0),
         dummyScaleOrientation = new Numbers_Vector3 (0, 0, 0),
         dummyCenter           = new Numbers_Vector2 (0, 0),
         rotMatrix             = new Numbers_Matrix2 (),
         soMatrix              = new Numbers_Matrix2 (),
         c                     = new Numbers_Vector2 (0, 0);

      return function (translation, rotation, scale, scaleOrientation, center)
      {
         if (translation      === null) translation      = dummyTranslation;
         if (rotation         === null) rotation         = dummyRotation;
         if (scale            === null) scale            = dummyScale;
         if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
         if (center           === null) center           = dummyCenter;

         switch (arguments .length)
         {
            case 1:
            {
               translation .set (this [6], this [7]);
               break;
            }
            case 2:
            {
               this .factor (translation, rotMatrix, dummyScale, soMatrix);

               rotation [0] = rotMatrix [0];
               rotation [1] = rotMatrix [1];
               rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
               break;
            }
            case 3:
            {
               this .factor (translation, rotMatrix, scale, soMatrix);

               rotation [0] = rotMatrix [0];
               rotation [1] = rotMatrix [1];
               rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
               break;
            }
            case 4:
            {
               this .factor (translation, rotMatrix, scale, soMatrix);

               rotation [0] = rotMatrix [0];
               rotation [1] = rotMatrix [1];
               rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);

               scaleOrientation [0] = soMatrix [0];
               scaleOrientation [1] = soMatrix [1];
               scaleOrientation [2] = Math .atan2 (soMatrix [1], soMatrix [0]);
               break;
            }
            case 5:
            {
               m .set (c .assign (center) .negate ());
               m .multLeft (this);
               m .translate (center);
               m .get (translation, rotation, scale, scaleOrientation);
               break;
            }
         }
      };
   })(),
   factor: (function ()
   {
      const
         si = new Numbers_Matrix2 (),
         u  = new Numbers_Matrix2 (),
         b  = new Numbers_Matrix2 ();

      const eigen = { values: [ ], vectors: [[ ], [ ]] };

      return function (translation, rotation, scale, scaleOrientation)
      {
         // (1) Get translation.
         translation .set (this [6], this [7]);

         // (2) Create 3x3 matrix.
         const a = this .submatrix;

         // (3) Compute det A. If negative, set sign = -1, else sign = 1
         const det      = a .determinant ();
         const det_sign = det < 0 ? -1 : 1;

         // (4) B = A * !A  (here !A means A transpose)
         b .assign (a) .transpose () .multLeft (a);
         const e = eigen_decomposition (b, eigen);

         // Find min / max eigenvalues and do ratio test to determine singularity.

         scaleOrientation .set (e .vectors [0] [0], e .vectors [1] [0],
                                e .vectors [0] [1], e .vectors [1] [1]);

         // Compute s = sqrt(evalues), with sign. Set si = s-inverse

         scale .x = det_sign * Math .sqrt (e .values [0]);
         scale .y = det_sign * Math .sqrt (e .values [1]);

         si [0] = 1 / scale .x;
         si [3] = 1 / scale .y;

         // (5) Compute U = !R ~S R A.
         rotation .assign (u .assign (scaleOrientation) .transpose () .multRight (si) .multRight (scaleOrientation) .multRight (a));
      };
   })(),
   determinant2: function ()
   {
      return this [0] * this [4] -
             this [1] * this [3];
   },
   determinant: function ()
   {
      const
         m0 = this [0], m1 = this [1], m2 = this [2],
         m3 = this [3], m4 = this [4], m5 = this [5],
         m6 = this [6], m7 = this [7], m8 = this [8];

      return m0 * (m4 * m8 - m5 * m7) -
             m1 * (m3 * m8 - m5 * m6) +
             m2 * (m3 * m7 - m4 * m6);
   },
   transpose: function ()
   {
      let tmp;

      tmp = this [1]; this [1] = this [3]; this [3] = tmp;
      tmp = this [2]; this [2] = this [6]; this [6] = tmp;
      tmp = this [5]; this [5] = this [7]; this [7] = tmp;

      return this;
   },
   inverse: function ()
   {
      const
         m0  = this [0],
         m1  = this [1],
         m2  = this [2],
         m3  = this [3],
         m4  = this [4],
         m5  = this [5],
         m6  = this [6],
         m7  = this [7],
         m8  = this [8],
         t4  = m0 * m4,
         t6  = m0 * m7,
         t8  = m3 * m1,
         t10 = m3 * m7,
         t12 = m6 * m1,
         t14 = m6 * m4;

      let d = (t4 * m8 - t6 * m5 - t8 * m8 + t10 * m2 + t12 * m5 - t14 * m2);

      // if (d === 0) ... determinant is zero.

      d = 1 / d;

      const
         b0 =  (m4 * m8 - m7 * m5) * d,
         b1 = -(m1 * m8 - m7 * m2) * d,
         b2 =  (m1 * m5 - m4 * m2) * d,
         b3 = -(m3 * m8 - m6 * m5) * d,
         b4 =  (m0 * m8 - m6 * m2) * d,
         b5 = -(m0 * m5 - m3 * m2) * d;

      this [0] = b0;
      this [1] = b1;
      this [2] = b2;
      this [3] = b3;
      this [4] = b4;
      this [5] = b5;
      this [6] =  (t10 - t14) * d;
      this [7] = -(t6 - t12) * d;
      this [8] =  (t4 - t8) * d;

      return this;
   },
   multLeft: function (matrix)
   {
      const
         a0 = this [0], a1 = this [1], a2 = this [2],
         a3 = this [3], a4 = this [4], a5 = this [5],
         a6 = this [6], a7 = this [7], a8 = this [8],
         b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
         b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
         b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

      this [0] = a0 * b0 + a3 * b1 + a6 * b2;
      this [1] = a1 * b0 + a4 * b1 + a7 * b2;
      this [2] = a2 * b0 + a5 * b1 + a8 * b2;
      this [3] = a0 * b3 + a3 * b4 + a6 * b5;
      this [4] = a1 * b3 + a4 * b4 + a7 * b5;
      this [5] = a2 * b3 + a5 * b4 + a8 * b5;
      this [6] = a0 * b6 + a3 * b7 + a6 * b8;
      this [7] = a1 * b6 + a4 * b7 + a7 * b8;
      this [8] = a2 * b6 + a5 * b7 + a8 * b8;

      return this;
   },
   multRight: function (matrix)
   {
      const
         a0 = this [0], a1 = this [1], a2 = this [2],
         a3 = this [3], a4 = this [4], a5 = this [5],
         a6 = this [6], a7 = this [7], a8 = this [8],
         b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
         b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
         b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

      this [0] = a0 * b0 + a1 * b3 + a2 * b6;
      this [1] = a0 * b1 + a1 * b4 + a2 * b7;
      this [2] = a0 * b2 + a1 * b5 + a2 * b8;
      this [3] = a3 * b0 + a4 * b3 + a5 * b6;
      this [4] = a3 * b1 + a4 * b4 + a5 * b7;
      this [5] = a3 * b2 + a4 * b5 + a5 * b8;
      this [6] = a6 * b0 + a7 * b3 + a8 * b6;
      this [7] = a6 * b1 + a7 * b4 + a8 * b7;
      this [8] = a6 * b2 + a7 * b5 + a8 * b8;

      return this;
   },
   multVecMatrix: function (vector)
   {
      if (vector .length === 2)
      {
         const
            x = vector .x,
            y = vector .y,
            w = x * this [2] + y * this [5] + this [8];

         vector .x = (x * this [0] + y * this [3] + this [6]) / w;
         vector .y = (x * this [1] + y * this [4] + this [7]) / w;

         return vector;
      }

      const
         x = vector .x,
         y = vector .y,
         z = vector .z;

      vector .x = x * this [0] + y * this [3] + z * this [6];
      vector .y = x * this [1] + y * this [4] + z * this [7];
      vector .z = x * this [2] + y * this [5] + z * this [8];

      return vector;
   },
   multMatrixVec: function (vector)
   {
      if (vector .length === 2)
      {
         const
            x = vector .x,
            y = vector .y,
            w = x * this [6] + y * this [7] + this [8];

         vector .x = (x * this [0] + y * this [1] + this [2]) / w;
         vector .y = (x * this [3] + y * this [4] + this [5]) / w;

         return vector;
      }

      const
         x = vector .x,
         y = vector .y,
         z = vector .z;

      vector .x = x * this [0] + y * this [1] + z * this [2];
      vector .y = x * this [3] + y * this [4] + z * this [5];
      vector .z = x * this [6] + y * this [7] + z * this [8];

      return vector;
   },
   multDirMatrix: function (vector)
   {
      const
         x = vector .x,
         y = vector .y;

      vector .x = x * this [0] + y * this [3];
      vector .y = x * this [1] + y * this [4];

      return vector;
   },
   multMatrixDir: function (vector)
   {
      const
         x = vector .x,
         y = vector .y;

      vector .x = x * this [0] + y * this [1];
      vector .y = x * this [3] + y * this [4];

      return vector;
   },
   identity: function ()
   {
      this [0] = 1; this [1] = 0; this [2] = 0;
      this [3] = 0; this [4] = 1; this [5] = 0;
      this [6] = 0; this [7] = 0; this [8] = 1;
   },
   translate: function (translation)
   {
      const
         x = translation .x,
         y = translation .y;

      this [6] += this [0] * x + this [3] * y;
      this [7] += this [1] * x + this [4] * y;

      return this;
   },
   rotate: function (rotation)
   {
      this .multLeft (Matrix3 .Rotation (rotation));

      return this;
   },
   scale: function (scale)
   {
      const
         x = scale .x,
         y = scale .y;

      this [0] *= x;
      this [3] *= y;

      this [1] *= x;
      this [4] *= y;

      return this;
   },
   toString: function ()
   {
      return this [0] + " " + this [1] + " " + this [2] + " " +
             this [3] + " " + this [4] + " " + this [5] + " " +
             this [6] + " " + this [7] + " " + this [8]
   },
};

Object .defineProperty (Matrix3 .prototype, "x",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [0], this [1], this [2]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "y",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [3], this [4], this [5]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "z",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [6], this [7], this [8]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "xAxis",
{
   get: (function ()
   {
      const vector = new Numbers_Vector2 (0, 0);

      return function () { return vector .set (this [0], this [1]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "yAxis",
{
   get: (function ()
   {
      const vector = new Numbers_Vector2 (0, 0);

      return function () { return vector .set (this [3], this [4]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "origin",
{
   get: (function ()
   {
      const vector = new Numbers_Vector2 (0, 0);

      return function () { return vector .set (this [6], this [7]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix3 .prototype, "submatrix",
{
   get: (function ()
   {
      const matrix = new Numbers_Matrix2 ();

      return function ()
      {
         matrix [0] = this [0]; matrix [1] = this [1];
         matrix [2] = this [3]; matrix [3] = this [4];
         return matrix;
      };
   })(),
   enumerable: false,
   configurable: false
});

Object .assign (Matrix3,
{
   Identity: new Matrix3 (),
   Rotation: function (rotation)
   {
      const
         sinAngle = Math .sin (rotation),
         cosAngle = Math .cos (rotation);

      return new Matrix3 ( cosAngle, sinAngle, 0,
                          -sinAngle, cosAngle, 0,
                           0, 0, 1);
   },
   Matrix2: function (matrix)
   {
      return new Matrix3 (matrix [0], matrix [1], 0,
                          matrix [2], matrix [3], 0,
                          0, 0, 1);
   },
   transpose: function (matrix)
   {
      return matrix .copy () .transpose ();
   },
   inverse: function (matrix)
   {
      return matrix .copy () .inverse ();
   },
   multLeft: function (lhs, rhs)
   {
      return lhs .copy () .multLeft (rhs);
   },
   multRight: function (lhs, rhs)
   {
      return lhs .copy () .multRight (rhs);
   },
});

const m = new Matrix3 ();

/* harmony default export */ const Numbers_Matrix3 = (Matrix3);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFMatrix3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function SFMatrix3Template (TypeName, Type, SFVec2, double)
{
   function SFMatrix3 (m00, m01, m02,
                       m10, m11, m12,
                       m20, m21, m22)
   {
      switch (arguments .length)
      {
         case 0:
            return Base_X3DField.call (this, new Numbers_Matrix3 ());

         case 1:
            return Base_X3DField.call (this, arguments [0]);

         case 9:
            return Base_X3DField.call (this, new Numbers_Matrix3 (+m00, +m01, +m02,
                                                      +m10, +m11, +m12,
                                                      +m20, +m21, +m22));
      }

      throw new Error ("Invalid arguments.");
   }

   SFMatrix3 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
      SFMatrixPrototypeTemplate (Numbers_Matrix3, SFVec2, double),
   {
      constructor: SFMatrix3,
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
      setTransform: function (translation, rotation, scale, scaleOrientation, center)
      {
         translation      = translation      ? translation      .getValue () : null;
         rotation         = rotation         ? rotation                      : 0;
         scale            = scale            ? scale            .getValue () : null;
         scaleOrientation = scaleOrientation ? scaleOrientation              : 0;
         center           = center           ? center           .getValue () : null;

         this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
      },
   });

   for (const key of Reflect .ownKeys (SFMatrix3 .prototype))
      Object .defineProperty (SFMatrix3 .prototype, key, { enumerable: false });

   function defineProperty (i)
   {
      Object .defineProperty (SFMatrix3 .prototype, i,
      {
         get: function ()
         {
            return this .getValue () [i];
         },
         set: function (value)
         {
            this .getValue () [i] = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false,
      });
   }

   for (let i = 0, length = Numbers_Matrix3.prototype.length; i < length; ++ i)
      defineProperty (i);

   return SFMatrix3;
}

/* harmony default export */ const SFMatrix3 = ({
   SFMatrix3d: SFMatrix3Template ("SFMatrix3d", Base_X3DConstants.SFMatrix3d, SFVec2.SFVec2d, true),
   SFMatrix3f: SFMatrix3Template ("SFMatrix3f", Base_X3DConstants.SFMatrix3f, SFVec2.SFVec2f, false),
});

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFVec3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function SFVec3Template (TypeName, Type, double)
{
   function SFVec3 (x, y, z)
   {
      switch (arguments .length)
      {
         case 0:
            return Base_X3DField.call (this, new Numbers_Vector3 (0, 0, 0));

         case 1:
            return Base_X3DField.call (this, arguments [0]);

         case 3:
            return Base_X3DField.call (this, new Numbers_Vector3 (+x, +y, +z));
      }

      throw new Error ("Invalid arguments.");
   }

   SFVec3 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
      SFVecPrototypeTemplate (Numbers_Vector3, double),
   {
      constructor: SFVec3,
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
      cross: function (vector)
      {
         return new (this .constructor) (Numbers_Vector3.cross (this .getValue (), vector .getValue ()));
      },
   });

   for (const key of Reflect .ownKeys (SFVec3 .prototype))
      Object .defineProperty (SFVec3 .prototype, key, { enumerable: false });

   const x = {
      get: function ()
      {
         return this .getValue () .x;
      },
      set: function (value)
      {
         this .getValue () .x = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const y = {
      get: function ()
      {
         return this .getValue () .y;
      },
      set: function (value)
      {
         this .getValue () .y = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const z = {
      get: function ()
      {
         return this .getValue () .z;
      },
      set: function (value)
      {
         this .getValue () .z = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFVec3 .prototype, "x", x);
   Object .defineProperty (SFVec3 .prototype, "y", y);
   Object .defineProperty (SFVec3 .prototype, "z", z);

   x .enumerable = false;
   y .enumerable = false;
   z .enumerable = false;

   Object .defineProperty (SFVec3 .prototype, "0", x);
   Object .defineProperty (SFVec3 .prototype, "1", y);
   Object .defineProperty (SFVec3 .prototype, "2", z);

   return SFVec3;
}

/* harmony default export */ const SFVec3 = ({
   SFVec3d: SFVec3Template ("SFVec3d", Base_X3DConstants.SFVec3d, true),
   SFVec3f: SFVec3Template ("SFVec3f", Base_X3DConstants.SFVec3f, false),
});

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Vector4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function Vector4 (x, y, z, w)
{
   this .x = x;
   this .y = y;
   this .z = z;
   this .w = w;
}

Vector4 .prototype =
{
   constructor: Vector4,
   length: 4,
   [Symbol .iterator]: function* ()
   {
      yield this .x;
      yield this .y;
      yield this .z;
      yield this .w;
   },
   copy: function ()
   {
      const copy = Object .create (Vector4 .prototype);
      copy .x = this .x;
      copy .y = this .y;
      copy .z = this .z;
      copy .w = this .w;
      return copy;
   },
   assign: function (vector)
   {
      this .x = vector .x;
      this .y = vector .y;
      this .z = vector .z;
      this .w = vector .w;
      return this;
   },
   set: function (x, y, z, w)
   {
      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
      return this;
   },
   equals: function (vector)
   {
      return this .x === vector .x &&
             this .y === vector .y &&
             this .z === vector .z &&
             this .w === vector .w;
   },
   getReal: function (vector)
   {
      vector .x = this .x / this .w;
      vector .y = this .y / this .w;
      vector .z = this .z / this .w;
   },
   negate: function ()
   {
      this .x = -this .x;
      this .y = -this .y;
      this .z = -this .z;
      this .w = -this .w;
      return this;
   },
   inverse: function ()
   {
      this .x = 1 / this .x;
      this .y = 1 / this .y;
      this .z = 1 / this .z;
      this .w = 1 / this .w;
      return this;
   },
   add: function (vector)
   {
      this .x += vector .x;
      this .y += vector .y;
      this .z += vector .z;
      this .w += vector .w;
      return this;
   },
   subtract: function (vector)
   {
      this .x -= vector .x;
      this .y -= vector .y;
      this .z -= vector .z;
      this .w -= vector .w;
      return this;
   },
   multiply: function (value)
   {
      this .x *= value;
      this .y *= value;
      this .z *= value;
      this .w *= value;
      return this;
   },
   multVec: function (vector)
   {
      this .x *= vector .x;
      this .y *= vector .y;
      this .z *= vector .z;
      this .w *= vector .w;
      return this;
   },
   divide: function (value)
   {
      this .x /= value;
      this .y /= value;
      this .z /= value;
      this .w /= value;
      return this;
   },
   divVec: function (vector)
   {
      this .x /= vector .x;
      this .y /= vector .y;
      this .z /= vector .z;
      this .w /= vector .w;
      return this;
   },
   normalize: function ()
   {
      const length = Math .hypot (this .x, this .y, this .z, this .w);

      if (length)
      {
         this .x /= length;
         this .y /= length;
         this .z /= length;
         this .w /= length;
      }

      return this;
   },
   dot: function (vector)
   {
      return this .x * vector .x +
             this .y * vector .y +
             this .z * vector .z +
             this .w * vector .w;
   },
   norm: function ()
   {
      const
         x = this .x,
         y = this .y,
         z = this .z,
         w = this .w;

      return x * x +
             y * y +
             z * z +
             w * w;
   },
   magnitude: function ()
   {
      return Math .hypot (this .x, this .y, this .z, this .w);
   },
   distance: function (vector)
   {
      return Math .hypot (this .x - vector .x,
                          this .y - vector .y,
                          this .z - vector .z,
                          this .w - vector .w);
   },
   lerp: function (destination, t)
   {
      const
         x = this .x,
         y = this .y,
         z = this .z,
         w = this .w;

      this .x = x + t * (destination .x - x);
      this .y = y + t * (destination .y - y);
      this .z = z + t * (destination .z - z);
      this .w = w + t * (destination .w - w);
      return this;
   },
   abs: function ()
   {
      this .x = Math .abs (this .x);
      this .y = Math .abs (this .y);
      this .z = Math .abs (this .z);
      this .w = Math .abs (this .w);
      return this;
   },
   min: function (vector)
   {
      let
         x = this .x,
         y = this .y,
         z = this .z,
         w = this .w;

      for (const vector of arguments)
      {
         x = Math .min (x, vector .x);
         y = Math .min (y, vector .y);
         z = Math .min (z, vector .z);
         w = Math .min (w, vector .w);
      }

      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
      return this;
   },
   max: function (vector)
   {
      let
         x = this .x,
         y = this .y,
         z = this .z,
         w = this .w;

      for (const vector of arguments)
      {
         x = Math .max (x, vector .x);
         y = Math .max (y, vector .y);
         z = Math .max (z, vector .z);
         w = Math .max (w, vector .w);
      }

      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
      return this;
   },
   toString: function ()
   {
      return this .x + " " +
             this .y + " " +
             this .z + " " +
             this .w;
   },
};

Object .defineProperty (Vector4 .prototype, "0",
{
   get: function () { return this .x; },
   set: function (value) { this .x = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector4 .prototype, "1",
{
   get: function () { return this .y; },
   set: function (value) { this .y = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector4 .prototype, "2",
{
   get: function () { return this .z; },
   set: function (value) { this .z = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Vector4 .prototype, "3",
{
   get: function () { return this .w; },
   set: function (value) { this .w = value; },
   enumerable: false,
   configurable: false
});

Object .assign (Vector4,
{
   Zero: new Vector4 (0, 0, 0, 0),
   One: new Vector4 (1, 1, 1, 1),
   xAxis: new Vector4 (1, 0, 0, 0),
   yAxis: new Vector4 (0, 1, 0, 0),
   zAxis: new Vector4 (0, 0, 1, 0),
   wAxis: new Vector4 (0, 0, 0, 1),
   negate: function (vector)
   {
      return vector .copy () .negate ();
   },
   inverse: function (vector)
   {
      return vector .copy () .inverse ();
   },
   add: function (lhs, rhs)
   {
      return lhs .copy () .add (rhs);
   },
   subtract: function (lhs, rhs)
   {
      return lhs .copy () .subtract (rhs);
   },
   multiply: function (lhs, rhs)
   {
      return lhs .copy () .multiply (rhs);
   },
   multVec: function (lhs, rhs)
   {
      return lhs .copy () .multVec (rhs);
   },
   divide: function (lhs, rhs)
   {
      return lhs .copy () .divide (rhs);
   },
   divVec: function (lhs, rhs)
   {
      return lhs .copy () .divVec (rhs);
   },
   normalize: function (vector)
   {
      return vector .copy () .normalize ();
   },
   dot: function (lhs, rhs)
   {
      return lhs .dot (rhs);
   },
   magnitude: function (vector)
   {
      return vector .magnitude ();
   },
   distance: function (lhs, rhs)
   {
      return lhs .distance (rhs);
   },
   lerp: function (source, destination, t)
   {
      return source .copy () .lerp (destination, t);
   },
   abs: function (vector)
   {
      return vector .copy () .abs ();
   },
   min: function (lhs, rhs)
   {
      return this .prototype .min .apply (lhs .copy (), arguments);
   },
   max: function (lhs, rhs)
   {
      return this .prototype .max .apply (lhs .copy (), arguments);
   },
});

/* harmony default export */ const Numbers_Vector4 = (Vector4);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Quaternion.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function Quaternion (x, y, z, w)
{
   this .x = x;
   this .y = y;
   this .z = z;
   this .w = w;
}

Quaternion .prototype =
{
   constructor: Quaternion,
   length: 4,
   [Symbol .iterator]: function* ()
   {
      yield this .x;
      yield this .y;
      yield this .z;
      yield this .w;
   },
   copy: function ()
   {
      const copy = Object .create (Quaternion .prototype);
      copy .x = this .x;
      copy .y = this .y;
      copy .z = this .z;
      copy .w = this .w;
      return copy;
   },
   assign: function (quat)
   {
      this .x = quat .x;
      this .y = quat .y;
      this .z = quat .z;
      this .w = quat .w;
      return this;
   },
   set: function (x, y, z, w)
   {
      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
      return this;
   },
   setMatrix: function (matrix)
   {
      let i;

      // First, find largest diagonal in matrix:
      if (matrix [0] > matrix [4])
      {
         i = matrix [0] > matrix [8] ? 0 : 2;
      }
      else
      {
         i = matrix [4] > matrix [8] ? 1 : 2;
      }

      const scalerow = matrix [0] + matrix [4] + matrix [8];

      if (scalerow > matrix [i * 3 + i])
      {
         // Compute w first:
         this [3] = Math .sqrt (scalerow + 1) / 2;

         // And compute other values:
         const d = 4 * this [3];
         this [0] = (matrix [5] - matrix [7]) / d;
         this [1] = (matrix [6] - matrix [2]) / d;
         this [2] = (matrix [1] - matrix [3]) / d;
      }
      else
      {
         // Compute x, y, or z first:
         const j = (i + 1) % 3;
         const k = (i + 2) % 3;

         // Compute first value:
         this [i] = Math .sqrt (matrix [i * 3 + i] - matrix [j * 3 + j] - matrix [k * 3 + k] + 1) / 2;

         // And the others:
         const d = 4 * this [i];
         this [j] = (matrix [i * 3 + j] + matrix [j * 3 + i]) / d;
         this [k] = (matrix [i * 3 + k] + matrix [k * 3 + i]) / d;
         this [3] = (matrix [j * 3 + k] - matrix [k * 3 + j]) / d;
      }

      return this;
   },
   getMatrix: function (matrix)
   {
      const
         x = this .x,
         y = this .y,
         z = this .z,
         w = this .w;

      const
         a = x * x,
         b = x * y,
         c = y * y,
         d = y * z,
         e = z * x,
         f = z * z,
         g = w * x,
         h = w * y,
         i = w * z;

      matrix [0] = 1 - 2 * (c + f);
      matrix [1] =     2 * (b + i);
      matrix [2] =     2 * (e - h);

      matrix [3] =     2 * (b - i);
      matrix [4] = 1 - 2 * (f + a);
      matrix [5] =     2 * (d + g);

      matrix [6] =     2 * (e + h);
      matrix [7] =     2 * (d - g);
      matrix [8] = 1 - 2 * (c + a);

      return matrix;
   },
   isReal: function ()
   {
      return ! (this .x || this .y || this .z);
   },
   isImag: function ()
   {
      return ! this .w;
   },
   equals: function (quat)
   {
      return this .x === quat .x &&
             this .y === quat .y &&
             this .z === quat .z &&
             this .w === quat .w;
   },
   negate: function ()
   {
      this .x = -this .x;
      this .y = -this .y;
      this .z = -this .z;
      this .w = -this .w;
      return this;
   },
   inverse: function ()
   {
      this .x = -this .x;
      this .y = -this .y;
      this .z = -this .z;
      return this;
   },
   add: function (quat)
   {
      this .x += quat .x;
      this .y += quat .y;
      this .z += quat .z;
      this .w += quat .w;
      return this;
   },
   subtract: function (quat)
   {
      this .x -= quat .x;
      this .y -= quat .y;
      this .z -= quat .z;
      this .w -= quat .w;
      return this;
   },
   multiply: function (value)
   {
      this .x *= value;
      this .y *= value;
      this .z *= value;
      this .w *= value;
      return this;
   },
   multLeft: function (quat)
   {
      const
         ax = this .x, ay = this .y, az = this .z, aw = this .w,
         bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

      this .x = aw * bx + ax * bw + ay * bz - az * by;
      this .y = aw * by + ay * bw + az * bx - ax * bz;
      this .z = aw * bz + az * bw + ax * by - ay * bx;
      this .w = aw * bw - ax * bx - ay * by - az * bz;

      return this;
   },
   multRight: function (quat)
   {
      const
         ax = this .x, ay = this .y, az = this .z, aw = this .w,
         bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

      this .x = bw * ax + bx * aw + by * az - bz * ay;
      this .y = bw * ay + by * aw + bz * ax - bx * az;
      this .z = bw * az + bz * aw + bx * ay - by * ax;
      this .w = bw * aw - bx * ax - by * ay - bz * az;

      return this;
   },
   divide: function (value)
   {
      this .x /= value;
      this .y /= value;
      this .z /= value;
      this .w /= value;
      return this;
   },
   multVecQuat: function (vector)
   {
      const
         qx = this .x, qy = this .y, qz = this .z, qw = this .w,
         vx = vector .x, vy = vector .y, vz = vector .z,
         a  = qw * qw - qx * qx - qy * qy - qz * qz,
         b  = 2 * (vx * qx + vy * qy + vz * qz),
         c  = 2 * qw;

      vector .x = a * vx + b * qx + c * (qy * vz - qz * vy);
      vector .y = a * vy + b * qy + c * (qz * vx - qx * vz);
      vector .z = a * vz + b * qz + c * (qx * vy - qy * vx);

      return vector;
   },
   multQuatVec: function (vector)
   {
      const
         qx = this .x, qy = this .y, qz = this .z, qw = this .w,
         vx = vector .x, vy = vector .y, vz = vector .z,
         a  = qw * qw - qx * qx - qy * qy - qz * qz,
         b  = 2 * (vx * qx + vy * qy + vz * qz),
         c  = 2 * qw;

      vector .x = a * vx + b * qx - c * (qy * vz - qz * vy);
      vector .y = a * vy + b * qy - c * (qz * vx - qx * vz);
      vector .z = a * vz + b * qz - c * (qx * vy - qy * vx);

      return vector;
   },
   normalize: function ()
   {
      let length = Math .hypot (this .x, this .y, this .z, this .w);

      if (length)
      {
         length = 1 / length;

         this .x *= length;
         this .y *= length;
         this .z *= length;
         this .w *= length;
      }

      return this;
   },
   dot: function (quat)
   {
      return this .x * quat .x +
             this .y * quat .y +
             this .z * quat .z +
             this .w * quat .w;
   },
   norm: function ()
   {
      return this .x * this .x +
             this .y * this .y +
             this .z * this .z +
             this .w * this .w;
   },
   magnitude: function ()
   {
      return Math .hypot (this .x, this .y, this .z, this .w);
   },
   pow: function (exponent)
   {
      if (exponent instanceof Quaternion)
         return this .assign (e .assign (exponent) .multRight (this .log ()) .exp ());

      if (this .isReal ())
         return this .set (0, 0, 0, Math .pow (this .w, exponent));

      const
         l     = this .magnitude (),
         theta = Math .acos (this .w / l),
         li    = this .imag .magnitude (),
         ltoe  = Math .pow (l, exponent),
         et    = exponent * theta,
         scale = ltoe / li * Math .sin (et);

      this .x *= scale;
      this .y *= scale;
      this .z *= scale;
      this .w  = ltoe * Math .cos (et);
      return this;
   },
   log: function ()
   {
      if (this .isReal ())
      {
         if (this .w > 0)
            return this .set (0, 0, 0, Math .log (this .w));

         else
            return this .set (Math .PI, 0, 0, Math .log (-this .w));
      }

      const
         l = this .magnitude (),
         v = this .imag .normalize () .multiply (Math .acos (this .w / l)),
         w = Math .log (l);

      this .x = v .x;
      this .y = v .y;
      this .z = v .z;
      this .w = w;
      return this;
   },
   exp: function ()
   {
      if (this .isReal ())
         return this .set (0, 0, 0, Math .exp (this .w));

      const
         i  = this .imag,
         li = i .magnitude (),
         ew = Math .exp (this .w),
         w  = ew * Math .cos (li),
         v  = i .multiply (ew * Math .sin (li) / li);

      this .x = v .x;
      this .y = v .y;
      this .z = v .z;
      this .w = w;
      return this;
   },
   slerp: function (destination, t)
   {
      return Math_Algorithm.slerp (this, t1 .assign (destination), t);
   },
   squad: function (a, b, destination, t)
   {
      // We must use shortest path slerp to prevent flipping.  Also see spline.

      return Math_Algorithm.slerp (Math_Algorithm.slerp (this, t1 .assign (destination), t),
                               Math_Algorithm.slerp (t2 .assign (a), t3 .assign (b), t),
                               2 * t * (1 - t));
   },
   toString: function ()
   {
      return this .x + " " +
             this .y + " " +
             this .z + " " +
             this .w;
   },
};

Object .defineProperty (Quaternion .prototype, "0",
{
   get: function () { return this .x; },
   set: function (value) { this .x = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Quaternion .prototype, "1",
{
   get: function () { return this .y; },
   set: function (value) { this .y = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Quaternion .prototype, "2",
{
   get: function () { return this .z; },
   set: function (value) { this .z = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Quaternion .prototype, "3",
{
   get: function () { return this .w; },
   set: function (value) { this .w = value; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Quaternion .prototype, "real",
{
   get: function () { return this .w; },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Quaternion .prototype, "imag",
{
   get: (function ()
   {
      const result = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         return result .set (this .x,
                             this .y,
                             this .z);
      };
   })(),
   enumerable: false,
   configurable: false
});

Object .assign (Quaternion,
{
   negate: function (quat)
   {
      return quat .copy () .negate ();
   },
   inverse: function (quat)
   {
      return quat .copy () .inverse ();
   },
   add: function (lhs, rhs)
   {
      return lhs .copy () .add (rhs);
   },
   subtract: function (lhs, rhs)
   {
      return lhs .copy () .subtract (rhs);
   },
   multiply: function (lhs, rhs)
   {
      return lhs .copy () .multiply (rhs);
   },
   multLeft: function (lhs, rhs)
   {
      return lhs .copy () .multLeft (rhs);
   },
   multRight: function (lhs, rhs)
   {
      return lhs .copy () .multRight (rhs);
   },
   divide: function (lhs, rhs)
   {
      return lhs .copy () .divide (rhs);
   },
   normalize: function (quat)
   {
      return quat .copy () .normalize ();
   },
   slerp: function (source, destination, t)
   {
      return source .copy () .slerp (destination, t);
   },
   squad: function (source, a, b, destination, t)
   {
      return source .copy () .squad (a, b, destination, t);
   },
   /*
   bezier: function (q0, a, b, q1, t)
   {
      return q0 .copy () .squad (a, b, q1, t);
   },
   */
   spline: function (Q0, Q1, Q2)
   {
      q0 .assign (Q0);
      q1 .assign (Q1);
      q2 .assign (Q2);

      // If the dot product is smaller than 0 we must negate the quaternion to prevent flipping. If we negate all
      // the terms we get a different quaternion but it represents the same rotation.

      if (q0 .dot (q1) < 0)
         q0 .negate ();

      if (q2 .dot (q1) < 0)
         q2 .negate ();

      q1_i .assign (q1) .inverse ();

      // The result must be normalized as it will be used in slerp and we can only slerp normalized vectors.

      return q1 .multRight (
         t1 .assign (q1_i) .multRight (q0) .log () .add (t2 .assign (q1_i) .multRight (q2) .log ()) .divide (-4) .exp ()
      )
      .normalize () .copy ();
   },
});

const
   t1 = new Quaternion (0, 0, 0, 1),
   t2 = new Quaternion (0, 0, 0, 1),
   t3 = new Quaternion (0, 0, 0, 1);

const
   q0   = new Quaternion (0, 0, 0, 1),
   q1   = new Quaternion (0, 0, 0, 1),
   q2   = new Quaternion (0, 0, 0, 1),
   q1_i = new Quaternion (0, 0, 0, 1);

/* harmony default export */ const Numbers_Quaternion = (Quaternion);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Rotation4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _x     = Symbol (),
   _y     = Symbol (),
   _z     = Symbol (),
   _angle = Symbol ();

function Rotation4 (x, y, z, angle)
{
   this [_x]     = 0;
   this [_y]     = 0;
   this [_z]     = 1;
   this [_angle] = 0;

   switch (arguments .length)
   {
      case 0:
      {
         this .value = new Numbers_Quaternion (0, 0, 0, 1);
         return;
      }
      case 1:
      {
         this .value = arguments [0];
         this .update ();
         return;
      }
      case 2:
      {
         const
            arg0 = arguments [0],
            arg1 = arguments [1];

         this .value = new Numbers_Quaternion (0, 0, 0, 1);

         if (arg1 instanceof Numbers_Vector3)
            return this .setFromToVec (arg0, arg1);

         this .set (arg0 .x,
                    arg0 .y,
                    arg0 .z,
                    arg1);

         return;
      }
      case 4:
      {
         this .value = new Numbers_Quaternion (0, 0, 0, 1);
         this .set (x, y, z, angle);
         return;
      }
   }
}

Rotation4 .prototype =
{
   constructor: Rotation4,
   length: 4,
   [Symbol .iterator]: function* ()
   {
      yield this [_x];
      yield this [_y];
      yield this [_z];
      yield this [_angle];
   },
   update: function ()
   {
      const rotation = this .get ();

      this [_x]     = rotation .x;
      this [_y]     = rotation .y;
      this [_z]     = rotation .z;
      this [_angle] = rotation .w;

      return this;
   },
   copy: function ()
   {
      const copy = Object .create (Rotation4 .prototype);

      copy [_x]     = this [_x];
      copy [_y]     = this [_y];
      copy [_z]     = this [_z];
      copy [_angle] = this [_angle];

      copy .value  = this .value .copy ();

      return copy;
   },
   assign: function (rotation)
   {
      this [_x]     = rotation [_x];
      this [_y]     = rotation [_y];
      this [_z]     = rotation [_z];
      this [_angle] = rotation [_angle];

      this .value .assign (rotation .value);

      return this;
   },
   set: function (x, y, z, angle)
   {
      this [_x]     = x;
      this [_y]     = y;
      this [_z]     = z;
      this [_angle] = angle;

      const scale = Math .hypot (x, y, z);

      if (scale === 0)
      {
         this .value .set (0, 0, 0, 1);
         return this;
      }

      // Calculate quaternion

      const
         halfTheta = Math_Algorithm.interval (angle / 2, 0, Math .PI),
         ascale    = Math .sin (halfTheta) / scale;

      this .value .set (x * ascale,
                        y * ascale,
                        z * ascale,
                        Math .cos (halfTheta));
      return this;
   },
   get: (function ()
   {
      const result = new Numbers_Vector4 (0, 0, 0, 0);

      return function ()
      {
         const value = this .value;

         if (Math .abs (value .w) > 1)
         {
            return Numbers_Vector4.zAxis;
         }
         else
         {
            const
               angle = Math .acos (value .w) * 2,
               scale = Math .sin (angle / 2);

            if (scale === 0)
            {
               return Numbers_Vector4.zAxis;
            }
            else
            {
               const axis = value .imag .divide (scale);

               return result .set (axis .x,
                                   axis .y,
                                   axis .z,
                                   angle);
            }
         }
      };
   })(),
   setAxisAngle: function (axis, angle)
   {
      return this .set (axis .x, axis .y, axis .z, angle);
   },
   setFromToVec: (function ()
   {
      const
         from = new Numbers_Vector3 (0, 0, 0),
         to   = new Numbers_Vector3 (0, 0, 0),
         cv   = new Numbers_Vector3 (0, 0, 0),
         t    = new Numbers_Vector3 (0, 0, 0);

      return function (fromVec, toVec)
      {
         // https://bitbucket.org/Coin3D/coin/src/abc9f50968c9/src/base/SbRotation.cpp

         from .assign (fromVec) .normalize ();
         to   .assign (toVec)   .normalize ();

         const
            cos_angle = Math_Algorithm.clamp (from .dot (to), -1, 1),
            crossvec  = cv .assign (from) .cross (to) .normalize (),
            crosslen  = crossvec .magnitude ();

         if (crosslen === 0)
         {
            // Parallel vectors
            // Check if they are pointing in the same direction.
            if (cos_angle > 0)
               this .value .set (0, 0, 0, 1); // standard rotation

            // Ok, so they are parallel and pointing in the opposite direction
            // of each other.
            else
            {
               // Try crossing with x axis.
               t .assign (from) .cross (Numbers_Vector3.xAxis);

               // If not ok, cross with y axis.
               if (t .norm () === 0)
                  t .assign (from) .cross (Numbers_Vector3.yAxis);

               t .normalize ();

               this .value .set (t .x, t .y, t .z, 0);
            }
         }
         else
         {
            // Vectors are not parallel
            // The abs () wrapping is to avoid problems when `dot' "overflows" a tiny wee bit,
            // which can lead to sqrt () returning NaN.
            crossvec .multiply (Math .sqrt (Math .abs (1 - cos_angle) / 2));

            this .value .set (crossvec .x,
                              crossvec .y,
                              crossvec .z,
                              Math .sqrt (Math .abs (1 + cos_angle) / 2));
         }

         this .update ();

         return this;
      };
   })(),
   setAxis: function (vector)
   {
      this .set (vector .x, vector .y, vector .z, this [_angle]);
   },
   getAxis: (function ()
   {
      const axis = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         return axis .set (this [_x], this [_y], this [_z]);
      };
   })(),
   setMatrix: function (matrix)
   {
      this .value .setMatrix (matrix) .normalize ();
      this .update ();
      return this;
   },
   getMatrix: function (matrix)
   {
      return this .value .getMatrix (matrix);
   },
   equals: function (rot)
   {
      return this .value .equals (rot .value);
   },
   inverse: function ()
   {
      this .value .inverse ();
      this .update ();
      return this;
   },
   multLeft: function (rotation)
   {
      this .value .multLeft (rotation .value) .normalize ();
      this .update ();
      return this;
   },
   multRight: function (rotation)
   {
      this .value .multRight (rotation .value) .normalize ();
      this .update ();
      return this;
   },
   multVecRot: function (vector)
   {
      return this .value .multVecQuat (vector);
   },
   multRotVec: function (vector)
   {
      return this .value .multQuatVec (vector);
   },
   normalize: function ()
   {
      this .value .normalize ();
      this .update ();
      return this;
   },
   pow: function (exponent)
   {
      this .value .pow (exponent);
      this .update ();
      return this;
   },
   slerp: function (dest, t)
   {
      this .value .slerp (dest .value, t);
      this .update ();
      return this;
   },
   squad: function (a ,b, dest, t)
   {
      this .value .squad (a .value, b .value, dest .value, t);
      this .update ();
      return this;
   },
   toString: function ()
   {
      return this [_x] + " " +
             this [_y] + " " +
             this [_z] + " " +
             this [_angle];
   }
};

const x = {
   get: function ()
   {
      return this [_x];
   },
   set: function (value)
   {
      this [_x] = value;
      this .set (value, this [_y], this [_z], this [_angle]);
   },
   enumerable: true,
   configurable: false
};

const y = {
   get: function ()
   {
      return this [_y];
   },
   set: function (value)
   {
      this [_y] = value;
      this .set (this [_x], value, this [_z], this [_angle]);
   },
   enumerable: true,
   configurable: false
};

const Rotation4_z = {
   get: function ()
   {
      return this [_z];
   },
   set: function (value)
   {
      this [_z] = value;
      this .set (this [_x], this [_y], value, this [_angle]);
   },
   enumerable: true,
   configurable: false
};

const angle = {
   get: function ()
   {
      return this [_angle];
   },
   set: function (value)
   {
      this [_angle] = value;
      this .set (this [_x], this [_y], this [_z], value);
   },
   enumerable: true,
   configurable: false
};

Object .defineProperty (Rotation4 .prototype, "x", x);
Object .defineProperty (Rotation4 .prototype, "y", y);
Object .defineProperty (Rotation4 .prototype, "z", Rotation4_z);
Object .defineProperty (Rotation4 .prototype, "angle", angle);

x     .enumerable = false;
y     .enumerable = false;
Rotation4_z     .enumerable = false;
angle .enumerable = false;

Object .defineProperty (Rotation4 .prototype, "0", x);
Object .defineProperty (Rotation4 .prototype, "1", y);
Object .defineProperty (Rotation4 .prototype, "2", Rotation4_z);
Object .defineProperty (Rotation4 .prototype, "3", angle);

Object .assign (Rotation4,
{
   Identity: new Rotation4 (),
   inverse: function (rotation)
   {
      return rotation .copy () .inverse ();
   },
   multRight: function (lhs, rhs)
   {
      return lhs .copy () .multRight (rhs);
   },
   normalize: function (rotation)
   {
      return rotation .copy () .normalize ();
   },
   slerp: function (source, destination, t)
   {
      return source .copy () .slerp (destination, t);
   },
   squad: function (source, a, b, destination, t)
   {
      return source .copy () .squad (a, b, destination, t);
   },
   /*
   bezier: function (source, a, b, destination, t)
   {
      const copy = Object .create (this .prototype);
      copy .value = Quaternion .bezier (source .value, a, b, destination .value, t);
      copy .update ();
      return copy;
   },
   */
   spline: function (q0, q1, q2)
   {
      const copy = Object .create (this .prototype);
      copy .value = Numbers_Quaternion.spline (q0 .value, q1 .value, q2 .value);
      copy .update ();
      return copy;
   },
});

/* harmony default export */ const Numbers_Rotation4 = (Rotation4);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Matrix4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Matrix4_Matrix4 ()
{
   if (arguments .length)
   {
      this [ 0] = arguments [ 0];
      this [ 1] = arguments [ 1];
      this [ 2] = arguments [ 2];
      this [ 3] = arguments [ 3];
      this [ 4] = arguments [ 4];
      this [ 5] = arguments [ 5];
      this [ 6] = arguments [ 6];
      this [ 7] = arguments [ 7];
      this [ 8] = arguments [ 8];
      this [ 9] = arguments [ 9];
      this [10] = arguments [10];
      this [11] = arguments [11];
      this [12] = arguments [12];
      this [13] = arguments [13];
      this [14] = arguments [14];
      this [15] = arguments [15];
   }
   else
   {
      this .identity ();
   }
}

Matrix4_Matrix4 .prototype =
{
   constructor: Matrix4_Matrix4,
   order: 4,
   length: 16,
   [Symbol .iterator]: function* ()
   {
      const length = this .length;

      for (let i = 0; i < length; ++ i)
         yield this [i];
   },
   copy: function ()
   {
      const copy = Object .create (Matrix4_Matrix4 .prototype);
      copy [ 0] = this [ 0];
      copy [ 1] = this [ 1];
      copy [ 2] = this [ 2];
      copy [ 3] = this [ 3];
      copy [ 4] = this [ 4];
      copy [ 5] = this [ 5];
      copy [ 6] = this [ 6];
      copy [ 7] = this [ 7];
      copy [ 8] = this [ 8];
      copy [ 9] = this [ 9];
      copy [10] = this [10];
      copy [11] = this [11];
      copy [12] = this [12];
      copy [13] = this [13];
      copy [14] = this [14];
      copy [15] = this [15];
      return copy;
   },
   assign: function (matrix)
   {
      this [ 0] = matrix [ 0];
      this [ 1] = matrix [ 1];
      this [ 2] = matrix [ 2];
      this [ 3] = matrix [ 3];
      this [ 4] = matrix [ 4];
      this [ 5] = matrix [ 5];
      this [ 6] = matrix [ 6];
      this [ 7] = matrix [ 7];
      this [ 8] = matrix [ 8];
      this [ 9] = matrix [ 9];
      this [10] = matrix [10];
      this [11] = matrix [11];
      this [12] = matrix [12];
      this [13] = matrix [13];
      this [14] = matrix [14];
      this [15] = matrix [15];
      return this;
   },
   equals: function (matrix)
   {
      return this [ 0] === matrix [ 0] &&
             this [ 1] === matrix [ 1] &&
             this [ 2] === matrix [ 2] &&
             this [ 3] === matrix [ 3] &&
             this [ 4] === matrix [ 4] &&
             this [ 5] === matrix [ 5] &&
             this [ 6] === matrix [ 6] &&
             this [ 7] === matrix [ 7] &&
             this [ 8] === matrix [ 8] &&
             this [ 9] === matrix [ 9] &&
             this [10] === matrix [10] &&
             this [11] === matrix [11] &&
             this [12] === matrix [12] &&
             this [13] === matrix [13] &&
             this [14] === matrix [14] &&
             this [15] === matrix [15];
   },
   set1: function (r, c, value)
   {
      this [r * this .order + c] = value;

      return this;
   },
   get1: function (r, c)
   {
      return this [r * this .order + c];
   },
   set: (function ()
   {
      const
         invScaleOrientation = new Numbers_Rotation4 (),
         invCenter           = new Numbers_Vector3 (0, 0, 0);

      return function (translation, rotation, scale, scaleOrientation, center)
      {
         switch (arguments .length)
         {
            case 0:
            {
               this .identity ();
               break;
            }
            case 1:
            {
               if (translation === null) translation = Numbers_Vector3.Zero;

               this .identity ();
               this .translate (translation);
               break;
            }
            case 2:
            {
               if (translation === null) translation = Numbers_Vector3.Zero;
               if (rotation    === null) rotation    = Numbers_Rotation4.Identity;

               this .identity ();
               this .translate (translation);

               if (! rotation .equals (Numbers_Rotation4.Identity))
                  this .rotate (rotation);

               break;
            }
            case 3:
            {
               if (translation === null) translation = Numbers_Vector3.Zero;
               if (rotation    === null) rotation    = Numbers_Rotation4.Identity;
               if (scale       === null) scale       = Numbers_Vector3.One;

               this .identity ();
               this .translate (translation);

               if (! rotation .equals (Numbers_Rotation4.Identity))
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector3.One))
                  this .scale  (scale);

               break;
            }
            case 4:
            {
               if (translation      === null) translation      = Numbers_Vector3.Zero;
               if (rotation         === null) rotation         = Numbers_Rotation4.Identity;
               if (scale            === null) scale            = Numbers_Vector3.One;
               if (scaleOrientation === null) scaleOrientation = Numbers_Rotation4.Identity;

               this .identity ();
               this .translate (translation);

               if (! rotation .equals (Numbers_Rotation4.Identity))
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector3.One))
               {
                  const hasScaleOrientation = ! scaleOrientation .equals (Numbers_Rotation4.Identity);

                  if (hasScaleOrientation)
                  {
                     this .rotate (scaleOrientation);
                     this .scale (scale);
                     this .rotate (invScaleOrientation .assign (scaleOrientation) .inverse ());
                  }
                  else
                     this .scale (scale);
               }

               break;
            }
            case 5:
            {
               if (translation      === null) translation      = Numbers_Vector3.Zero;
               if (rotation         === null) rotation         = Numbers_Rotation4.Identity;
               if (scale            === null) scale            = Numbers_Vector3.One;
               if (scaleOrientation === null) scaleOrientation = Numbers_Rotation4.Identity;
               if (center           === null) center           = Numbers_Vector3.Zero;

               // P' = T * C * R * SR * S * -SR * -C * P
               this .identity ();
               this .translate (translation);

               const hasCenter = ! center .equals (Numbers_Vector3.Zero);

               if (hasCenter)
                  this .translate (center);

               if (! rotation .equals (Numbers_Rotation4.Identity))
                  this .rotate (rotation);

               if (! scale .equals (Numbers_Vector3.One))
               {
                  if (! scaleOrientation .equals (Numbers_Rotation4.Identity))
                  {
                     this .rotate (scaleOrientation);
                     this .scale (scale);
                     this .rotate (invScaleOrientation .assign (scaleOrientation) .inverse ());
                  }
                  else
                     this .scale (scale);
               }

               if (hasCenter)
                  this .translate (invCenter .assign (center) .negate ());

               break;
            }
            case 16:
            {
               this [ 0] = arguments [ 0];
               this [ 1] = arguments [ 1];
               this [ 2] = arguments [ 2];
               this [ 3] = arguments [ 3];
               this [ 4] = arguments [ 4];
               this [ 5] = arguments [ 5];
               this [ 6] = arguments [ 6];
               this [ 7] = arguments [ 7];
               this [ 8] = arguments [ 8];
               this [ 9] = arguments [ 9];
               this [10] = arguments [10];
               this [11] = arguments [11];
               this [12] = arguments [12];
               this [13] = arguments [13];
               this [14] = arguments [14];
               this [15] = arguments [15];
               break;
            }
         }

         return this;
      };
   })(),
   get: (function ()
   {
      const
         dummyTranslation      = new Numbers_Vector3 (0, 0, 0),
         dummyRotation         = new Numbers_Rotation4 (),
         dummyScale            = new Numbers_Vector3 (0, 0, 0),
         dummyScaleOrientation = new Numbers_Rotation4 (),
         dummyCenter           = new Numbers_Vector3 (0, 0, 0),
         rot                   = new Numbers_Matrix3 (),
         so                    = new Numbers_Matrix3 (),
         c                     = new Numbers_Vector3 (0, 0, 0);

      return function (translation, rotation, scale, scaleOrientation, center)
      {
         if (translation      === null) translation      = dummyTranslation;
         if (rotation         === null) rotation         = dummyRotation;
         if (scale            === null) scale            = dummyScale;
         if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
         if (center           === null) center           = dummyCenter;

         switch (arguments .length)
         {
            case 1:
            {
               translation .set (this [12], this [13], this [14]);
               break;
            }
            case 2:
            {
               this .factor (translation, rot, dummyScale, so);
               rotation .setMatrix (rot);
               break;
            }
            case 3:
            {
               this .factor (translation, rot, scale, so);
               rotation .setMatrix (rot);
               break;
            }
            case 4:
            {
               this .factor (translation, rot, scale, so);
               rotation         .setMatrix (rot);
               scaleOrientation .setMatrix (so);
               break;
            }
            case 5:
            {
               Matrix4_m .set (c .assign (center) .negate ());
               Matrix4_m .multLeft (this);
               Matrix4_m .translate (center);
               Matrix4_m .get (translation, rotation, scale, scaleOrientation);
               break;
            }
         }
      };
   })(),
   setRotation: function (rotation)
   {
      return this .setQuaternion (rotation .value);
   },
   setQuaternion: function (quaternion)
   {
      const
         x = quaternion .x,
         y = quaternion .y,
         z = quaternion .z,
         w = quaternion .w,
         A = y * y,
         B = z * z,
         C = x * y,
         D = z * w,
         E = z * x,
         F = y * w,
         G = x * x,
         H = y * z,
         I = x * w;

      this [0]  = 1 - 2 * (A + B);
      this [1]  = 2 * (C + D);
      this [2]  = 2 * (E - F);
      this [3]  = 0;
      this [4]  = 2 * (C - D);
      this [5]  = 1 - 2 * (B + G);
      this [6]  = 2 * (H + I);
      this [7]  = 0;
      this [8]  = 2 * (E + F);
      this [9]  = 2 * (H - I);
      this [10] = 1 - 2 * (A + G);
      this [11] = 0;
      this [12] = 0;
      this [13] = 0;
      this [14] = 0;
      this [15] = 1;

      return this;
   },
   factor: (function ()
   {
      const
         si = new Numbers_Matrix3 (),
         u  = new Numbers_Matrix3 (),
         b  = new Numbers_Matrix3 ();

      const eigen = { values: [ ], vectors: [[ ], [ ], [ ]] };

      return function (translation, rotation, scale, scaleOrientation)
      {
         // (1) Get translation.
         translation .set (this [12], this [13], this [14]);

         // (2) Create 3x3 matrix.
         const a = this .submatrix;

         // (3) Compute det A. If negative, set sign = -1, else sign = 1
         const det      = a .determinant ();
         const det_sign = det < 0 ? -1 : 1;

         // (4) B = A * !A  (here !A means A transpose)
         b .assign (a) .transpose () .multLeft (a);
         const e = eigen_decomposition (b, eigen);

         // Find min / max eigenvalues and do ratio test to determine singularity.

         scaleOrientation .set (e .vectors [0] [0], e .vectors [1] [0], e .vectors [2] [0],
                                e .vectors [0] [1], e .vectors [1] [1], e .vectors [2] [1],
                                e .vectors [0] [2], e .vectors [1] [2], e .vectors [2] [2]);

         // Compute s = sqrt(evalues), with sign. Set si = s-inverse

         scale .x = det_sign * Math .sqrt (e .values [0]);
         scale .y = det_sign * Math .sqrt (e .values [1]);
         scale .z = det_sign * Math .sqrt (e .values [2]);

         si [0] = 1 / scale .x;
         si [4] = 1 / scale .y;
         si [8] = 1 / scale .z;

         // (5) Compute U = !R ~S R A.
         rotation .assign (u .assign (scaleOrientation) .transpose () .multRight (si) .multRight (scaleOrientation) .multRight (a));
      };
   })(),
   determinant3: function ()
   {
      const
         m00 = this [0], m01 = this [1], m02 = this [ 2],
         m04 = this [4], m05 = this [5], m06 = this [ 6],
         m08 = this [8], m09 = this [9], m10 = this [10];

      return m00 * (m05 * m10 - m06 * m09) -
             m01 * (m04 * m10 - m06 * m08) +
             m02 * (m04 * m09 - m05 * m08);
   },
   determinant: function ()
   {
      const
         m00 = this [ 0],
         m01 = this [ 1],
         m02 = this [ 2],
         m03 = this [ 3],
         m04 = this [ 4],
         m05 = this [ 5],
         m06 = this [ 6],
         m07 = this [ 7],
         m08 = this [ 8],
         m09 = this [ 9],
         m10 = this [10],
         m11 = this [11],
         m12 = this [12],
         m13 = this [13],
         m14 = this [14],
         m15 = this [15],
         b = m10 * m15,
         c = m14 * m11,
         d = m06 * m15,
         e = m14 * m07,
         f = m06 * m11,
         g = m10 * m07,
         h = m02 * m15,
         i = m14 * m03,
         j = m02 * m11,
         o = m10 * m03,
         r = m02 * m07,
         x = m06 * m03,
         H = b * m05 + e * m09 + f * m13 - (c * m05) - (d * m09) - (g * m13),
         I = c * m01 + h * m09 + o * m13 - (b * m01) - (i * m09) - (j * m13),
         J = d * m01 + i * m05 + r * m13 - (e * m01) - (h * m05) - (x * m13),
         K = g * m01 + j * m05 + x * m09 - (f * m01) - (o * m05) - (r * m09);

      return m00 * H + m04 * I + m08 * J + m12 * K;
   },
   transpose: function ()
   {
      let tmp;

      tmp = this [ 1]; this [ 1] = this [ 4]; this [ 4] = tmp;
      tmp = this [ 2]; this [ 2] = this [ 8]; this [ 8] = tmp;
      tmp = this [ 3]; this [ 3] = this [12]; this [12] = tmp;
      tmp = this [ 6]; this [ 6] = this [ 9]; this [ 9] = tmp;
      tmp = this [ 7]; this [ 7] = this [13]; this [13] = tmp;
      tmp = this [11]; this [11] = this [14]; this [14] = tmp;

      return this;
   },
   inverse: function ()
   {
      const
         m00 = this [ 0],
         m01 = this [ 1],
         m02 = this [ 2],
         m03 = this [ 3],
         m04 = this [ 4],
         m05 = this [ 5],
         m06 = this [ 6],
         m07 = this [ 7],
         m08 = this [ 8],
         m09 = this [ 9],
         m10 = this [10],
         m11 = this [11],
         m12 = this [12],
         m13 = this [13],
         m14 = this [14],
         m15 = this [15],
         b = m10 * m15,
         c = m14 * m11,
         d = m06 * m15,
         e = m14 * m07,
         f = m06 * m11,
         g = m10 * m07,
         h = m02 * m15,
         i = m14 * m03,
         j = m02 * m11,
         o = m10 * m03,
         r = m02 * m07,
         x = m06 * m03,
         t = m08 * m13,
         p = m12 * m09,
         v = m04 * m13,
         s = m12 * m05,
         y = m04 * m09,
         z = m08 * m05,
         A = m00 * m13,
         C = m12 * m01,
         D = m00 * m09,
         E = m08 * m01,
         F = m00 * m05,
         G = m04 * m01,
         H = b * m05 + e * m09 + f * m13 - ((c * m05) + (d * m09) + (g * m13)),
         I = c * m01 + h * m09 + o * m13 - ((b * m01) + (i * m09) + (j * m13)),
         J = d * m01 + i * m05 + r * m13 - ((e * m01) + (h * m05) + (x * m13)),
         K = g * m01 + j * m05 + x * m09 - ((f * m01) + (o * m05) + (r * m09));

      let B = m00 * H + m04 * I + m08 * J + m12 * K;

      // if (B === 0) ... determinant is zero.

      B = 1 / B;

      this [ 0] = B * H;
      this [ 1] = B * I;
      this [ 2] = B * J;
      this [ 3] = B * K;
      this [ 4] = B * (c * m04 + d * m08 + g * m12 - (b * m04) - (e * m08) - (f * m12));
      this [ 5] = B * (b * m00 + i * m08 + j * m12 - (c * m00) - (h * m08) - (o * m12));
      this [ 6] = B * (e * m00 + h * m04 + x * m12 - (d * m00) - (i * m04) - (r * m12));
      this [ 7] = B * (f * m00 + o * m04 + r * m08 - (g * m00) - (j * m04) - (x * m08));
      this [ 8] = B * (t * m07 + s * m11 + y * m15 - (p * m07) - (v * m11) - (z * m15));
      this [ 9] = B * (p * m03 + A * m11 + E * m15 - (t * m03) - (C * m11) - (D * m15));
      this [10] = B * (v * m03 + C * m07 + F * m15 - (s * m03) - (A * m07) - (G * m15));
      this [11] = B * (z * m03 + D * m07 + G * m11 - (y * m03) - (E * m07) - (F * m11));
      this [12] = B * (v * m10 + z * m14 + p * m06 - (y * m14) - (t * m06) - (s * m10));
      this [13] = B * (D * m14 + t * m02 + C * m10 - (A * m10) - (E * m14) - (p * m02));
      this [14] = B * (A * m06 + G * m14 + s * m02 - (F * m14) - (v * m02) - (C * m06));
      this [15] = B * (F * m10 + y * m02 + E * m06 - (D * m06) - (G * m10) - (z * m02));

      return this;
   },
   multLeft: function (matrix)
   {
      const
         a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
         a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
         a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
         a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
         b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
         b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
         b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
         b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

      this [ 0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
      this [ 1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
      this [ 2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
      this [ 3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;
      this [ 4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
      this [ 5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
      this [ 6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
      this [ 7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;
      this [ 8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
      this [ 9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
      this [10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
      this [11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;
      this [12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
      this [13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
      this [14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
      this [15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

      return this;
   },
   multRight: function (matrix)
   {
      const
         a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
         a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
         a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
         a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
         b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
         b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
         b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
         b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

      this [ 0] = a00 * b00 + a01 * b04 + a02 * b08 + a03 * b12;
      this [ 1] = a00 * b01 + a01 * b05 + a02 * b09 + a03 * b13;
      this [ 2] = a00 * b02 + a01 * b06 + a02 * b10 + a03 * b14;
      this [ 3] = a00 * b03 + a01 * b07 + a02 * b11 + a03 * b15;
      this [ 4] = a04 * b00 + a05 * b04 + a06 * b08 + a07 * b12;
      this [ 5] = a04 * b01 + a05 * b05 + a06 * b09 + a07 * b13;
      this [ 6] = a04 * b02 + a05 * b06 + a06 * b10 + a07 * b14;
      this [ 7] = a04 * b03 + a05 * b07 + a06 * b11 + a07 * b15;
      this [ 8] = a08 * b00 + a09 * b04 + a10 * b08 + a11 * b12;
      this [ 9] = a08 * b01 + a09 * b05 + a10 * b09 + a11 * b13;
      this [10] = a08 * b02 + a09 * b06 + a10 * b10 + a11 * b14;
      this [11] = a08 * b03 + a09 * b07 + a10 * b11 + a11 * b15;
      this [12] = a12 * b00 + a13 * b04 + a14 * b08 + a15 * b12;
      this [13] = a12 * b01 + a13 * b05 + a14 * b09 + a15 * b13;
      this [14] = a12 * b02 + a13 * b06 + a14 * b10 + a15 * b14;
      this [15] = a12 * b03 + a13 * b07 + a14 * b11 + a15 * b15;

      return this;
   },
   multVecMatrix: function (vector)
   {
      if (vector .length === 3)
      {
         const
            x = vector .x,
            y = vector .y,
            z = vector .z,
            w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

         vector .x = (x * this [0] + y * this [4] + z * this [ 8] + this [12]) * w;
         vector .y = (x * this [1] + y * this [5] + z * this [ 9] + this [13]) * w;
         vector .z = (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;

         return vector;
      }

      const
         x = vector .x,
         y = vector .y,
         z = vector .z,
         w = vector .w;

      vector .x = x * this [0] + y * this [4] + z * this [ 8] + w * this [12];
      vector .y = x * this [1] + y * this [5] + z * this [ 9] + w * this [13];
      vector .z = x * this [2] + y * this [6] + z * this [10] + w * this [14];
      vector .w = x * this [3] + y * this [7] + z * this [11] + w * this [15];

      return vector;
   },
   multMatrixVec: function (vector)
   {
      if (vector .length === 3)
      {
         const
            x = vector .x,
            y = vector .y,
            z = vector .z,
            w = 1 / (x * this [12] + y * this [13] + z * this [14] + this [15]);

         vector .x = (x * this [0] + y * this [1] + z * this [ 2] + this [ 3]) * w;
         vector .y = (x * this [4] + y * this [5] + z * this [ 6] + this [ 7]) * w;
         vector .z = (x * this [8] + y * this [9] + z * this [10] + this [11]) * w;

         return vector;
      }

      const
         x = vector .x,
         y = vector .y,
         z = vector .z,
         w = vector .w;

      vector .x = x * this [ 0] + y * this [ 1] + z * this [ 2] + w * this [ 3];
      vector .y = x * this [ 4] + y * this [ 5] + z * this [ 6] + w * this [ 7];
      vector .z = x * this [ 8] + y * this [ 9] + z * this [10] + w * this [11];
      vector .w = x * this [12] + y * this [13] + z * this [14] + w * this [15];

      return vector;
   },
   multDirMatrix: function (vector)
   {
      const
         x = vector .x,
         y = vector .y,
         z = vector .z;

      vector .x = x * this [0] + y * this [4] + z * this [ 8];
      vector .y = x * this [1] + y * this [5] + z * this [ 9];
      vector .z = x * this [2] + y * this [6] + z * this [10];

      return vector;
   },
   multMatrixDir: function (vector)
   {
      const
         x = vector .x,
         y = vector .y,
         z = vector .z;

      vector .x = x * this [0] + y * this [1] + z * this [ 2];
      vector .y = x * this [4] + y * this [5] + z * this [ 6];
      vector .z = x * this [8] + y * this [9] + z * this [10];

      return vector;
   },
   identity: function ()
   {
      this [ 0] = 1; this [ 1] = 0; this [ 2] = 0; this [ 3] = 0;
      this [ 4] = 0; this [ 5] = 1; this [ 6] = 0; this [ 7] = 0;
      this [ 8] = 0; this [ 9] = 0; this [10] = 1; this [11] = 0;
      this [12] = 0; this [13] = 0; this [14] = 0; this [15] = 1;
   },
   translate: function (translation)
   {
      const
         x = translation .x,
         y = translation .y,
         z = translation .z;

      this [12] += this [ 0] * x + this [ 4] * y + this [ 8] * z;
      this [13] += this [ 1] * x + this [ 5] * y + this [ 9] * z;
      this [14] += this [ 2] * x + this [ 6] * y + this [10] * z;

      return this;
   },
   rotate: function (rotation)
   {
      this .multLeft (Matrix4_m .setQuaternion (rotation .value));

      return this;
   },
   scale: function (scale)
   {
      const
         x = scale .x,
         y = scale .y,
         z = scale .z;

      this [ 0] *= x;
      this [ 4] *= y;
      this [ 8] *= z;

      this [ 1] *= x;
      this [ 5] *= y;
      this [ 9] *= z;

      this [ 2] *= x;
      this [ 6] *= y;
      this [10] *= z;

      return this;
   },
   getDepth: function (vector)
   {
      const
         x = vector .x,
         y = vector .y,
         z = vector .z,
         w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

      return (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;
   },
   toString: function ()
   {
      return this [ 0] + " " + this [ 1] + " " + this [ 2] + " " + this [ 3] + " " +
             this [ 4] + " " + this [ 5] + " " + this [ 6] + " " + this [ 7] + " " +
             this [ 8] + " " + this [ 9] + " " + this [10] + " " + this [11] + " " +
             this [12] + " " + this [13] + " " + this [14] + " " + this [15]
   },
};

Object .defineProperty (Matrix4_Matrix4 .prototype, "x",
{
   get: (function ()
   {
      const vector = new Numbers_Vector4 (0, 0, 0, 0);

      return function () { return vector .set (this [0], this [1], this [2], this [3]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "y",
{
   get: (function ()
   {
      const vector = new Numbers_Vector4 (0, 0, 0, 0);

      return function () { return vector .set (this [4], this [5], this [6], this [7]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "z",
{
   get: (function ()
   {
      const vector = new Numbers_Vector4 (0, 0, 0, 0);

      return function () { return vector .set (this [8], this [9], this [10], this [11]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "w",
{
   get: (function ()
   {
      const vector = new Numbers_Vector4 (0, 0, 0, 0);

      return function () { return vector .set (this [12], this [13], this [14], this [15]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "xAxis",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [0], this [1], this [2]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "yAxis",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [4], this [5], this [6]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "zAxis",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [8], this [9], this [10]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "origin",
{
   get: (function ()
   {
      const vector = new Numbers_Vector3 (0, 0, 0);

      return function () { return vector .set (this [12], this [13], this [14]); };
   })(),
   enumerable: false,
   configurable: false
});

Object .defineProperty (Matrix4_Matrix4 .prototype, "submatrix",
{
   get: (function ()
   {
      const matrix = new Numbers_Matrix3 ();

      return function ()
      {
         matrix [0] = this [0]; matrix [1] = this [1]; matrix [2] = this [ 2];
         matrix [3] = this [4]; matrix [4] = this [5]; matrix [5] = this [ 6];
         matrix [6] = this [8]; matrix [7] = this [9]; matrix [8] = this [10];
         return matrix;
      };
   })(),
   enumerable: false,
   configurable: false
});

Object .assign (Matrix4_Matrix4,
{
   Identity: new Matrix4_Matrix4 (),
   Rotation: function (rotation)
   {
      return Object .create (this .prototype) .setQuaternion (rotation .value);
   },
   Quaternion: function (quaternion)
   {
      return Object .create (this .prototype) .setQuaternion (quaternion);
   },
   Matrix3: function (matrix)
   {
      return new Matrix4_Matrix4 (matrix [0], matrix [1], matrix [2], 0,
                          matrix [3], matrix [4], matrix [5], 0,
                          matrix [6], matrix [7], matrix [8], 0,
                          0, 0, 0, 1);
   },
   transpose: function (matrix)
   {
      return matrix .copy () .transpose ();
   },
   inverse: function (matrix)
   {
      return matrix .copy () .inverse ();
   },
   multLeft: function (lhs, rhs)
   {
      return lhs .copy () .multLeft (rhs);
   },
   multRight: function (lhs, rhs)
   {
      return lhs .copy () .multRight (rhs);
   },
});

const Matrix4_m = new Matrix4_Matrix4 ();

/* harmony default export */ const Numbers_Matrix4 = (Matrix4_Matrix4);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFMatrix4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function SFMatrix4Template (TypeName, Type, SFVec3, double)
{
   function SFMatrix4 (m00, m01, m02, m03,
                       m10, m11, m12, m13,
                       m20, m21, m22, m23,
                       m30, m31, m32, m33)
   {
      switch (arguments .length)
      {
         case 0:
            return Base_X3DField.call (this, new Numbers_Matrix4 ());

         case 1:
            return Base_X3DField.call (this, arguments [0]);

         case 16:
            return Base_X3DField.call (this, new Numbers_Matrix4 (+m00, +m01, +m02, +m03,
                                                      +m10, +m11, +m12, +m13,
                                                      +m20, +m21, +m22, +m23,
                                                      +m30, +m31, +m32, +m33));
      }

      throw new Error ("Invalid arguments.");
   }

   SFMatrix4 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
      SFMatrixPrototypeTemplate (Numbers_Matrix4, SFVec3, double),
   {
      constructor: SFMatrix4,
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
   });

   for (const key of Reflect .ownKeys (SFMatrix4 .prototype))
      Object .defineProperty (SFMatrix4 .prototype, key, { enumerable: false });

   function defineProperty (i)
   {
      Object .defineProperty (SFMatrix4 .prototype, i,
      {
         get: function ()
         {
            return this .getValue () [i];
         },
         set: function (value)
         {
            this .getValue () [i] = value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false,
      });
   }

   for (let i = 0, length = Numbers_Matrix4.prototype.length; i < length; ++ i)
      defineProperty (i);

   return SFMatrix4;
}

/* harmony default export */ const SFMatrix4 = ({
   SFMatrix4d: SFMatrix4Template ("SFMatrix4d", Base_X3DConstants.SFMatrix4d, SFVec3.SFVec3d, true),
   SFMatrix4f: SFMatrix4Template ("SFMatrix4f", Base_X3DConstants.SFMatrix4f, SFVec3.SFVec3f, false),
   VrmlMatrix: SFMatrix4Template ("VrmlMatrix", Base_X3DConstants.VrmlMatrix, SFVec3.SFVec3f, false),
});

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFNodeCache.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const cache = new WeakMap ();

function SFNodeCache () { }

SFNodeCache .prototype =
{
   get: function (baseNode)
   {
      const node = cache .get (baseNode);

      if (node)
      {
         return node;
      }
      else
      {
         const node = new Fields_SFNode (baseNode);

         cache .set (baseNode, node);

         return node;
      }
   },
};

/* harmony default export */ const Fields_SFNodeCache = (new SFNodeCache ());

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _target     = Symbol (),
   _proxy      = Symbol (),
   _cloneCount = Symbol ();

const SFNode_handler =
{
   get: function (target, key)
   {
      try
      {
         const value = target [key];

         if (value !== undefined)
            return value;

         const
            field      = target .getValue () .getField (key),
            accessType = field .getAccessType ();

         // Specification conform would be: accessType & X3DConstants .outputOnly.
         // But we allow read access to plain fields, too.
         if (accessType === Base_X3DConstants.inputOnly)
            return undefined;

         return field .valueOf ();
      }
      catch (error)
      {
         return undefined;
      }
   },
   set: function (target, key, value)
   {
      if (key in target)
      {
         target [key] = value;
         return true;
      }

      try
      {
         const
            field      = target .getValue () .getField (key),
            accessType = field .getAccessType ();

         if (accessType !== Base_X3DConstants.outputOnly)
            field .setValue (value);

          return true;
      }
      catch (error)
      {
         console .error (target, key, error);
         return false;
      }
   },
   has: function (target, key)
   {
      try
      {
         return Boolean (target .getValue () .getField (key));
      }
      catch (error)
      {
         return key in target;
      }
   },
   ownKeys: function (target)
   {
      const
         value   = target .getValue (),
         ownKeys = [ ];

      if (value)
      {
         for (const fieldDefinition of value .getFieldDefinitions ())
            ownKeys .push (fieldDefinition .name);
      }

      return ownKeys;
   },
   getOwnPropertyDescriptor: function (target, key)
   {
      const value = target .getValue ();

      if (value)
      {
         const fieldDefinition = value .getFieldDefinitions () .get (key);

         if (fieldDefinition)
         {
            return {
               value: this .get (target, key),
               writable: fieldDefinition .accessType !== Base_X3DConstants.outputOnly,
               enumerable: true,
               configurable: true,
            };
         }
      }
   },
};

function SFNode (value)
{
   // Node need to test for X3DBaseNode, because there is a special version of SFNode in Script.

   const proxy = new Proxy (this, SFNode_handler);

   this [_target] = this;
   this [_proxy]  = proxy;

   if (value)
   {
      value .addParent (proxy);

      Base_X3DField.call (this, value);
   }
   else
   {
      Base_X3DField.call (this, null);
   }

   return proxy;
}

SFNode .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFNode,
   [_target]: null,
   [_proxy]: null,
   [_cloneCount]: 0,
   copy: function (instance)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return new SFNode (instance ? value .copy (instance) : value);

      return new SFNode ();
   },
   getTypeName: function ()
   {
      return "SFNode";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFNode;
   },
   equals: function (node)
   {
      const target = this [_target];

      if (node)
         return target .getValue () === node .getValue ();

      return target .getValue () === null;
   },
   isDefaultValue: function ()
   {
      const target = this [_target];

      return target .getValue () === null;
   },
   set: function (value)
   {
      const
         target  = this [_target],
         current = target .getValue ();

      if (current)
      {
         current .removeCloneCount (target [_cloneCount]);
         current .removeParent (target [_proxy]);
      }

      // No need to test for X3DBaseNode, because there is a special version of SFNode in Script.

      if (value)
      {
         value .addParent (target [_proxy]);
         value .addCloneCount (target [_cloneCount]);

         Base_X3DField.prototype.set.call (target, value);
      }
      else
      {
         Base_X3DField.prototype.set.call (target, null);
      }
   },
   getNodeTypeName: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return value .getTypeName ();

      throw new Error ("SFNode.getNodeTypeName: node is null.");
   },
   getNodeName: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return value .getName ();

      throw new Error ("SFNode.getNodeName: node is null.");
   },
   getNodeDisplayName: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return value .getDisplayName ();

      throw new Error ("SFNode.getNodeDisplayName: node is null.");
   },
   getNodeType: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return value .getType () .slice ();

      throw new Error ("SFNode.getNodeType: node is null.");
   },
   getFieldDefinitions: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return value .getFieldDefinitions ();

      throw new Error ("SFNode.getFieldDefinitions: node is null.");
   },
   addFieldCallback: function (name, string, object)
   {
      const target = this [_target];

      switch (arguments .length)
      {
         case 2:
         {
            return Base_X3DField.prototype.addFieldCallback.apply (target, arguments);
         }
         case 3:
         {
            const value = target .getValue ();

            if (value)
               return value .getField (name) .addFieldCallback (string, object);

            throw new Error ("SFNode.addFieldCallback: node is null.");
         }
      }
   },
   removeFieldCallback: function (name, string)
   {
      const target = this [_target];

      switch (arguments .length)
      {
         case 1:
         {
            return Base_X3DField.prototype.removeFieldCallback.apply (target, arguments);
         }
         case 2:
         {
            const value = target .getValue ();

            if (value)
               return value .getField (name) .removeFieldCallback (string);

            throw new Error ("SFNode.removeFieldCallback: node is null.");
         }
      }
   },
   addCloneCount: function (count)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      target [_cloneCount] += count;

      if (value)
         value .addCloneCount (count);
   },
   removeCloneCount: function (count)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      target [_cloneCount] -= count;

      if (value)
         value .removeCloneCount (count);
   },
   valueOf: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         return Fields_SFNodeCache.get (value);

      return null;
   },
   toStream: function (stream)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         value .toStream (stream);
      else
         stream .string += "NULL";
   },
   toVRMLStream: function (stream)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         value .toVRMLStream (stream);
      else
         stream .string += "NULL";
   },
   toXMLString: function ()
   {
      const
         target    = this [_target],
         stream    = { string: "" },
         generator = InputOutput_Generator.Get (stream),
         value     = target .getValue ();

      generator .PushExecutionContext (value .getExecutionContext ());

      target .toXMLStream (stream);

      generator .PopExecutionContext ();

      return stream .string;
   },
   toXMLStream: function (stream)
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         value .toXMLStream (stream);
      else
         stream .string += "<!-- NULL -->";
   },
   dispose: function ()
   {
      const
         target = this [_target],
         value  = target .getValue ();

      if (value)
         value .dispose ();

      Base_X3DField.prototype.dispose.call (target);
   },
});

for (const key of Reflect .ownKeys (SFNode .prototype))
   Object .defineProperty (SFNode .prototype, key, { enumerable: false });

/* harmony default export */ const Fields_SFNode = (SFNode);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFRotation.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const SFVec3f = SFVec3.SFVec3f;

function SFRotation (x, y, z, angle)
{
   switch (arguments .length)
   {
      case 0:
         return Base_X3DField.call (this, new Numbers_Rotation4 ());

      case 1:
         return Base_X3DField.call (this, arguments [0]);

      case 2:
         if (arguments [1] instanceof SFVec3f)
            return Base_X3DField.call (this, new Numbers_Rotation4 (arguments [0] .getValue (), arguments [1] .getValue ()));

         return Base_X3DField.call (this, new Numbers_Rotation4 (arguments [0] .getValue (), +arguments [1]));

      case 4:
         return Base_X3DField.call (this, new Numbers_Rotation4 (+x, +y, +z, +angle));
   }

   throw new Error ("Invalid arguments.");
}

SFRotation .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFRotation,
   [Symbol .iterator]: function* ()
   {
      yield* this .getValue ();
   },
   copy: function ()
   {
      return new SFRotation (this .getValue () .copy ());
   },
   equals: function (rotation)
   {
      return this .getValue () .equals (rotation .getValue ());
   },
   isDefaultValue: function ()
   {
      return this .getValue () .equals (Numbers_Rotation4.Identity);
   },
   getTypeName: function ()
   {
      return "SFRotation";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFRotation;
   },
   set: function (value)
   {
      this .getValue () .assign (value);
   },
   setAxis: function (vector)
   {
      this .getValue () .setAxis (vector .getValue ());
      this .addEvent ();
   },
   getAxis: function ()
   {
      return new SFVec3f (this .getValue () .getAxis () .copy ());
   },
   inverse: function ()
   {
      return new SFRotation (Numbers_Rotation4.inverse (this .getValue ()));
   },
   multiply: function (rotation)
   {
      return new SFRotation (Numbers_Rotation4.multRight (this .getValue (), rotation .getValue ()));
   },
   multVec: function (vector)
   {
      return new SFVec3f (this .getValue () .multVecRot (vector .getValue () .copy ()));
   },
   slerp: function (rotation, t)
   {
      return new SFRotation (Numbers_Rotation4.slerp (this .getValue (), rotation .getValue (), t));
   },
   toStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         rotation  = this .getValue ();

      stream .string += generator .DoublePrecision (rotation .x) + " " +
                        generator .DoublePrecision (rotation .y) + " " +
                        generator .DoublePrecision (rotation .z) + " " +
                        generator .DoublePrecision (generator .ToUnit ("angle", rotation .angle));
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFRotation .prototype))
   Object .defineProperty (SFRotation .prototype, key, { enumerable: false });

const SFRotation_x = {
   get: function ()
   {
      return this .getValue () .x;
   },
   set: function (value)
   {
      this .getValue () .x = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFRotation_y = {
   get: function ()
   {
      return this .getValue () .y;
   },
   set: function (value)
   {
      this .getValue () .y = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFRotation_z = {
   get: function ()
   {
      return this .getValue () .z;
   },
   set: function (value)
   {
      this .getValue () .z = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const SFRotation_angle = {
   get: function ()
   {
      return this .getValue () .angle;
   },
   set: function (value)
   {
      this .getValue () .angle = +value;
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

Object .defineProperty (SFRotation .prototype, "x",     SFRotation_x);
Object .defineProperty (SFRotation .prototype, "y",     SFRotation_y);
Object .defineProperty (SFRotation .prototype, "z",     SFRotation_z);
Object .defineProperty (SFRotation .prototype, "angle", SFRotation_angle);

SFRotation_x     .enumerable = false;
SFRotation_y     .enumerable = false;
SFRotation_z     .enumerable = false;
SFRotation_angle .enumerable = false;

Object .defineProperty (SFRotation .prototype, "0", SFRotation_x);
Object .defineProperty (SFRotation .prototype, "1", SFRotation_y);
Object .defineProperty (SFRotation .prototype, "2", SFRotation_z);
Object .defineProperty (SFRotation .prototype, "3", SFRotation_angle);

/* harmony default export */ const Fields_SFRotation = (SFRotation);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFString.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const
   SFString_unescape = /\\(.)/g,
   SFString_escape   = /([\\"])/g;

function SFString (value)
{
   return Base_X3DField.call (this, arguments .length ? "" + value : "");
}

Object .assign (SFString,
{
   unescape: function (string)
   {
      return string .replace (SFString_unescape, "$1");
   },
   escape: function (string)
   {
      return string .replace (SFString_escape, "\\$1");
   },
});

SFString .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFString,
   [Symbol .iterator]: function* ()
   {
      yield* this .getValue ();
   },
   copy: function ()
   {
      return new SFString (this .getValue ());
   },
   getTypeName: function ()
   {
      return "SFString";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFString;
   },
   isDefaultValue: function ()
   {
      return this .getValue () === "";
   },
   set: function (value)
   {
      Base_X3DField.prototype.set.call (this, "" + value);
   },
   valueOf: Base_X3DField.prototype.getValue,
   toStream: function (stream)
   {
      stream .string += '"' + SFString .escape (this .getValue ()) + '"';
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      stream .string += InputOutput_Generator.Get (stream) .XMLEncode (this .getValue ());
   },
});

for (const key of Reflect .ownKeys (SFString .prototype))
   Object .defineProperty (SFString .prototype, key, { enumerable: false });

Object .defineProperty (SFString .prototype, "length",
{
   get: function ()
   {
      return this .getValue () .length;
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Fields_SFString = (SFString);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFVec4.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function SFVec4Template (TypeName, Type, double)
{
   function SFVec4 (x, y, z, w)
   {
      switch (arguments .length)
      {
         case 0:
            return Base_X3DField.call (this, new Numbers_Vector4 (0, 0, 0, 0));

         case 1:
            return Base_X3DField.call (this, arguments [0]);

         case 4:
            return Base_X3DField.call (this, new Numbers_Vector4 (+x, +y, +z, +w));
      }

      throw new Error ("Invalid arguments.");
   }

   SFVec4 .prototype = Object .assign (Object .create (Base_X3DField.prototype),
      SFVecPrototypeTemplate (Numbers_Vector4, double),
   {
      constructor: SFVec4,
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
   });

   for (const key of Reflect .ownKeys (SFVec4 .prototype))
      Object .defineProperty (SFVec4 .prototype, key, { enumerable: false });

   const x = {
      get: function ()
      {
         return this .getValue () .x;
      },
      set: function (value)
      {
         this .getValue () .x = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const y = {
      get: function ()
      {
         return this .getValue () .y;
      },
      set: function (value)
      {
         this .getValue () .y = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const z = {
      get: function ()
      {
         return this .getValue () .z;
      },
      set: function (value)
      {
         this .getValue () .z = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const w = {
      get: function ()
      {
         return this .getValue () .w;
      },
      set: function (value)
      {
         this .getValue () .w = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFVec4 .prototype, "x", x);
   Object .defineProperty (SFVec4 .prototype, "y", y);
   Object .defineProperty (SFVec4 .prototype, "z", z);
   Object .defineProperty (SFVec4 .prototype, "w", w);

   x .enumerable = false;
   y .enumerable = false;
   z .enumerable = false;
   w .enumerable = false;

   Object .defineProperty (SFVec4 .prototype, "0", x);
   Object .defineProperty (SFVec4 .prototype, "1", y);
   Object .defineProperty (SFVec4 .prototype, "2", z);
   Object .defineProperty (SFVec4 .prototype, "3", w);

   return SFVec4;
}

/* harmony default export */ const SFVec4 = ({
   SFVec4d: SFVec4Template ("SFVec4d", Base_X3DConstants.SFVec4d, true),
   SFVec4f: SFVec4Template ("SFVec4f", Base_X3DConstants.SFVec4f, false),
});

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DArrayField.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function X3DArrayField (value)
{
   Base_X3DField.call (this, value);
}

X3DArrayField .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: X3DArrayField,
   at: Array .prototype .at,
   concat: Array .prototype .concat,
   //entries: function () { return iterator -> [index, value]; },
   every: Array .prototype .every,
   fill: Array .prototype .fill,
   filter: Array .prototype .filter,
   find: Array .prototype .find,
   findIndex: Array .prototype .findIndex,
   forEach: Array .prototype .forEach,
   includes: Array .prototype .includes,
   indexOf: Array .prototype .indexOf,
   join: Array .prototype .join,
   keys: function () { return Array (this .length) .keys (); },
   lastIndexOf: Array .prototype .lastIndexOf,
   map: Array .prototype .map,
   reduce: Array .prototype .reduce,
   reduceRight: Array .prototype .reduceRight,
   slice: Array .prototype .slice,
   some: Array .prototype .some,
   values: function () { return this [Symbol .iterator]; },
});

for (const key of Reflect .ownKeys (X3DArrayField .prototype))
   Object .defineProperty (X3DArrayField .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DArrayField = (X3DArrayField);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DObjectArrayField.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const
   X3DObjectArrayField_target = Symbol (),
   X3DObjectArrayField_proxy  = Symbol ();

const X3DObjectArrayField_handler =
{
   get: function (target, key)
   {
      const value = target [key];

      if (value !== undefined)
         return value;

      if (typeof key === "string")
      {
         const
            array = target .getValue (),
            index = +key;

         if (Number .isInteger (index))
         {
            if (index >= array .length)
               target .resize (index + 1);

            return array [index] .valueOf ();
         }
         else
         {
            return target [key];
         }
      }
   },
   set: function (target, key, value)
   {
      if (key in target)
      {
         target [key] = value;
         return true;
      }

      const
         array = target .getValue (),
         index = +key;

      if (index >= array .length)
         target .resize (index + 1);

      array [index] .setValue (value);

      return true;
   },
   has: function (target, key)
   {
      if (Number .isInteger (+key))
         return key < target .getValue () .length;

      return key in target;
   },
   ownKeys: function (target)
   {
      return Object .keys (target .getValue ());
   },
   getOwnPropertyDescriptor: function (target, key)
   {
      if (typeof key !== "string")
         return;

      const index = +key;

      if (Number .isInteger (index) && index < target .getValue () .length)
         return Object .getOwnPropertyDescriptor (target .getValue (), key);
   },
};

function X3DObjectArrayField (value)
{
   const proxy = new Proxy (this, X3DObjectArrayField_handler);

   Base_X3DArrayField.call (this, [ ]);

   this [X3DObjectArrayField_target] = this;
   this [X3DObjectArrayField_proxy]  = proxy;

   if (value [0] instanceof Array)
      value = value [0];

   X3DObjectArrayField .prototype .push .apply (this, value);

   return proxy;
}

X3DObjectArrayField .prototype = Object .assign (Object .create (Base_X3DArrayField.prototype),
{
   constructor: X3DObjectArrayField,
   [X3DObjectArrayField_target]: null,
   [X3DObjectArrayField_proxy]: null,
   [Symbol .iterator]: function* ()
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      for (const value of array)
         yield value .valueOf ();
   },
   getTarget: function ()
   {
      return this [X3DObjectArrayField_target];
   },
   copy: function ()
   {
      const
         target = this [X3DObjectArrayField_target],
         copy   = target .create (),
         array  = target .getValue ();

      X3DObjectArrayField .prototype .push .apply (copy, array);

      copy .setModificationTime (0);

      return copy;
   },
   equals: function (array)
   {
      const
         target = this [X3DObjectArrayField_target],
         a      = target .getValue (),
         b      = array .getValue (),
         length = a .length;

      if (a === b)
         return true;

      if (length !== b .length)
         return false;

      for (let i = 0; i < length; ++ i)
      {
         if (! a [i] .equals (b [i]))
            return false;
      }

      return true;
   },
   set: function (value)
   {
      const target = this [X3DObjectArrayField_target];

      target .resize (value .length, undefined, true);

      const array = target .getValue ();

      for (let i = 0, length = value .length; i < length; ++ i)
         array [i] .set (value [i] instanceof Base_X3DField ? value [i] .getValue () : value [i]);
   },
   isDefaultValue: function ()
   {
      return this .length === 0;
   },
   setValue: function (value)
   {
      const target = this [X3DObjectArrayField_target];

      target .set (value instanceof X3DObjectArrayField ? value .getValue () : value);
      target .addEvent ();
   },
   unshift: function (value)
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      for (let i = arguments .length - 1; i >= 0; -- i)
      {
         const field = new (target .getSingleType ()) ();

         field .setValue (arguments [i]);
         target .addChildObject (field);
         array .unshift (field);
      }

      target .addEvent ();

      return array .length;
   },
   shift: function ()
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      if (array .length)
      {
         const field = array .shift ();
         target .removeChildObject (field);
         target .addEvent ();
         return field .valueOf ();
      }
   },
   push: function (value)
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      for (const argument of arguments)
      {
         const field = new (target .getSingleType ()) ();

         field .setValue (argument);
         target .addChildObject (field);
         array .push (field);
      }

      target .addEvent ();

      return array .length;
   },
   pop: function ()
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      if (array .length)
      {
         const field = array .pop ();
         target .removeChildObject (field);
         target .addEvent ();
         return field .valueOf ();
      }
   },
   splice: function (index, deleteCount)
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      if (index > array .length)
         index = array .length;

      if (index + deleteCount > array .length)
         deleteCount = array .length - index;

      const result = target .erase (index, index + deleteCount);

      if (arguments .length > 2)
         target .insert (index, arguments, 2, arguments .length);

      return result;
   },
   insert: function (index, array, first, last)
   {
      const
         target = this [X3DObjectArrayField_target],
         args   = [index, 0];

      for (let i = first; i < last; ++ i)
      {
         const field = new (target .getSingleType ()) ();

         field .setValue (array [i]);
         target .addChildObject (field);
         args .push (field);
      }

      Array .prototype .splice .apply (target .getValue (), args);

      target .addEvent ();
   },
   find: function (first, last, value)
   {
      const
         target = this [X3DObjectArrayField_target],
         values = target .getValue ();

      if (typeof value === "function")
      {
         for (let i = first; i < last; ++ i)
         {
            if (value (values [i] .valueOf ()))
               return i;
         }

         return last;
      }

      for (let i = first; i < last; ++ i)
      {
         if (values [i] .equals (value))
            return i;
      }

      return last;
   },
   remove: function (first, last, value)
   {
      const
         target = this [X3DObjectArrayField_target],
         values = target .getValue ();

      if (typeof value === "function")
      {
         first = target .find (first, last, value);

         if (first !== last)
         {
            for (let i = first; ++ i < last; )
            {
               const current = values [i];

               if (! value (current .valueOf ()))
               {
                  const tmp = values [first];

                  values [first ++] = current;
                  values [i]        = tmp;
               }
            }
         }

         if (first !== last)
            target .addEvent ();

         return first;
      }

      first = target .find (first, last, value);

      if (first !== last)
      {
         for (let i = first; ++ i < last; )
         {
            const current = values [i];

            if (! current .equals (value))
            {
               const tmp = values [first];

               values [first ++] = current;
               values [i]        = tmp;
            }
         }
      }

      if (first !== last)
         target .addEvent ();

      return first;
   },
   erase: function (first, last)
   {
      const
         target = this [X3DObjectArrayField_target],
         values = target .getValue () .splice (first, last - first);

      for (const value of values)
         target .removeChildObject (value);

      target .addEvent ();

      return values .map (function (value) { return value .valueOf () });
   },
   resize: function (size, value, silent)
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      if (size < array .length)
      {
         for (let i = size, length = array .length; i < length; ++ i)
            target .removeChildObject (array [i]);

         array .length = size;

         if (! silent)
            target .addEvent ();
      }
      else if (size > array .length)
      {
         for (let i = array .length; i < size; ++ i)
         {
            const field = new (target .getSingleType ()) ();

            if (value !== undefined)
               field .setValue (value);

            target .addChildObject (field);
            array .push (field);
         }

         if (! silent)
            target .addEvent ();
      }
   },
   addChildObject: function (value)
   {
      value .addParent (this [X3DObjectArrayField_proxy]);
   },
   removeChildObject: function (value)
   {
      value .removeParent (this [X3DObjectArrayField_proxy]);
   },
   toStream: function (stream)
   {
      const
         target    = this [X3DObjectArrayField_target],
         array     = target .getValue (),
         generator = InputOutput_Generator.Get (stream);

      switch (array .length)
      {
         case 0:
         {
            stream .string += "[ ]";
            break;
         }
         case 1:
         {
            generator .PushUnitCategory (target .getUnit ());

            array [0] .toStream (stream);

            generator .PopUnitCategory ();
            break;
         }
         default:
         {
            generator .PushUnitCategory (target .getUnit ());

            stream .string += "[\n";
            generator .IncIndent ();

            for (let i = 0, length = array .length - 1; i < length; ++ i)
            {
               stream .string += generator .Indent ();
               array [i] .toStream (stream);
               stream .string += ",\n";
            }

            stream .string += generator .Indent ();
            array .at (-1) .toStream (stream);
            stream .string += "\n";

            generator .DecIndent ();
            stream .string += generator .Indent ();
            stream .string += "]";

            generator .PopUnitCategory ();
            break;
         }
      }
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      const
         target = this [X3DObjectArrayField_target],
         length = target .length;

      if (length)
      {
         const
            generator = InputOutput_Generator.Get (stream),
            array     = target .getValue ();

         generator .PushUnitCategory (target .getUnit ());

         for (const element of array)
         {
            element .toXMLStream (stream);
            stream .string += ", ";
         }

         array .at (-1) .toXMLStream (stream);

         generator .PopUnitCategory ();
      }
   },
   dispose: function ()
   {
      const
         target = this [X3DObjectArrayField_target],
         array  = target .getValue ();

      for (const value of array)
         target .removeChildObject (value);

      array .length = 0;

      Base_X3DArrayField.prototype.dispose.call (target);
   },
});

for (const key of Reflect .ownKeys (X3DObjectArrayField .prototype))
   Object .defineProperty (X3DObjectArrayField .prototype, key, { enumerable: false });

Object .defineProperty (X3DObjectArrayField .prototype, "length",
{
   get: function () { return this [X3DObjectArrayField_target] .getValue () .length; },
   set: function (value) { this [X3DObjectArrayField_target] .resize (value); },
   enumerable: false,
   configurable: false,
});

/* harmony default export */ const Base_X3DObjectArrayField = (X3DObjectArrayField);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DTypedArrayField.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const
   X3DTypedArrayField_target = Symbol (),
   _tmp    = Symbol (),
   _length = Symbol ();

const X3DTypedArrayField_handler =
{
   get: function (target, key)
   {
      const value = target [key];

      if (value !== undefined)
         return value;

      if (typeof key === "string")
      {
         const index = +key;

         if (Number .isInteger (index))
         {
            const
               components = target .getComponents (),
               valueType  = target .getValueType ();

            let array = target .getValue ();

            if (index >= target [_length])
               array = target .resize (index + 1);

            if (components === 1)
            {
               // Return native JavaScript value.
               return valueType (array [index]);
            }
            else
            {
               // Return reference to index.

               const
                  value         = new (valueType) (),
                  internalValue = value .getValue (),
                  i             = index * components;

               value .addEvent = addEvent .bind (target, i, internalValue, components);
               value .getValue = getValue .bind (target, i, internalValue, components);

               return value;
            }
         }
         else
         {
            return target [key];
         }
      }
   },
   set: function (target, key, value)
   {
      if (key in target)
      {
         target [key] = value;
         return true;
      }

      const components = target .getComponents ();

      let
         index = +key,
         array = target .getValue ();

      if (index >= target [_length])
         array = target .resize (index + 1);

      if (components === 1)
      {
         array [index] = value;
      }
      else
      {
         index *= components;

         for (let c = 0; c < components; ++ c, ++ index)
            array [index] = value [c];
      }

      target .addEvent ();

      return true;
   },
   has: function (target, key)
   {
      if (Number .isInteger (+key))
         return key < target [_length];

      return key in target;
   },
   ownKeys: function (target)
   {
      const ownKeys = [ ];

      for (let i = 0, length = target [_length]; i < length; ++ i)
         ownKeys .push (String (i));

      return ownKeys;
   },
   getOwnPropertyDescriptor: function (target, key)
   {
      if (typeof key !== "string")
         return;

      const index = +key;

      if (Number .isInteger (index) && index < target [_length])
         return Object .getOwnPropertyDescriptor (target .getValue (), key);
   },
};

function X3DTypedArrayField (value)
{
   Base_X3DArrayField.call (this, new (this .getArrayType ()) (2));

   this [X3DTypedArrayField_target] = this;
   this [_tmp]    = [ ];  // Array with components size.

   if (value [0] instanceof Array)
      value = value [0];

   X3DTypedArrayField .prototype .push .apply (this, value);

   return new Proxy (this, X3DTypedArrayField_handler);
}

X3DTypedArrayField .prototype = Object .assign (Object .create (Base_X3DArrayField.prototype),
{
   constructor: X3DTypedArrayField,
   [X3DTypedArrayField_target]: null,
   [_tmp]: null,
   [_length]: 0,
   [Symbol .iterator]: function* ()
   {
      const
         target     = this [X3DTypedArrayField_target],
         array      = target .getValue (),
         components = target .getComponents (),
         valueType  = target .getValueType (),
         length     = target [_length];

      if (components === 1)
      {
         // Return native JavaScript value.

         for (let index = 0; index < length; ++ index)
            yield valueType (array [index]);
      }
      else
      {
         // Return reference to index.

         for (let index = 0; index < length; ++ index)
         {
            const
               value         = new (valueType) (),
               internalValue = value .getValue (),
               i             = index * components;

            value .addEvent = addEvent .bind (target, i, internalValue, components);
            value .getValue = getValue .bind (target, i, internalValue, components);

            yield value;
         }
      }
   },
   getTarget: function ()
   {
      return this [X3DTypedArrayField_target];
   },
   copy: function ()
   {
      const
         target     = this [X3DTypedArrayField_target],
         array      = target .getValue (),
         copy       = target .create (),
         copyArray  = new (target .getArrayType ()) (array);

      copy [_length] = target [_length];

      Base_X3DArrayField.prototype.set.call (copy, copyArray, target [_length]);

      copy .setModificationTime (0);

      return copy;
   },
   equals: function (other)
   {
      if (this === other)
         return true;

      const
         target = this [X3DTypedArrayField_target],
         length = target [_length];

      if (length !== other [_length])
         return false;

      const
         a = target  .getValue (),
         b = other .getValue ();

      for (let i = 0, l = length * target .getComponents (); i < l; ++ i)
      {
         if (a [i] !== b [i])
            return false;
      }

      return true;
   },
   assign: function (value)
   {
      const target = this [X3DTypedArrayField_target];

      target .set (value .getValue (), value .length);
      target .addEvent ();
   },
   set: function (otherArray /* value of field */, l /* length of field */)
   {
      const
         target      = this [X3DTypedArrayField_target],
         components  = target .getComponents (),
         length      = target [_length];

      let
         array       = target .getValue (),
         otherLength = l !== undefined ? l * components : otherArray .length;

      const
         rest = otherLength % components;

      if (rest)
      {
         otherLength -= rest;

         console .warn ("Array length must be multiple of components size, which is " + components + ".");
      }

      otherLength /= components;

      if (array .length < otherArray .length)
      {
         array = target .grow (otherArray .length);

         array .set (otherArray);

         if (rest)
            array .fill (0, otherLength * components, otherLength * components + rest);
      }
      else
      {
         array .set (otherArray);

         if (otherLength < length)
            array .fill (0, otherLength * components, length * components);
      }

      target [_length] = otherLength;
   },
   isDefaultValue: function ()
   {
      return this [_length] === 0;
   },
   setValue: function (value)
   {
      const target = this [X3DTypedArrayField_target];

      if (value instanceof target .constructor)
      {
         target .assign (value);
      }
      else
      {
         target .set (value);
         target .addEvent ();
      }
   },
   unshift: function (value)
   {
      const
         target          = this [X3DTypedArrayField_target],
         components      = target .getComponents (),
         length          = target [_length],
         argumentsLength = arguments .length,
         array           = target .grow ((length + argumentsLength) * components);

      array .copyWithin (argumentsLength * components, 0, length * components);

      if (components === 1)
      {
         array .set (arguments, 0);
      }
      else
      {
         for (let i = 0, a = 0; a < argumentsLength; ++ a)
         {
            const argument = arguments [a];

            for (let c = 0; c < components; ++ c, ++ i)
            {
               array [i] = argument [c];
            }
         }
      }

      target [_length] += argumentsLength;

      target .addEvent ();

      return array .length;
   },
   shift: function ()
   {
      const
         target = this [X3DTypedArrayField_target],
         length = target [_length];

      if (length)
      {
         const
            array      = target .getValue (),
            components = target .getComponents (),
            valueType  = target .getValueType (),
            newLength  = length - 1;

         if (components === 1)
         {
            var value = valueType (array [0]);
         }
         else
         {
            const tmp = target [_tmp];

            for (let c = 0; c < components; ++ c)
               tmp [c] = array [c];

            var value = Object .create (valueType .prototype);

            valueType .apply (value, tmp);
         }

         array .copyWithin (0, components, length * components);
         array .fill (0, components * newLength, length * components);

         target [_length] = newLength;

         target .addEvent ();
         return value;
      }
   },
   push: function (value)
   {
      const
         target          = this [X3DTypedArrayField_target],
         components      = target .getComponents (),
         length          = target [_length],
         argumentsLength = arguments .length,
         array           = target .grow ((length + argumentsLength) * components);

      if (components === 1)
      {
         array .set (arguments, length);
      }
      else
      {
         for (let i = length * components, a = 0; a < argumentsLength; ++ a)
         {
            const argument = arguments [a];

            for (let c = 0; c < components; ++ c,  ++ i)
            {
               array [i] = argument [c];
            }
         }
      }

      target [_length] += argumentsLength;

      target .addEvent ();

      return target [_length];
   },
   pop: function ()
   {
      const
         target = this [X3DTypedArrayField_target],
         length = target [_length];

      if (length)
      {
         const
            array      = target .getValue (),
            components = target .getComponents (),
            valueType  = target .getValueType (),
            newLength  = length - 1;

         if (components === 1)
         {
            var value = valueType (array [length - 1]); // Don't use at(-1).
         }
         else
         {
            const tmp = target [_tmp];

            for (let c = 0, a = newLength * components; c < components; ++ c, ++ a)
               tmp [c] = array [a];

            var value = Object .create (valueType .prototype);

            valueType .apply (value, tmp);
         }

         array .fill (0, newLength * components, length * components);

         target [_length] = newLength;

         target .addEvent ();

         return value;
      }
   },
   splice: function (index, deleteCount)
   {
      const
         target = this [X3DTypedArrayField_target],
         length = target [_length];

      if (index > length)
         index = length;

      if (index + deleteCount > length)
         deleteCount = length - index;

      const result = target .erase (index, index + deleteCount);

      if (arguments .length > 2)
         target .spliceInsert (index, Array .prototype .splice .call (arguments, 2));

      target .addEvent ();

      return result;
   },
   spliceInsert: function (index, other)
   {
      const
         target      = this [X3DTypedArrayField_target],
         components  = target .getComponents (),
         length      = target [_length],
         otherLength = other .length,
         array       = target .grow ((length + otherLength) * components);

      index *= components;

      array .copyWithin (index + otherLength * components, index, length * components);

      if (components === 1)
      {
         array .set (other, index);
      }
      else
      {
         for (let i = 0, a = index; i < otherLength; ++ i)
         {
            const value = other [i];

            for (let c = 0; c < components; ++ c, ++ a)
               array [a] = value [c];
         }
      }

      target [_length] += otherLength;
   },
   insert: function (index, other, first, last)
   {
      const
         target     = this [X3DTypedArrayField_target],
         length     = target [_length],
         otherArray = other .getValue (),
         components = target .getComponents (),
         difference = last - first,
         array      = target .grow ((length + difference) * components);

      index *= components;
      first *= components;
      last  *= components;

      array .copyWithin (index + difference * components, index, length * components);

      for (; first < last; ++ index, ++ first)
         array [index] = otherArray [first];

      target [_length] += difference;

      target .addEvent ();
   },
   erase: function (first, last)
   {
      const
         target      = this [X3DTypedArrayField_target],
         array       = target .getValue (),
         components  = target .getComponents (),
         difference  = last - first,
         length      = target [_length],
         newLength   = length - difference,
         values      = target .create (),
         valuesArray = values .grow (difference * components);

      first *= components;
      last  *= components;

      for (let v = 0, f = first; f < last; ++ v, ++ f)
         valuesArray [v] = array [f];

      array .copyWithin (first, last, length * components);
      array .fill (0, newLength * components, length * components);

      target [_length] = newLength;
      values [_length] = difference;

      target .addEvent ();

      return values .slice ();
   },
   resize: function (newLength, value, silent)
   {
      const
         target     = this [X3DTypedArrayField_target],
         length     = target [_length],
         components = target .getComponents ();

      let array = target .getValue ();

      if (newLength < length)
      {
         array .fill (0, newLength * components, length * components);

         if (!silent)
            target .addEvent ();
      }
      else if (newLength > length)
      {
         array = target .grow (newLength * components);

         if (value !== undefined)
         {
            if (components === 1)
            {
               array .fill (value, length * components, newLength * components);
            }
            else
            {
               for (let i = length * components, il = newLength * components; i < il; )
               {
                  for (let c = 0; c < components; ++ c, ++ i)
                  {
                     array [i] = value [c];
                  }
               }
            }
         }

         if (!silent)
            target .addEvent ();
      }

      target [_length] = newLength;

      return array;
   },
   grow: function (length)
   {
      const
         target = this [X3DTypedArrayField_target],
         array  = target .getValue ();

      if (length < array .length)
         return array;

      const
         maxLength = Math_Algorithm.nextPowerOfTwo (length),
         newArray  = new (target .getArrayType ()) (maxLength);

      newArray .set (array);

      Base_X3DArrayField.prototype.set.call (target, newArray);

      return newArray;
   },
   shrinkToFit: function ()
   {
      const
         target = this [X3DTypedArrayField_target],
         array  = target .getValue (),
         length = target [_length] * target .getComponents ();

      if (array .length == length)
         return array;

      const newArray = array .subarray (0, length);

      Base_X3DArrayField.prototype.set.call (target, newArray);

      return newArray;
   },
   toStream: function (stream)
   {
      const
         target     = this [X3DTypedArrayField_target],
         generator  = InputOutput_Generator.Get (stream),
         array      = target .getValue (),
         length     = target [_length],
         components = target .getComponents (),
         value      = new (target .getSingleType ()) ();

      switch (length)
      {
         case 0:
         {
            stream .string += "[ ]";
            break;
         }
         case 1:
         {
            generator .PushUnitCategory (target .getUnit ());

            if (components === 1)
            {
               value .set (array [0]);

               value .toStream (stream);
            }
            else
            {
               for (let c = 0, first = 0; c < components; ++ c, ++ first)
                  value [c] = array [first];

               value .toStream (stream);
            }

            generator .PopUnitCategory ();
            break;
         }
         default:
         {
            generator .PushUnitCategory (target .getUnit ());

            stream .string += "[\n";
            generator .IncIndent ();

            if (components === 1)
            {
               for (let i = 0, n = length - 1; i < n; ++ i)
               {
                  stream .string += generator .Indent ();

                  value .set (array [i * components]);
                  value .toStream (stream);

                  stream .string += ",\n";
               }

               stream .string += generator .Indent ();
               value .set (array [(length - 1) * components]);
               value .toStream (stream);

               stream .string += "\n";
            }
            else
            {
               for (let i = 0, n = length - 1; i < n; ++ i)
               {
                  stream .string += generator .Indent ();

                  for (let c = 0, first = i * components; c < components; ++ c, ++ first)
                     value [c] = array [first];

                  value .toStream (stream);

                  stream .string += ",\n";
               }

               stream .string += generator .Indent ();

               for (let c = 0, first = (length - 1) * components; c < components; ++ c, ++ first)
                  value [c] = array [first];

               value .toStream (stream);
               stream .string += "\n";
            }

            generator .DecIndent ();
            stream .string += generator .Indent ();
            stream .string += "]";

            generator .PopUnitCategory ();
            break;
         }
      }
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      const
         target = this [X3DTypedArrayField_target],
         length = target [_length];

      if (length)
      {
         const
            generator  = InputOutput_Generator.Get (stream),
            array      = target .getValue (),
            components = target .getComponents (),
            value      = new (target .getSingleType ()) ();

         generator .PushUnitCategory (target .getUnit ());

         if (components === 1)
         {
            for (let i = 0, n = length - 1; i < n; ++ i)
            {
               value .set (array [i * components]);
               value .toXMLStream (stream);

               stream .string += ", ";
            }

            value .set (array [(length - 1) * components]);

            value .toXMLStream (stream);
         }
         else
         {
            for (let i = 0, n = length - 1; i < n; ++ i)
            {
               for (let c = 0, first = i * components; c < components; ++ c, ++ first)
                  value [c] = array [first];

               value .toXMLStream (stream);

               stream .string += ", ";
            }

            for (let c = 0, first = (length - 1) * components; c < components; ++ c, ++ first)
               value [c] = array [first];

            value .toXMLStream (stream);
         }

         generator .PopUnitCategory ();
      }
   },
   dispose: function ()
   {
      Base_X3DArrayField.prototype.dispose.call (this [X3DTypedArrayField_target]);
   },
});

for (const key of Reflect .ownKeys (X3DTypedArrayField .prototype))
   Object .defineProperty (X3DTypedArrayField .prototype, key, { enumerable: false });

Object .defineProperty (X3DTypedArrayField .prototype, "length",
{
   get: function () { return this [_length]; },
   set: function (value) { this [X3DTypedArrayField_target] .resize (value); },
   enumerable: false,
   configurable: false,
});

// Getter/Setter functions to reference a value for a given index.

function getValue (index, value, components)
{
   const
      array = this .getValue (),
      tmp   = this [_tmp];

   for (let c = 0; c < components; ++ c, ++ index)
      tmp [c] = array [index];

   value .set .apply (value, tmp);

   return value;
}

function addEvent (index, value, components)
{
   const array = this .getValue ();

   for (let c = 0; c < components; ++ c, ++ index)
      array [index] = value [c];

   this .addEvent ();
}

/* harmony default export */ const Base_X3DTypedArrayField = (X3DTypedArrayField);

;// CONCATENATED MODULE: ./src/x_ite/Fields/ArrayFields.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/























const
   SFMatrix3d = SFMatrix3.SFMatrix3d,
   SFMatrix3f = SFMatrix3.SFMatrix3f,
   SFMatrix4d = SFMatrix4.SFMatrix4d,
   SFMatrix4f = SFMatrix4.SFMatrix4f,
   SFVec2d    = SFVec2.SFVec2d,
   SFVec2f    = SFVec2.SFVec2f,
   SFVec3d    = SFVec3.SFVec3d,
   ArrayFields_SFVec3f    = SFVec3.SFVec3f,
   SFVec4d    = SFVec4.SFVec4d,
   SFVec4f    = SFVec4.SFVec4f;

/*
 *  MFNode
 */

const ArrayFields_cloneCount = Symbol ();

function MFNode (value)
{
   return Base_X3DObjectArrayField.call (this, arguments);
}

MFNode .prototype = Object .assign (Object .create (Base_X3DObjectArrayField.prototype),
{
   constructor: MFNode,
   [ArrayFields_cloneCount]: 0,
   getSingleType: function ()
   {
      return Fields_SFNode;
   },
   getValueType: function ()
   {
      return Fields_SFNode;
   },
   getArrayType: function ()
   {
      return Array;
   },
   getComponents: function ()
   {
      return 1;
   },
   getTypeName: function ()
   {
      return "MFNode";
   },
   getType: function ()
   {
      return Base_X3DConstants.MFNode;
   },
   copy: function (instance)
   {
      if (instance)
      {
         const copy = new MFNode ();

         for (const node of this .getValue ())
            copy .push (node .copy (instance));

         copy .setModificationTime (0);

         return copy;
      }
      else
      {
         return Base_X3DObjectArrayField.prototype.copy.call (this);
      }
   },
   addCloneCount: function (count)
   {
      this [ArrayFields_cloneCount] += count;

      for (const element of this .getValue ())
         element .addCloneCount (count);
   },
   removeCloneCount: function (count)
   {
      this [ArrayFields_cloneCount] -= count;

      for (const element of this .getValue ())
         element .removeCloneCount (count);
   },
   addChildObject: function (value)
   {
      Base_X3DObjectArrayField.prototype.addChildObject.call (this, value);

      value .addCloneCount (this [ArrayFields_cloneCount]);
   },
   removeChildObject: function (value)
   {
      Base_X3DObjectArrayField.prototype.removeChildObject.call (this, value);

      value .removeCloneCount (this [ArrayFields_cloneCount]);
   },
   toStream: function (stream)
   {
      const
         target    = this .getTarget (),
         array     = target .getValue (),
         generator = InputOutput_Generator.Get (stream);

      switch (array .length)
      {
         case 0:
         {
            stream .string += "[ ]";
            break;
         }
         case 1:
         {
            generator .PushUnitCategory (target .getUnit ());

            array [0] .toStream (stream);

            generator .PopUnitCategory ();
            break;
         }
         default:
         {
            generator .PushUnitCategory (target .getUnit ());

            stream .string += "[\n";
            generator .IncIndent ();

            for (let i = 0, length = array .length; i < length; ++ i)
            {
               stream .string += generator .Indent ();
               array [i] .toStream (stream);
               stream .string += "\n";
            }

            generator .DecIndent ();
            stream .string += generator .Indent ();
            stream .string += "]";

            generator .PopUnitCategory ();
            break;
         }
      }
   },
   toVRMLString: function ()
   {
      this .addCloneCount (1);

      const string = Base_X3DObjectArrayField.prototype.toVRMLString.call (this);

      this .removeCloneCount (1);

      return string;
   },
   toVRMLStream: function (stream)
   {
      const
         target    = this .getTarget (),
         array     = target .getValue (),
         generator = InputOutput_Generator.Get (stream);

      switch (array .length)
      {
         case 0:
         {
            stream .string += "[ ]";
            break;
         }
         case 1:
         {
            generator .EnterScope ();

            array [0] .toVRMLStream (stream);

            generator .LeaveScope ();
            break;
         }
         default:
         {
            generator .EnterScope ();

            stream .string += "[\n";
            generator .IncIndent ();

            for (const element of array)
            {
               stream .string += generator .Indent ();
               element .toVRMLStream (stream);
               stream .string += "\n";
            }

            generator .DecIndent ();
            stream .string += generator .Indent ();
            stream .string += "]";

            generator .LeaveScope ();
            break;
         }
      }
   },
   toXMLString: function ()
   {
      this .addCloneCount (1);

      const string = Base_X3DObjectArrayField.prototype.toXMLString.call (this);

      this .removeCloneCount (1);

      return string;
   },
   toXMLStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         length    = this .length;

      if (length)
      {
         generator .EnterScope ();

         const array = this .getValue ();

         for (let i = 0, n = length - 1; i < n; ++ i)
         {
            const node = array [i] .getValue ();

            if (node)
            {
               node .toXMLStream (stream);
               stream .string += "\n";
            }
            else
            {
               stream .string += generator .Indent ();
               stream .string += "<";
               stream .string += "NULL";

               const containerField = generator .ContainerField ();

               if (containerField)
               {
                  stream .string += " ";
                  stream .string += "containerField='";
                  stream .string += generator .XMLEncode (containerField .getName ());
                  stream .string += "'";
               }

               stream .string += "/>";
            }
         }

         const node = array .at (-1) .getValue ();

         if (node)
         {
            node .toXMLStream (stream);
         }
         else
         {
            stream .string += generator .Indent ();
            stream .string += "<";
            stream .string += "NULL";

            const containerField = generator .ContainerField ();

            if (containerField)
            {
               stream .string += " ";
               stream .string += "containerField='";
               stream .string += generator .XMLEncode (containerField .getName ());
               stream .string += "'";
            }
         }

         generator .LeaveScope ();
      }
   },
   dispose: function ()
   {
      this .resize (0);

      Base_X3DObjectArrayField.prototype.dispose.call (this);
   },
});

for (const key of Reflect .ownKeys (MFNode .prototype))
   Object .defineProperty (MFNode .prototype, key, { enumerable: false });

function MFString (value)
{
   return Base_X3DObjectArrayField.call (this, arguments);
}

MFString .prototype = Object .assign (Object .create (Base_X3DObjectArrayField.prototype),
{
   constructor: MFString,
   getValueType: function ()
   {
      return String;
   },
   getSingleType: function ()
   {
      return Fields_SFString;
   },
   getArrayType: function ()
   {
      return Array;
   },
   getComponents: function ()
   {
      return 1;
   },
   getTypeName: function ()
   {
      return "MFString";
   },
   getType: function ()
   {
      return Base_X3DConstants.MFString;
   },
   toXMLStream: function (stream)
   {
      const length = this .length;

      if (length)
      {
         const value = this .getValue ();

         for (let i = 0, n = length - 1; i < n; ++ i)
         {
            stream .string += "\"";
            value [i] .toXMLStream (stream);
            stream .string += "\"";
            stream .string += ", ";
         }

         stream .string += "\"";
         value .at (-1) .toXMLStream (stream);
         stream .string += "\"";
      }
   },
});

for (const key of Reflect .ownKeys (MFString .prototype))
   Object .defineProperty (MFString .prototype, key, { enumerable: false });

function MFImageTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
{
   function ArrayField (value)
   {
      return Base_X3DObjectArrayField.call (this, arguments);
   }

   ArrayField .prototype = Object .assign (Object .create (Base_X3DObjectArrayField.prototype),
   {
      constructor: ArrayField,
      getSingleType: function ()
      {
         return Fields_SFImage;
      },
      getValueType: function ()
      {
         return Fields_SFImage;
      },
      getArrayType: function ()
      {
         return ArrayType;
      },
      getComponents: function ()
      {
         return Components;
      },
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
   });

   for (const key of Reflect .ownKeys (ArrayField .prototype))
      Object .defineProperty (ArrayField .prototype, key, { enumerable: false });

   return ArrayField;
}

function TypedArrayTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
{
   function ArrayField (value)
   {
      return Base_X3DTypedArrayField.call (this, arguments);
   }

   ArrayField .prototype = Object .assign (Object .create (Base_X3DTypedArrayField.prototype),
   {
      constructor: ArrayField,
      getSingleType: function ()
      {
         return SingleType;
      },
      getValueType: function ()
      {
         return ValueType;
      },
      getArrayType: function ()
      {
         return ArrayType;
      },
      getComponents: function ()
      {
         return Components;
      },
      getTypeName: function ()
      {
         return TypeName;
      },
      getType: function ()
      {
         return Type;
      },
   });

   for (const key of Reflect .ownKeys (ArrayField .prototype))
      Object .defineProperty (ArrayField .prototype, key, { enumerable: false });

   return ArrayField;
}

function Value (value) { return value; }

const ArrayFields =
{
   MFBool:      TypedArrayTemplate ("MFBool",      Base_X3DConstants.MFBool,      Fields_SFBool,      Boolean,     Uint8Array,   1),
   MFColor:     TypedArrayTemplate ("MFColor",     Base_X3DConstants.MFColor,     Fields_SFColor,     Fields_SFColor,     Float32Array, 3),
   MFColorRGBA: TypedArrayTemplate ("MFColorRGBA", Base_X3DConstants.MFColorRGBA, Fields_SFColorRGBA, Fields_SFColorRGBA, Float32Array, 4),
   MFDouble:    TypedArrayTemplate ("MFDouble",    Base_X3DConstants.MFDouble,    Fields_SFDouble,    Value,       Float64Array, 1),
   MFFloat:     TypedArrayTemplate ("MFFloat",     Base_X3DConstants.MFFloat,     Fields_SFFloat,     Value,       Float32Array, 1),
   MFImage:     MFImageTemplate    ("MFImage",     Base_X3DConstants.MFImage,     undefined,   undefined,   Array,        1),
   MFInt32:     TypedArrayTemplate ("MFInt32",     Base_X3DConstants.MFInt32,     Fields_SFInt32,     Value,       Int32Array,   1),
   MFMatrix3d:  TypedArrayTemplate ("MFMatrix3d",  Base_X3DConstants.MFMatrix3d,  SFMatrix3d,  SFMatrix3d,  Float64Array, 9),
   MFMatrix3f:  TypedArrayTemplate ("MFMatrix3f",  Base_X3DConstants.MFMatrix3f,  SFMatrix3f,  SFMatrix3f,  Float32Array, 9),
   MFMatrix4d:  TypedArrayTemplate ("MFMatrix4d",  Base_X3DConstants.MFMatrix4d,  SFMatrix4d,  SFMatrix4d,  Float64Array, 16),
   MFMatrix4f:  TypedArrayTemplate ("MFMatrix4f",  Base_X3DConstants.MFMatrix4f,  SFMatrix4f,  SFMatrix4f,  Float32Array, 16),
   MFNode:      MFNode,
   MFRotation:  TypedArrayTemplate ("MFRotation",  Base_X3DConstants.MFRotation,  Fields_SFRotation,  Fields_SFRotation,  Float64Array, 4),
   MFString:    MFString,
   MFTime:      TypedArrayTemplate ("MFTime",      Base_X3DConstants.MFTime,      Fields_SFTime,      Value,       Float64Array, 1),
   MFVec2d:     TypedArrayTemplate ("MFVec2d",     Base_X3DConstants.MFVec2d,     SFVec2d,     SFVec2d,     Float64Array, 2),
   MFVec2f:     TypedArrayTemplate ("MFVec2f",     Base_X3DConstants.MFVec2f,     SFVec2f,     SFVec2f,     Float32Array, 2),
   MFVec3d:     TypedArrayTemplate ("MFVec3d",     Base_X3DConstants.MFVec3d,     SFVec3d,     SFVec3d,     Float64Array, 3),
   MFVec3f:     TypedArrayTemplate ("MFVec3f",     Base_X3DConstants.MFVec3f,     ArrayFields_SFVec3f,     ArrayFields_SFVec3f,     Float32Array, 3),
   MFVec4d:     TypedArrayTemplate ("MFVec4d",     Base_X3DConstants.MFVec4d,     SFVec4d,     SFVec4d,     Float64Array, 4),
   MFVec4f:     TypedArrayTemplate ("MFVec4f",     Base_X3DConstants.MFVec4f,     SFVec4f,     SFVec4f,     Float32Array, 4),
};

/* harmony default export */ const Fields_ArrayFields = (ArrayFields);

;// CONCATENATED MODULE: ./src/x_ite/Fields/SFImage.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






/*
 *  Image
 */

function Image (width, height, comp, array)
{
   const MFInt32 = Fields_ArrayFields.MFInt32;

   this .width  = ~~width;
   this .height = ~~height;
   this .comp   = ~~comp;
   this .array  = new MFInt32 ();
   this .array .setValue (array);
   this .array .length = this .width * this .height;
}

Image .prototype =
{
   constructor: Image,
   copy: function ()
   {
      return new Image (this .width, this .height, this .comp, this .array);
   },
   equals: function (image)
   {
      return this .width  === image .width &&
             this .height === image .height &&
             this .comp   === image .comp &&
             this .array .equals (image .array);
   },
   assign: function (image)
   {
      this .width  = image .width;
      this .height = image .height;
      this .comp   = image .comp;
      this .array .assign (image .array);
   },
   set: function (width, height, comp, array)
   {
      this .width  = ~~width;
      this .height = ~~height;
      this .comp   = ~~comp;
      this .array .assign (array);
   },
   setWidth: function (value)
   {
      this .width = ~~value;
      this .array .length = this .width  * this .height;
   },
   getWidth: function ()
   {
      return this .width;
   },
   setHeight: function (value)
   {
      this .height = ~~value;
      this .array .length = this .width  * this .height;
   },
   getHeight: function ()
   {
      return this .height;
   },
   setComp: function (value)
   {
      this .comp = ~~value;
   },
   getComp: function ()
   {
      return this .comp;
   },
   setArray: function (value)
   {
      this .array .setValue (value);
      this .array .length = this .width  * this .height;
   },
   getArray: function ()
   {
      return this .array;
   },
};

/*
 *  SFImage
 */

function SFImage (width, height, comp, array)
{
   const MFInt32 = Fields_ArrayFields.MFInt32;

   if (arguments [0] instanceof Image)
      Base_X3DField.call (this, arguments [0]);
   else if (arguments .length === 4)
      Base_X3DField.call (this, new Image (width, height, comp, array));
   else
      Base_X3DField.call (this, new Image (0, 0, 0, new MFInt32 ()));

   this .getValue () .getArray () .addParent (this);
   this .addInterest ("set_size__", this);
   return this;
}

SFImage .prototype = Object .assign (Object .create (Base_X3DField.prototype),
{
   constructor: SFImage,
   set_size__: function ()
   {
      this .getValue () .getArray () .length = this .width * this .height;
   },
   copy: function ()
   {
      return new SFImage (this .getValue () .copy ());
   },
   equals: function (image)
   {
      return this .getValue () .equals (image .getValue ());
   },
   isDefaultValue: function ()
   {
      return (
         this .width  === 0 &&
         this .height === 0 &&
         this .comp   === 0);
   },
   set: function (image)
   {
      this .getValue () .assign (image);
   },
   getTypeName: function ()
   {
      return "SFImage";
   },
   getType: function ()
   {
      return Base_X3DConstants.SFImage;
   },
   toStream: function (stream)
   {
      stream .string += this .width + " " + this .height + " " + this .comp;

      for (const value of this .array)
         stream .string += " 0x" + value .toString (16);
   },
   toVRMLStream: function (stream)
   {
      this .toStream (stream);
   },
   toXMLStream: function (stream)
   {
      this .toStream (stream);
   },
});

for (const key of Reflect .ownKeys (SFImage .prototype))
   Object .defineProperty (SFImage .prototype, key, { enumerable: false });

const width = {
   get: function ()
   {
      return this .getValue () .getWidth ();
   },
   set: function (value)
   {
      this .getValue () .setWidth (value);
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const height = {
   get: function ()
   {
      return this .getValue () .getHeight ();
   },
   set: function (value)
   {
      this .getValue () .setHeight (value);
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const comp = {
   get: function ()
   {
      return this .getValue () .getComp ();
   },
   set: function (value)
   {
      this .getValue () .setComp (value);
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

const array = {
   get: function ()
   {
      return this .getValue () .getArray ();
   },
   set: function (value)
   {
      this .getValue () .setArray (value);
      this .addEvent ();
   },
   enumerable: true,
   configurable: false
};

Object .defineProperty (SFImage .prototype, "width",  width);
Object .defineProperty (SFImage .prototype, "height", height);
Object .defineProperty (SFImage .prototype, "comp",   comp);
Object .defineProperty (SFImage .prototype, "array",  array);

width  .enumerable = false;
height .enumerable = false;

Object .defineProperty (SFImage .prototype, "x", width);
Object .defineProperty (SFImage .prototype, "y", height);

/* harmony default export */ const Fields_SFImage = (SFImage);

;// CONCATENATED MODULE: ./src/x_ite/Fields.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




















const Fields = Object .assign (
{
   SFBool:      Fields_SFBool,
   SFColor:     Fields_SFColor,
   SFColorRGBA: Fields_SFColorRGBA,
   SFDouble:    Fields_SFDouble,
   SFFloat:     Fields_SFFloat,
   SFImage:     Fields_SFImage,
   SFInt32:     Fields_SFInt32,
   SFMatrix3d:  SFMatrix3.SFMatrix3d,
   SFMatrix3f:  SFMatrix3.SFMatrix3f,
   SFMatrix4d:  SFMatrix4.SFMatrix4d,
   SFMatrix4f:  SFMatrix4.SFMatrix4f,
   SFNode:      Fields_SFNode,
   SFRotation:  Fields_SFRotation,
   SFString:    Fields_SFString,
   SFTime:      Fields_SFTime,
   SFVec2d:     SFVec2.SFVec2d,
   SFVec2f:     SFVec2.SFVec2f,
   SFVec3d:     SFVec3.SFVec3d,
   SFVec3f:     SFVec3.SFVec3f,
   SFVec4d:     SFVec4.SFVec4d,
   SFVec4f:     SFVec4.SFVec4f,
   VrmlMatrix:  SFMatrix4.VrmlMatrix,
},
Fields_ArrayFields);

/* harmony default export */ const x_ite_Fields = (Fields);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DBaseNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









const
   _executionContext  = Symbol (),
   _type              = Symbol (),
   _fieldDefinitions  = Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions"),
   _fields            = Symbol (),
   _predefinedFields  = Symbol (),
   _aliases           = Symbol (),
   _userDefinedFields = Symbol (),
   _initialized       = Symbol (),
   _live              = Symbol (),
   _set_live__        = Symbol ("X3DBaseNode.set_live__"),
   _private           = Symbol (),
   X3DBaseNode_cloneCount        = Symbol ();

function X3DBaseNode (executionContext)
{
   if (this [_executionContext])
      return;

   Base_X3DEventObject.call (this, executionContext .getBrowser ());

   this [_executionContext]  = executionContext;
   this [_type]              = [ Base_X3DConstants.X3DBaseNode ];
   this [_fields]            = new Base_FieldArray ();
   this [_predefinedFields]  = new Base_FieldArray ();
   this [_aliases]           = new Map ();
   this [_userDefinedFields] = new Base_FieldArray ();
   this [_live]              = true;
   this [_initialized]       = false;
   this [_private]           = false;
   this [X3DBaseNode_cloneCount]        = 0;

   // Setup fields.

   if (this .canUserDefinedFields ())
      this [_fieldDefinitions] = new Base_FieldDefinitionArray (this [_fieldDefinitions]);

   for (const fieldDefinition of this [_fieldDefinitions])
      this .addField (fieldDefinition);

   this .addChildObjects ("name_changed",       new x_ite_Fields.SFTime (),
                          "typeName_changed",   new x_ite_Fields.SFTime (),
                          "fields_changed",     new x_ite_Fields.SFTime (),
                          "cloneCount_changed", new x_ite_Fields.SFTime ())
}

X3DBaseNode .prototype = Object .assign (Object .create (Base_X3DEventObject.prototype),
{
   constructor: X3DBaseNode,
   [_fieldDefinitions]: new Base_FieldDefinitionArray ([ ]),
   setName: function (value)
   {
      Base_X3DEventObject.prototype.setName.call (this, value)

      if (this [_initialized])
         this ._name_changed = this .getBrowser () .getCurrentTime ();
   },
   getMainScene: function ()
   {
      let scene = this [_executionContext] .getScene ();

      while (! scene .isMainScene ())
         scene = scene .getScene ();

      return scene;
   },
   getScene: function ()
   {
      let executionContext = this [_executionContext];

      while (! executionContext .isScene ())
         executionContext = executionContext .getExecutionContext ();

      return executionContext;
   },
   getExecutionContext: function ()
   {
      return this [_executionContext];
   },
   setExecutionContext: function (value)
   {
      // Currently only useful for Scene.
      this [_executionContext] = value;
   },
   addType: function (value)
   {
      this [_type] .push (value);
   },
   getType: function ()
   {
      return this [_type];
   },
   getInnerNode: function ()
   {
      return this;
   },
   isLive: (function ()
   {
      function isLive ()
      {
         return this ._isLive;
      }

      return function ()
      {
         ///  Returns the live event of this node.

         // Change function.

         Object .defineProperty (this, "isLive",
         {
            value: isLive,
            enumerable: false,
            configurable: true,
         });

         // Add isLive event.

         this .addChildObjects ("isLive", new x_ite_Fields.SFBool (this .getLiveState ()));

         // Event processing is done manually and immediately, so:
         this ._isLive .removeParent (this);

         // Connect to execution context.

         if (this .getOuterNode && this .getOuterNode ())
            this .getOuterNode () .isLive () .addInterest (_set_live__, this);

         else if (this [_executionContext] !== this)
            this [_executionContext] .isLive () .addInterest (_set_live__, this);

         // Return field

         return this .isLive ();
      };
   })(),
   setLive: function (value)
   {
      ///  Sets the own live state of this node.  Setting the live state to false
      ///  temporarily disables this node completely.

      this [_live] = value .valueOf ();

      this [_set_live__] ();
   },
   getLive: function ()
   {
      ///  Returns the own live state of this node.

      return this [_live];
   },
   getLiveState: function ()
   {
      ///  Determines the live state of this node.

      if (this .getOuterNode && this .getOuterNode ())
         return this .getLive () && this .getOuterNode () .isLive () .getValue ();

      else if (this !== this [_executionContext])
         return this .getLive () && this [_executionContext] .isLive () .getValue ();

      return this .getLive ();
   },
   [_set_live__]: function ()
   {
      const
         live   = this .getLiveState (),
         isLive = this .isLive ();

      if (live)
      {
         if (isLive .getValue ())
            return;

         isLive .set (true);
         isLive .processEvent ();
      }
      else
      {
         if (isLive .getValue ())
         {
            isLive .set (false);
            isLive .processEvent ();
         }
      }
   },
   create: function (executionContext)
   {
      return new (this .constructor) (executionContext || this [_executionContext]);
   },
   setup: (function ()
   {
      const attributes = { value: Function .prototype, enumerable: false };

      return function ()
      {
         Object .defineProperty (this, "setup", attributes);

         for (const field of this [_fields])
            field .setTainted (false);

         this .initialize ();

         this [_initialized] = true;
      };
   })(),
   initialize: function ()
   { },
   isInitialized: function ()
   {
      return this [_initialized];
   },
   copy: function (executionContext)
   {
      const copy = this .create (executionContext);

      if (this .canUserDefinedFields ())
      {
         for (const fieldDefinition of this [_fieldDefinitions])
         {
            if (copy .getFields () .has (fieldDefinition .name))
               continue;

            copy .addUserDefinedField (fieldDefinition .accessType, fieldDefinition .name, fieldDefinition .value .copy ());
         }
      }

      for (const field of this [_fields])
         copy .getFields () .get (field .getName ()) .assign (field);

      copy .setup ();

      return copy;
   },
   addChildObjects: function (name, field)
   {
      for (let i = 0, length = arguments .length; i < length; i += 2)
         this .addChildObject (arguments [i], arguments [i + 1]);
   },
   addChildObject: function (name, field)
   {
      field .addParent (this);
      field .setName (name);

      Object .defineProperty (this, "_" + name,
      {
         get: function () { return field; },
         set: function (value) { field .setValue (value); },
         enumerable: false,
         configurable: false,
      });
   },
   getFieldDefinitions: function ()
   {
      return this [_fieldDefinitions];
   },
   getFieldsAreEnumerable: function ()
   {
      return false;
   },
   addField: function (fieldDefinition)
   {
      const
         accessType = fieldDefinition .accessType,
         name       = fieldDefinition .name,
         field      = fieldDefinition .value .copy ();

      field .setTainted (!this [_initialized]);
      field .addParent (this);
      field .setName (name);
      field .setAccessType (accessType);

      this [_fields]           .add (name, field);
      this [_predefinedFields] .add (name, field);

      Object .defineProperty (this, "_" + name,
      {
         get: function () { return field; },
         set: function (value) { field .setValue (value); },
         enumerable: this .getFieldsAreEnumerable (),
         configurable: true, // false : non deletable
      });

      if (!this .isPrivate ())
         field .addCloneCount (1);

      if (this [_initialized])
         this ._fields_changed = this .getBrowser () .getCurrentTime ();
   },
   getField: (function ()
   {
      const
         set_field     = /^set_(.*?)$/,
         field_changed = /^(.*?)_changed$/;

      return function (name)
      {
         const field = this [_fields] .get (name) || this [_aliases] .get (name);

         if (field)
            return field;

         const match = name .match (set_field);

         if (match)
         {
            const field = this [_fields] .get (match [1]) || this [_aliases] .get (match [1]);

            if (field && field .getAccessType () === Base_X3DConstants.inputOutput)
               return field;
         }
         else
         {
            const match = name .match (field_changed);

            if (match)
            {
               const field = this [_fields] .get (match [1]) || this [_aliases] .get (match [1]);

               if (field && field .getAccessType () === Base_X3DConstants.inputOutput)
                  return field;
            }
         }

         throw new Error ("Unknown field '" + name + "' in node class " + this .getTypeName () + ".");
      };
   })(),
   addAlias: function (alias, field)
   {
      this [_aliases] .set (alias, field);

      Object .defineProperty (this, "_" + alias,
      {
         get: function () { return field; },
         set: function (value) { field .setValue (value); },
         enumerable: true,
         configurable: false,
      });
   },
   removeField: function (name)
   {
      const field = this [_predefinedFields] .get (name);

      if (field)
      {
         field .removeParent (this);

         this [_fields]           .remove (name);
         this [_predefinedFields] .remove (name);

         delete this ["_" + field .getName ()];

         if (!this .isPrivate ())
            field .removeCloneCount (1);

         if (this [_initialized])
            this ._fields_changed = this .getBrowser () .getCurrentTime ();
      }
   },
   canUserDefinedFields: function ()
   {
      return false;
   },
   addUserDefinedField: function (accessType, name, field)
   {
      if (this [_userDefinedFields] .has (name))
         this .removeUserDefinedField (name);

      field .setTainted (!this [_initialized]);
      field .addParent (this);
      field .setName (name);
      field .setAccessType (accessType);

      this [_fieldDefinitions]  .add (name, new Base_X3DFieldDefinition (accessType, name, field));
      this [_fields]            .add (name, field);
      this [_userDefinedFields] .add (name, field);

      if (!this .isPrivate ())
         field .addCloneCount (1);

      if (this [_initialized])
         this ._fields_changed = this .getBrowser () .getCurrentTime ();
   },
   removeUserDefinedField: function (name)
   {
      const field = this [_userDefinedFields] .get (name);

      if (field)
      {
         field .removeParent (this);

         this [_fields]            .remove (name);
         this [_userDefinedFields] .remove (name);
         this [_fieldDefinitions]  .remove (name);

         if (!this .isPrivate ())
            field .removeCloneCount (1);

         if (this [_initialized])
            this ._fields_changed = this .getBrowser () .getCurrentTime ();
      }
   },
   getUserDefinedFields: function ()
   {
      return this [_userDefinedFields];
   },
   getPredefinedFields: function ()
   {
      return this [_predefinedFields];
   },
   getChangedFields: function (extended)
   {
      /* param routes: also return fields with routes */

      const changedFields = [ ];

      if (extended)
      {
         for (const field of this [_userDefinedFields])
            changedFields .push (field);
      }

      for (const field of this [_predefinedFields])
      {
         if (extended)
         {
            if (field .getInputRoutes () .size || field .getOutputRoutes () .size)
            {
               changedFields .push (field);
               continue;
            }
         }

         if (field .getReferences () .size === 0)
         {
            if (!field .isInitializable ())
               continue;

            if (this .isDefaultValue (field))
               continue;
         }

         changedFields .push (field);
      }

      return changedFields;
   },
   isDefaultValue: function (field)
   {
      const fieldDefinition = this .getFieldDefinitions () .get (field .getName ());

      if (fieldDefinition)
         return fieldDefinition .value .equals (field);

      return !field .getModificationTime ();
   },
   getFields: function ()
   {
      return this [_fields];
   },
   getSourceText: function ()
   {
      return null;
   },
   hasRoutes: function ()
   {
      ///  Returns true if there are any routes from or to fields of this node otherwise false.

      for (const field of this [_fields])
      {
         if (field .getInputRoutes () .size)
            return true;

         if (field .getOutputRoutes () .size)
            return true;
      }

      return false;
   },
   isPrivate: function ()
   {
      return this [_private];
   },
   setPrivate: function (value)
   {
      this [_private] = value;

      if (value)
      {
         for (const field of this [_fields])
            field .removeCloneCount (1);
      }
      else
      {
         for (const field of this [_fields])
            field .addCloneCount (1);
      }
   },
   getCloneCount: function ()
   {
      return this [X3DBaseNode_cloneCount];
   },
   addCloneCount: function (count)
   {
      if (count === 0)
         return;

      const time = this .getBrowser () .getCurrentTime ();

      this [X3DBaseNode_cloneCount] += count;

      this [_executionContext] ._sceneGraph_changed = time;

      if (this [_initialized])
         this ._cloneCount_changed = time;
   },
   removeCloneCount: function (count)
   {
      if (count === 0)
         return;

      const time = this .getBrowser () .getCurrentTime ();

      this [X3DBaseNode_cloneCount] -= count;

      this [_executionContext] ._sceneGraph_changed = time;

      if (this [_initialized])
         this ._cloneCount_changed = time;
   },
   getEnum: function (object, property, defaultValue)
   {
      return object .hasOwnProperty (property) ? object [property] : defaultValue;
   },
   dispose: function ()
   {
      for (const field of this .getFields ())
         field .dispose ();

      Base_X3DEventObject.prototype.dispose.call (this);
   },
});

for (const key of Reflect .ownKeys (X3DBaseNode .prototype))
   Object .defineProperty (X3DBaseNode .prototype, key, { enumerable: false });

/* harmony default export */ const Base_X3DBaseNode = (X3DBaseNode);

;// CONCATENATED MODULE: ./src/x_ite/DEBUG.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


// Modified during dist build.

/* harmony default export */ const DEBUG = (false);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/Context.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const extensions = [
   "ANGLE_instanced_arrays",
   "EXT_blend_minmax",
   "EXT_frag_depth",
   "EXT_shader_texture_lod",
   "EXT_texture_filter_anisotropic",
   "OES_element_index_uint",
   "OES_standard_derivatives",
   "OES_texture_float",
   "OES_texture_float_linear",
   "OES_texture_half_float",
   "OES_texture_half_float_linear",
   "OES_vertex_array_object",
   "WEBGL_compressed_texture_s3tc",
   //"WEBGL_debug_renderer_info",
   "WEBGL_debug_shaders",
   "WEBGL_depth_texture",
   "WEBGL_draw_buffers",
   "WEBGL_lose_context",

   "EXT_color_buffer_float",
   "EXT_color_buffer_half_float",
   "EXT_disjoint_timer_query",
   "EXT_disjoint_timer_query_webgl2",
   "EXT_sRGB",
   "WEBGL_color_buffer_float",
   "WEBGL_compressed_texture_astc",
   "WEBGL_compressed_texture_atc",
   "WEBGL_compressed_texture_etc",
   "WEBGL_compressed_texture_etc1",
   "WEBGL_compressed_texture_pvrtc",
   "WEBGL_compressed_texture_s3tc",
   "WEBGL_compressed_texture_s3tc_srgb",

   "EXT_float_blend",
   "OES_fbo_render_mipmap",
   "WEBGL_get_buffer_sub_data_async",
   "WEBGL_multiview",
   "WEBGL_security_sensitive_resources",
   "WEBGL_shared_resources",

   "EXT_clip_cull_distance",
   "WEBGL_debug",
   "WEBGL_dynamic_texture",
   "WEBGL_subarray_uploads",
   "WEBGL_texture_multisample",
   "WEBGL_texture_source_iframe",
   "WEBGL_video_texture",

   "EXT_texture_storage",
   "OES_depth24",
   "WEBGL_debug_shader_precision",
   "WEBGL_draw_elements_no_range_check",
   "WEBGL_subscribe_uniform",
   "WEBGL_texture_from_depth_video",
];

const Context =
{
   create: function (canvas, version, preserveDrawingBuffer)
   {
      const options = { preserveDrawingBuffer: preserveDrawingBuffer };

      let gl = null;

      if (version >= 2 && ! gl)
      {
         gl = canvas .getContext ("webgl2", options);

         if (gl)
            gl .getVersion = function () { return 2; };
      }

      if (version >= 1 && ! gl)
      {
         gl = canvas .getContext ("webgl",              options) ||
              canvas .getContext ("experimental-webgl", options);

         if (gl)
         {
            gl .getVersion = function () { return 1; };

            {
               const ext = gl .getExtension ("OES_vertex_array_object");

               gl .bindVertexArray   =  ext .bindVertexArrayOES   .bind (ext);
               gl .createVertexArray =  ext .createVertexArrayOES .bind (ext);
               gl .deleteVertexArray =  ext .deleteVertexArrayOES .bind (ext);
               gl .isVertexArray     =  ext .isVertexArrayOES     .bind (ext);
            }
         }
       }

      if (! gl)
         throw new Error ("Couldn't create WebGL context.");

      // Feature detection:

      // If the aliased lineWidth ranges are both 1, gl .lineWidth is probably not possible,
      // thus we disable it completely to prevent webgl errors.

      const aliasedLineWidthRange = gl .getParameter (gl .ALIASED_LINE_WIDTH_RANGE);

      if (aliasedLineWidthRange [0] === 1 && aliasedLineWidthRange [1] === 1)
      {
         gl .lineWidth                     = Function .prototype;
         gl .HAS_FEATURE_TRANSFORMED_LINES = gl .getVersion () >= 2;

         if (DEBUG)
            console .info ("Lines are transformed if necessary to obtain thick lines.");
      }
      else
      {
         gl .HAS_FEATURE_TRANSFORMED_LINES = false;
      }

      gl .HAS_FEATURE_DEPTH_TEXTURE = gl .getVersion () >= 2 || !! gl .getExtension ("WEBGL_depth_texture");
      gl .HAS_FEATURE_FRAG_DEPTH    = gl .getVersion () >= 2 || !! gl .getExtension ("EXT_frag_depth");

      // Load extensions.

      for (const extension of extensions)
         gl .getExtension (extension);

      // Return context.

      return gl;
   },
}

/* harmony default export */ const Core_Context = (Context);

;// CONCATENATED MODULE: ./src/locale/de.po.js
/* harmony default export */ const de_po = (`msgid ""
msgstr ""
"Project-Id-Version: X_ITE\n"
"POT-Creation-Date: 2015-12-23 04:56+0100\n"
"PO-Revision-Date: 2015-12-23 04:57+0100\n"
"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\n"
"Language-Team: \n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.4\n"
"X-Poedit-Basepath: ../x_ite\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Poedit-SourceCharset: UTF-8\n"
"X-Poedit-SearchPath-0: .\n"

msgid "Less Properties"
msgstr "Weniger Eigenschaften"

msgid "More Properties"
msgstr "Mehr Eigenschaften"

msgid "Frame rate"
msgstr "Bildrate"

msgid "fps"
msgstr "BpS"

msgid "Speed"
msgstr "Geschwindigkeit"

msgid "m/s"
msgstr ""

msgid "km/h"
msgstr ""

msgid "Browser"
msgstr ""

msgid "ms"
msgstr ""

msgid "X3D total"
msgstr "X3D gesamt"

msgid "Event Processing"
msgstr "Ereignisverarbeitung"

msgid "Pointer"
msgstr "Zeigegerät"

msgid "Camera"
msgstr "Kamera"

msgid "Collision Detection"
msgstr "Kollisionserkennung"

msgid "Rendering"
msgstr "Rendering"

msgid "Number of Shapes"
msgstr "Anzahl der Formen"

msgid "Number of Sensors"
msgstr "Anzahl der Sensoren"

msgid "Browser Timings"
msgstr "Zeitberechnung"

msgid "X_ITE Browser"
msgstr ""

msgid "Viewpoints"
msgstr "Ansichtspunkte"

msgid "Available Viewers"
msgstr "Verfügbare Betrachter"

msgid "Straighten Horizon"
msgstr "Horizont gerade richten"

msgid "Primitive Quality"
msgstr "Qualität der Grundobjekte"

msgid "High"
msgstr "Hoch"

msgid "high"
msgstr "hoch"

msgid "Medium"
msgstr "Mittel"

msgid "medium"
msgstr "mittel"

msgid "Low"
msgstr "Niedrig"

msgid "low"
msgstr "niedrig"

msgid "Texture Quality"
msgstr "Textur Qualität"

msgid "Display Rubberband"
msgstr "Gummiband anzeigen"

msgid "Rubberband"
msgstr "Gummiband"

msgid "on"
msgstr "an"

msgid "off"
msgstr "aus"

msgid "Mute Browser"
msgstr "Browser stumm schalten"

msgid "Browser muted"
msgstr "Browser stumm geschalten"

msgid "Browser unmuted"
msgstr "Browser Ton an"

msgid "Leave Fullscreen"
msgstr "Vollbild verlassen"

msgid "Fullscreen"
msgstr "Vollbild"

msgid "About X_ITE"
msgstr "Über X_ITE"

msgid "Examine Viewer"
msgstr "Untersuchen"

msgid "Walk Viewer"
msgstr "Laufen"

msgid "Fly Viewer"
msgstr "Fliegen"

msgid "Plane Viewer"
msgstr "Ebenen Betrachter"

msgid "Look At Viewer"
msgstr "Auf Objekte zielen"

msgid "None Viewer"
msgstr "Kein Betrachter"

msgid "Loading %1 file"
msgstr "Lade %1 Datei"

msgid "Loading %1 files"
msgstr "Lade %1 Dateien"

msgid "Loading done"
msgstr "Fertig mit Laden"

msgid "Failed loading world."
msgstr "Laden der Dateien fehlgeschlagen."

msgid "Show World Info"
msgstr "World Info anzeigen"

msgid "Viewpoint is copied to clipboard."
msgstr "Ansichtspunkt wurde in die Zwischenablage kopiert."
`);

;// CONCATENATED MODULE: ./src/locale/fr.po.js
/* harmony default export */ const fr_po = (`msgid ""
msgstr ""
"Project-Id-Version: X_ITE\n"
"POT-Creation-Date: 2015-12-23 04:58+0100\n"
"PO-Revision-Date: 2015-12-23 05:07+0100\n"
"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.4\n"
"X-Poedit-Basepath: ../x_ite\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Poedit-SourceCharset: UTF-8\n"
"X-Poedit-SearchPath-0: .\n"

msgid "Less Properties"
msgstr "Moins de propriétés"

msgid "More Properties"
msgstr "Plus de propriétés"

msgid "Frame rate"
msgstr "Fréquence"

msgid "fps"
msgstr "fps"

msgid "Speed"
msgstr "Vélocité"

msgid "m/s"
msgstr ""

msgid "km/h"
msgstr ""

msgid "Browser"
msgstr "X_ITE Navigateur"

msgid "ms"
msgstr ""

msgid "X3D total"
msgstr "X3D total"

msgid "Traitement des événements"
msgstr "Routes"

msgid "Pointer"
msgstr "Pointeur"

msgid "Camera"
msgstr "Caméra"

msgid "Collision Detection"
msgstr "Détection des collisions"

msgid "Rendering"
msgstr "Rendement"

msgid "Number of Shapes"
msgstr "Nombre de formes"

msgid "Number of Sensors"
msgstr "Nombre de senseurs"

msgid "Browser Timings"
msgstr "Calcul du temps"

msgid "X_ITE Browser"
msgstr "X_ITE Navigateur"

msgid "Viewpoints"
msgstr "Points de vue"

msgid "Available Viewers"
msgstr "Visionneurs disponibles"

msgid "Straighten Horizon"
msgstr "Redresser l'horizon"

msgid "Primitive Quality"
msgstr "Qualité des objets simples"

msgid "High"
msgstr "Haut"

msgid "high"
msgstr "haut"

msgid "Medium"
msgstr "Moyenne"

msgid "medium"
msgstr "moyenne"

msgid "Low"
msgstr "Faible"

msgid "low"
msgstr "faible"

msgid "Texture Quality"
msgstr "Qualité des textures"

msgid "Display Rubberband"
msgstr "Présenter le bande élastique"

msgid "Rubberband"
msgstr "Bande élastique"

msgid "on"
msgstr "marche"

msgid "off"
msgstr "arrêt"

msgid "Mute Browser"
msgstr "Rendre navigateur muet"

msgid "Browser muted"
msgstr "Navigateur muet"

msgid "Browser unmuted"
msgstr "Son de navigateur réactivé"

msgid "Leave Fullscreen"
msgstr "Sortie en plein écran"

msgid "Fullscreen"
msgstr "Plein écran"

msgid "About X_ITE"
msgstr "À propos de X_ITE"

msgid "Examine Viewer"
msgstr "Examiner"

msgid "Walk Viewer"
msgstr "Aller"

msgid "Fly Viewer"
msgstr "Voler"

msgid "Plane Viewer"
msgstr "Visionneur de la plaine"

msgid "Look At Viewer"
msgstr "Regarder un objet de près"

msgid "None Viewer"
msgstr "Pas de visionneur"

msgid "Loading %1 file"
msgstr "Télécharger %1 fichier"

msgid "Loading %1 files"
msgstr "Télécharger %1 fichiers"

msgid "Loading done"
msgstr "Téléchargement fini"

msgid "Failed loading world."
msgstr "Le chargement des fichiers a échoué."

msgid "Show World Info"
msgstr "Afficher World Info"

msgid "Viewpoint is copied to clipboard."
msgstr "Le point de vue est copié dans le presse-papiers."
`);

;// CONCATENATED MODULE: ./src/locale/gettext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function execAll (regex, string)
{
   const matches = [ ];

   let match = null;

   while (match = regex .exec (string))
      matches .push (match);

   return matches;
}

function getLanguage ()
{
   for (const la of navigator .languages)
   {
      const language = la .split ("-") [0];

      if (locales [language])
         return language;
   }

   return (navigator .language || navigator .userLanguage) .split ("-") [0];
}

function setLocale (language)
{
   if (locales [language])
   {
      const
         matches = execAll (msg, locales [language]),
         locale  = locales [language] = { };

      for (var i = 0, length = matches .length; i < length; ++ i)
      {
         if (matches [i] [2] .length)
            locale [matches [i] [1]] = matches [i] [2];
      }
   }
}

const locales =
{
   en: "C",
   de: de_po,
   fr: fr_po,
};

const
   msg      = /msgid\s+"(.*?)"\nmsgstr\s+"(.*?)"\n/g,
   language = getLanguage ();

setLocale (language);

function gettext (string)
{
   const locale = locales [language];

   if (locale === undefined)
      return string;

   const translation = locale [string];

   if (translation === undefined)
      return string;

   return translation;
}

/* harmony default export */ const locale_gettext = (gettext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/BrowserTimings.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function f2 (n) { return n .toFixed (2); }

function BrowserTimings (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .localStorage = this .getBrowser () .getLocalStorage () .addNameSpace ("BrowserTimings.");
   this .enabled      = false;
}

BrowserTimings .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BrowserTimings,
   getTypeName: function ()
   {
      return "BrowserTimings";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "browserTimings";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      this .localStorage .addDefaultValues ({ type: "LESS" });

      this .localeOptions = { minimumFractionDigits: 2, maximumFractionDigits: 2 };
      this .startTime     = 0;
      this .frames        = 0;

      this .element = $("<div></div>") .hide () .addClass ("x_ite-private-browser-timings") .appendTo (this .getBrowser () .getSurface ());
      this .table   = $("<table></table>") .appendTo (this .element);
      this .header  = $("<thead></thead>") .append ($("<tr></tr>") .append ($("<th colspan='2'></th>"))) .appendTo (this .table);
      this .body    = $("<tbody></tbody>") .appendTo (this .table);
      this .footer  = $("<tfoot></tfoot>") .append ($("<tr></tr>") .append ($("<td colspan='2'></td>"))) .appendTo (this .table);
      this .button  = $("<button></button>") .attr ("type", "button") .appendTo (this .footer .find ("td"));
      this .rows    = [ ];

      this .button .on ("click touchend", this .set_type__ .bind (this));

      this .set_button__ ();
   },
   getEnabled: function ()
   {
      return this .enabled;
   },
   setEnabled: function (enabled)
   {
      if (this .enabled === enabled)
         return;

      this .enabled = enabled;

      if (enabled)
      {
         this .element .stop (true, true) .fadeIn ();
         this .getBrowser () .prepareEvents () .addInterest ("update", this);
         this .update ();
      }
      else
      {
         this .element .stop (true, true) .fadeOut ();
         this .getBrowser () .prepareEvents () .removeInterest ("update", this);
      }
   },
   set_type__: function ()
   {
      if (this .localStorage .type === "MORE")
         this .localStorage .type = "LESS";
      else
         this .localStorage .type = "MORE";

      this .set_button__ ();
      this .build ();
   },
   set_button__: function ()
   {
      if (this .localStorage .type === "MORE")
         this .button .text (locale_gettext("Less Properties"));
      else
         this .button .text (locale_gettext("More Properties"));
   },
   update: function ()
   {
      const currentTime = this .getBrowser () .getCurrentTime ();

      if (currentTime - this .startTime > 1)
      {
         this .build ();

         this .frames    = 0;
         this .startTime = currentTime;
      }
      else
         ++ this .frames;
   },
   build: function ()
   {
      const
         browser     = this .getBrowser (),
         currentTime = browser .getCurrentTime (),
         language    = navigator .language || navigator .userLanguage,
         fixed       = this .localeOptions,
         rows        = this .rows;

      let r = 0;

      rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Frame rate") + ":")) .append ($("<td></td>") .text (f2(this .frames / (currentTime - this .startTime)) .toLocaleString (language, fixed) + " " + locale_gettext("fps")));
      rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Speed")      + ":")) .append ($("<td></td>") .text (f2(this .getSpeed (browser .currentSpeed))         .toLocaleString (language, fixed) + " " + this .getSpeedUnit (browser .currentSpeed)));

      if (this .localStorage .type === "MORE")
      {
         const
            layers         = browser .getWorld () .getLayerSet () .getLayers (),
            activeLayer    = browser .getActiveLayer (),
            systemTime     = browser .getSystemTime (),
            navigationTime = activeLayer && browser .getCollisionCount () ? activeLayer .collisionTime : 0,
            collisionTime  = browser .getCollisionTime () + navigationTime,
            routingTime    = browser .getBrowserTime () - (browser .getCameraTime () + browser .getCollisionTime () + browser .getDisplayTime () + navigationTime),
            prepareEvents  = browser .prepareEvents () .getInterests () .size - 1,
            sensors        = browser .sensorEvents () .getInterests () .size;

         let
            opaqueShapes      = 0,
            transparentShapes = 0;

         for (const layer of layers)
         {
            opaqueShapes      += layer .numOpaqueShapes;
            transparentShapes += layer .numTransparentShapes;
         }

         rows [1] .addClass ("x_ite-private-more");

         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Browser")   + ":")) .append ($("<td></td>") .text (f2(systemTime)           .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("X3D total")       + ":")) .append ($("<td></td>") .text (f2(browser .getBrowserTime ()) .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Event Processing")   + ":")) .append ($("<td></td>") .text (f2(routingTime)          .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Pointer")   + ":")) .append ($("<td></td>") .text (f2(browser .getPointerTime ()) .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Camera")    + ":")) .append ($("<td></td>") .text (f2(browser .getCameraTime ())  .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Picking")   + ":")) .append ($("<td></td>") .text (f2(browser .getPickingTime ()) .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Collision Detection") + ":")) .append ($("<td></td>") .text (f2(collisionTime)        .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Rendering")   + ":")) .append ($("<td></td>") .text (f2(browser .getDisplayTime ()) .toLocaleString (language, fixed) + " " + locale_gettext("ms")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Number of Shapes")    + ":")) .append ($("<td></td>") .text (opaqueShapes + " + " + transparentShapes));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (locale_gettext("Number of Sensors")   + ":")) .append ($("<td></td>") .text (prepareEvents + sensors));
      }

      rows .length = r;

      this .header .find ("th") .text (locale_gettext("Browser Timings"));
      this .body .empty ();
      this .body .append (rows);
   },
   getSpeed: function (speed)
   {
      if (speed < 15)
         return speed;

      return speed * 3.6;
   },
   getSpeedUnit: function (speed)
   {
      if (speed < 15)
         return locale_gettext("m/s");

      return locale_gettext("km/h");
   },
});

/* harmony default export */ const Core_BrowserTimings = (BrowserTimings);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/PrimitiveQuality.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let i = 0;

const PrimitiveQuality =
{
   LOW:    i ++,
   MEDIUM: i ++,
   HIGH:   i ++,
};

/* harmony default export */ const Core_PrimitiveQuality = (PrimitiveQuality);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/Shading.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let Shading_i = 0;

const Shading =
{
   POINT:     Shading_i ++,
   WIREFRAME: Shading_i ++,
   FLAT:      Shading_i ++,
   GOURAUD:   Shading_i ++,
   PHONG:     Shading_i ++,
};

/* harmony default export */ const Core_Shading = (Shading);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/TextureQuality.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let TextureQuality_i = 0;

const TextureQuality =
{
   LOW:    TextureQuality_i ++,
   MEDIUM: TextureQuality_i ++,
   HIGH:   TextureQuality_i ++,
};

/* harmony default export */ const Core_TextureQuality = (TextureQuality);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/BrowserOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function BrowserOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addAlias ("AntiAliased", this ._Antialiased);

   const browser = this .getBrowser ();

   this .localStorage     = browser .getLocalStorage () .addNameSpace ("BrowserOptions.");
   this .textureQuality   = Core_TextureQuality.MEDIUM
   this .primitiveQuality = Core_PrimitiveQuality.MEDIUM;
   this .shading          = Core_Shading.GOURAUD;

   this .setAttributeSplashScreen ();
}

BrowserOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BrowserOptions,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "SplashScreen",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Dashboard",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Rubberband",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "EnableInlineViewpoints", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Antialiased",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "TextureQuality",         new x_ite_Fields.SFString ("MEDIUM")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "PrimitiveQuality",       new x_ite_Fields.SFString ("MEDIUM")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "QualityWhenMoving",      new x_ite_Fields.SFString ("MEDIUM")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Shading",                new x_ite_Fields.SFString ("GOURAUD")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "MotionBlur",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Gravity",                new x_ite_Fields.SFFloat (9.80665)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "StraightenHorizon",      new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "LogarithmicDepthBuffer", new x_ite_Fields.SFBool (false)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "Timings",                new x_ite_Fields.SFBool (false)),
   ]),
   getTypeName: function ()
   {
      return "BrowserOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "browserOptions";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      this .localStorage .addDefaultValues ({
         Rubberband:        this ._Rubberband        .getValue (),
         PrimitiveQuality:  this ._PrimitiveQuality  .getValue (),
         TextureQuality:    this ._TextureQuality    .getValue (),
         StraightenHorizon: this ._StraightenHorizon .getValue (),
         Timings:           this ._Timings           .getValue (),
      });

      this ._SplashScreen           .addInterest ("set_splashScreen__",           this);
      this ._Rubberband             .addInterest ("set_rubberband__",             this);
      this ._PrimitiveQuality       .addInterest ("set_primitiveQuality__",       this);
      this ._TextureQuality         .addInterest ("set_textureQuality__",         this);
      this ._Shading                .addInterest ("set_shading__",                this);
      this ._StraightenHorizon      .addInterest ("set_straightenHorizon__",      this);
      this ._LogarithmicDepthBuffer .addInterest ("set_logarithmicDepthBuffer__", this);
      this ._Timings                .addInterest ("set_timings__",                this);

      this .configure ();
   },
   configure: function ()
   {
      const localStorage = this .localStorage;

      for (const fieldDefinition of this .getFieldDefinitions ())
      {
         const field = this .getField (fieldDefinition .name);

         if (localStorage [fieldDefinition .name] !== undefined)
            continue;

         if (! field .equals (fieldDefinition .value))
            field .assign (fieldDefinition .value);
      }

      const
         rubberband        = localStorage .Rubberband,
         primitiveQuality  = localStorage .PrimitiveQuality,
         textureQuality    = localStorage .TextureQuality,
         straightenHorizon = localStorage .StraightenHorizon,
         timings           = localStorage .Timings;

      this .setAttributeSplashScreen ();

      if (rubberband !== this ._Rubberband .getValue ())
         this ._Rubberband = rubberband;

      if (primitiveQuality !== this ._PrimitiveQuality .getValue ())
         this ._PrimitiveQuality = primitiveQuality;

      if (textureQuality !== this ._TextureQuality .getValue ())
         this ._TextureQuality = textureQuality;

      if (straightenHorizon !== this ._StraightenHorizon .getValue ())
         this ._StraightenHorizon = straightenHorizon;

      if (timings !== this ._Timings .getValue ())
         this ._Timings = timings;
   },
   setAttributeSplashScreen: function ()
   {
      this ._SplashScreen .set (this .getSplashScreen ());
   },
   getCache: function ()
   {
      return toBoolean (this .getBrowser () .getElement () .attr ("cache"), true);
   },
   getContextMenu: function ()
   {
      return toBoolean (this .getBrowser () .getElement () .attr ("contextMenu"), true);
   },
   getDebug: function ()
   {
      return toBoolean (this .getBrowser () .getElement () .attr ("debug"), false);
   },
   getNotifications: function ()
   {
      return toBoolean (this .getBrowser () .getElement () .attr ("notifications"), true);
   },
   getSplashScreen: function ()
   {
      return toBoolean (this .getBrowser () .getElement () .attr ("splashScreen"), true);
   },
   getPrimitiveQuality: function ()
   {
      return this .primitiveQuality;
   },
   getShading: function ()
   {
      return this .shading;
   },
   getTextureQuality: function ()
   {
      return this .textureQuality;
   },
   set_splashScreen__: function (splashScreen)
   {
      this .getBrowser () .getElement () .attr ("splashScreen", splashScreen .getValue () ? "true" : "false");
   },
   set_rubberband__: function (rubberband)
   {
      this .localStorage .Rubberband = rubberband .getValue ();
   },
   set_primitiveQuality__: function (value)
   {
      const
         browser          = this .getBrowser (),
         primitiveQuality = value .getValue () .toUpperCase ();

      this .localStorage .PrimitiveQuality = primitiveQuality;
      this .primitiveQuality               = this .getEnum (Core_PrimitiveQuality, primitiveQuality, Core_PrimitiveQuality.MEDIUM);

      if (typeof browser .setPrimitiveQuality2D === "function")
         browser .setPrimitiveQuality2D (this .primitiveQuality);

      if (typeof browser .setPrimitiveQuality3D === "function")
         browser .setPrimitiveQuality3D (this .primitiveQuality);
   },
   set_textureQuality__: function (value)
   {
      const
         browser        = this .getBrowser (),
         textureQuality = value .getValue () .toUpperCase ();

      this .localStorage .TextureQuality = textureQuality;
      this .textureQuality               = this .getEnum (Core_TextureQuality, textureQuality, Core_TextureQuality.MEDIUM);

      if (typeof browser .setTextureQuality === "function")
         browser .setTextureQuality (this .textureQuality);
   },
   set_shading__: (function ()
   {
      const strings = {
         [Core_Shading.POINT]:     "POINT",
         [Core_Shading.WIREFRAME]: "WIREFRAME",
         [Core_Shading.FLAT]:      "FLAT",
         [Core_Shading.GOURAUD]:   "GOURAUD",
         [Core_Shading.PHONG]:     "PHONG",
      };

      return function (value)
      {
         const
            browser = this .getBrowser (),
            shading = value .getValue () .toUpperCase () .replace ("POINTSET", "POINT");

         this .shading = this .getEnum (Core_Shading, shading, Core_Shading.GOURAUD);

         browser .getRenderingProperties () ._Shading = strings [this .shading];
         browser .setShading (this .shading);
      };
   })(),
   set_straightenHorizon__: function (straightenHorizon)
   {
      this .localStorage .StraightenHorizon = straightenHorizon .getValue ();
   },
   set_logarithmicDepthBuffer__: function (logarithmicDepthBuffer)
   {
      const
         browser = this .getBrowser (),
         gl      = browser .getContext ();

      browser .getRenderingProperties () ._LogarithmicDepthBuffer = logarithmicDepthBuffer .getValue () && gl .HAS_FEATURE_FRAG_DEPTH;
   },
   set_timings__: function (timings)
   {
      this .localStorage .Timings = timings .getValue ();

      this .getBrowser () .getBrowserTimings () .setEnabled (timings .getValue ());
   },
});

function toBoolean (value, defaultValue)
{
   value = String (value) .toUpperCase ();

   if (value === "TRUE")
      return true;

   if (value === "FALSE")
      return false;

   return defaultValue;
}

/* harmony default export */ const Core_BrowserOptions = (BrowserOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/BrowserProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function BrowserProperties (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);
}

BrowserProperties .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BrowserProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ABSTRACT_NODES",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "CONCRETE_NODES",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "EXTERNAL_INTERACTIONS", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "PROTOTYPE_CREATE",      new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "DOM_IMPORT",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "XML_ENCODING",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "CLASSIC_VRML_ENCODING", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "BINARY_ENCODING",       new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "BrowserProperties";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "browserProperties";
   },
});

/* harmony default export */ const Core_BrowserProperties = (BrowserProperties);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/RenderingProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function RenderingProperties (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addAlias ("AntiAliased", this ._Antialiased);
}

RenderingProperties .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: RenderingProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "Shading",                new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "MaxTextureSize",         new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "TextureUnits",           new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "MaxLights",              new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "Antialiased",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "ColorDepth",             new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "TextureMemory",          new x_ite_Fields.SFDouble ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "LogarithmicDepthBuffer", new x_ite_Fields.SFBool (false)),
   ]),
   getTypeName: function ()
   {
      return "RenderingProperties";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "renderingProperties";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      const browser = this .getBrowser ();

      this ._MaxTextureSize = browser .getMaxTextureSize ();
      this ._TextureUnits   = browser .getMaxCombinedTextureUnits ();
      this ._MaxLights      = browser .getMaxLights ();
      this ._ColorDepth     = browser .getColorDepth ();
      this ._TextureMemory  = browser .getTextureMemory ();
   },
});

/* harmony default export */ const Core_RenderingProperties = (RenderingProperties);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/Notification.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





$.fn.textWidth = function (string)
{
   const
      children = $(this) .children (),
      html     = $(this) .html (),
      span     = '<span>' + html + '</span>';
   $(this) .html (span);
   const width = $(this) .find ('span:first') .width ();
   $(this) .empty ();
   $(this) .append (children);
   return width;
};

function Notification (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("string", new Fields_SFString ());
}

Notification .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: Notification,
   getTypeName: function ()
   {
      return "Notification";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      this .element = $("<div></div>")
         .hide ()
         .addClass ("x_ite-private-notification")
         .appendTo (this .getBrowser () .getSurface ())
         .animate ({ width: 0 });

      $("<span></span>") .appendTo (this .element);

      this ._string .addInterest ("set_string__", this);
   },
   set_string__: function ()
   {
      if (! this .getBrowser () .getBrowserOptions () .getNotifications ())
         return;

      if (this ._string .length === 0)
         return;

      this .element .children () .text (this ._string .getValue ());

      this .element
         .stop (true, true)
         .fadeIn (0)
         .animate ({ width: this .element .textWidth () })
         .animate ({ "delay": 1 }, 5000)
         .animate ({ width: 0 })
         .fadeOut (0);
   },
});

/* harmony default export */ const Core_Notification = (Notification);

;// CONCATENATED MODULE: ./src/lib/jquery.fullscreen-min.js

/*
 jquery.fullscreen 1.1.5
 https://github.com/kayahr/jquery-fullscreen-plugin
 Copyright (C) 2012-2013 Klaus Reimer <k@ailis.de>
 Licensed under the MIT license
 (See http://www.opensource.org/licenses/mit-license)
*/
function d(c){var b,a;if(!this.length)return this;b=this[0];b.ownerDocument?a=b.ownerDocument:(a=b,b=a.documentElement);if(null==c){if(!a.exitFullscreen&&!a.webkitExitFullscreen&&!a.webkitCancelFullScreen&&!a.msExitFullscreen&&!a.mozCancelFullScreen)return null;c=!!a.fullscreenElement||!!a.msFullscreenElement||!!a.webkitIsFullScreen||!!a.mozFullScreen;return!c?c:a.fullscreenElement||a.webkitFullscreenElement||a.webkitCurrentFullScreenElement||a.msFullscreenElement||a.mozFullScreenElement||c}c?(c=
b.requestFullscreen||b.webkitRequestFullscreen||b.webkitRequestFullScreen||b.msRequestFullscreen||b.mozRequestFullScreen)&&c.call(b):(c=a.exitFullscreen||a.webkitExitFullscreen||a.webkitCancelFullScreen||a.msExitFullscreen||a.mozCancelFullScreen)&&c.call(a);return this}jQuery.fn.fullScreen=d;jQuery.fn.toggleFullScreen=function(){return d.call(this,!d.call(this))};var jquery_fullscreen_min_e,f,jquery_fullscreen_min_g;jquery_fullscreen_min_e=document;
jquery_fullscreen_min_e.webkitCancelFullScreen?(f="webkitfullscreenchange",jquery_fullscreen_min_g="webkitfullscreenerror"):jquery_fullscreen_min_e.msExitFullscreen?(f="MSFullscreenChange",jquery_fullscreen_min_g="MSFullscreenError"):jquery_fullscreen_min_e.mozCancelFullScreen?(f="mozfullscreenchange",jquery_fullscreen_min_g="mozfullscreenerror"):(f="fullscreenchange",jquery_fullscreen_min_g="fullscreenerror");jQuery(document).bind(f,function(){jQuery(document).trigger(new jQuery.Event("fullscreenchange"))});jQuery(document).bind(jquery_fullscreen_min_g,function(){jQuery(document).trigger(new jQuery.Event("fullscreenerror"))});

/* harmony default export */ const jquery_fullscreen_min = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/ContextMenu.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const _userMenu = Symbol ();

function ContextMenu (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this [_userMenu] = null;
}

ContextMenu .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: ContextMenu,
   getTypeName: function ()
   {
      return "ContextMenu";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "contextMenu";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      const browser = this .getBrowser ();

      this .init ({
         element: browser .getElement (),
         appendTo: browser .getShadow (),
         build: this .build .bind (this),
         animation: {duration: 500, show: "fadeIn", hide: "fadeOut"},
      });
   },
   getUserMenu: function ()
   {
      return this [_userMenu];
   },
   setUserMenu: function (userMenu)
   {
      this [_userMenu] = userMenu;
   },
   createUserMenu: function ()
   {
      const userMenu = { };

      if (typeof this [_userMenu] === "function")
      {
         const menu = this [_userMenu] ();

         if ($.isPlainObject (menu))
         {
            for (const key in menu)
               userMenu ["user-" + key] = menu [key];
         }
      }

      return userMenu;
   },
   build: function (event)
   {
      const
         browser          = this .getBrowser (),
         activeLayer      = browser .getActiveLayer (),
         currentViewpoint = activeLayer ? activeLayer .getViewpoint () : null,
         fullscreen       = browser .getElement () .fullScreen ();

      if (! browser .getBrowserOptions () .getContextMenu ())
         return;

      const menu = {
         className: "x_ite-private-menu",
         items: {
            "title": {
               name: browser .getName () + " Browser v" + browser .getVersion (),
               className: "context-menu-title context-menu-not-selectable",
            },
            "separator0": "--------",
            "viewpoints": {
               name: locale_gettext("Viewpoints"),
               className: "context-menu-icon x_ite-private-icon-viewpoint",
               items: this .getViewpoints (),
            },
            "available-viewers": {
               name: locale_gettext("Available Viewers"),
               items: this .getAvailableViewers (),
            },
            "straighten-horizon": {
               name: locale_gettext("Straighten Horizon"),
               type: "checkbox",
               selected: browser .getBrowserOption ("StraightenHorizon"),
               events: {
                  click: function (event)
                  {
                     const straightenHorizon = $(event .target) .is (":checked");

                     browser .setBrowserOption ("StraightenHorizon", straightenHorizon);

                     if (straightenHorizon)
                     {
                        browser .getNotification () ._string = locale_gettext("Straighten Horizon") + ": " + locale_gettext("on");

                        const activeViewpoint = browser .getActiveViewpoint ();

                        if (activeViewpoint)
                           activeViewpoint .straighten (browser .getActiveLayer (), true);
                     }
                     else
                     {
                        browser .getNotification () ._string = locale_gettext("Straighten Horizon") + ": " + locale_gettext("off");
                     }
                  }
                  .bind (this),
               },
            },
            "display-rubberband": {
               name: locale_gettext("Display Rubberband"),
               type: "checkbox",
               selected: browser .getBrowserOption ("Rubberband"),
               events: {
                  click: function (event)
                  {
                     const rubberband = $(event .target) .is (":checked");

                     browser .setBrowserOption ("Rubberband", rubberband);

                     if (rubberband)
                        browser .getNotification () ._string = locale_gettext("Rubberband") + ": " + locale_gettext("on");
                     else
                        browser .getNotification () ._string = locale_gettext("Rubberband") + ": " + locale_gettext("off");
                  }
                  .bind (this),
               },
            },
            "separator1": "--------",
            "primitive-quality": {
               name: locale_gettext("Primitive Quality"),
               className: "context-menu-icon x_ite-private-icon-primitive-quality",
               items: {
                  "high": {
                     name: locale_gettext("High"),
                     type: "radio",
                     radio: "primitive-quality",
                     selected: browser .getBrowserOption ("PrimitiveQuality") === "HIGH",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("PrimitiveQuality", "HIGH");
                           browser .getNotification () ._string = locale_gettext("Primitive Quality") + ": " + locale_gettext("high");
                        }
                        .bind (this),
                     },
                  },
                  "medium": {
                     name: locale_gettext("Medium"),
                     type: "radio",
                     radio: "primitive-quality",
                     selected: browser .getBrowserOption ("PrimitiveQuality") === "MEDIUM",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("PrimitiveQuality", "MEDIUM");
                           browser .getNotification () ._string = locale_gettext("Primitive Quality") + ": " + locale_gettext("medium");
                        }
                        .bind (this),
                     },
                  },
                  "low": {
                     name: locale_gettext("Low"),
                     type: "radio",
                     radio: "primitive-quality",
                     selected: browser .getBrowserOption ("PrimitiveQuality") === "LOW",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("PrimitiveQuality", "LOW");
                           browser .getNotification () ._string = locale_gettext("Primitive Quality") + ": " + locale_gettext("low");
                        }
                        .bind (this),
                     },
                  },
               },
            },
            "texture-quality": {
               name: locale_gettext("Texture Quality"),
               className: "context-menu-icon x_ite-private-icon-texture-quality",
               items: {
                  "high": {
                     name: locale_gettext("High"),
                     type: "radio",
                     radio: "texture-quality",
                     selected: browser .getBrowserOption ("TextureQuality") === "HIGH",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("TextureQuality", "HIGH");
                           browser .getNotification () ._string = locale_gettext("Texture Quality") + ": " + locale_gettext("high");
                        }
                        .bind (this),
                     },
                  },
                  "medium": {
                     name: locale_gettext("Medium"),
                     type: "radio",
                     radio: "texture-quality",
                     selected: browser .getBrowserOption ("TextureQuality") === "MEDIUM",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("TextureQuality", "MEDIUM");
                           browser .getNotification () ._string = locale_gettext("Texture Quality") + ": " + locale_gettext("medium");
                        }
                        .bind (this),
                     },
                  },
                  "low": {
                     name: locale_gettext("Low"),
                     type: "radio",
                     radio: "texture-quality",
                     selected: browser .getBrowserOption ("TextureQuality") === "LOW",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("TextureQuality", "LOW");
                           browser .getNotification () ._string = locale_gettext("Texture Quality") + ": " + locale_gettext("low");
                        }
                        .bind (this),
                     },
                  },
               },
            },
            "shading": {
               name: locale_gettext("Shading"),
               className: "context-menu-icon x_ite-private-icon-shading",
               items: {
                  "point": {
                     name: locale_gettext("Point"),
                     type: "radio",
                     radio: "shading",
                     selected: browser .getBrowserOption ("Shading") === "POINT",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("Shading", "POINT");
                           browser .getNotification () ._string = locale_gettext("Shading") + ": " + locale_gettext("Point");
                        }
                        .bind (this),
                     },
                  },
                  "wireframe": {
                     name: locale_gettext("Wireframe"),
                     type: "radio",
                     radio: "shading",
                     selected: browser .getBrowserOption ("Shading") === "WIREFRAME",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("Shading", "WIREFRAME");
                           browser .getNotification () ._string = locale_gettext("Shading") + ": " + locale_gettext("Wireframe");
                        }
                        .bind (this),
                     },
                  },
                  "flat": {
                     name: locale_gettext("Flat"),
                     type: "radio",
                     radio: "shading",
                     selected: browser .getBrowserOption ("Shading") === "FLAT",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("Shading", "FLAT");
                           browser .getNotification () ._string = locale_gettext("Shading") + ": " + locale_gettext("Flat");
                        }
                        .bind (this),
                     },
                  },
                  "gouraud": {
                     name: locale_gettext("Gouraud"),
                     type: "radio",
                     radio: "shading",
                     selected: browser .getBrowserOption ("Shading") === "GOURAUD",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("Shading", "GOURAUD");
                           browser .getNotification () ._string = locale_gettext("Shading") + ": " + locale_gettext("Gouraud");
                        }
                        .bind (this),
                     },
                  },
                  "phong": {
                     name: locale_gettext("Phong"),
                     type: "radio",
                     radio: "shading",
                     selected: browser .getBrowserOption ("Shading") === "PHONG",
                     events: {
                        click: function ()
                        {
                           browser .setBrowserOption ("Shading", "PHONG");
                           browser .getNotification () ._string = locale_gettext("Shading") + ": " + locale_gettext("Phong");
                        }
                        .bind (this),
                     },
                  },
               },
            },
            "separator2": "--------",
            "browser-timings": {
               name: locale_gettext("Browser Timings"),
               type: "checkbox",
               selected: browser .getBrowserOption ("Timings"),
               events: {
                  click: function (event)
                  {
                     browser .setBrowserOption ("Timings", $(event .target) .is (":checked"));
                     browser .getSurface () .focus ();
                  }
                  .bind (this),
               },
            },
            "fullscreen": {
               name: fullscreen ? locale_gettext("Leave Fullscreen") : locale_gettext("Fullscreen"),
               className: "context-menu-icon " + (fullscreen
                  ? "x_ite-private-icon-leave-fullscreen"
                  : "x_ite-private-icon-enter-fullscreen"),
               callback: function ()
               {
                  browser .getElement () .toggleFullScreen ();
               }
               .bind (this),
            },
            "separator3": "--------",
         },
      };

      Object .assign (menu .items, this .createUserMenu ());

      Object .assign (menu .items, {
         "separator4": "--------",
         "world-info": {
            name: locale_gettext("Show World Info"),
            className: "context-menu-icon x_ite-private-icon-world-info",
            callback: function ()
            {
               const
                  priv      = browser .getShadow () .find (".x_ite-private-browser"),
                  overlay   = $("<div></div>") .addClass ("x_ite-private-world-info-overlay") .appendTo (priv),
                  div       = $("<div></div>") .addClass ("x_ite-private-world-info") .appendTo (overlay),
                  worldInfo = browser .getExecutionContext () .getWorldInfos () [0],
                  title     = worldInfo .title,
                  info      = worldInfo .info;

               browser .getShadow () .find (".x_ite-private-world-info") .remove ();

               $("<div></div>") .addClass ("x_ite-private-world-info-top") .text ("World Info") .appendTo (div);

               if (title .length)
               {
                  $("<div></div>") .addClass ("x_ite-private-world-info-title") .text (title) .appendTo (div);
               }

               for (const line of info)
               {
                  $("<div></div>") .addClass ("x_ite-private-world-info-info") .text (line) .appendTo (div);
               }

               div .find ("a") .on ("click", function (event) { event .stopPropagation (); });

               // Open external link in new tab.
               div .find ("a[href^=http]") .each (function ()
               {
                  if (this .href .indexOf (location .hostname) !== -1)
                     return;

                  $(this) .attr ("target", "_blank");
               });

               overlay .on ("click", function () { overlay .remove (); });
            },
         },
         "about": {
            name: locale_gettext("About X_ITE"),
            className: "context-menu-icon x_ite-private-icon-help-about",
            callback: function ()
            {
               window .open (browser .getProviderUrl ());
            },
         },
      });

      if ($.isEmptyObject (menu .items .viewpoints .items))
         delete menu .items ["viewpoints"];

      if (Object .keys (menu .items ["available-viewers"] .items) .length < 2)
      {
         delete menu .items ["available-viewers"];
      }

      if (! browser .getCurrentViewer () .match (/^(?:EXAMINE|FLY)$/))
      {
         delete menu .items ["straighten-horizon"];
      }

      if (! browser .getDebug ())
      {
         delete menu .items ["shading"];
      }

      const worldInfo = browser .getExecutionContext () .getWorldInfos () [0];

      if (! worldInfo || (worldInfo .title .length === 0 && worldInfo .info .length === 0))
      {
         delete menu .items ["world-info"];
      }

      return menu;
   },
   getViewpoints: function ()
   {
      const
         browser     = this .getBrowser (),
         activeLayer = browser .getActiveLayer ();

      if (! activeLayer)
         return { };

      const
         enableInlineViewpoints = browser .getBrowserOption ("EnableInlineViewpoints"),
         currentScene           = browser .currentScene,
         viewpoints             = activeLayer .getViewpoints () .get (),
         currentViewpoint       = activeLayer .getViewpoint (),
         menu                   = { };

      for (const viewpoint of viewpoints)
      {
         const description = viewpoint ._description .getValue ();

         if (description === "")
            continue;

         if (! enableInlineViewpoints && viewpoint .getScene () !== currentScene)
            continue;

         const item = {
            name: description,
            callback: function (viewpoint)
            {
               browser .bindViewpoint (browser .getActiveLayer (), viewpoint);
               browser .getSurface () .focus ();
            }
            .bind (this, viewpoint),
         };

         if (viewpoint === currentViewpoint)
            item .className = "context-menu-selected";

         menu ["Viewpoint" + viewpoint .getId ()] = item;
      }

      return menu;
   },
   getAvailableViewers: function ()
   {
      const
         browser          = this .getBrowser (),
         currentViewer    = browser ._viewer .getValue (),
         availableViewers = browser ._availableViewers,
         menu             = { };

      for (const viewer of availableViewers)
      {
         menu [viewer] = {
            name: locale_gettext(this .getViewerName (viewer)),
            className: "context-menu-icon x_ite-private-icon-" + viewer .toLowerCase () + "-viewer",
            callback: function (viewer)
            {
               browser ._viewer = viewer;
               browser .getNotification () ._string = locale_gettext(this .getViewerName (viewer));
               browser .getSurface () .focus ();
            }
            .bind (this, viewer),
         };

         if (viewer === currentViewer)
            menu [viewer] .className += " context-menu-selected";
      }

      return menu;
   },
   getViewerName: function (viewer)
   {
      switch (viewer)
      {
         case "EXAMINE":
            return locale_gettext("Examine Viewer");
         case "WALK":
            return locale_gettext("Walk Viewer");
         case "FLY":
            return locale_gettext("Fly Viewer");
         case "PLANE":
            return locale_gettext("Plane Viewer");
         case "LOOKAT":
            return locale_gettext("Look At Viewer");
         case "NONE":
            return locale_gettext("None Viewer");
      }
   },
   init: function (options)
   {
      this .show = this .createRoot .bind (this, options);

      options .element .on ("contextmenu", this .show);
   },
   show: function (event)
   { },
   hide: function (event)
   { },
   createRoot: function (options, event)
   {
      const
         menu  = options .build (event),
         level = 1;

      if (! menu) return;

      // Layer

      const layer = $("<div></div>")
         .addClass ("context-menu-layer")
         .addClass (menu .className)
         .appendTo (options .appendTo);

      const hide = this .hide = function ()
      {
         delete this .hide;

         layer .remove ();

         ul [options .animation .hide] (options .animation .duration, function ()
         {
            ul .remove ();

            if (options .events && typeof options .events .hide === "function")
               options .events .hide ();
         });

         return false;
      }
      .bind (this);

      // Menu

      const
         x = event .pageX - $(document) .scrollLeft (),
         y = event .pageY - $(document) .scrollTop ();

      const ul = $("<ul></ul>")
         .hide ()
         .addClass ("context-menu-list")
         .addClass (menu .className)
         .addClass ("context-menu-root")
         .css ({ "left": x, "top": y })
         .appendTo (options .appendTo);

      for (const k in menu .items)
         ul .append (this .createItem (menu .items [k], "context-menu-root", k, level + 1, hide));

      ul [options .animation .show] (options .animation .duration);

      // Reposition menu if to right or to low.

      if (ul .offset () .left - $(document) .scrollLeft () + ul .outerWidth () > $(window) .width ())
         ul .offset ({ "left":  $(document) .scrollLeft () + Math .max (0, $(window) .width () - ul .outerWidth ()) });

      if (ul .offset () .top - $(document) .scrollTop () + ul .outerHeight () > $(window) .height ())
         ul .offset ({ "top": $(document) .scrollTop () + Math .max (0, $(window) .height () - ul .outerHeight ()) });

      // Display submenus on the left or right side.
      // If the submenu is higher than vh, add scrollbars.

      ul .find ("ul") .each (function (i, e)
      {
         e = $(e);

         const
            width    = e .outerWidth () + ul .outerWidth (),
            position = ul .offset () .left - $(document) .scrollLeft () + width > $(window) .width () ? "right" : "left";

         e .css ("width", e .outerWidth ());
         e .css (position, e .parent () .closest ("ul") .width ());

         if (e .outerHeight () >= $(window) .height ())
            e .css ({ "max-height": "100vh", "overflow-y": "scroll" });
      });

      // If the submenu is higher than vh, reposition it.

      ul .find ("li") .on ("mouseenter touchstart", function (event)
      {
         event .stopImmediatePropagation ();

         const
            t = $(event .target) .closest ("li"),
            e = t .children ("ul");

         if (! e .length)
            return;

         e .css ("top", "");

         const bottom = e .offset () .top + e .outerHeight () - $(window) .scrollTop () - $(window) .height ();

         if (bottom > 0)
            e .offset ({ "top": e .offset () .top - bottom });
      });

      // Layer

      layer .on ("click contextmenu", hide);
      ul .on ("contextmenu", hide);

      // Show

      if (options .events && typeof options .events .show === "function")
         options .events .show (ul);

      return false;
   },
   createItem: function (item, parent, key, level, hide)
   {
      const li = $("<li></li>") .addClass ("context-menu-item");

      switch (typeof item)
      {
         case "string":
         {
            if (item .match (/^-+$/))
               li .addClass (["context-menu-separator", "context-menu-not-selectable"]);

            break;
         }
         case "object":
         {
            if (item .className)
               li .addClass (item .className);

            switch (item .type)
            {
               case "radio":
               case "checkbox":
               {
                  const
                     label = $("<label></label>") .appendTo (li),
                     input = $("<input></input>") .appendTo (label);

                  input
                     .attr ("type", item .type)
                     .attr ("name", "context-menu-input-" + (item .radio || parent));

                  $("<span></span>") .text (item .name) .appendTo (label);

                  if (item .selected)
                     input .attr ("checked", "checked");

                  for (const k in item .events)
                  {
                     if (typeof item .events [k] === "function")
                        input .on (k, item .events [k]);
                  }

                  li .addClass ("context-menu-input");

                  break;
               }
               default:
               {
                  if (item .name)
                     $("<span></span>") .text (item .name) .appendTo (li);

                  if (typeof item .callback === "function")
                     li .on ("click", item .callback) .on ("click", hide);

                  break;
               }
            }

            break;
         }
      }

      if (typeof item .items === "object" && level < 3)
      {
         const ul = $("<ul></ul>")
            .addClass ("context-menu-list")
            .css ({ "z-index": level })
            .appendTo (li);

         for (const k in item .items)
            ul .append (this .createItem (item .items [k], key, k, level + 1, hide));

         li .addClass ("context-menu-submenu");
      }

      return li;
   },
});

/* harmony default export */ const Core_ContextMenu = (ContextMenu);

;// CONCATENATED MODULE: ./src/x_ite/Parser/HTMLSupport.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of the X_ITE Project.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains "non-military use only" components.
 *
 * Copyright 2016 Andreas Plesch.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


// Maps are set when component is registered.

const
   nodeTypeNames = new Map (), // (TYPENAME -> TypeName)
   fieldNames    = new Map (); // (fieldname -> fieldName)

const HTMLSupport =
{
   addNodeTypeName: function (typeName)
   {
      nodeTypeNames .set (typeName,                 typeName);
      nodeTypeNames .set (typeName .toUpperCase (), typeName);
   },
   getNodeTypeName: function (typeName)
   {
      return nodeTypeNames .get (typeName);
   },
   addFieldName: function (name)
   {
      fieldNames .set (name,                 name);
      fieldNames .set (name .toLowerCase (), name);
   },
   getFieldName: function (name)
   {
      return fieldNames .get (name);
   },
};

/* harmony default export */ const Parser_HTMLSupport = (HTMLSupport);

;// CONCATENATED MODULE: ./src/x_ite/Configuration/SupportedNodes.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   types         = new Map (),
   abstractTypes = new Map ();

let nodeType = Base_X3DConstants.X3DBaseNode;

function SupportedNodes () { }

SupportedNodes .prototype =
{
   addType: function (typeName, Type)
   {
      Base_X3DConstants [typeName] = ++ nodeType; // Start with 1, as X3DBaseNode is 0.

      types .set (typeName, Type);

      Parser_HTMLSupport.addNodeTypeName (typeName);

      // HTMLSupport

      for (const fieldDefinition of Type .prototype [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")])
      {
         const
            name       = fieldDefinition .name,
            accessType = fieldDefinition .accessType;

         if (accessType & Base_X3DConstants.initializeOnly)
            Parser_HTMLSupport.addFieldName (name)
      }
   },
   getType: function (typeName)
   {
      return types .get (typeName);
   },
   getTypes ()
   {
      return Array .from (types .values ());
   },
   addAbstractType: function (typeName, Type)
   {
      Base_X3DConstants [typeName] = ++ nodeType;

      abstractTypes .set (typeName, Type);
   },
   getAbstractType: function (typeName)
   {
      return abstractTypes .get (typeName);
   },
   getAbstractTypes ()
   {
      return Array .from (abstractTypes .values ());
   },
};

for (const key of Reflect .ownKeys (SupportedNodes .prototype))
   Object .defineProperty (SupportedNodes .prototype, key, { enumerable: false });

/* harmony default export */ const Configuration_SupportedNodes = (new SupportedNodes ());

;// CONCATENATED MODULE: ./src/x_ite/Execution/NamedNodesArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function NamedNodesArray (array)
{
   return Base_X3DInfoArray.call (this, array);
}

NamedNodesArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: NamedNodesArray,
   getTypeName: function ()
   {
      return "NamedNodesArray";
   },
});

for (const key of Reflect .ownKeys (NamedNodesArray .prototype))
   Object .defineProperty (NamedNodesArray .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_NamedNodesArray = (NamedNodesArray);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DNode (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DNode);
}

X3DNode .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: X3DNode,
   copy: function (instance)
   {
      if (!instance || instance .getType () .includes (Base_X3DConstants.X3DExecutionContext))
      {
         return Base_X3DBaseNode.prototype.copy.call (this, instance);
      }
      else
      {
         const executionContext = instance .getBody ();

         // First try to get a named node with the node's name.

         if (this .getName () .length)
         {
            const namedNode = executionContext .getNamedNodes () .get (this .getName ());

            if (namedNode)
               return namedNode;
         }

         // Create copy.

         const copy = this .create (executionContext);

         if (this .getNeedsName ())
            this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (), this);

         if (this .getName () .length)
            executionContext .updateNamedNode (this .getName (), copy);

         // Default fields

         for (const sourceField of this .getPredefinedFields ())
         {
            try
            {
               const destinationField = copy .getField (sourceField .getName ());

               if (sourceField .hasReferences ())
               {
                  // IS relationship

                  for (const originalReference of sourceField .getReferences ())
                  {
                     try
                     {
                        destinationField .addReference (instance .getField (originalReference .getName ()));
                     }
                     catch (error)
                     {
                        console .error (error .message);
                     }
                  }
               }
               else
               {
                  if (sourceField .getAccessType () & Base_X3DConstants.initializeOnly)
                  {
                     switch (sourceField .getType ())
                     {
                        case Base_X3DConstants.SFNode:
                        case Base_X3DConstants.MFNode:
                           destinationField .assign (sourceField .copy (instance));
                           break;
                        default:
                           destinationField .assign (sourceField);
                           break;
                     }
                  }
               }

               destinationField .setModificationTime (sourceField .getModificationTime ());
            }
            catch (error)
            {
               console .log (error .message);
            }
         }

         // User-defined fields

         for (const sourceField of this .getUserDefinedFields ())
         {
            const destinationField = sourceField .copy (instance);

            copy .addUserDefinedField (sourceField .getAccessType (),
                                       sourceField .getName (),
                                       destinationField);

            if (sourceField .hasReferences ())
            {
               // IS relationship

               for (const originalReference of sourceField .getReferences ())
               {
                  try
                  {
                     destinationField .addReference (instance .getField (originalReference .getName ()));
                  }
                  catch (error)
                  {
                     console .error ("No reference '" + originalReference .getName () + "' inside execution context " + instance .getTypeName () + " '" + instance .getName () + "'.");
                  }
               }
            }

            destinationField .setModificationTime (sourceField .getModificationTime ());
         }

         copy .setup ();

         return copy;
      }
   },
   getDisplayName: (function ()
   {
      const _TrailingNumber = /_\d+$/;

      return function ()
      {
         return this .getName () .replace (_TrailingNumber, "");
      };
   })(),
   getNeedsName: function ()
   {
      if (this .getName () .length)
         return false;

      if (this .getCloneCount () > 1)
         return true;

      if (this .hasRoutes ())
         return true;

      const executionContext = this .getExecutionContext ()

      for (const importedNode of executionContext .getImportedNodes ())
      {
         if (importedNode .getInlineNode () === this)
            return true;
      }

      if (executionContext .isScene ())
      {
         for (const exportedNode of executionContext .getExportedNodes ())
         {
            if (exportedNode .getLocalNode () === this)
               return true;
         }
      }

      return false;
   },
   getFieldsAreEnumerable: function ()
   {
      return true;
   },
   traverse: function () { },
   toStream: function (stream)
   {
      stream .string += this .getTypeName () + " { }";
   },
   toVRMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      generator .EnterScope ();

      const name = generator .Name (this);

      if (name .length)
      {
         if (generator .ExistsNode (this))
         {
            stream .string += "USE";
            stream .string += " ";
            stream .string += name;

            generator .LeaveScope ();
            return;
         }
      }

      if (name .length)
      {
         generator .AddNode (this);

         stream .string += "DEF";
         stream .string += " ";
         stream .string += name;
         stream .string += " ";
      }

      stream .string += this .getTypeName ();
      stream .string += " ";
      stream .string += "{";

      const
         fields            = this .getChangedFields (),
         userDefinedFields = this .getUserDefinedFields ();

      let
         fieldTypeLength  = 0,
         accessTypeLength = 0;

      if (this .canUserDefinedFields ())
      {
         for (const field of userDefinedFields)
         {
            fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
            accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
         }

         if (userDefinedFields .length)
         {
            stream .string += "\n";
            generator .IncIndent ();

            for (const field of userDefinedFields)
            {
               this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);

               stream .string += "\n";
            }

            generator .DecIndent ();

            if (fields .length !== 0)
               stream .string += "\n";
         }
      }

      if (fields .length === 0)
      {
         if (userDefinedFields .length)
            stream .string += generator .Indent ();
         else
            stream .string += " ";
      }
      else
      {
         if (userDefinedFields .length === 0)
            stream .string += "\n";

         generator .IncIndent ();

         fields .forEach (function (field)
         {
            this .toVRMLStreamField (stream, field, fieldTypeLength, accessTypeLength);

            stream .string += "\n";
         },
         this);

         generator .DecIndent ();
         stream .string += generator .Indent ();
      }

      stream .string += "}";

      generator .LeaveScope ();
   },
   toVRMLStreamField: function (stream, field, fieldTypeLength, accessTypeLength)
   {
      const
         generator  = InputOutput_Generator.Get (stream),
         sharedNode = generator .IsSharedNode (this);

      if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
      {
         if (field .isInitializable ())
         {
            stream .string += generator .Indent ();
            stream .string += field .getName ();
            stream .string += " ";

            field .toVRMLStream (stream);
         }
      }
      else
      {
         let
            index                  = 0,
            initializableReference = false;

         field .getReferences () .forEach (function (reference)
         {
            initializableReference = initializableReference || reference .isInitializable ();

            // Output build in reference field

            stream .string += generator .Indent ();
            stream .string += field .getName ();
            stream .string += " ";
            stream .string += "IS";
            stream .string += " ";
            stream .string += reference .getName ();

            ++ index;

            if (index !== field .getReferences () .size)
               stream .string += "\n";
         });

         if (field .getAccessType () === Base_X3DConstants.inputOutput && !initializableReference && !this .isDefaultValue (field))
         {
            // Output build in field

            stream .string += "\n";
            stream .string += generator .Indent ();
            stream .string += field .getName ();
            stream .string += " ";

            field .toVRMLStream (stream);
         }
      }
   },
   toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
   {
      const
         generator  = InputOutput_Generator.Get (stream),
         sharedNode = generator .IsSharedNode (this);

      if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
      {
         stream .string += generator .Indent ();
         stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
         stream .string += " ";
         stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
         stream .string += " ";
         stream .string += field .getName ();

         if (field .isInitializable ())
         {
            stream .string += " ";

            field .toVRMLStream (stream);
         }
      }
      else
      {
         let
            index                  = 0,
            initializableReference = false;

         field .getReferences () .forEach (function (reference)
         {
            initializableReference = initializableReference || reference .isInitializable ();

            // Output user defined reference field

            stream .string += generator .Indent ();
            stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
            stream .string += " ";
            stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
            stream .string += " ";
            stream .string += field .getName ();
            stream .string += " ";
            stream .string += "IS";
            stream .string += " ";
            stream .string += reference .getName ();

            ++ index;

            if (index !== field .getReferences () .size)
               stream .string += "\n";
         });

         if (field .getAccessType () === Base_X3DConstants.inputOutput && !initializableReference && !field .isDefaultValue ())
         {
            stream .string += "\n";
            stream .string += generator .Indent ();
            stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
            stream .string += " ";
            stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
            stream .string += " ";
            stream .string += field .getName ();

            if (field .isInitializable ())
            {
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
      }
   },
   toXMLStream: function (stream)
   {
      const
         generator  = InputOutput_Generator.Get (stream),
         sharedNode = generator .IsSharedNode (this);

      generator .EnterScope ();

      const name = generator .Name (this);

      if (name .length)
      {
         if (generator .ExistsNode (this))
         {
            stream .string += generator .Indent ();
            stream .string += "<";
            stream .string += this .getTypeName ();
            stream .string += " ";
            stream .string += "USE='";
            stream .string += generator .XMLEncode (name);
            stream .string += "'";

            const containerField = generator .ContainerField ();

            if (containerField)
            {
               if (containerField .getName () !== this .getContainerField ())
               {
                  stream .string += " ";
                  stream .string += "containerField='";
                  stream .string += generator .XMLEncode (containerField .getName ());
                  stream .string += "'";
               }
            }

            stream .string += "/>";

            generator .LeaveScope ();
            return;
         }
      }

      stream .string += generator .Indent ();
      stream .string += "<";
      stream .string += this .getTypeName ();

      if (name .length)
      {
         generator .AddNode (this);

         stream .string += " ";
         stream .string += "DEF='";
         stream .string += generator .XMLEncode (name);
         stream .string += "'";
      }

      const containerField = generator .ContainerField ();

      if (containerField)
      {
         if (containerField .getName () !== this .getContainerField ())
         {
            stream .string += " ";
            stream .string += "containerField='";
            stream .string += generator .XMLEncode (containerField .getName ());
            stream .string += "'";
         }
      }

      const
         fields            = this .getChangedFields (),
         userDefinedFields = this .getUserDefinedFields ();

      const
         references = [ ],
         childNodes = [ ];

      let cdata = this .getSourceText ();

      if (cdata && cdata .length === 0)
         cdata = null;

      generator .IncIndent ();
      generator .IncIndent ();

      for (const field of fields)
      {
         // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
         // for this field.

         let mustOutputValue = false;

         if (generator .ExecutionContext ())
         {
            if (field .getAccessType () === Base_X3DConstants.inputOutput && field .getReferences () .size !== 0)
            {
               let initializableReference = false;

               field .getReferences () .forEach (function (fieldReference)
               {
                  initializableReference = initializableReference || fieldReference .isInitializable ();
               });

               if (!initializableReference)
                  mustOutputValue = !this .isDefaultValue (field);
            }
         }

         // If we have no execution context we are not in a proto and must not generate IS references the same is true
         // if the node is a shared node as the node does not belong to the execution context.

         if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode || mustOutputValue)
         {
            if (mustOutputValue)
               references .push (field);

            if (field .isInitializable ())
            {
               switch (field .getType ())
               {
                  case Base_X3DConstants.SFNode:
                  case Base_X3DConstants.MFNode:
                  {
                     childNodes .push (field);
                     break;
                  }
                  default:
                  {
                     if (field === cdata)
                        break;

                     stream .string += "\n";
                     stream .string += generator .Indent ();
                     stream .string += field .getName ();
                     stream .string += "='";

                     field .toXMLStream (stream);

                     stream .string += "'";
                     break;
                  }
               }
            }
         }
         else
         {
            references .push (field);
         }
      }

      generator .DecIndent ();
      generator .DecIndent ();

      if ((!this .canUserDefinedFields () || !userDefinedFields .length) && (!references .length || sharedNode) && !childNodes .length && !cdata)
      {
         stream .string += "/>";
      }
      else
      {
         stream .string += ">\n";

         generator .IncIndent ();

         if (this .canUserDefinedFields ())
         {
            for (const field of userDefinedFields)
            {
               stream .string += generator .Indent ();
               stream .string += "<field";
               stream .string += " ";
               stream .string += "accessType='";
               stream .string += generator .AccessType (field .getAccessType ());
               stream .string += "'";
               stream .string += " ";
               stream .string += "type='";
               stream .string += field .getTypeName ();
               stream .string += "'";
               stream .string += " ";
               stream .string += "name='";
               stream .string += generator .XMLEncode (field .getName ());
               stream .string += "'";

               // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
               // for this field.

               let mustOutputValue = false;

               if (field .getAccessType () === Base_X3DConstants.inputOutput && field .getReferences () .size !== 0)
               {
                  let initializableReference = false;

                  field .getReferences () .forEach (function (fieldReference)
                  {
                     initializableReference = initializableReference || fieldReference .isInitializable ();
                  });

                  if (!initializableReference)
                     mustOutputValue = true;
               }

               if ((field .getReferences () .size === 0 || !generator .ExecutionContext ()) || sharedNode || mustOutputValue)
               {
                  if (mustOutputValue && generator .ExecutionContext ())
                     references .push (field);

                  if (!field .isInitializable () || field .isDefaultValue ())
                  {
                     stream .string += "/>\n";
                  }
                  else
                  {
                     // Output value

                     switch (field .getType ())
                     {
                        case Base_X3DConstants.SFNode:
                        case Base_X3DConstants.MFNode:
                        {
                           generator .PushContainerField (field);

                           stream .string += ">\n";

                           generator .IncIndent ();

                           field .toXMLStream (stream);

                           stream .string += "\n";

                           generator .DecIndent ();

                           stream .string += generator .Indent ();
                           stream .string += "</field>\n";

                           generator .PopContainerField ();
                           break;
                        }
                        default:
                        {
                           stream .string += " ";
                           stream .string += "value='";

                           field .toXMLStream (stream);

                           stream .string += "'";
                           stream .string += "/>\n";
                           break;
                        }
                     }
                  }
               }
               else
               {
                  if (generator .ExecutionContext ())
                     references .push (field);

                  stream .string += "/>\n";
               }
            }
         }

         if (references .length && !sharedNode)
         {
            stream .string += generator .Indent ();
            stream .string += "<IS>";
            stream .string += "\n";

            generator .IncIndent ();

            for (const field of references)
            {
               const protoFields = field .getReferences ();

               protoFields .forEach (function (protoField)
               {
                  stream .string += generator .Indent ();
                  stream .string += "<connect";
                  stream .string += " ";
                  stream .string += "nodeField='";
                  stream .string += generator .XMLEncode (field .getName ());
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "protoField='";
                  stream .string += generator .XMLEncode (protoField .getName ());
                  stream .string += "'";
                  stream .string += "/>\n";
               });
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</IS>\n";
         }

         for (const field of childNodes)
         {
            generator .PushContainerField (field);

            field .toXMLStream (stream);

            stream .string += "\n";

            generator .PopContainerField ();
         }

         if (cdata)
         {
            for (const value of cdata)
            {
               stream .string += "<![CDATA[";
               stream .string += generator .escapeCDATA (value);
               stream .string += "]]>\n";
            }
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</";
         stream .string += this .getTypeName ();
         stream .string += ">";
      }

      generator .LeaveScope ();
   },
   dispose: function ()
   {
      const executionContext = this .getExecutionContext ();

      // Remove named node if any.

      if (this .getName ())
         executionContext .removeNamedNode (this .getName ())

      // Remove imported node if any.

      if (!executionContext .isMainScene ())
      {
         const parentContext = executionContext .getExecutionContext ();

         for (const importedNode of parentContext .getImportedNodes ())
         {
            try
            {
               if (importedNode .getExportedNode () === this)
                  parentContext .removeImportedNode (importedNode .getImportedName ());
            }
            catch (error)
            {
               //console .error (error);
            }
         }
      }

      // Remove exported node if any.

      if (executionContext .isScene ())
      {
         for (const exportedNode of executionContext .getExportedNodes ())
         {
            if (exportedNode .getLocalNode () === this)
               executionContext .removeExportedNode (exportedNode .getExportedName ());
         }
      }

      // Remove routes from and to node if any, and dispose values of fields.

      for (const field of this .getFields ())
         field .dispose ();

      // Remove node from entire scene graph.

      for (const firstParent of new Set (this .getParents ()))
      {
         if (firstParent instanceof x_ite_Fields.SFNode)
         {
            for (const secondParent of new Set (firstParent .getParents ()))
            {
               if (secondParent instanceof x_ite_Fields.MFNode)
               {
                  const length = secondParent .length;

                  secondParent .erase (secondParent .remove (0, length, firstParent), length);
               }
            }

            firstParent .setValue (null);
         }
      }

      // Call super.dispose, where fields get disposed.

      Base_X3DBaseNode.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Core_X3DNode = (X3DNode);

;// CONCATENATED MODULE: ./src/x_ite/Execution/X3DImportedNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _inlineNode   = Symbol (),
   _exportedName = Symbol (),
   _importedName = Symbol (),
   _routes       = Symbol ();

function X3DImportedNode (executionContext, inlineNode, exportedName, importedName)
{
   Core_X3DNode.call (this, executionContext);

   this [_inlineNode]   = inlineNode;
   this [_exportedName] = exportedName;
   this [_importedName] = importedName;
   this [_routes]       = new Set ();

   this [_inlineNode] ._loadState .addInterest ("set_loadState__", this);
}

X3DImportedNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DImportedNode,
   getInlineNode: function ()
   {
      return this [_inlineNode];
   },
   getExportedName: function ()
   {
      return this [_exportedName];
   },
   getExportedNode: function ()
   {
      return this [_inlineNode] .getInternalScene () .getExportedNode (this [_exportedName]) .getValue ();
   },
   getImportedName: function ()
   {
      return this [_importedName];
   },
   addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
   {
      // Add route.

      const route = {
         sourceNode: sourceNode,
         sourceField: sourceField,
         destinationNode: destinationNode,
         destinationField: destinationField,
      };

      this [_routes] .add (route);

      // Try to resolve source or destination node routes.

      if (this [_inlineNode] .checkLoadState () === Base_X3DConstants.COMPLETE_STATE)
         this .resolveRoute (route);
   },
   resolveRoute: function (route)
   {
      try
      {
         const
            sourceField      = route .sourceField,
            destinationField = route .destinationField;

         let
            sourceNode      = route .sourceNode,
            destinationNode = route .destinationNode;

         if (route .real)
            route .real .dispose ();

         if (sourceNode instanceof X3DImportedNode)
            sourceNode = sourceNode .getExportedNode ();

         if (destinationNode instanceof X3DImportedNode)
            destinationNode = destinationNode .getExportedNode ();

         route .real = this .getExecutionContext () .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
      }
      catch (error)
      {
         console .error (error .message);
      }
   },
   deleteRoute: function (real)
   {
      for (const route of this [_routes])
      {
         if (route .real === real)
            this [_routes] .delete (route);
      }
   },
   deleteRoutes: function ()
   {
      for (const route of this [_routes])
      {
         const real = route .real

         if (real)
         {
            delete route .real;
            this .getExecutionContext () .deleteSimpleRoute (real);
         }
      }
   },
   set_loadState__: function ()
   {
      switch (this [_inlineNode] .checkLoadState ())
      {
         case Base_X3DConstants.NOT_STARTED_STATE:
         case Base_X3DConstants.FAILED_STATE:
         {
            this .deleteRoutes ();
            break;
         }
         case Base_X3DConstants.COMPLETE_STATE:
         {
            this .deleteRoutes ();

            for (const route of this [_routes])
               this .resolveRoute (route);

            break;
         }
      }
   },
   toVRMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      if (generator .ExistsNode (this .getInlineNode ()))
      {
         stream .string += generator .Indent ();
         stream .string += "IMPORT";
         stream .string += " ";
         stream .string += generator .Name (this .getInlineNode ());
         stream .string += ".";
         stream .string += this .getExportedName ();

         if (this .getImportedName () !== this .getExportedName ())
         {
            stream .string += " ";
            stream .string += "AS";
            stream .string += " ";
            stream .string += this .getImportedName ();
         }

         try
         {
            generator .AddRouteNode (this);
            generator .AddImportedNode (this .getExportedNode (), this .getImportedName ());
         }
         catch (error)
         {
            // Output unresolved routes.

            for (const route of this [_routes])
            {
               const
                  sourceNode       = route .sourceNode,
                  sourceField      = route .sourceField,
                  destinationNode  = route .destinationNode,
                  destinationField = route .destinationField;

               if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
               {
                  const sourceNodeName = sourceNode instanceof X3DImportedNode
                     ? sourceNode .getImportedName ()
                     : generator .Name (sourceNode);

                  const destinationNodeName = destinationNode instanceof X3DImportedNode
                     ? destinationNode .getImportedName ()
                     : generator .Name (destinationNode);

                  stream .string += "\n";
                  stream .string += "\n";
                  stream .string += generator .Indent ();
                  stream .string += "ROUTE";
                  stream .string += " ";
                  stream .string += sourceNodeName;
                  stream .string += ".";
                  stream .string += sourceField;
                  stream .string += " ";
                  stream .string += "TO";
                  stream .string += " ";
                  stream .string += destinationNodeName;
                  stream .string += ".";
                  stream .string += destinationField;
               }
            }
         }
      }
      else
         throw new Error ("X3DImportedNode.toXMLStream: Inline node does not exist.");
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      if (generator .ExistsNode (this .getInlineNode ()))
      {
         stream .string += generator .Indent ();
         stream .string += "<IMPORT";
         stream .string += " ";
         stream .string += "inlineDEF='";
         stream .string += generator .XMLEncode (generator .Name (this .getInlineNode ()));
         stream .string += "'";
         stream .string += " ";
         stream .string += "importedDEF='";
         stream .string += generator .XMLEncode (this .getExportedName ());
         stream .string += "'";

         if (this .getImportedName () !== this .getExportedName ())
         {
            stream .string += " ";
            stream .string += "AS='";
            stream .string += generator .XMLEncode (this .getImportedName ());
            stream .string += "'";
         }

         stream .string += "/>";

         try
         {
            generator .AddRouteNode (this);
            generator .AddImportedNode (this .getExportedNode (), this .getImportedName ());
         }
         catch (error)
         {
            // Output unresolved routes.

            for (const route of this [_routes])
            {
               const
                  sourceNode       = route .sourceNode,
                  sourceField      = route .sourceField,
                  destinationNode  = route .destinationNode,
                  destinationField = route .destinationField;

               if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
               {
                  const sourceNodeName = sourceNode instanceof X3DImportedNode
                     ? sourceNode .getImportedName ()
                     : generator .Name (sourceNode);

                  const destinationNodeName = destinationNode instanceof X3DImportedNode
                     ? destinationNode .getImportedName ()
                     : generator .Name (destinationNode);

                  stream .string += "\n";
                  stream .string += "\n";
                  stream .string += generator .Indent ();
                  stream .string += "<ROUTE";
                  stream .string += " ";
                  stream .string += "fromNode='";
                  stream .string += generator .XMLEncode (sourceNodeName);
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "fromField='";
                  stream .string += generator .XMLEncode (sourceField);
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "toNode='";
                  stream .string += generator .XMLEncode (destinationNodeName);
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "toField='";
                  stream .string += generator .XMLEncode (destinationField);
                  stream .string += "'";
                  stream .string += "/>";
               }
            }
         }
      }
      else
         throw new Error ("X3DImportedNode.toXMLStream: Inline node does not exist.");
   },
   dispose: function ()
   {
      this [_inlineNode] ._loadState .removeInterest ("set_loadState__", this);

      this .deleteRoutes ();

      Core_X3DNode.prototype.dispose.call (this);
   },
});

for (const key of Reflect .ownKeys (X3DImportedNode .prototype))
   Object .defineProperty (X3DImportedNode .prototype, key, { enumerable: false });

Object .defineProperty (X3DImportedNode .prototype, "inlineNode",
{
   get: function ()
   {
      return Fields_SFNodeCache.get (this [_inlineNode]);
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DImportedNode .prototype, "exportedName",
{
   get: function ()
   {
      return this [_exportedName];
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DImportedNode .prototype, "exportedNode",
{
   get: function ()
   {
      return this [_inlineNode] .getInternalScene () .getExportedNode (this [_exportedName]);
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DImportedNode .prototype, "importedName",
{
   get: function ()
   {
      return this [_importedName];
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Execution_X3DImportedNode = (X3DImportedNode);

;// CONCATENATED MODULE: ./src/x_ite/Execution/ImportedNodesArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function ImportedNodesArray (array)
{
   return Base_X3DInfoArray.call (this, array);
}

ImportedNodesArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: ImportedNodesArray,
   getTypeName: function ()
   {
      return "ImportedNodesArray";
   },
});

for (const key of Reflect .ownKeys (ImportedNodesArray .prototype))
   Object .defineProperty (ImportedNodesArray .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_ImportedNodesArray = (ImportedNodesArray);

;// CONCATENATED MODULE: ./src/x_ite/Prototype/ExternProtoDeclarationArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function ExternProtoDeclarationArray (values)
{
   return Base_X3DInfoArray.call (this, values);
}

ExternProtoDeclarationArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: ExternProtoDeclarationArray,
   getTypeName: function ()
   {
      return "ExternProtoDeclarationArray";
   },
});

for (const key of Reflect .ownKeys (ExternProtoDeclarationArray .prototype))
   Object .defineProperty (ExternProtoDeclarationArray .prototype, key, { enumerable: false });

/* harmony default export */ const Prototype_ExternProtoDeclarationArray = (ExternProtoDeclarationArray);

;// CONCATENATED MODULE: ./src/x_ite/Prototype/ProtoDeclarationArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function ProtoDeclarationArray (array)
{
   return Base_X3DInfoArray.call (this, array);
}

ProtoDeclarationArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: ProtoDeclarationArray,
   getTypeName: function ()
   {
      return "ProtoDeclarationArray";
   },
});

for (const key of Reflect .ownKeys (ProtoDeclarationArray .prototype))
   Object .defineProperty (ProtoDeclarationArray .prototype, key, { enumerable: false });

/* harmony default export */ const Prototype_ProtoDeclarationArray = (ProtoDeclarationArray);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DPrototypeInstance.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const
   _protoNode        = Symbol (),
   _protoFields      = Symbol (),
   X3DPrototypeInstance_fieldDefinitions = Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions"),
   _body             = Symbol ();

function X3DPrototypeInstance (executionContext, protoNode)
{
   this [_protoNode]        = protoNode;
   this [_protoFields]      = new Map (protoNode .getFields () .map (f => [f, f .getName ()]));
   this [X3DPrototypeInstance_fieldDefinitions] = protoNode .getFieldDefinitions ();
   this [_body]             = null;

   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DPrototypeInstance);
}

X3DPrototypeInstance .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DPrototypeInstance,
   create: function (executionContext)
   {
      return new X3DPrototypeInstance (executionContext, this [_protoNode]);
   },
   getTypeName: function ()
   {
      return this [_protoNode] .getName ();
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);

      this .setProtoNode (this [_protoNode]);
   },
   construct: function ()
   {
      if (this [_body])
         this [_body] .dispose ();

      const proto = this [_protoNode] .getProtoDeclaration ();

      if (! proto)
      {
         this [_body] = new Execution_X3DExecutionContext (this .getExecutionContext ());
         this [_body] .setOuterNode (this);
         this [_body] .setup ();

         if (this .isInitialized ())
            Base_X3DChildObject.prototype.addEvent.call (this);

         return;
      }

      // If there is a proto the externproto is completely loaded.

      if (this [_protoNode] .isExternProto)
      {
         for (const protoField of proto .getUserDefinedFields ())
         {
            try
            {
               const field = this .getField (protoField .getName ());

               // Continue if something is wrong.
               if (field .getAccessType () !== protoField .getAccessType ())
                  continue;

               // Continue if something is wrong.
               if (field .getType () !== protoField .getType ())
                  continue;

               // Continue if field is eventIn or eventOut.
               if (! field .isInitializable ())
                  continue;

               // Is set during parse.
               if (field .getModificationTime ())
                  continue;

               // Has IS references.
               if (field .hasReferences ())
                  continue;

               if (field .equals (protoField))
                  continue;

               // If default value of protoField is different from field, thus update default value for field.
               field .assign (protoField);
            }
            catch (error)
            {
               // Definition exists in proto but does not exist in extern proto.
               this .addField (proto .getFieldDefinitions () .get (protoField .getName ()));
            }
         }
      }

      // Create execution context.

      this [_body] = new Execution_X3DExecutionContext (proto .getExecutionContext ());
      this [_body] .setOuterNode (this);

      // Copy proto.

      this .importExternProtos (proto .getBody () .externprotos);
      this .importProtos       (proto .getBody () .protos);
      this .copyRootNodes      (proto .getBody () .rootNodes);
      this .copyImportedNodes  (proto .getBody (), proto .getBody () .getImportedNodes ());
      this .copyRoutes         (proto .getBody (), proto .getBody () .routes);

      this [_body] .setup ();

      if (this .isInitialized ())
         Base_X3DChildObject.prototype.addEvent.call (this);

      this [_protoNode] ._updateInstances .removeInterest ("construct", this);
      this [_protoNode] ._updateInstances .addInterest ("update", this);
   },
   update: function ()
   {
      // Remove old fields.

      const
         oldProtoFields = this [_protoFields],
         oldFields      = new Map (this .getFields () .map (f => [f .getName (), f]));

      for (const field of oldFields .values ())
         this .removeField (field .getName ());

      // Add new fields.

      this [_protoFields] = new Map (this [_protoNode] .getFields () .map (f => [f, f .getName ()]));

      for (const fieldDefinition of this .getFieldDefinitions ())
         this .addField (fieldDefinition);

      // Reuse old fields, and therefor routes.

      for (const protoField of this [_protoFields] .keys ())
      {
         const oldFieldName = oldProtoFields .get (protoField);

         if (! oldFieldName)
            continue;

         const
            newField = this .getFields () .get (protoField .getName ()),
            oldField = oldFields .get (oldFieldName);

         oldField .addParent (this);
         oldField .setAccessType (newField .getAccessType ());
         oldField .setName (newField .getName ());

         this .getPredefinedFields () .update (newField .getName (), newField .getName (), oldField);
         this .getFields ()           .update (newField .getName (), newField .getName (), oldField);

         if (! this .isPrivate ())
            oldField .addCloneCount (1);

         oldFields .delete (oldFieldName);
         newField .dispose ();
      }

      for (const oldField of oldFields .values ())
         oldField .dispose ();

      // Construct now.

      this .construct ();
   },
   getExtendedEventHandling: function ()
   {
      return false;
   },
   getProtoNode: function ()
   {
      return this [_protoNode];
   },
   setProtoNode: function (protoNode)
   {
      if (protoNode !== this [_protoNode])
      {
         // Disconnect old proto node.

         if (this [_protoNode])
         {
            const protoNode = this [_protoNode];

            protoNode ._name_changed .removeFieldInterest (this ._typeName_changed);
            protoNode ._updateInstances .removeInterest ("construct", this);
            protoNode ._updateInstances .removeInterest ("update",    this);
         }

         // Get field from new proto node.

         this [_protoFields]      = new Map (protoNode .getFields () .map (f => [f, f .getName ()]));
         this [X3DPrototypeInstance_fieldDefinitions] = protoNode .getFieldDefinitions ();
      }

      this [_protoNode] = protoNode;

      protoNode ._name_changed .addFieldInterest (this ._typeName_changed);

      const outerNode = this .getExecutionContext () .getOuterNode ();

      if (outerNode && outerNode .getType () .includes (Base_X3DConstants.X3DProtoDeclaration))
         return;

      if (protoNode .isExternProto)
      {
         if (this [_protoNode] .checkLoadState () === Base_X3DConstants.COMPLETE_STATE)
         {
            this .construct ();
         }
         else
         {
            protoNode ._updateInstances .addInterest ("construct", this);
            protoNode .requestImmediateLoad ();
         }
      }
      else
      {
         this .construct ();
      }
   },
   getBody: function ()
   {
      return this [_body];
   },
   getInnerNode: function ()
   {
      const rootNodes = this [_body] .getRootNodes () .getValue ();

      if (rootNodes .length)
      {
         const rootNode = rootNodes [0];

         if (rootNode)
            return rootNode .getValue () .getInnerNode ();
      }

      throw new Error ("Root node not available.");
   },
   importExternProtos: function (externprotos1)
   {
      const externprotos2 = this [_body] .externprotos;

      for (const externproto of externprotos1)
         externprotos2 .add (externproto .getName (), externproto);
   },
   importProtos: function (protos1)
   {
      const protos2 = this [_body] .protos;

      for (const proto of protos1)
         protos2 .add (proto .getName (), proto);
   },
   copyRootNodes: function (rootNodes1)
   {
      const rootNodes2 = this [_body] .getRootNodes ();

      for (const node of rootNodes1)
         rootNodes2 .push (node .copy (this));
   },
   copyImportedNodes: function (executionContext, importedNodes)
   {
      for (const importedNode of importedNodes)
      {
         try
         {
            const
               inlineNode   = this [_body] .getNamedNode (importedNode .getInlineNode () .getName ()),
               importedName = importedNode .getImportedName (),
               exportedName = importedNode .getExportedName ();

            this [_body] .addImportedNode (inlineNode, exportedName, importedName);
         }
         catch (error)
         {
            console .error ("Bad IMPORT specification in copy: ", error);
         }
      }
   },
   copyRoutes: function (executionContext, routes)
   {
      for (const route of routes)
      {
         try
         {
            const
               sourceNode      = this [_body] .getLocalNode (executionContext .getLocalName (route .sourceNode)),
               destinationNode = this [_body] .getLocalNode (executionContext .getLocalName (route .destinationNode));

            this [_body] .addRoute (sourceNode, route .sourceField, destinationNode, route .destinationField);
         }
         catch (error)
         {
            console .error (error);
         }
      }
   },
   toXMLStream: function (stream)
   {
      const
         generator  = InputOutput_Generator.Get (stream),
         sharedNode = generator .IsSharedNode (this);

      generator .EnterScope ();

      const name = generator .Name (this);

      if (name .length)
      {
         if (generator .ExistsNode (this))
         {
            stream .string += generator .Indent ();
            stream .string += "<ProtoInstance";
            stream .string += " ";
            stream .string += "name='";
            stream .string += generator .XMLEncode (this .getTypeName ());
            stream .string += "'";
            stream .string += " ";
            stream .string += "USE='";
            stream .string += generator .XMLEncode (name);
            stream .string += "'";

            const containerField = generator .ContainerField ();

            if (containerField)
            {
               if (containerField .getName () !== this .getContainerField ())
               {
                  stream .string += " ";
                  stream .string += "containerField='";
                  stream .string += generator .XMLEncode (containerField .getName ());
                  stream .string += "'";
               }
            }

            stream .string += "/>";

            generator .LeaveScope ();
            return;
         }
      }

      stream .string += generator .Indent ();
      stream .string += "<ProtoInstance";
      stream .string += " ";
      stream .string += "name='";
      stream .string += generator .XMLEncode (this .getTypeName ());
      stream .string += "'";

      if (name .length)
      {
         generator .AddNode (this);

         stream .string += " ";
         stream .string += "DEF='";
         stream .string += generator .XMLEncode (name);
         stream .string += "'";
      }

      const containerField = generator .ContainerField ();

      if (containerField)
      {
         if (containerField .getName () !== this .getContainerField ())
         {
            stream .string += " ";
            stream .string += "containerField='";
            stream .string += generator .XMLEncode (containerField .getName ());
            stream .string += "'";
         }
      }

      const fields = this .getChangedFields ();

      if (fields .length === 0)
      {
         stream .string += "/>";
      }
      else
      {
         stream .string += ">\n";

         generator .IncIndent ();

         const references = [ ];

         for (const field of fields)
         {
            // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
            // for this field.

            let mustOutputValue = false;

            if (generator .ExecutionContext ())
            {
               if (field .getAccessType () === Base_X3DConstants.inputOutput && field .getReferences () .size !== 0)
               {
                  let initializableReference = false;

                  field .getReferences () .forEach (function (fieldReference)
                  {
                     initializableReference = initializableReference || fieldReference .isInitializable ();
                  });

                  if (!initializableReference)
                     mustOutputValue = !this .isDefaultValue (field);
               }
            }

            // If we have no execution context we are not in a proto and must not generate IS references the same is true
            // if the node is a shared node as the node does not belong to the execution context.

            if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode || mustOutputValue)
            {
               if (mustOutputValue)
                  references .push (field);

               switch (field .getType ())
               {
                  case Base_X3DConstants.MFNode:
                  {
                     stream .string += generator .Indent ();
                     stream .string += "<fieldValue";
                     stream .string += " ";
                     stream .string += "name='";
                     stream .string += generator .XMLEncode (field .getName ());
                     stream .string += "'";

                     if (field .length === 0)
                     {
                        stream .string += "/>\n";
                     }
                     else
                     {
                        generator .PushContainerField (field);

                        stream .string += ">\n";

                        generator .IncIndent ();

                        field .toXMLStream (stream);

                        stream .string += "\n";

                        generator .DecIndent ();

                        stream .string += generator .Indent ();
                        stream .string += "</fieldValue>\n";

                        generator .PopContainerField ();
                     }

                     break;
                  }
                  case Base_X3DConstants.SFNode:
                  {
                     if (field .getValue () !== null)
                     {
                        generator .PushContainerField (field);

                        stream .string += generator .Indent ();
                        stream .string += "<fieldValue";
                        stream .string += " ";
                        stream .string += "name='";
                        stream .string += generator .XMLEncode (field .getName ());
                        stream .string += "'";
                        stream .string += ">\n";

                        generator .IncIndent ();

                        field .toXMLStream (stream);

                        stream .string += "\n";

                        generator .DecIndent ();

                        stream .string += generator .Indent ();
                        stream .string += "</fieldValue>\n";

                        generator .PopContainerField ();
                        break;
                     }

                     // Proceed with next case.
                  }
                  default:
                  {
                     stream .string += generator .Indent ();
                     stream .string += "<fieldValue";
                     stream .string += " ";
                     stream .string += "name='";
                     stream .string += generator .XMLEncode (field .getName ());
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "value='";

                     field .toXMLStream (stream);

                     stream .string += "'";
                     stream .string += "/>\n";
                     break;
                  }
               }
            }
            else
            {
               references .push (field);
            }
         }

         if (references .length && ! sharedNode)
         {
            stream .string += generator .Indent ();
            stream .string += "<IS>";
            stream .string += "\n";

            generator .IncIndent ();

            for (const field of references)
            {
               const protoFields = field .getReferences ();

               protoFields .forEach (function (protoField)
               {
                  stream .string += generator .Indent ();
                  stream .string += "<connect";
                  stream .string += " ";
                  stream .string += "nodeField='";
                  stream .string += generator .XMLEncode (field .getName ());
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "protoField='";
                  stream .string += generator .XMLEncode (protoField .getName ());
                  stream .string += "'";
                  stream .string += "/>\n";
               });
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</IS>\n";
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</ProtoInstance>";
      }

      generator .LeaveScope ();
   },
   dispose: function ()
   {
      this [_protoNode] ._updateInstances .removeInterest ("construct", this);
      this [_protoNode] ._updateInstances .removeInterest ("update",    this);

      if (this [_body])
         this [_body] .dispose ();

      Core_X3DNode.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Core_X3DPrototypeInstance = (X3DPrototypeInstance);

;// CONCATENATED MODULE: ./src/x_ite/Prototype/X3DProtoDeclarationNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









Configuration_SupportedNodes.addAbstractType ("X3DProtoDeclarationNode", X3DProtoDeclarationNode);

function X3DProtoDeclarationNode (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DProtoDeclarationNode);

   this .addChildObjects ("updateInstances", new x_ite_Fields.SFTime ());
}

X3DProtoDeclarationNode .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: X3DProtoDeclarationNode,
   canUserDefinedFields: function ()
   {
      return true;
   },
   createInstance: function (executionContext, setup = true)
   {
      if (setup === false)
      {
         return new Core_X3DPrototypeInstance (executionContext, this);
      }
      else
      {
         const instance = new Core_X3DPrototypeInstance (executionContext, this);

         instance .setup ();

         return Fields_SFNodeCache.get (instance);
      }
   },
   newInstance: function ()
   {
      return this .createInstance (this .getExecutionContext ());
   },
   requestUpdateInstances: function ()
   {
      this ._updateInstances = this .getBrowser () .getCurrentTime ();
   },
   updateInstances: function ()
   {
      this ._updateInstances .processEvent ();
   },
});

for (const key of Reflect .ownKeys (X3DProtoDeclarationNode .prototype))
   Object .defineProperty (X3DProtoDeclarationNode .prototype, key, { enumerable: false });

/* harmony default export */ const Prototype_X3DProtoDeclarationNode = (X3DProtoDeclarationNode);

;// CONCATENATED MODULE: ./src/x_ite/Prototype/X3DProtoDeclaration.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











Configuration_SupportedNodes.addAbstractType ("X3DProtoDeclaration", X3DProtoDeclaration);

const
   X3DProtoDeclaration_body = Symbol ();

function X3DProtoDeclaration (executionContext)
{
   Prototype_X3DProtoDeclarationNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DProtoDeclaration)

   this .addChildObjects ("loadState", new x_ite_Fields.SFInt32 (Base_X3DConstants.NOT_STARTED_STATE));

   this [X3DProtoDeclaration_body] = new Execution_X3DExecutionContext (executionContext);
   this [X3DProtoDeclaration_body] .setOuterNode (this);
   this [X3DProtoDeclaration_body] .setLive (false);
   this .setLive (false);
}

X3DProtoDeclaration .prototype = Object .assign (Object .create (Prototype_X3DProtoDeclarationNode.prototype),
{
   constructor: X3DProtoDeclaration,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "X3DProtoDeclaration";
   },
   initialize: function ()
   {
      Prototype_X3DProtoDeclarationNode.prototype.initialize.call (this);

      this [X3DProtoDeclaration_body] .setup ();

      this ._loadState = Base_X3DConstants.COMPLETE_STATE;
   },
   getProtoDeclaration: function ()
   {
      return this;
   },
   getBody: function ()
   {
      return this [X3DProtoDeclaration_body];
   },
   checkLoadState: function ()
   {
      return this ._loadState .getValue ();
   },
   canUserDefinedFields: function ()
   {
      return true;
   },
   toVRMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "PROTO";
      stream .string += " ";
      stream .string += this .getName ();
      stream .string += " ";
      stream .string += "[";

      generator .EnterScope ();

      const userDefinedFields = this .getUserDefinedFields ();

      let
         fieldTypeLength  = 0,
         accessTypeLength = 0;

      if (userDefinedFields .length === 0)
      {
         stream .string += " ";
      }
      else
      {
         for (const field of userDefinedFields)
         {
            fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
            accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
         }

         stream .string += "\n";

         generator .IncIndent ();

         for (const field of userDefinedFields)
         {
            this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
            stream .string += "\n";
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
      }

      generator .LeaveScope ();

      stream .string += "]";
      stream .string += "\n";

      stream .string += generator .Indent ();
      stream .string += "{";
      stream .string += "\n";

      generator .IncIndent ();

      this [X3DProtoDeclaration_body] .toVRMLStream (stream);

      generator .DecIndent ();

      stream .string += generator .Indent ();
      stream .string += "}";
   },
   toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
      stream .string += " ";
      stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
      stream .string += " ";
      stream .string += field .getName ();

      if (field .isInitializable ())
      {
         stream .string += " ";

         field .toVRMLStream (stream);
      }
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "<ProtoDeclare";
      stream .string += " ";
      stream .string += "name='";
      stream .string += generator .XMLEncode (this .getName ());
      stream .string += "'";
      stream .string += ">";
      stream .string += "\n";

      // <ProtoInterface>

      generator .EnterScope ();

      const userDefinedFields = this .getUserDefinedFields ();

      if (userDefinedFields .length !== 0)
      {
         generator .IncIndent ();

         stream .string += generator .Indent ();
         stream .string += "<ProtoInterface>\n";

         generator .IncIndent ();

         for (const field of userDefinedFields)
         {
            stream .string += generator .Indent ();
            stream .string += "<field";
            stream .string += " ";
            stream .string += "accessType='";
            stream .string += generator .AccessType (field .getAccessType ());
            stream .string += "'";
            stream .string += " ";
            stream .string += "type='";
            stream .string += field .getTypeName ();
            stream .string += "'";
            stream .string += " ";
            stream .string += "name='";
            stream .string += generator .XMLEncode (field .getName ());
            stream .string += "'";

            if (field .isDefaultValue ())
            {
               stream .string += "/>\n";
            }
            else
            {
               switch (field .getType ())
               {
                  case Base_X3DConstants.SFNode:
                  case Base_X3DConstants.MFNode:
                  {
                     generator .PushContainerField (field);

                     stream .string += ">\n";

                     generator .IncIndent ();

                     field .toXMLStream (stream);

                     stream .string += "\n";

                     generator .DecIndent ();

                     stream .string += generator .Indent ();
                     stream .string += "</field>\n";

                     generator .PopContainerField ();
                     break;
                  }
                  default:
                  {
                     stream .string += " ";
                     stream .string += "value='";

                     field .toXMLStream (stream);

                     stream .string += "'";
                     stream .string += "/>\n";
                     break;
                  }
               }
            }
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</ProtoInterface>\n";

         generator .DecIndent ();
      }

      generator .LeaveScope ();

      // </ProtoInterface>

      // <ProtoBody>

      generator .IncIndent ();

      stream .string += generator .Indent ();
      stream .string += "<ProtoBody>\n";

      generator .IncIndent ();

      this [X3DProtoDeclaration_body] .toXMLStream (stream);

      generator .DecIndent ();

      stream .string += generator .Indent ();
      stream .string += "</ProtoBody>\n";

      generator .DecIndent ();

      // </ProtoBody>

      stream .string += generator .Indent ();
      stream .string += "</ProtoDeclare>";
   },
});

for (const key of Reflect .ownKeys (X3DProtoDeclaration .prototype))
   Object .defineProperty (X3DProtoDeclaration .prototype, key, { enumerable: false });

Object .defineProperty (X3DProtoDeclaration .prototype, "name",
{
   get: function () { return this .getName (); },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DProtoDeclaration .prototype, "fields",
{
   get: function () { return this .getFieldDefinitions (); },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DProtoDeclaration .prototype, "isExternProto",
{
   get: function () { return false; },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Prototype_X3DProtoDeclaration = (X3DProtoDeclaration);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking/X3DUrlObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   _cache                   = Symbol (),
   _autoRefreshStartTime    = Symbol (),
   _autoRefreshCompleteTime = Symbol (),
   _autoRefreshId           = Symbol ();

function X3DUrlObject (executionContext)
{
   this .addType (Base_X3DConstants.X3DUrlObject);

   this .addChildObjects ("loadState", new x_ite_Fields.SFInt32 (Base_X3DConstants.NOT_STARTED_STATE),
                          "loadNow",   new x_ite_Fields.SFTime ());

   this [_cache]                = true;
   this [_autoRefreshStartTime] = performance .now ();
}

X3DUrlObject .prototype =
{
   constructor: X3DUrlObject,
   initialize: function ()
   {
      this .isLive () .addInterest ("set_live__", this);

      this ._load                 .addInterest ("set_load__",        this);
      this ._url                  .addInterest ("set_url__",         this);
      this ._loadNow              .addInterest ("loadNow",           this);
      this ._autoRefresh          .addInterest ("set_autoRefresh__", this);
      this ._autoRefreshTimeLimit .addInterest ("set_autoRefresh__", this);
   },
   setLoadState: function (value, notify = true)
   {
      this ._loadState = value;

      if (value === Base_X3DConstants.COMPLETE_STATE)
      {
         this [_autoRefreshCompleteTime] = performance .now ();
         this .setAutoRefreshTimer (this ._autoRefresh .getValue ());
      }

      if (!notify)
         return;

      switch (value)
      {
         case Base_X3DConstants.NOT_STARTED_STATE:
            break;
         case Base_X3DConstants.IN_PROGRESS_STATE:
         {
            this .getScene () .addLoadCount (this);
            break;
         }
         case Base_X3DConstants.COMPLETE_STATE:
         case Base_X3DConstants.FAILED_STATE:
         {
            this .getScene () .removeLoadCount (this);
            break;
         }
      }
   },
   checkLoadState: function ()
   {
      return this ._loadState .getValue ();
   },
   getLoadState: function ()
   {
      return this ._loadState;
   },
   setCache: function (value)
   {
      this [_cache] = value;
   },
   getCache: function ()
   {
      return this [_cache];
   },
   requestImmediateLoad: function (cache = true)
   {
      const loadState = this .checkLoadState ();

      if (loadState === Base_X3DConstants.COMPLETE_STATE || loadState === Base_X3DConstants.IN_PROGRESS_STATE)
         return;

      if (!this ._load .getValue ())
         return;

      if (this ._url .length === 0)
         return;

      this .setCache (cache);
      this .setLoadState (Base_X3DConstants.IN_PROGRESS_STATE);

      if (this .isInitialized ())
         // Buffer prevents double load of the scene if load and url field are set at the same time.
         this ._loadNow = this .getBrowser () .getCurrentTime ();
      else
         this .loadNow ();
   },
   loadNow: function ()
   { },
   requestUnload: function ()
   {
      const loadState = this .checkLoadState ();

      if (loadState === Base_X3DConstants.NOT_STARTED_STATE || loadState === Base_X3DConstants.FAILED_STATE)
         return;

      this .setLoadState (Base_X3DConstants.NOT_STARTED_STATE);
      this .unLoadNow ();
   },
   unLoadNow: function ()
   { },
   setAutoRefreshTimer: function (autoRefreshInterval)
   {
      clearTimeout (this [_autoRefreshId]);

      if (this ._autoRefresh .getValue () <= 0)
         return;

      const autoRefreshTimeLimit = this ._autoRefreshTimeLimit .getValue ();

      if (autoRefreshTimeLimit !== 0)
      {
         if ((performance .now () - this [_autoRefreshStartTime]) / 1000 > autoRefreshTimeLimit - autoRefreshInterval)
            return;
      }

      this [_autoRefreshId] = setTimeout (this .performAutoRefresh .bind (this), autoRefreshInterval * 1000);
   },
   performAutoRefresh: function ()
   {
      this .setLoadState (Base_X3DConstants.NOT_STARTED_STATE);
      this .requestImmediateLoad (false);
   },
   set_live__: function ()
   {
      if (this .isLive () .getValue ())
         this .set_autoRefresh__ ();
      else
         clearTimeout (this [_autoRefreshId]);
   },
   set_load__: function ()
   {
      if (this ._load .getValue ())
         this .requestImmediateLoad ();
      else
         this .requestUnload ();
   },
   set_url__: function ()
   {
      if (!this ._load .getValue ())
         return;

      this .setLoadState (Base_X3DConstants.NOT_STARTED_STATE);
      this .requestImmediateLoad ();
   },
   set_autoRefresh__: function ()
   {
      if (this .checkLoadState () !== Base_X3DConstants.COMPLETE_STATE)
         return;

      const
         elapsedTime = (performance .now () - this [_autoRefreshCompleteTime]) / 1000,
         autoRefresh = this ._autoRefresh .getValue ();

      let autoRefreshInterval = autoRefresh - elapsedTime;

      if (autoRefreshInterval < 0)
         autoRefreshInterval = Math .ceil (elapsedTime / autoRefresh) * autoRefresh - elapsedTime;

      this .setAutoRefreshTimer (autoRefreshInterval);
   },
   dispose: function () { },
};

/* harmony default export */ const Networking_X3DUrlObject = (X3DUrlObject);

;// CONCATENATED MODULE: ./src/x_ite/Parser/X3DParser.js
var X3DParser_filename = "/index.js";
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function X3DParser (scene)
{
   this .scene             = scene;
   this .executionContexts = [ scene ];
   this .prototypes        = [ ];
   this .units             = true;
}

X3DParser .prototype = {
   constructor: X3DParser,
   getScene: function ()
   {
      return this .scene;
   },
   getBrowser: function ()
   {
      return this .scene .getBrowser ();
   },
   getExecutionContext: function ()
   {
      return this .executionContexts .at (-1);
   },
   pushExecutionContext: function (executionContext)
   {
      return this .executionContexts .push (executionContext);
   },
   popExecutionContext: function ()
   {
      this .executionContexts .pop ();
   },
   getPrototype: function ()
   {
      return this .prototypes .at (-1);
   },
   pushPrototype: function (prototype)
   {
      return this .prototypes .push (prototype);
   },
   popPrototype: function ()
   {
      this .prototypes .pop ();
   },
   isInsideProtoDefinition: function ()
   {
      return Boolean (this .prototypes .length);
   },
   addRootNode: function (node)
   {
      this .getExecutionContext () .rootNodes .push (node);
   },
   getProviderUrls: (function ()
   {
      const componentsUrl = /\.js$/;

      return function ()
      {
         const
            scene             = this .getScene (),
            profile           = scene .getProfile () || scene .getBrowser () .getProfile ("Full"),
            profileComponents = profile .components,
            components        = scene .getComponents (),
            providerUrls      = new Set ();

         for (const component of profileComponents)
         {
            const providerUrl = component .providerUrl;

            if (providerUrl .match (componentsUrl))
               providerUrls .add (providerUrl);
         }

         for (const component of components)
         {
            const providerUrl = component .providerUrl;

            if (providerUrl .match (componentsUrl))
               providerUrls .add (providerUrl);
         }

         if (typeof __global_require__ === "function" && typeof X3DParser_filename === "string")
         {
            for (const url of providerUrls)
               __global_require__ (__global_require__ ("url") .fileURLToPath (url));
         }

         return Array .from (providerUrls);
      };
   })(),
   setUnits: function (generator)
   {
      if (typeof arguments [0] == "boolean")
      {
         this .units = arguments [0];
         return;
      }

      const
         version = /Titania\s+V(\d+).*/,
         match   = generator .match (version);

      if (match)
      {
         const major = parseInt (match [1]);

         // Before version 4 units are wrongly implemented.
         if (major < 4)
         {
            this .units = false;
            return;
         }
      }

      this .units = true;
   },
   getUnits: function ()
   {
      return this .units;
   },
   fromUnit: function (category, value)
   {
      if (this .units)
         return this .scene .fromUnit (category, value);

      return value;
   },
};

/* harmony default export */ const Parser_X3DParser = (X3DParser);

;// CONCATENATED MODULE: ./src/x_ite/Parser/VRMLParser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








/*
 *  Grammar
 */


//	Comment out scriptBody function fragments
//
//	// VRML lexical elements
//	var Grammar =
//	{
//		// General
//		Whitespaces: /^([\x20\n,\t\r]+)/,
//		Comment:     /^#(.*?)(?=[\n\r])/,
//
//		// Header
//		Header:	    /^#(VRML|X3D) V(.*?) (utf8)(?: (.*?))?[\n\r]/,
//
//		// Keywords
//		AS:          /^AS/,
//		COMPONENT:   /^COMPONENT/,
//		DEF:         /^DEF/,
//		EXPORT:      /^EXPORT/,
//		EXTERNPROTO: /^EXTERNPROTO/,
//		FALSE:       /^FALSE/,
//		false:       /^false/,
//		IMPORT:      /^IMPORT/,
//		IS:          /^IS/,
//		META:        /^META/,
//		NULL:        /^NULL/,
//		TRUE:        /^TRUE/,
//		true:        /^true/,
//		PROFILE:     /^PROFILE/,
//		PROTO:       /^PROTO/,
//		ROUTE:       /^ROUTE/,
//		TO:          /^TO/,
//		UNIT:        /^UNIT/,
//		USE:         /^USE/,
//
//		// Terminal symbols
//		OpenBrace:    /^\{/,
//		CloseBrace:   /^\}/,
//		OpenBracket:  /^\[/,
//		CloseBracket: /^\]/,
//		Period:       /^\./,
//		Colon:        /^\:/,
//
//		Id: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f]*)/,
//		ComponentNameId: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]*)/,
//
//		initializeOnly: /^initializeOnly/,
//		inputOnly:      /^inputOnly/,
//		outputOnly:     /^outputOnly/,
//		inputOutput:    /^inputOutput/,
//
//		field:        /^field/,
//		eventIn:      /^eventIn/,
//		eventOut:     /^eventOut/,
//		exposedField: /^exposedField/,
//
//		FieldType: /^(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)/,
//
//		// Values
//		int32:  /^((?:0[xX][\da-fA-F]+)|(?:[+-]?\d+))/,
//		double: /^([+-]?(?:(?:(?:\d*\.\d+)|(?:\d+(?:\.)?))(?:[eE][+-]?\d+)?))/,
//		string: /^"((?:[^"\\]|\\\\|\\")*)"/,
//
//		Inf:         /^[+]?inf/i,
//		NegativeInf: /^-inf/i,
//		NaN:         /^[+-]?nan/i,
//
//		// Misc
//		Break: /\r?\n/g,
//	};
//
//	function parse (parser)
//	{
//		this .lastIndex = 0;
//		parser .result  = this .exec (parser .input);
//
//		if (parser .result)
//		{
//			parser .input = parser .input .slice (parser .result [0] .length);
//			return true;
//		}
//
//		return false;
//	}


// Comment out scriptBody function fragments
//
// VRML lexical elements
var Grammar =
{
   // General
   Whitespaces: new RegExp ('([\\x20\\n,\\t\\r]+)', 'gy'),
   Comment:     new RegExp ('#(.*?)(?=[\\n\\r])',   'gy'),

   // Header
   Header:	    new RegExp ("^#(VRML|X3D) V(.*?) (utf8)(?:[ \\t]+(.*?))?[ \\t]*[\\n\\r]", 'gy'),

   // Keywords
   AS:          new RegExp ('AS',          'gy'),
   COMPONENT:   new RegExp ('COMPONENT',   'gy'),
   DEF:         new RegExp ('DEF',         'gy'),
   EXPORT:      new RegExp ('EXPORT',      'gy'),
   EXTERNPROTO: new RegExp ('EXTERNPROTO', 'gy'),
   FALSE:       new RegExp ('FALSE|false', 'gy'),
   IMPORT:      new RegExp ('IMPORT',      'gy'),
   IS:          new RegExp ('IS',          'gy'),
   META:        new RegExp ('META',        'gy'),
   NULL:        new RegExp ('NULL',        'gy'),
   TRUE:        new RegExp ('TRUE|true',   'gy'),
   PROFILE:     new RegExp ('PROFILE',     'gy'),
   PROTO:       new RegExp ('PROTO',       'gy'),
   ROUTE:       new RegExp ('ROUTE',       'gy'),
   TO:          new RegExp ('TO',          'gy'),
   UNIT:        new RegExp ('UNIT',        'gy'),
   USE:         new RegExp ('USE',         'gy'),

   // Terminal symbols
   OpenBrace:    new RegExp ('\\{', 'gy'),
   CloseBrace:   new RegExp ('\\}', 'gy'),
   OpenBracket:  new RegExp ('\\[', 'gy'),
   CloseBracket: new RegExp ('\\]', 'gy'),
   Period:       new RegExp ('\\.', 'gy'),
   Colon:        new RegExp ('\\:', 'gy'),

   Id: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]*)', 'gy'),
   ComponentNameId: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]*)', 'gy'),

   initializeOnly: new RegExp ('initializeOnly', 'gy'),
   inputOnly:      new RegExp ('inputOnly',      'gy'),
   outputOnly:     new RegExp ('outputOnly',     'gy'),
   inputOutput:    new RegExp ('inputOutput',    'gy'),

   field:        new RegExp ('field', 'gy'),
   eventIn:      new RegExp ('eventIn', 'gy'),
   eventOut:     new RegExp ('eventOut', 'gy'),
   exposedField: new RegExp ('exposedField', 'gy'),

   FieldType: new RegExp ('(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)', 'gy'),

   // Values
   int32:  new RegExp ('((?:0[xX][\\da-fA-F]+)|(?:[+-]?\\d+))', 'gy'),
   double: new RegExp ('([+-]?(?:(?:(?:\\d*\\.\\d+)|(?:\\d+(?:\\.)?))(?:[eE][+-]?\\d+)?))', 'gy'),
   string: new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'gy'),

   Inf:         new RegExp ('[+]?(?:inf|Infinity)', 'gy'),
   NegativeInf: new RegExp ('-(?:inf|Infinity)',    'gy'),
   NaN:         new RegExp ('[+-]?(nan|NaN)',       'gy'),

   // Misc
   Break: new RegExp ('\\r?\\n', 'g'),
};

function parse (parser)
{
   this .lastIndex = parser .lastIndex;

   parser .result = this .exec (parser .input);

   if (parser .result)
   {
      parser .lastIndex = this .lastIndex;
      return true;
   }

   return false;
}

for (var key in Grammar)
   Grammar [key] .parse = parse;

/*
 *  Parser
 */

function VRMLParser (scene)
{
   Parser_X3DParser.call (this, scene);
}

VRMLParser .prototype = Object .assign (Object .create (Parser_X3DParser.prototype),
{
   constructor: VRMLParser,
   accessTypes:
   {
      field:          Base_X3DConstants.initializeOnly,
      eventIn:        Base_X3DConstants.inputOnly,
      eventOut:       Base_X3DConstants.outputOnly,
      exposedField:   Base_X3DConstants.inputOutput,
      initializeOnly: Base_X3DConstants.initializeOnly,
      inputOnly:      Base_X3DConstants.inputOnly,
      outputOnly:     Base_X3DConstants.outputOnly,
      inputOutput:    Base_X3DConstants.inputOutput,
   },
   SFBool: new x_ite_Fields.SFBool (),
   SFColor: new x_ite_Fields.SFColor (),
   SFColorRGBA: new x_ite_Fields.SFColorRGBA (),
   SFDouble: new x_ite_Fields.SFDouble (),
   SFFloat: new x_ite_Fields.SFFloat (),
   SFImage: new x_ite_Fields.SFImage (),
   SFInt32: new x_ite_Fields.SFInt32 (),
   SFMatrix3f: new x_ite_Fields.SFMatrix3f (),
   SFMatrix3d: new x_ite_Fields.SFMatrix3d (),
   SFMatrix4f: new x_ite_Fields.SFMatrix4f (),
   SFMatrix4d: new x_ite_Fields.SFMatrix4d (),
   SFNode: new x_ite_Fields.SFNode (),
   SFRotation: new x_ite_Fields.SFRotation (),
   SFString: new x_ite_Fields.SFString (),
   SFTime: new x_ite_Fields.SFTime (),
   SFVec2d: new x_ite_Fields.SFVec2d (),
   SFVec2f: new x_ite_Fields.SFVec2f (),
   SFVec3d: new x_ite_Fields.SFVec3d (),
   SFVec3f: new x_ite_Fields.SFVec3f (),
   SFVec4d: new x_ite_Fields.SFVec4d (),
   SFVec4f: new x_ite_Fields.SFVec4f (),
   MFBool: new x_ite_Fields.MFBool (),
   MFColor: new x_ite_Fields.MFColor (),
   MFColorRGBA: new x_ite_Fields.MFColorRGBA (),
   MFDouble: new x_ite_Fields.MFDouble (),
   MFFloat: new x_ite_Fields.MFFloat (),
   MFImage: new x_ite_Fields.MFImage (),
   MFInt32: new x_ite_Fields.MFInt32 (),
   MFMatrix3d: new x_ite_Fields.MFMatrix3d (),
   MFMatrix3f: new x_ite_Fields.MFMatrix3f (),
   MFMatrix4d: new x_ite_Fields.MFMatrix4d (),
   MFMatrix4f: new x_ite_Fields.MFMatrix4f  (),
   MFNode: new x_ite_Fields.MFNode (),
   MFRotation: new x_ite_Fields.MFRotation (),
   MFString: new x_ite_Fields.MFString (),
   MFTime: new x_ite_Fields.MFTime (),
   MFVec2d: new x_ite_Fields.MFVec2d (),
   MFVec2f: new x_ite_Fields.MFVec2f (),
   MFVec3d: new x_ite_Fields.MFVec3d (),
   MFVec3f: new x_ite_Fields.MFVec3f (),
   MFVec4d: new x_ite_Fields.MFVec4d (),
   MFVec4f: new x_ite_Fields.MFVec4f (),
   isValid: function ()
   {
      return !! this .input .match (/^(?:#X3D|#VRML|(?:[\x20\n,\t\r]*|#.*?[\r\n])*(PROFILE|COMPONENT|META|UNIT|EXTERNPROTO|PROTO|DEF|NULL|IMPORT|EXPORT|ROUTE|\w+(?:[\x20\n,\t\r]*|#.*?[\r\n])\{|$))/);
   },
   getInput: function ()
   {
      return this .input;
   },
   setInput: function (vrmlSyntax)
   {
      this .input      = vrmlSyntax;
      this .lineNumber = 1;
      this .lastIndex  = 0;
   },
   parseIntoScene: function (success, error)
   {
      try
      {
         this .success = success;
         this .error   = error;

         this .getScene () .setEncoding ("VRML");
         this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));
         this .x3dScene ();
      }
      catch (error)
      {
         //console .error (error);
         throw new Error (this .getError (error));
      }
   },
   exception: function (string)
   {
      if (this .getBrowser () .isStrict ())
         throw new Error (string);

      console .warn (string);
   },
   getError: function (error)
   {
      //console .error (error);

      var string = error .message;

      var
         rest     = this .getLine (),
         line     = this .getLastLine (),
         lastLine = this .getLastLine (),
         linePos  = line .length - rest .length + 1;

      if (line .length > 80)
      {
         line     = line .substr (linePos - 40, 80);
         lastLine = "";
         linePos  = 40;
      }

      // Format error

      var message = "\n"
         + "********************************************************************************" + "\n"
         + "Parser error at line " + this .lineNumber + ":" + linePos  + "\n"
         + "in '" + this .getScene () .getWorldURL () + "'" + "\n"
         + "\n"
         + lastLine + "\n"
         + line + "\n"
         + Array (linePos) .join (" ") + "^" + "\n"
         + string + "\n"
         + "********************************************************************************"
         + "\n"
      ;

      return message;
   },
   getLine: function ()
   {
      var
         input     = this .input,
         lastIndex = this .lastIndex,
         line      = "";

      while (lastIndex < input .length && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
         line += input [lastIndex ++];

      this .lastIndex = lastIndex;

      return line;
   },
   getLastLine: function ()
   {
      var
         input     = this .input,
         lastIndex = this .lastIndex,
         line      = "";

      if (lastIndex < input .length && (input [lastIndex] !== "\n" || input [lastIndex] !== "\r"))
         -- lastIndex;

      while (lastIndex >= 0 && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
         line = input [lastIndex --] + line;

      this .lastIndex = lastIndex;

      return line;
   },
   comments: function ()
   {
      while (this .comment ())
         ;
   },
   comment: function ()
   {
      if (this .whitespaces ())
         return true;

      return Grammar .Comment .parse (this);
   },
   whitespaces: function ()
   {
      if (Grammar .Whitespaces .parse (this))
      {
         if (!this .xml)
            this .lines (this .result [1]);

         return true;
      }

      return false;
   },
   lines: function (string)
   {
      var match = string .match (Grammar .Break);

      if (match)
         this .lineNumber += match .length;
   },
   x3dScene: function ()
   {
      this .headerStatement ();
      this .profileStatement ();
      this .componentStatements ();
      this .unitStatements ();
      this .metaStatements ();

      try
      {
         this .setUnits (this .getScene () .getMetaData ("generator"));
      }
      catch (error)
      { }

      if (this .success)
      {
         Promise .all (this .getProviderUrls () .map (url => import (/* webpackIgnore: true */ url)))
         .then (function ()
         {
            try
            {
               this .statements ();

               if (this .lastIndex < this .input .length)
                  throw new Error ("Unknown statement.");

               this .success (this .getScene ());
            }
            catch (error)
            {
               //console .error (error);
               this .error (new Error (this .getError (error)));
            }
         }
         .bind (this))
         .catch (function (error)
         {
            this .error (error);
         }
         .bind (this));
      }
      else
      {
         this .statements ();

         if (this .lastIndex < this .input .length)
            throw new Error ("Unknown statement.");
      }
   },
   headerStatement: function ()
   {
      Grammar .Header .lastIndex = 0;

      var result = Grammar .Header .exec (this .input);

      if (result)
      {
         this .getScene () .setSpecificationVersion (result [2]);
         this .getScene () .setEncoding             ("VRML");
         return true;
      }

      return false;
   },
   profileStatement: function ()
   {
      this .comments ();

      if (Grammar .PROFILE .parse (this))
      {
         if (this .profileNameId ())
         {
            var profile = this .getBrowser () .getProfile (this .result [1]);

            this .getScene () .setProfile (profile);
            return;
         }

         throw new Error ("Expected a profile name.");
      }
   },
   componentStatements: function ()
   {
      var component = this .componentStatement ();

      while (component)
      {
         this .getScene () .addComponent (component);

         component = this .componentStatement ();
      }
   },
   componentStatement: function ()
   {
      this .comments ();

      if (Grammar .COMPONENT .parse (this))
      {
         if (this .componentNameId ())
         {
            var componentNameIdCharacters = this .result [1];

            this .comments ();

            if (Grammar .Colon .parse (this))
            {
               if (this .componentSupportLevel ())
               {
                  var componentSupportLevel = this .value;

                  return this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);
               }

               throw new Error ("Expected a component support level.");
            }

            throw new Error ("Expected a ':' after component name.");
         }

         throw new Error ("Expected a component name.");
      }

      return null;
   },
   componentSupportLevel: function ()
   {
      return this .int32 ();
   },
   unitStatements: function ()
   {
      while (this .unitStatement ())
         ;
   },
   unitStatement: function ()
   {
      this .comments ();

      if (Grammar .UNIT .parse (this))
      {
         if (this .categoryNameId ())
         {
            var categoryNameId = this .result [1];

            if (this .unitNameId ())
            {
               var unitNameId = this .result [1];

               if (this .unitConversionFactor ())
               {
                  var unitConversionFactor = this .value;

                  try
                  {
                     this .getScene () .updateUnit (categoryNameId, unitNameId, unitConversionFactor);
                     return true;
                  }
                  catch (error)
                  {
                     console .log (error .message);
                     return true;
                  }
               }

               throw new Error ("Expected unit conversion factor.");
            }

            throw new Error ("Expected unit name identifier.");
         }

         throw new Error ("Expected category name identifier after UNIT statement.");
      }

      return false;
   },
   unitConversionFactor: function ()
   {
      return this .double ();
   },
   metaStatements: function ()
   {
      while (this .metaStatement ())
         ;
   },
   metaStatement: function ()
   {
      this .comments ();

      if (Grammar .META .parse (this))
      {
         if (this .metakey ())
         {
            var metakey = this .value;

            if (this .metavalue ())
            {
               var metavalue = this .value;

               this .getScene () .setMetaData (metakey, metavalue);
               return true;
            }

            throw new Error ("Expected metadata value.");
         }

         throw new Error ("Expected metadata key.");
      }

      return false;
   },
   metakey: function ()
   {
      return this .string ();
   },
   metavalue: function ()
   {
      return this .string ();
   },
   exportStatement: function ()
   {
      this .comments ();

      if (Grammar .EXPORT .parse (this))
      {
         if (this .nodeNameId ())
         {
            var
               localNodeNameId    = this .result [1],
               exportedNodeNameId = "";

            this .comments ();

            var node = this .getScene () .getLocalNode (localNodeNameId);

            if (Grammar .AS .parse (this))
            {
               if (this .exportedNodeNameId ())
                  exportedNodeNameId = this .result [1];
               else
                  throw new Error ("No name given after AS.");
            }
            else
               exportedNodeNameId = localNodeNameId;

            if (this .getScene () === this .getExecutionContext ())
            {
               this .getScene () .updateExportedNode (exportedNodeNameId, node);
               return true;
            }

            throw new Error ("Export statement not allowed here.");
         }

         throw new Error ("No name given after EXPORT.");
      }

      return false;
   },
   importStatement: function ()
   {
      this .comments ();

      if (Grammar .IMPORT .parse (this))
      {
         if (this .nodeNameId ())
         {
            var
               inlineNodeNameId = this .result [1],
               namedNode        = this .getExecutionContext () .getNamedNode (inlineNodeNameId);

            this .comments ();

            if (Grammar .Period .parse (this))
            {
               if (this .exportedNodeNameId ())
               {
                  var
                     exportedNodeNameId = this .result [1],
                     nodeNameId         = exportedNodeNameId;

                  this .comments ();

                  if (Grammar .AS .parse (this))
                  {
                     if (this .nodeNameId ())
                        nodeNameId = this .result [1];

                     else
                        throw new Error ("No name given after AS.");
                  }

                  this .getExecutionContext () .updateImportedNode (namedNode, exportedNodeNameId, nodeNameId);
                  return true;
               }

               throw new Error ("Expected exported node name.");
            }

            throw new Error ("Expected a '.' after exported node name.");
         }

         throw new Error ("No name given after IMPORT statement.");
      }
      return false;
   },
   statements: function ()
   {
      while (this .statement ())
         ;
   },
   statement: function ()
   {
      if (this .protoStatement ())
         return true;

      if (this .routeStatement ())
         return true;

      if (this .importStatement ())
         return true;

      if (this .exportStatement ())
         return true;

      var node = this .nodeStatement ();

      if (node !== false)
      {
         this .addRootNode (node);
         return true;
      }

      return false;
   },
   nodeStatement: function ()
   {
      this .comments ();

      if (Grammar .DEF .parse (this))
      {
         if (this .nodeNameId ())
            return this .node (this .result [1]);

         throw new Error ("No name given after DEF.");
      }

      if (Grammar .USE .parse (this))
      {
         if (this .nodeNameId ())
            return this .getExecutionContext () .getNamedNode (this .result [1]) .getValue ();

         throw new Error ("No name given after USE.");
      }

      if (Grammar .NULL .parse (this))
         return null;

      return this .node ("");
   },
   protoStatement: function ()
   {
      if (this .proto ())
         return true;

      if (this .externproto ())
         return true;

      return false;
   },
   protoStatements: function ()
   {
      while (this .protoStatement ())
         ;
   },
   proto: function ()
   {
      this .comments ();

      if (Grammar .PROTO .parse (this))
      {
         if (this .nodeTypeId ())
         {
            var nodeTypeId = this .result [1];

            this .comments ();

            if (Grammar .OpenBracket .parse (this))
            {
               var interfaceDeclarations = this .interfaceDeclarations ();

               this .comments ();

               if (Grammar .CloseBracket .parse (this))
               {
                  this .comments ();

                  if (Grammar .OpenBrace .parse (this))
                  {
                     var proto = new Prototype_X3DProtoDeclaration (this .getExecutionContext ());

                     for (var i = 0, length = interfaceDeclarations .length; i < length; ++ i)
                     {
                        var field = interfaceDeclarations [i];

                        proto .addUserDefinedField (field .getAccessType (), field .getName (), field);
                     }

                     this .pushPrototype (proto);
                     this .pushExecutionContext (proto .getBody ());

                     this .protoBody ();

                     this .popExecutionContext ();
                     this .popPrototype ();

                     this .comments ();

                     if (Grammar .CloseBrace .parse (this))
                     {
                        proto .setup ();

                        try
                        {
                           const existingProto = this .getExecutionContext () .getProtoDeclaration (nodeTypeId);

                           this .getExecutionContext () .updateProtoDeclaration (this .getExecutionContext () .getUniqueProtoName (nodeTypeId), existingProto);
                        }
                        catch (error)
                        { }

                        this .getExecutionContext () .updateProtoDeclaration (nodeTypeId, proto);

                        return true;
                     }

                     throw new Error ("Expected a '}' at the end of PROTO body.");
                  }

                  throw new Error ("Expected a '{' at the beginning of PROTO body.");
               }

               throw new Error ("Expected a ']' at the end of PROTO interface declaration.");
            }

            throw new Error ("Expected a '[' at the beginning of PROTO interface declaration.");
         }

         throw new Error ("Invalid PROTO definition name.");
      }

      return false;
   },
   protoBody: function ()
   {
      this .protoStatements ();

      var rootNodeStatement = this .rootNodeStatement ();

      if (rootNodeStatement !== false)
         this .addRootNode (rootNodeStatement);

      this .statements ();
   },
   rootNodeStatement: function ()
   {
      this .comments ();

      if (Grammar .DEF .parse (this))
      {
         if (this .nodeNameId ())
         {
            var
               nodeNameId = this .result [0],
               baseNode   = this .node (nodeNameId);

            if (baseNode !== false)
               return baseNode;

            throw new Error ("Expected node type name after DEF.");
         }

         throw new Error ("No name given after DEF.");
      }

      var baseNode = this .node ("");

      if (baseNode !== false)
         return baseNode;

      return false;
   },
   interfaceDeclarations: function ()
   {
      var
         interfaceDeclarations = [ ],
         field                 = this .interfaceDeclaration ();

      while (field)
      {
         interfaceDeclarations .push (field);

         field = this .interfaceDeclaration ();
      }

      return interfaceDeclarations;
   },
   restrictedInterfaceDeclaration: function ()
   {
      this .comments ();

      if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .inputOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.inputOnly);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .outputOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.outputOnly);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .initializeOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               if (this .fieldValue (field))
               {
                  field .setAccessType (Base_X3DConstants.initializeOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Couldn't read value for field '" + fieldId + "'.");
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      return null;
   },
   interfaceDeclaration: function ()
   {
      var field = this .restrictedInterfaceDeclaration ();

      if (field)
         return field;

      this .comments ();

      if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .inputOutputId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               if (this .fieldValue (field))
               {
                  field .setAccessType (Base_X3DConstants.inputOutput);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Couldn't read value for field '" + fieldId + "'.");
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ();

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      return null;
   },
   externproto: function ()
   {
      this .comments ();

      if (Grammar .EXTERNPROTO .parse (this))
      {
         if (this .nodeTypeId ())
         {
            var nodeTypeId = this .result [1];

            this .comments ();

            if (Grammar .OpenBracket .parse (this))
            {
               var externInterfaceDeclarations = this .externInterfaceDeclarations ();

               this .comments ();

               if (Grammar .CloseBracket .parse (this))
               {
                  if (this .URLList (this .MFString))
                  {
                     var externproto = new Prototype_X3DExternProtoDeclaration (this .getExecutionContext (), this .MFString);

                     for (var i = 0, length = externInterfaceDeclarations .length; i < length; ++ i)
                     {
                        var field = externInterfaceDeclarations [i];

                        externproto .addUserDefinedField (field .getAccessType (), field .getName (), field);
                     }

                     externproto .setup ();

                     try
                     {
                        const existingExternProto = this .getExecutionContext () .getExternProtoDeclaration (nodeTypeId);

                        this .getExecutionContext () .updateExternProtoDeclaration (this .getExecutionContext () .getUniqueExternProtoName (nodeTypeId), existingExternProto);
                     }
                     catch (error)
                     { }

                     this .getExecutionContext () .updateExternProtoDeclaration (nodeTypeId, externproto);
                     return true;
                  }

                  throw new Error ("Expected a URL list after EXTERNPROTO interface declaration '" + nodeTypeId + "'.");
               }

               throw new Error ("Expected a ']' at the end of EXTERNPROTO interface declaration.");
            }

            throw new Error ("Expected a '[' at the beginning of EXTERNPROTO interface declaration.");
         }

         throw new Error ("Invalid EXTERNPROTO definition name.");
      }

      return false;
   },
   externInterfaceDeclarations: function ()
   {
      var
         externInterfaceDeclarations = [ ],
         field                       = this .externInterfaceDeclaration ();

      while (field)
      {
         externInterfaceDeclarations .push (field);

         field = this .externInterfaceDeclaration ();
      }

      return externInterfaceDeclarations;
   },
   externInterfaceDeclaration: function ()
   {
      this .comments ();

      if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .inputOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.inputOnly);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .outputOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.outputOnly);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .initializeOnlyId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.initializeOnly);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
      {
         if (this .fieldType ())
         {
            var fieldType = this .result [1];

            if (this .inputOutputId ())
            {
               var
                  fieldId = this .result [1],
                  field   = this [fieldType] .create ();

               field .setAccessType (Base_X3DConstants.inputOutput);
               field .setName (fieldId);
               return field;
            }

            throw new Error ("Expected a name for field.");
         }

         this .Id ()

         throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
      }

      return null;
   },
   URLList: function (field)
   {
      return this .mfstringValue (field);
   },
   routeStatement: function ()
   {
      this .comments ();

      if (Grammar .ROUTE .parse (this))
      {
         if (this .nodeNameId ())
         {
            var
               fromNodeId = this .result [1],
               fromNode   = this .getExecutionContext () .getLocalNode (fromNodeId);

            this .comments ();

            if (Grammar .Period .parse (this))
            {
               if (this .outputOnlyId ())
               {
                  var eventOutId = this .result [1];

                  this .comments ();

                  if (Grammar .TO .parse (this))
                  {
                     if (this .nodeNameId ())
                     {
                        var
                           toNodeId = this .result [1],
                           toNode   = this .getExecutionContext () .getLocalNode (toNodeId);

                        this .comments ();

                        if (Grammar .Period .parse (this))
                        {
                           if (this .inputOnlyId ())
                           {
                              try
                              {
                                 var eventInId = this .result [1];

                                 this .getExecutionContext () .addRoute (fromNode, eventOutId, toNode, eventInId);
                                 return true;
                              }
                              catch (error)
                              {
                                 this .exception (error .message);

                                 return true;
                              }
                           }

                           throw new Error ("Bad ROUTE specification: Expected a field name.");
                        }

                        throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
                     }

                     throw new Error ("Bad ROUTE specification: Expected a node name.");
                  }

                  throw new Error ("Bad ROUTE specification: Expected a 'TO'.");
               }

               throw new Error ("Bad ROUTE specification: Expected a field name.");
            }

            throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
         }

         throw new Error ("Bad ROUTE specification: Expected a node name.");
      }

      return false;
   },
   node: function (nodeNameId)
   {
      if (this .nodeTypeId ())
      {
         var
            nodeTypeId = this .result [1],
            baseNode   = this .getExecutionContext () .createNode (nodeTypeId, false);

         if (! baseNode)
         {
            baseNode = this .getExecutionContext () .createProto (nodeTypeId, false);

            if (! baseNode)
               throw new Error ("Unknown node type or proto '" + nodeTypeId + "', you probably have insufficient component/profile statements.");
         }

         if (nodeNameId .length)
         {
            try
            {
               var namedNode = this .getExecutionContext () .getNamedNode (nodeNameId);

               this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (nodeNameId), namedNode);
            }
            catch (error)
            { }

            this .getExecutionContext () .updateNamedNode (nodeNameId, baseNode);
         }

         this .comments ();

         if (Grammar .OpenBrace .parse (this))
         {
            if (baseNode .canUserDefinedFields ())
               this .scriptBody (baseNode);

            else
               this .nodeBody (baseNode);

            this .comments ();

            if (Grammar .CloseBrace .parse (this))
            {
               if (! this .isInsideProtoDefinition ())
                  baseNode .setup ();

               return baseNode;
            }

            throw new Error ("Expected '}' at the end of node body.");
         }

         throw new Error ("Expected '{' at the beginning of node body.");
      }

      return false;
   },
   scriptBody: function (baseNode)
   {
      while (this .scriptBodyElement (baseNode))
         ;
   },
   scriptBodyElement: function (baseNode)
   {
      var
         lastIndex  = this .lastIndex,
         lineNumber = this .lineNumber;

//			var
//				input      = this .input,
//				lineNumber = this .lineNumber;

      if (this .Id ())
      {
         var accessType = this .accessTypes [this .result [1]];

         if (accessType)
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .Id ())
               {
                  var fieldId = this .result [1];

                  this .comments ();

                  if (Grammar .IS .parse (this))
                  {
                     if (this .isInsideProtoDefinition ())
                     {
                        if (this .Id ())
                        {
                           var isId = this .result [1];

                           try
                           {
                              var reference = this .getPrototype () .getField (isId);
                           }
                           catch (error)
                           {
                              this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getPrototype () .getName () + " interface declaration.");

                              return true;
                           }

                           var supportedField = this [fieldType];

                           if (supportedField .getType () === reference .getType ())
                           {
                              if (reference .isReference (accessType))
                              {
                                 try
                                 {
                                    var field = baseNode .getField (fieldId);

                                    if (! (accessType === field .getAccessType () && reference .getType () === field .getType ()))
                                    {
                                       field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
                                    }
                                 }
                                 catch (error)
                                 {
                                    var field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
                                 }

                                 field .addReference (reference);
                                 return true;
                              }

                              throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getPrototype () .getName () + "' are incompatible as an IS mapping.");
                           }

                           throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getPrototype () .getName () + "' have different types.");
                        }

                        throw new Error ("No name give after IS statement.");
                     }

                     throw new Error ("IS statement outside PROTO definition.");
                  }
               }
            }
         }
      }

      this .lastIndex  = lastIndex;
      this .lineNumber = lineNumber;

//			this .input      = input;
//			this .lineNumber = lineNumber;

      var field = this .interfaceDeclaration ();

      if (field)
      {
         try
         {
            if (field .getAccessType () === Base_X3DConstants.inputOutput)
            {
               var existingField = baseNode .getField (field .getName ());

               if (existingField .getAccessType () === Base_X3DConstants.inputOutput)
               {
                  if (field .getType () === existingField .getType ())
                  {
                     existingField .setValue (field);
                     return true;
                  }
               }
            }
         }
         catch (error)
         { }

         baseNode .addUserDefinedField (field .getAccessType (), field .getName (), field);
         return true;
      }

      return this .nodeBodyElement (baseNode);
   },
   createUserDefinedField: function (baseNode, accessType, fieldId, supportedField)
   {
      var field = supportedField .create ();

      baseNode .addUserDefinedField (accessType, fieldId, field);

      return field;
   },
   nodeBody: function (baseNode)
   {
      while (this .nodeBodyElement (baseNode))
         ;
   },
   nodeBodyElement: function (baseNode)
   {
      if (this .protoStatement ())
         return true;

      if (this .routeStatement ())
         return true;

      if (this .Id ())
      {
         var fieldId = this .result [1];

         try
         {
            var field = baseNode .getField (fieldId);
         }
         catch (error)
         {
            throw new Error ("Unknown field '" + fieldId + "' in class '" + baseNode .getTypeName () + "'.");
         }

         this .comments ();

         if (Grammar .IS .parse (this))
         {
            if (this .isInsideProtoDefinition ())
            {
               if (this .Id ())
               {
                  var isId = this .result [1];

                  try
                  {
                     var reference = this .getPrototype () .getField (isId);
                  }
                  catch (error)
                  {
                     this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getPrototype () .getName ());

                     return true;
                  }

                  if (field .getType () === reference .getType ())
                  {
                     if (reference .isReference (field .getAccessType ()))
                     {
                        field .addReference (reference);
                        return true;
                     }

                     throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getPrototype () . getName () + " are incompatible as an IS mapping.");
                  }

                  throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getPrototype () .getName () + " have different types.");
               }

               throw new Error("No name give after IS statement.");
            }

            throw new Error ("IS statement outside PROTO definition.");
         }

         if (field .isInitializable ())
         {
            if (this .fieldValue (field))
               return true;

            throw new Error ("Couldn't read value for field '" + fieldId + "'.");
         }

         throw new Error ("Couldn't assign value to " + this .accessTypeToString (field .getAccessType ()) + " field '" + fieldId + "'.");
      }

      return false;
   },
   profileNameId: function () { return this .Id (); },
   componentNameId: function ()
   {
      this .comments ();

      return Grammar .ComponentNameId .parse (this);
   },
   categoryNameId: function () { return this .Id (); },
   unitNameId: function () { return this .Id (); },
   exportedNodeNameId: function () { return this .Id (); },
   nodeNameId: function () { return this .Id (); },
   nodeTypeId: function () { return this .Id (); },
   initializeOnlyId: function () { return this .Id (); },
   inputOnlyId: function () { return this .Id (); },
   outputOnlyId: function () { return this .Id (); },
   inputOutputId: function () { return this .Id (); },
   Id: function ()
   {
      this .comments ();

      return Grammar .Id .parse (this);
   },
   fieldType: function ()
   {
      this .comments ();

      return Grammar .FieldType .parse (this);
   },
   fieldValue: function (field)
   {
      return this .fieldTypes [field .getType ()] .call (this, field);
   },
   double: function ()
   {
      this .comments ();

      if (Grammar .double .parse (this))
      {
         this .value = parseFloat (this .result [1]);
         return true;
      }

      if (Grammar .Inf .parse (this))
      {
         this .value = Number .POSITIVE_INFINITY;
         return true;
      }

      if (Grammar .NegativeInf .parse (this))
      {
         this .value = Number .NEGATIVE_INFINITY;
         return true;
      }

      if (Grammar .NaN .parse (this))
      {
         this .value = Number .NaN;
         return true;
      }

      return false;
   },
   int32: function ()
   {
      this .comments ();

      if (Grammar .int32 .parse (this))
      {
         this .value = parseInt (this .result [1]);
         return true;
      }

      return false;
   },
   string: function ()
   {
      this .comments ();

      if (Grammar .string .parse (this))
      {
         this .value = x_ite_Fields.SFString.unescape (this .result [1]);

         this .lines (this .value);

         return true;
      }

      return false;
   },
   sfboolValue: function (field)
   {
      this .comments ();

      if (Grammar .TRUE .parse (this))
      {
         field .setValue (true);
         return true;
      }

      if (Grammar .FALSE .parse (this))
      {
         field .setValue (false);
         return true;
      }

      return false;
   },
   mfboolValue: function (field)
   {
      field .length = 0;

      if (this .sfboolValue (this .SFBool))
      {
         field .push (this .SFBool);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfboolValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfboolValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfboolValue (this .SFBool))
      {
         field .push (this .SFBool);
      }
   },
   sfcolorValue: function (field)
   {
      if (this .double ())
      {
         var r = this .value;

         if (this .double ())
         {
            var g = this .value;

            if (this .double ())
            {
               var b = this .value;

               field .r = r;
               field .g = g;
               field .b = b;

               return true;
            }
         }
      }

      return false;
   },
   mfcolorValue: function (field)
   {
      field .length = 0;

      if (this .sfcolorValue (this .SFColor))
      {
         field .push (this .SFColor);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfcolorValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfcolorValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfcolorValue (this .SFColor))
      {
         field .push (this .SFColor);
      }
   },
   sfcolorrgbaValue: function (field)
   {
      if (this .double ())
      {
         var r = this .value;

         if (this .double ())
         {
            var g = this .value;

            if (this .double ())
            {
               var b = this .value;

               if (this .double ())
               {
                  var a = this .value;

                  field .r = r;
                  field .g = g;
                  field .b = b;
                  field .a = a;

                  return true;
               }
            }
         }
      }

      return false;
   },
   mfcolorrgbaValue: function (field)
   {
      field .length = 0;

      if (this .sfcolorrgbaValue (this .SFColorRGBA))
      {
         field .push (this .SFColorRGBA);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfcolorrgbaValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfcolorrgbaValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfcolorrgbaValue (this .SFColorRGBA))
      {
         field .push (this .SFColorRGBA);
      }
   },
   sfdoubleValue: function (field)
   {
      if (this .double ())
      {
         field .setValue (this .fromUnit (field .getUnit (), this .value));
         return true;
      }

      return false;
   },
   mfdoubleValue: function (field)
   {
      field .length = 0;

      this .SFDouble .setUnit (field .getUnit ());

      if (this .sfdoubleValue (this .SFDouble))
      {
         field .push (this .SFDouble);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfdoubleValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfdoubleValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFDouble .setUnit (field .getUnit ());

      while (this .sfdoubleValue (this .SFDouble))
      {
         field .push (this .SFDouble);
      }
   },
   sffloatValue: function (field)
   {
      return this .sfdoubleValue (field);
   },
   mffloatValue: function (field)
   {
      field .length = 0;

      this .SFFloat .setUnit (field .getUnit ());

      if (this .sffloatValue (this .SFFloat))
      {
         field .push (this .SFFloat);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sffloatValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sffloatValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFFloat .setUnit (field .getUnit ());

      while (this .sffloatValue (this .SFFloat))
      {
         field .push (this .SFFloat);
      }
   },
   sfimageValue: function (field)
   {
      if (this .int32 ())
      {
         var width = this .value;

         if (this .int32 ())
         {
            var height = this .value;

            if (this .int32 ())
            {
               var
                  comp  = this .value,
                  size  = width * height;

               field .width  = width;
               field .height = height;
               field .comp   = comp;

               var array = field .array;

               for (var i = 0; i < size; ++ i)
               {
                  if (this .int32 ())
                  {
                     array [i] = this .value;
                     continue;
                  }

                  return false;
               }

               return true;
            }
         }
      }

      return false;
   },
   mfimageValue: function (field)
   {
      field .length = 0;

      if (this .sfimageValue (this .SFImage))
      {
         field .push (this .SFImage);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfimageValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfimageValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfimageValue (this .SFImage))
      {
         field .push (this .SFImage);
      }
   },
   sfint32Value: function (field)
   {
      if (this .int32 ())
      {
         field .setValue (this .value);
         return true;
      }

      return false;
   },
   mfint32Value: function (field)
   {
      field .length = 0;

      if (this .sfint32Value (this .SFInt32))
      {
         field .push (this .SFInt32);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfint32Values (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfint32Values: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfint32Value (this .SFInt32))
      {
         field .push (this .SFInt32);
      }
   },
   sfmatrix3dValue: function (field)
   {
      if (this .double ())
      {
         var m00 = this .value;

         if (this .double ())
         {
            var m01 = this .value;

            if (this .double ())
            {
               var m02 = this .value;

                  if (this .double ())
                  {
                     var m10 = this .value;

                     if (this .double ())
                     {
                        var m11 = this .value;

                        if (this .double ())
                        {
                           var m12 = this .value;

                           if (this .double ())
                           {
                              var m20 = this .value;

                              if (this .double ())
                              {
                                 var m21 = this .value;

                                 if (this .double ())
                                 {
                                    var m22 = this .value;

                                    field [0] = m00;
                                    field [1] = m01;
                                    field [2] = m02;
                                    field [3] = m10;
                                    field [4] = m11;
                                    field [5] = m12;
                                    field [6] = m20;
                                    field [7] = m21;
                                    field [8] = m22;

                                    return true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

      return false;
   },
   mfmatrix3dValue: function (field)
   {
      field .length = 0;

      if (this .sfmatrix3dValue (this .SFMatrix3d))
      {
         field .push (this .SFMatrix3d);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfmatrix3dValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfmatrix3dValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfmatrix3dValue (this .SFMatrix3d))
      {
         field .push (this .SFMatrix3d);
      }
   },
   sfmatrix3fValue: function (field)
   {
      return this .sfmatrix3dValue (field);
   },
   mfmatrix3fValue: function (field)
   {
      field .length = 0;

      if (this .sfmatrix3fValue (this .SFMatrix3f))
      {
         field .push (this .SFMatrix3f);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfmatrix3fValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfmatrix3fValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfmatrix3fValue (this .SFMatrix3f))
      {
         field .push (this .SFMatrix3f);
      }
   },
   sfmatrix4dValue: function (field)
   {
      if (this .double ())
      {
         var m00 = this .value;

         if (this .double ())
         {
            var m01 = this .value;

            if (this .double ())
            {
               var m02 = this .value;

               if (this .double ())
               {
                  var m03 = this .value;

                  if (this .double ())
                  {
                     var m10 = this .value;

                     if (this .double ())
                     {
                        var m11 = this .value;

                        if (this .double ())
                        {
                           var m12 = this .value;

                           if (this .double ())
                           {
                              var m13 = this .value;

                              if (this .double ())
                              {
                                 var m20 = this .value;

                                 if (this .double ())
                                 {
                                    var m21 = this .value;

                                    if (this .double ())
                                    {
                                       var m22 = this .value;

                                       if (this .double ())
                                       {
                                          var m23 = this .value;

                                          if (this .double ())
                                          {
                                             var m30 = this .value;

                                             if (this .double ())
                                             {
                                                var m31 = this .value;

                                                if (this .double ())
                                                {
                                                   var m32 = this .value;

                                                   if (this .double ())
                                                   {
                                                      var m33 = this .value;

                                                      field [ 0] = m00;
                                                      field [ 1] = m01;
                                                      field [ 2] = m02;
                                                      field [ 3] = m03;
                                                      field [ 4] = m10;
                                                      field [ 5] = m11;
                                                      field [ 6] = m12;
                                                      field [ 7] = m13;
                                                      field [ 8] = m20;
                                                      field [ 9] = m21;
                                                      field [10] = m22;
                                                      field [11] = m23;
                                                      field [12] = m30;
                                                      field [13] = m31;
                                                      field [14] = m32;
                                                      field [15] = m33;

                                                      return true;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }

      return false;
   },
   mfmatrix4dValue: function (field)
   {
      field .length = 0;

      if (this .sfmatrix4dValue (this .SFMatrix4d))
      {
         field .push (this .SFMatrix4d);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfmatrix4dValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfmatrix4dValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfmatrix4dValue (this .SFMatrix4d))
      {
         field .push (this .SFMatrix4d);
      }
   },
   sfmatrix4fValue: function (field)
   {
      return this .sfmatrix4dValue (field);
   },
   mfmatrix4fValue: function (field)
   {
      field .length = 0;

      if (this .sfmatrix4fValue (this .SFMatrix4f))
      {
         field .push (this .SFMatrix4f);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfmatrix4fValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfmatrix4fValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfmatrix4fValue (this .SFMatrix4f))
      {
         field .push (this .SFMatrix4f);
      }
   },
   sfnodeValue: function (field)
   {
      var baseNode = this .nodeStatement ();

      if (baseNode !== false)
      {
         field .setValue (baseNode);
         return true;
      }

      return false;
   },
   mfnodeValue: function (field)
   {
      field .length = 0;

      var node = this .nodeStatement ();

      if (node !== false)
      {
         field .push (node);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .nodeStatements (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   nodeStatements: function (field)
   {
      var node = this .nodeStatement ();

      while (node !== false)
      {
         field .push (node);

         node = this .nodeStatement ();
      }
   },
   sfrotationValue: function (field)
   {
      if (this .double ())
      {
         var x = this .value;

         if (this .double ())
         {
            var y = this .value;

            if (this .double ())
            {
               var z = this .value;

               if (this .double ())
               {
                  var angle = this .value;

                  field .x     = x;
                  field .y     = y;
                  field .z     = z;
                  field .angle = this .fromUnit ("angle", angle);

                  return true;
               }
            }
         }
      }

      return false;
   },
   mfrotationValue: function (field)
   {
      field .length = 0;

      if (this .sfrotationValue (this .SFRotation))
      {
         field .push (this .SFRotation);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfrotationValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfrotationValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfrotationValue (this .SFRotation))
      {
         field .push (this .SFRotation);
      }
   },
   sfstringValue: function (field)
   {
      if (this .string ())
      {
         field .setValue (this .value);
         return true;
      }

      return false;
   },
   mfstringValue: function (field)
   {
      field .length = 0;

      if (this .sfstringValue (this .SFString))
      {
         field .push (this .SFString);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfstringValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfstringValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sfstringValue (this .SFString))
      {
         field .push (this .SFString);
      }
   },
   sftimeValue: function (field)
   {
      return this .sfdoubleValue (field);
   },
   mftimeValue: function (field)
   {
      field .length = 0;

      if (this .sftimeValue (this .SFTime))
      {
         field .push (this .SFTime);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sftimeValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sftimeValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      while (this .sftimeValue (this .SFTime))
      {
         field .push (this .SFTime);
      }
   },
   sfvec2dValue: function (field)
   {
      if (this .double ())
      {
         var x = this .value;

         if (this .double ())
         {
            var
               y        = this .value,
               category = field .getUnit ();

            field .x = this .fromUnit (category, x);
            field .y = this .fromUnit (category, y);

            return true;
         }
      }

      return false;
   },
   mfvec2dValue: function (field)
   {
      field .length = 0;

      this .SFVec2d .setUnit (field .getUnit ());

      if (this .sfvec2dValue (this .SFVec2d))
      {
         field .push (this .SFVec2d);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec2dValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec2dValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec2d .setUnit (field .getUnit ());

      while (this .sfvec2dValue (this .SFVec2d))
      {
         field .push (this .SFVec2d);
      }
   },
   sfvec2fValue: function (field)
   {
      return this .sfvec2dValue (field);
   },
   mfvec2fValue: function (field)
   {
      field .length = 0;

      this .SFVec2f .setUnit (field .getUnit ());

      if (this .sfvec2fValue (this .SFVec2f))
      {
         field .push (this .SFVec2f);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec2fValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec2fValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec2f .setUnit (field .getUnit ());

      while (this .sfvec2fValue (this .SFVec2f))
      {
         field .push (this .SFVec2f);
      }
   },
   sfvec3dValue: function (field)
   {
      if (this .double ())
      {
         var x = this .value;

         if (this .double ())
         {
            var y = this .value;

            if (this .double ())
            {
               var
                  z        = this .value,
                  category = field .getUnit ();

               field .x = this .fromUnit (category, x);
               field .y = this .fromUnit (category, y);
               field .z = this .fromUnit (category, z);

               return true;
            }
         }
      }

      return false;
   },
   mfvec3dValue: function (field)
   {
      field .length = 0;

      this .SFVec3d .setUnit (field .getUnit ());

      if (this .sfvec3dValue (this .SFVec3d))
      {
         field .push (this .SFVec3d);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec3dValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec3dValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec3d .setUnit (field .getUnit ());

      while (this .sfvec3dValue (this .SFVec3d))
      {
         field .push (this .SFVec3d);
      }
   },
   sfvec3fValue: function (field)
   {
      return this .sfvec3dValue (field);
   },
   mfvec3fValue: function (field)
   {
      field .length = 0;

      this .SFVec3f .setUnit (field .getUnit ());

      if (this .sfvec3fValue (this .SFVec3f))
      {
         field .push (this .SFVec3f);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec3fValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec3fValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec3f .setUnit (field .getUnit ());

      while (this .sfvec3fValue (this .SFVec3f))
      {
         field .push (this .SFVec3f);
      }
   },
   sfvec4dValue: function (field)
   {
      if (this .double ())
      {
         var x = this .value;

         if (this .double ())
         {
            var y = this .value;

            if (this .double ())
            {
               var z = this .value;

               if (this .double ())
               {
                  var
                     w        = this .value,
                     category = field .getUnit ();

                  field .x = this .fromUnit (category, x);
                  field .y = this .fromUnit (category, y);
                  field .z = this .fromUnit (category, z);
                  field .w = this .fromUnit (category, w);

                  return true;
               }
            }
         }
      }

      return false;
   },
   mfvec4dValue: function (field)
   {
      field .length = 0;

      this .SFVec4d .setUnit (field .getUnit ());

      if (this .sfvec4dValue (this .SFVec4d))
      {
         field .push (this .SFVec4d);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec4dValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec4dValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec4d .setUnit (field .getUnit ());

      while (this .sfvec4dValue (this .SFVec4d))
      {
         field .push (this .SFVec4d);
      }
   },
   sfvec4fValue: function (field)
   {
      return this .sfvec4dValue (field);
   },
   mfvec4fValue: function (field)
   {
      field .length = 0;

      this .SFVec4f .setUnit (field .getUnit ());

      if (this .sfvec4fValue (this .SFVec4f))
      {
         field .push (this .SFVec4f);
         return true;
      }

      if (Grammar .OpenBracket .parse (this))
      {
         this .sfvec4fValues (field);

         this .comments ();

         if (Grammar .CloseBracket .parse (this))
            return true;

         throw new Error ("Expected ']'.");
      }

      return false;
   },
   sfvec4fValues: function (field)
   {
      field .length = 0;
      field         = field .getTarget ();

      this .SFVec4f .setUnit (field .getUnit ());

      while (this .sfvec4fValue (this .SFVec4f))
      {
         field .push (this .SFVec4f);
      }
   },
   accessTypeToString: function (accessType)
   {
      switch (accessType)
      {
         case Base_X3DConstants.initializeOnly:
            return "initializeOnly";
         case Base_X3DConstants.inputOnly:
            return "inputOnly";
         case Base_X3DConstants.outputOnly:
            return "outputOnly";
         case Base_X3DConstants.inputOutput:
            return "inputOutput";
      }
   },
});

VRMLParser .prototype .fieldTypes = [ ];
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFBool]      = VRMLParser .prototype .sfboolValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFColor]     = VRMLParser .prototype .sfcolorValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFColorRGBA] = VRMLParser .prototype .sfcolorrgbaValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFDouble]    = VRMLParser .prototype .sfdoubleValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFFloat]     = VRMLParser .prototype .sffloatValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFImage]     = VRMLParser .prototype .sfimageValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFInt32]     = VRMLParser .prototype .sfint32Value;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix3f]  = VRMLParser .prototype .sfmatrix3dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix3d]  = VRMLParser .prototype .sfmatrix3fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix4f]  = VRMLParser .prototype .sfmatrix4dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix4d]  = VRMLParser .prototype .sfmatrix4fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFNode]      = VRMLParser .prototype .sfnodeValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFRotation]  = VRMLParser .prototype .sfrotationValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFString]    = VRMLParser .prototype .sfstringValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFTime]      = VRMLParser .prototype .sftimeValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec2d]     = VRMLParser .prototype .sfvec2dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec2f]     = VRMLParser .prototype .sfvec2fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec3d]     = VRMLParser .prototype .sfvec3dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec3f]     = VRMLParser .prototype .sfvec3fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec4d]     = VRMLParser .prototype .sfvec4dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec4f]     = VRMLParser .prototype .sfvec4fValue;

VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFBool]      = VRMLParser .prototype .mfboolValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFColor]     = VRMLParser .prototype .mfcolorValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFColorRGBA] = VRMLParser .prototype .mfcolorrgbaValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFDouble]    = VRMLParser .prototype .mfdoubleValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFFloat]     = VRMLParser .prototype .mffloatValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFImage]     = VRMLParser .prototype .mfimageValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFInt32]     = VRMLParser .prototype .mfint32Value;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3d]  = VRMLParser .prototype .mfmatrix3dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3f]  = VRMLParser .prototype .mfmatrix3fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4d]  = VRMLParser .prototype .mfmatrix4dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4f]  = VRMLParser .prototype .mfmatrix4fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFNode]      = VRMLParser .prototype .mfnodeValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFRotation]  = VRMLParser .prototype .mfrotationValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFString]    = VRMLParser .prototype .mfstringValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFTime]      = VRMLParser .prototype .mftimeValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2d]     = VRMLParser .prototype .mfvec2dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2f]     = VRMLParser .prototype .mfvec2fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3d]     = VRMLParser .prototype .mfvec3dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3f]     = VRMLParser .prototype .mfvec3fValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4d]     = VRMLParser .prototype .mfvec4dValue;
VRMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4f]     = VRMLParser .prototype .mfvec4fValue;

/* harmony default export */ const Parser_VRMLParser = (VRMLParser);

;// CONCATENATED MODULE: ./src/x_ite/Parser/XMLParser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













const _dom = Symbol .for ("X_ITE.dom");

const AccessType =
{
   initializeOnly: Base_X3DConstants.initializeOnly,
   inputOnly:      Base_X3DConstants.inputOnly,
   outputOnly:     Base_X3DConstants.outputOnly,
   inputOutput:    Base_X3DConstants.inputOutput,
};

function XMLParser (scene)
{
   Parser_X3DParser.call (this, scene);

   this .protoDeclarations = [ ];
   this .parents           = [ ];
   this .parser            = new Parser_VRMLParser (scene);
   this .url               = new x_ite_Fields.MFString ();

   try
   {
      this .setUnits (this .getScene () .getMetaData ("generator"));
      this .parser .setUnits (this .getUnits ());
   }
   catch (error)
   { }
}

XMLParser .prototype = Object .assign (Object .create (Parser_X3DParser.prototype),
{
   constructor: XMLParser,
   isValid: function ()
   {
      return (this .input instanceof XMLDocument) || (this .input instanceof HTMLElement) || (this .input === null);
   },
   getInput: function ()
   {
      return this .input;
   },
   setInput (xmlElement)
   {
      try
      {
         if (typeof xmlElement === "string")
            xmlElement = $.parseXML (xmlElement);

         this .input = xmlElement;
      }
      catch (error)
      {
         this .input = undefined;
      }
   },
   parseIntoScene: function (success, error)
   {
      this .scene [_dom] = this .input;
      this .success      = success;
      this .error        = error;

      this .getScene () .setEncoding ("XML");
      this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));

      this .xmlElement (this .input);
   },
   parseIntoNode: function (node, xmlElement)
   {
      this .pushExecutionContext (node .getExecutionContext ());
      this .pushParent (node);

      this .childElement (xmlElement);

      this .popParent ();
      this .popExecutionContext ();
   },
   xmlElement: function (xmlElement)
   {
      if (xmlElement === null)
      {
         if (this .success)
            return this .success (this .getScene ());
      }

      switch (xmlElement .nodeName)
      {
         case "#document":
         {
            var X3D = $(xmlElement) .children ("X3D");

            if (X3D .length)
            {
               for (var i = 0; i < X3D .length; ++ i)
                  this .x3dElement (X3D [i]);
            }
            else
            {
               if (this .success)
               {
                  Promise .all (this .getProviderUrls () .map (url => import (/* webpackIgnore: true */ url)))
                  .then (function ()
                  {
                     this .childrenElements (xmlElement);
                     this .success (this .getScene ());
                  }
                  .bind (this))
                  .catch (function (error)
                  {
                     if (this .error)
                        this .error (error);
                  }
                  .bind (this));
               }
               else
               {
                  this .childrenElements (xmlElement);
               }
            }

            break;
         }
         case "X3D":
         {
            this .x3dElement (xmlElement);
            break;
         }
         case "Scene":
         case "SCENE":
         {
            if (this .success)
            {
               Promise .all (this .getProviderUrls () .map (url => import (/* webpackIgnore: true */ url)))
               .then (function ()
               {
                  this .sceneElement (xmlElement);
                  this .success (this .getScene ());
               }
               .bind (this))
               .catch (function (error)
               {
                  if (this .error)
                     this .error (error);
               }
               .bind (this));
            }
            else
            {
               this .sceneElement (xmlElement);
            }

            break;
         }
         default:
         {
            if (this .success)
            {
               Promise .all (this .getProviderUrls () .map (url => import (/* webpackIgnore: true */ url)))
               .then (function ()
               {
                  this .childrenElements (xmlElement);
                  this .success (this .getScene ());
               }
               .bind (this))
               .catch (function (error)
               {
                  if (this .error)
                     this .error (error);
               }
               .bind (this));
            }
            else
            {
               this .childrenElements (xmlElement);
            }

            break;
         }
      }
   },
   x3dElement: function (xmlElement)
   {
      try
      {
         // Profile

         var
            profileNameId = xmlElement .getAttribute ("profile"),
            profile       = this .getBrowser () .getProfile (profileNameId || "Full");

         this .getScene () .setProfile (profile);
      }
      catch (error)
      {
         console .error (error);
      }

      // Specification version

      var specificationVersion = xmlElement .getAttribute ("version");

      if (specificationVersion)
         this .getScene () .setSpecificationVersion (specificationVersion);

      // Process child nodes

      var childNodes = xmlElement .childNodes;

      for (var i = 0; i < childNodes .length; ++ i)
         this .x3dElementChildHead (childNodes [i])

      if (this .success)
      {
         Promise .all (this .getProviderUrls () .map (url => import (/* webpackIgnore: true */ url)))
         .then (function ()
         {
            for (var i = 0; i < childNodes .length; ++ i)
               this .x3dElementChildScene (childNodes [i])

            this .success (this .getScene ());
         }
         .bind (this))
         .catch (function (error)
         {
            if (this .error)
               this .error (error);
         }
         .bind (this));
      }
      else
      {
         for (var i = 0; i < childNodes .length; ++ i)
            this .x3dElementChildScene (childNodes [i])
      }
   },
   x3dElementChildHead: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "head":
         case "HEAD":
            this .headElement (xmlElement);
            return;
      }
   },
   x3dElementChildScene: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "Scene":
         case "SCENE":
            this .sceneElement (xmlElement);
            return;
      }
   },
   headElement: function (xmlElement)
   {
      var childNodes = xmlElement .childNodes;

      for (var i = 0; i < childNodes .length; ++ i)
         this .headElementChild (childNodes [i]);

      try
      {
         this .setUnits (this .getScene () .getMetaData ("generator"));
         this .parser .setUnits (this .getUnits ());
      }
      catch (error)
      { }
   },
   headElementChild: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "component":
         case "COMPONENT":
            this .componentElement (xmlElement);
            return;
         case "unit":
         case "UNIT":
            this .unitElement (xmlElement);
            return;
         case "meta":
         case "META":
            this .metaElement (xmlElement);
            return;
      }
   },
   componentElement: function (xmlElement)
   {
      try
      {
         var
            componentNameIdCharacters = xmlElement .getAttribute ("name"),
            componentSupportLevel = parseInt (xmlElement .getAttribute ("level"));

         if (componentNameIdCharacters === null)
            return console .warn ("XML Parser Error: Bad component statement: Expected name attribute.");

         if (componentSupportLevel === null)
            return console .warn ("XML Parser Error: Bad component statement: Expected level attribute.");

         var component = this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);

         this .getScene () .addComponent (component);
      }
      catch (error)
      {
         console .log (error .message);
      }
   },
   unitElement: function (xmlElement)
   {
      var
         category         = xmlElement .getAttribute ("category"),
         name             = xmlElement .getAttribute ("name"),
         conversionFactor = xmlElement .getAttribute ("conversionFactor"); //works for html5 as well

      if (category === null)
         return console .warn ("XML Parser Error: Bad unit statement: Expected category attribute.");

      if (name === null)
         return console .warn ("XML Parser Error: Bad unit statement: Expected name attribute.");

      if (conversionFactor === null)
         return console .warn ("XML Parser Error: Bad unit statement: Expected conversionFactor attribute.");

      this .getScene () .updateUnit (category, name, parseFloat (conversionFactor));
   },
   metaElement: function (xmlElement)
   {
      var
         metakey   = xmlElement .getAttribute ("name"),
         metavalue = xmlElement .getAttribute ("content");

      if (metakey === null)
         return console .warn ("XML Parser Error: Bad meta statement: Expected name attribute.");

      if (metavalue === null)
         return console .warn ("XML Parser Error: Bad meta statement: Expected content attribute.");

      this .getScene () .setMetaData (metakey, metavalue);
   },
   sceneElement: function (xmlElement)
   {
      this .childrenElements (xmlElement);
   },
   childrenElements: function (xmlElement)
   {
      var childNodes = xmlElement .childNodes;

      for (var i = 0; i < childNodes .length; ++ i)
         this .childElement (childNodes [i]);
   },
   childElement: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "#comment":
         case "#text":
            return;

         case "#cdata-section":
            this .cdataNode (xmlElement);
            return;

         case "ExternProtoDeclare":
         case "EXTERNPROTODECLARE":
            this .externProtoDeclareElement (xmlElement);
            return;

         case "ProtoDeclare":
         case "PROTODECLARE":
            this .protoDeclareElement (xmlElement);
            return;

         case "IS":
            this .isElement (xmlElement);
            return;

         case "ProtoInstance":
         case "PROTOINSTANCE":
            this .protoInstanceElement (xmlElement);
            return;

         case "fieldValue":
         case "FIELDVALUE":
            this .fieldValueElement (xmlElement);
            return;

         case "field":
         case "FIELD":
            this .fieldElement (xmlElement);
            return;

         case "ROUTE":
            this .routeElement (xmlElement);
            return;

         case "IMPORT":
            this .importElement (xmlElement);
            return;

         case "EXPORT":
            this .exportElement (xmlElement);
            return;

         default:
            this .nodeElement (xmlElement);
            return;
      }
   },
   externProtoDeclareElement: function (xmlElement)
   {
      var name = xmlElement .getAttribute ("name");

      if (this .id (name))
      {
         var url = xmlElement .getAttribute ("url");

         if (url === null)
            return console .warn ("XML Parser Error: Bad ExternProtoDeclare statement: Expected url attribute.");

         this .parser .setInput (url);
         Parser_VRMLParser.prototype.sfstringValues.call (this .parser, this .url);

         var externproto = new Prototype_X3DExternProtoDeclaration (this .getExecutionContext (), this .url);

         this .pushParent (externproto);
         this .protoInterfaceElement (xmlElement); // parse fields
         this .popParent ();

         externproto .setup ();

         try
         {
            const existingExternProto = this .getExecutionContext () .getExternProtoDeclaration (name);

            this .getExecutionContext () .updateExternProtoDeclaration (this .getExecutionContext () .getUniqueExternProtoName (name), existingExternProto);
         }
         catch (error)
         { }

         this .getExecutionContext () .updateExternProtoDeclaration (name, externproto);
      }
   },
   protoDeclareElement: function (xmlElement)
   {
      var name = xmlElement .getAttribute ("name");

      if (this .id (name))
      {
         var
            proto      = new Prototype_X3DProtoDeclaration (this .getExecutionContext ()),
            childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
         {
            var child = childNodes [i];

            switch (child .nodeName)
            {
               case "ProtoInterface":
               case "PROTOINTERFACE":
               {
                  this .pushParent (proto);
                  this .protoInterfaceElement (child);
                  this .popParent ();
                  break;
               }
               default:
                  continue;
            }

            break;
         }

         for (var i = 0; i < childNodes .length; ++ i)
         {
            var child = childNodes [i];

            switch (child .nodeName)
            {
               case "ProtoBody":
               case "PROTOBODY":
               {
                  this .pushPrototype (proto);
                  this .pushExecutionContext (proto .getBody ());
                  this .pushParent (proto);
                  this .protoBodyElement (child);
                  this .popParent ();
                  this .popExecutionContext ();
                  this .popPrototype ();
                  break;
               }
               default:
                  continue;
            }

            break;
         }

         proto .setup ();

         try
         {
            const existingProto = this .getExecutionContext () .getProtoDeclaration (name);

            this .getExecutionContext () .updateProtoDeclaration (this .getExecutionContext () .getUniqueProtoName (name), existingProto);
         }
         catch (error)
         { }

         this .getExecutionContext () .updateProtoDeclaration (name, proto);
      }
   },
   protoInterfaceElement: function (xmlElement)
   {
      var childNodes = xmlElement .childNodes;

      for (var i = 0; i < childNodes .length; ++ i)
         this .protoInterfaceElementChild (childNodes [i]);
   },
   protoInterfaceElementChild: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "field": // User-defined field
         case "FIELD": // User-defined field
            this .fieldElement (xmlElement);
            return;
      }
   },
   fieldElement: function (xmlElement)
   {
      try
      {
         if (this .getParents () .length === 0)
            return;

         var node = this .getParent ();

         if (! (node instanceof Base_X3DBaseNode))
            return;

         if (! node .canUserDefinedFields ())
            return;

         var accessType = AccessType [xmlElement .getAttribute ("accessType")];

         if (accessType === undefined)
            accessType = Base_X3DConstants.initializeOnly;

         var type = x_ite_Fields [xmlElement .getAttribute ("type")];

         if (type === undefined)
            return;

         var name = xmlElement .getAttribute ("name");

         if (! this .id (name))
            return;

         var field = new type ();

         if (accessType & Base_X3DConstants.initializeOnly)
         {
            this .fieldValue (field, xmlElement .getAttribute ("value"));

            this .pushParent (field);
            this .childrenElements (xmlElement);
            this .popParent ();
         }

         node .addUserDefinedField (accessType, name, field);
      }
      catch (error)
      {
         //console .error (error);
      }
   },
   protoBodyElement: function (xmlElement)
   {
      this .childrenElements (xmlElement);
   },
   isElement: function (xmlElement)
   {
      if (this .isInsideProtoDefinition ())
      {
         var childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
            this .isElementChild (childNodes [i]);
      }
   },
   isElementChild: function (xmlElement)
   {
      switch (xmlElement .nodeName)
      {
         case "connect":
         case "CONNECT":
            this .connectElement (xmlElement);
            return;
      }
   },
   connectElement: function (xmlElement)
   {
      var
         nodeFieldName  = xmlElement .getAttribute ("nodeField"),
         protoFieldName = xmlElement .getAttribute ("protoField");

      if (nodeFieldName === null)
         return console .warn ("XML Parser Error: Bad connect statement: Expected nodeField attribute.");

      if (protoFieldName === null)
         return console .warn ("XML Parser Error: Bad connect statement: Expected protoField attribute.");

      try
      {
         if (this .getParents () .length === 0)
            return;

         var
            node  = this .getParent (),
            proto = this .getPrototype ();

         if (! (node instanceof Base_X3DBaseNode))
            return;

         var
            nodeField  = node .getField (nodeFieldName),
            protoField = proto .getField (protoFieldName);

         if (nodeField .getType () === protoField .getType ())
         {
            if (protoField .isReference (nodeField .getAccessType ()))
               nodeField .addReference (protoField);
            else
               throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + proto .getName () + " are incompatible as an IS mapping.");
         }
         else
            throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + this .proto .getName () + " have different types.");
      }
      catch (error)
      {
         console .warn ("XML Parser Error: Couldn't create IS reference: " + error .message);
      }
   },
   protoInstanceElement: function (xmlElement)
   {
      try
      {
         if (this .useAttribute (xmlElement))
            return;

         var name = xmlElement .getAttribute ("name");

         if (this .id (name))
         {
            var node = this .getExecutionContext () .createProto (name, false);

            if (! node)
               throw new Error ("Unknown proto or externproto type '" + name + "'.");

            //AP: attach node to DOM xmlElement for access from DOM.
            xmlElement .x3d = node;

            this .defAttribute (xmlElement, node);
            this .addNode (xmlElement, node);
            this .pushParent (node);
            this .childrenElements (xmlElement);

            if (! this .isInsideProtoDefinition ())
               node .setup ();

            this .popParent ();
         }
      }
      catch (error)
      {
         console .warn ("XML Parser Error: ", error .message);
         //console .error (error);
      }
   },
   fieldValueElement: function (xmlElement)
   {
      try
      {
         if (this .getParents () .length === 0)
            return;

         var
            node = this .getParent (),
            name = xmlElement .getAttribute ("name");

         if (! (node instanceof Core_X3DPrototypeInstance))
            return;

         if (! this .id (name))
            return;

         var
            field      = node .getField (name),
            accessType = field .getAccessType ();

         if (accessType & Base_X3DConstants.initializeOnly)
         {
            if (field .getType () === Base_X3DConstants.MFNode)
            {
               field .length = 0
            }

            this .fieldValue (field, xmlElement .getAttribute ("value"));

            this .pushParent (field);
            this .childrenElements (xmlElement);
            this .popParent ();
         }
      }
      catch (error)
      {
         console .warn ("XML Parser Error: Couldn't assign field value: " + error .message);
      }
   },
   nodeElement: function (xmlElement)
   {
      try
      {
         if (this .useAttribute (xmlElement))
            return;

         var node = this .getExecutionContext () .createNode (this .nodeNameToCamelCase (xmlElement .nodeName), false);

         if (! node)
            throw new Error ("Unknown node type '" + xmlElement .nodeName + "', you probably have insufficient component/profile statements.");

         //AP: attach node to DOM xmlElement for access from DOM.
         xmlElement .x3d = node;

         this .defAttribute (xmlElement, node);
         this .addNode (xmlElement, node);
         this .pushParent (node);
         this .nodeAttributes (xmlElement, node);
         this .childrenElements (xmlElement);

         if (! this .isInsideProtoDefinition ())
            node .setup ();

         this .popParent ();
      }
      catch (error)
      {
         // NULL

         if (xmlElement .nodeName == "NULL")
         {
            this .addNode (xmlElement, null);
            return;
         }

         console .error (error);

         console .error ("XML Parser Error: " + error .message);
      }
   },
   routeElement: function (xmlElement)
   {
      try
      {
         var
            sourceNodeName      = xmlElement .getAttribute ("fromNode"),
            sourceField         = xmlElement .getAttribute ("fromField"),
            destinationNodeName = xmlElement .getAttribute ("toNode"),
            destinationField    = xmlElement .getAttribute ("toField");

         if (sourceNodeName === null)
            throw new Error ("Bad ROUTE statement: Expected fromNode attribute.");

         if (sourceField === null)
            throw new Error ("Bad ROUTE statement: Expected fromField attribute.");

         if (destinationNodeName === null)
            throw new Error ("Bad ROUTE statement: Expected toNode attribute.");

         if (destinationField === null)
            throw new Error ("Bad ROUTE statement: Expected toField attribute.");

         var
            executionContext = this .getExecutionContext (),
            sourceNode       = executionContext .getLocalNode (sourceNodeName),
            destinationNode  = executionContext .getLocalNode (destinationNodeName),
            route            = executionContext .addRoute (sourceNode, sourceField, destinationNode, destinationField);

         xmlElement .x3d = route;
      }
      catch (error)
      {
         console .error (error);
         console .warn ("XML Parser Error: " + error .message);
      }
   },
   importElement: function (xmlElement)
   {
      try
      {
         var
            inlineNodeName   = xmlElement .getAttribute ("inlineDEF"),
            exportedNodeName = xmlElement .getAttribute ("importedDEF") || xmlElement .getAttribute ("exportedDEF"),
            localNodeName    = xmlElement .getAttribute ("AS");

         if (inlineNodeName === null)
            throw new Error ("Bad IMPORT statement: Expected inlineDEF attribute.");

         if (exportedNodeName === null)
            throw new Error ("Bad IMPORT statement: Expected importedDEF attribute.");

         if (! localNodeName)
            localNodeName = exportedNodeName;

         var inlineNode = this .getExecutionContext () .getNamedNode (inlineNodeName);

         this .getExecutionContext () .updateImportedNode (inlineNode, exportedNodeName, localNodeName);
      }
      catch (error)
      {
         console .warn ("XML Parser Error: " + error .message);
      }
   },
   exportElement: function (xmlElement)
   {
      try
      {
         if (this .getScene () !== this .getExecutionContext ())
         {
            console .warn ("XML Parser Error: Export statement not allowed here.");
            return;
         }

         var
            localNodeName    = xmlElement .getAttribute ("localDEF"),
            exportedNodeName = xmlElement .getAttribute ("AS");

         if (localNodeName === null)
            throw new Error ("Bad EXPORT statement: Expected localDEF attribute.");

         if (! exportedNodeName)
            exportedNodeName = localNodeName;

         var localNode = this .getExecutionContext () .getLocalNode (localNodeName);

         this .getScene () .updateExportedNode (exportedNodeName, localNode);
      }
      catch (error)
      {
         console .warn ("XML Parser Error: " + error .message);
      }
   },
   cdataNode: function (xmlElement)
   {
      if (this .getParents () .length === 0)
         return;

      var node = this .getParent ();

      if (node instanceof Base_X3DBaseNode)
      {
         var field = node .getSourceText ();

         if (field)
         {
            field .push (xmlElement .data);
         }
      }
   },
   useAttribute: function (xmlElement)
   {
      try
      {
         var name = xmlElement .getAttribute ("USE");

         if (this .id (name))
         {
            var node = this .getExecutionContext () .getNamedNode (name);

            this .addNode (xmlElement, node .getValue ());
            return true;
         }
      }
      catch (error)
      {
         console .warn ("Invalid USE name: " + error .message);
      }

      return false;
   },
   defAttribute: function (xmlElement, node)
   {
      try
      {
         var name = xmlElement .getAttribute ("DEF");

         if (name)
         {
            try
            {
               var namedNode = this .getExecutionContext () .getNamedNode (name);

               this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (name), namedNode);
            }
            catch (error)
            { }

            this .getExecutionContext () .updateNamedNode (name, node);
         }
      }
      catch (error)
      {
         console .warn ("Invalid DEF name: " + error .message);
      }
   },
   nodeAttributes: function (xmlElement, node)
   {
      var xmlAttributes = xmlElement .attributes;

      for (var i = 0; i < xmlAttributes .length; ++ i)
         this .nodeAttribute (xmlAttributes [i], node);
   },
   nodeAttribute: function (xmlAttribute, node)
   {
      try
      {
         var
            field      = node .getField (this .attributeToCamelCase (xmlAttribute .name)),
            accessType = field .getAccessType ();

         if (accessType & Base_X3DConstants.initializeOnly)
            this .fieldValue (field, xmlAttribute .value);
      }
      catch (error)
      {
         //console .error (error);
      }
   },
   fieldValue: function (field, value)
   {
      if (value === null)
         return;

      this .parser .pushExecutionContext (this .getExecutionContext ());

      this .parser .setInput (value);
      this .fieldTypes [field .getType ()] .call (this .parser, field);

      this .parser .popExecutionContext ();
   },
   addNode: function (xmlElement, node)
   {
      if (this .parents .length === 0 || this .getParent () instanceof Prototype_X3DProtoDeclaration)
      {
         this .getExecutionContext () .rootNodes .push (node);
         return;
      }

      var parent = this .getParent ();

      if (parent instanceof Base_X3DField)
      {
         switch (parent .getType ())
         {
            case Base_X3DConstants.SFNode:
               parent .setValue (node);
               return;

            case Base_X3DConstants.MFNode:
               parent .push (node);
               return;
         }

         return;
      }

      // parent is a node.

      try
      {
         var containerField = xmlElement .getAttribute ("containerField");

         if (! containerField)
         {
            if (node)
               containerField = node .getContainerField ();
            else
               throw new Error ("NULL node must have a container field attribute.");
         }

         var field = parent .getField (containerField);

         switch (field .getType ())
         {
            case Base_X3DConstants.SFNode:
               field .setValue (node);
               return;

            case Base_X3DConstants.MFNode:
               field .push (node);
               return;
         }
      }
      catch (error)
      {
         //console .warn (error .message);
      }
   },
   getParents: function ()
   {
      return this .parents;
   },
   getParent: function ()
   {
      return this .parents .at (-1);
   },
   pushParent: function (parent)
   {
      return this .parents .push (parent);
   },
   popParent: function ()
   {
      this .parents .pop ();
   },
   id: function (string)
   {
      if (string === null)
         return false;

      if (string .length === 0)
         return false;

      return true;
   },
   nodeNameToCamelCase: function (nodeName)
   {
      // Function also needed by X_ITE DOM.
      return Parser_HTMLSupport.getNodeTypeName (nodeName);
   },
   attributeToCamelCase: function (name)
   {
      // Function also needed by X_ITE DOM.
      return Parser_HTMLSupport.getFieldName (name);
   },
});

XMLParser .prototype .fieldTypes = [ ];
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFBool]      = Parser_VRMLParser.prototype.sfboolValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFColor]     = Parser_VRMLParser.prototype.sfcolorValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFColorRGBA] = Parser_VRMLParser.prototype.sfcolorrgbaValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFDouble]    = Parser_VRMLParser.prototype.sfdoubleValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFFloat]     = Parser_VRMLParser.prototype.sffloatValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFImage]     = Parser_VRMLParser.prototype.sfimageValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFInt32]     = Parser_VRMLParser.prototype.sfint32Value;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix3f]  = Parser_VRMLParser.prototype.sfmatrix3dValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix3d]  = Parser_VRMLParser.prototype.sfmatrix3fValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix4f]  = Parser_VRMLParser.prototype.sfmatrix4dValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFMatrix4d]  = Parser_VRMLParser.prototype.sfmatrix4fValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFNode]      = function (field) { field .setValue (null); };
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFRotation]  = Parser_VRMLParser.prototype.sfrotationValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFString]    = function (field) { field .setValue (x_ite_Fields.SFString.unescape (this .input)); };
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFTime]      = Parser_VRMLParser.prototype.sftimeValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec2d]     = Parser_VRMLParser.prototype.sfvec2dValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec2f]     = Parser_VRMLParser.prototype.sfvec2fValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec3d]     = Parser_VRMLParser.prototype.sfvec3dValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec3f]     = Parser_VRMLParser.prototype.sfvec3fValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec4d]     = Parser_VRMLParser.prototype.sfvec4dValue;
XMLParser .prototype .fieldTypes [Base_X3DConstants.SFVec4f]     = Parser_VRMLParser.prototype.sfvec4fValue;

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFBool]      = Parser_VRMLParser.prototype.sfboolValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFColor]     = Parser_VRMLParser.prototype.sfcolorValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFColorRGBA] = Parser_VRMLParser.prototype.sfcolorrgbaValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFDouble]    = Parser_VRMLParser.prototype.sfdoubleValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFFloat]     = Parser_VRMLParser.prototype.sffloatValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFImage]     = Parser_VRMLParser.prototype.sfimageValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFInt32]     = Parser_VRMLParser.prototype.sfint32Values;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3d]  = Parser_VRMLParser.prototype.sfmatrix3dValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3f]  = Parser_VRMLParser.prototype.sfmatrix3fValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4d]  = Parser_VRMLParser.prototype.sfmatrix4dValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4f]  = Parser_VRMLParser.prototype.sfmatrix4fValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFNode]      = function (field) { field .length = 0; };
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFRotation]  = Parser_VRMLParser.prototype.sfrotationValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFString]    = Parser_VRMLParser.prototype.sfstringValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFTime]      = Parser_VRMLParser.prototype.sftimeValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2d]     = Parser_VRMLParser.prototype.sfvec2dValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2f]     = Parser_VRMLParser.prototype.sfvec2fValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3d]     = Parser_VRMLParser.prototype.sfvec3dValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3f]     = Parser_VRMLParser.prototype.sfvec3fValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4d]     = Parser_VRMLParser.prototype.sfvec4dValues;
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4f]     = Parser_VRMLParser.prototype.sfvec4fValues;

/*
 * Lazy parse functions.
 */

var
   infs            = /\binf\b/g,
   nans            = /\bnan\b/g,
   trimWhitespaces = /^[\x20\n,\t\r"]+|[\x20\n,\t\r"]+$/g,
   whitespaces     = /[\x20\n,\t\r"]+/,
   strings         = new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'g');

function prepareBools (string)
{
   return string .replace (trimWhitespaces, "") .split (whitespaces);
}

function prepareFloats (string)
{
   return (string
      .replace (infs, "Infinity")
      .replace (nans, "NaN")
      .replace (trimWhitespaces, "")
      .split (whitespaces));
}

function prepareInts (string)
{
   return string .replace (trimWhitespaces, "") .split (whitespaces);
}

function prepareStrings (string)
{
   var
      match = null,
      array = [ ];

   while (match = strings .exec (string))
      array .push (match [1]);

   return array .map (x_ite_Fields.SFString.unescape);
}

// Unitless fields.

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFColor] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFColorRGBA] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3d] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix3f] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4d] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFMatrix4f] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4d] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec4f] = function (field)
{
   field .setValue (prepareFloats (this .getInput ()) .map (function (value)
   {
      return parseFloat (value);
   }));
};

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFBool] = function (field)
{
   field .setValue (prepareBools (this .getInput ()) .map (function (value)
   {
      if (value === "true" || value === "TRUE")
         return true;

      return false;
   }));
};

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFInt32] = function (field)
{
   field .setValue (prepareInts (this .getInput ()) .map (function (value)
   {
      return parseInt (value);
   }));
};

// Unit fields.

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFDouble] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFFloat] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2d] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec2f] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3d] =
XMLParser .prototype .fieldTypes [Base_X3DConstants.MFVec3f] = function (field)
{
   var category = field .getUnit ();

   field .setValue (prepareFloats (this .getInput ()) .map (function (value)
   {
      return this .fromUnit (category, parseFloat (value));
   },
   this));
};

XMLParser .prototype .fieldTypes [Base_X3DConstants.MFString] = function (field)
{
   field .setValue (prepareStrings (this .getInput ()));
};

/* harmony default export */ const Parser_XMLParser = (XMLParser);

;// CONCATENATED MODULE: ./src/x_ite/Parser/JSONParser.js
﻿/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 * X3DJSONLD Copyright John Carlson, USA 2016-2017
 * https://coderextreme.net/X3DJSONLD/
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the Cobweb Project.
 *
 * Cobweb is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * Cobweb is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with Cobweb.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function JSONParser (scene)
{
   Parser_X3DParser.call (this, scene);

   this .x3djsonNS = "http://www.web3d.org/specifications/x3d-namespace";
}

JSONParser .prototype = Object .assign (Object .create (Parser_X3DParser.prototype),
{
   constructor: JSONParser,
   isValid: function ()
   {
      return this .input instanceof Object;
   },
   getInput: function ()
   {
      return this .input;
   },
   setInput: function (json)
   {
      try
      {
         if (typeof json === "string")
            json = JSON .parse (json)

         this .input = json;
      }
      catch (error)
      {
         this .input = undefined;
      }
   },
   parseIntoScene: function (success, error)
   {
      /**
       * Load X3D JSON into an element.
       * json - the JavaScript object to convert to DOM.
       */

      const child = this .createElement ("X3D");

      this .convertToDOM (this .input, "", child);

      // Call the DOM parser.

      const parser = new Parser_XMLParser (this .getScene ());

      parser .setInput (child);
      parser .parseIntoScene (success, error);

      return child;
   },
   elementSetAttribute: function (element, key, value)
   {
      /**
       * Yet another way to set an attribute on an element.  does not allow you to
       * set JSON schema or encoding.
       */

      switch (key)
      {
         case "SON schema":
         {
            // JSON Schema
            break;
         }
         case "ncoding":
         {
            // encoding, UTF-8, UTF-16 or UTF-32
            break;
         }
         default:
         {
            if (typeof element .setAttribute === "function")
               element .setAttribute (key, value);

            break;
         }
      }
   },
   convertChildren: function (parentkey, object, element)
   {
      /**
       * converts children of object to DOM.
       */

      for (const key in object)
      {
         if (typeof object [key] === "object")
         {
            if (isNaN (parseInt (key)))
               this .convertObject (key, object, element, parentkey .substr (1));

            else
               this .convertToDOM (object[ key], key, element, parentkey .substr (1));
         }
      }
   },
   createElement: function (key, containerField)
   {
      /**
       * a method to create and element with tagnam key to DOM in a namespace.  If
       * containerField is set, then the containerField is set in the elemetn.
       */

      if (typeof this .x3djsonNS === "undefined")
      {
         var child = document .createElement (key);
      }
      else
      {
         var child = document .createElementNS (this .x3djsonNS, key);

         if (child === null || typeof child === "undefined")
         {
            console .error ("Trouble creating element for", key);

            child = document .createElement(key);
         }
      }

      if (typeof containerField !== "undefined")
         this .elementSetAttribute (child, "containerField", containerField);

      return child;
   },
   createCDATA: function (document, element, str)
   {
      /**
       * a way to create a CDATA function or script in HTML, by using a DOM parser.
       */

      let y = str .trim ()
         .replace (/\\"/g, "\\\"")
         .replace (/&lt;/g, "<")
         .replace (/&gt;/g, ">")
         .replace (/&amp;/g, "&");

      do
      {
         str = y;
         y   = str .replace (/'([^'\r\n]*)\n([^']*)'/g, "'$1\\n$2'");

         if (str !== y)
            console .log ("CDATA Replacing", str, "with", y);
      }
      while (y !== str);

      const
         domParser = new DOMParser(),
         cdataStr  = "<script> <![CDATA[ " + y + " ]]> </script>", // has to be wrapped into an element
         scriptDoc = domParser .parseFromString (cdataStr, "application/xml"),
         cdata     = scriptDoc .children [0] .childNodes [1]; // space after script is childNode[0]

      element .appendChild (cdata);
   },
   convertObject: function (key, object, element, containerField)
   {
      /**
       * convert the object at object[key] to DOM.
       */

      if (object !== null && typeof object [key] === "object")
      {
         if (key .substr (0, 1) === "@")
         {
            this .convertToDOM (object [key], key, element);
         }
         else if (key .substr (0, 1) === "-")
         {
            this .convertChildren (key, object [key], element);
         }
         else if (key === "#comment")
         {
            for (const c in object [key])
            {
               const child = document .createComment (this .commentStringToXML (object [key] [c]));

               element .appendChild (child);
            }
         }
         else if (key === "#sourceCode" || key === "@sourceCode" || key === "#sourceText")
         {
            this .createCDATA (document, element, object [key] .join ("\r\n") + "\r\n");
         }
         else
         {
            if (key === "connect" || key === "fieldValue" || key === "field" || key === "meta" || key === "component")
            {
               for (const childkey in object [key])
               {
                  // for each field
                  if (typeof object [key] [childkey] === "object")
                  {
                     const child = this .createElement (key, containerField);

                     this .convertToDOM (object [key] [childkey], childkey, child);

                     element .appendChild (child);
                     element .appendChild (document .createTextNode ("\n"));
                  }
               }
            }
            else
            {
               const child = this .createElement (key, containerField);

               this .convertToDOM (object [key], key, child);

               element .appendChild (child);
               element .appendChild (document .createTextNode ("\n"));
            }
         }
      }
   },
   commentStringToXML: function (str)
   {
      /**
       * convert a comment string in JavaScript to XML.  Pass the string
       */

      let y = str;

      str = str .replace (/\\\\/g, "\\");

      if (y !== str)
         console .log ("X3DJSONLD <!-> replacing", y, "with", str);

      return str;
   },
   SFStringToXML: function (str)
   {
      /**
       * convert an SFString to XML.
       */

      const y = str;

      /*
      str = (""+str).replace(/\\\\/g, "\\\\");
      str = str.replace(/\\\\\\\\/g, "\\\\");
      str = str.replace(/(\\+)"/g, "\\"");
      */

      str = str .replace (/\\/g, "\\\\");
      str = str .replace (/"/g, "\\\"");

      if (y !== str)
         console .log ("X3DJSONLD [] replacing", y, "with", str);

      return str;
   },
   JSONStringToXML: function (str)
   {
      /**
       * convert a JSON String to XML.
       */

      const y = str;

      str = str .replace (/\\/g, "\\\\");
      str = str .replace (/\n/g, "\\n");

      if (y !== str)
         console .log ("X3DJSONLD replacing", y, "with", str);

      return str;
   },
   convertToDOM: function(object, parentkey, element, containerField)
   {
      /**
       * main routine for converting a JavaScript object to DOM.
       * object is the object to convert.
       * parentkey is the key of the object in the parent.
       * element is the parent element.
       * containerField is a possible containerField.
       */

      let
         isArray        = false,
         localArray     = [ ],
         arrayOfStrings = false;

      for (const key in object)
      {
         isArray = !isNaN (parseInt (key));

         if (isArray)
         {
            switch (typeof object [key])
            {
               case "number":
               {
                  localArray .push (object [key]);
                  break;
               }
               case "string":
               {
                  localArray .push (object [key]);

                  arrayOfStrings = true;
                  break;
               }
               case "boolean":
               {
                  localArray .push (object [key]);
                  break;
               }
               case "object":
               {
                  /*
                  if (object[key] != null && typeof object[key].join === "function") {
                     localArray.push(object[key].join(" "));
                  }
                  */
                  this .convertToDOM (object [key], key, element);
                  break;
               }
               case "undefined":
               {
                  break;
               }
               default:
               {
                  console .error ("Unknown type found in array " + typeof object [key]);
               }
            }
         }
         else
         {
            switch (typeof object [key])
            {
               case "object":
               {
                  // This is where the whole thing starts

                  if (key === "X3D")
                     this .convertToDOM (object [key], key, element);

                  else
                     this .convertObject (key, object, element, containerField);

                  break;
               }
               case "number":
               {
                  this .elementSetAttribute (element, key .substr (1), object [key]);
                  break;
               }
               case "string":
               {
                  if (key !== "#comment")
                  {
                     // ordinary string attributes
                     this .elementSetAttribute (element, key .substr (1), this .JSONStringToXML (object [key]));
                  }
                  else
                  {
                     const child = document .createComment (this .commentStringToXML (object [key]));

                     element .appendChild (child);
                  }

                  break;
               }
               case "boolean":
               {
                  this .elementSetAttribute (element, key .substr (1), object [key]);
                  break;
               }
               case "undefined":
               {
                  break;
               }
               default:
               {
                  console .error ("Unknown type found in object " + typeof object [key]);
                  console .error (object);
               }
            }
         }
      }

      if (isArray)
      {
         if (parentkey .substr (0,1) === "@")
         {
            if (arrayOfStrings)
            {
               arrayOfStrings = false;

               for (const str in localArray)
                  localArray [str] = this .SFStringToXML (localArray [str]);

               this .elementSetAttribute (element, parentkey .substr (1), '"' + localArray .join ('" "') + '"');
            }
            else
            {
               // if non string array
               this .elementSetAttribute (element, parentkey .substr (1), localArray .join (" "));
            }
         }

         isArray = false;
      }

      return element;
   },
});

/* harmony default export */ const Parser_JSONParser = (JSONParser);

;// CONCATENATED MODULE: ./src/x_ite/Parser/GoldenGate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function GoldenGate (scene)
{
   Parser_X3DParser.call (this, scene);
}

GoldenGate .prototype = Object .assign (Object .create (Parser_X3DParser.prototype),
{
   constructor: GoldenGate,
   parseIntoScene: function (x3dSyntax, success, error)
   {
      for (const Parser of GoldenGate .Parser)
      {
         try
         {
            const parser = new Parser (this .getScene ());

            parser .setInput (x3dSyntax);

            if (parser .isValid ())
            {
               parser .pushExecutionContext (this .getExecutionContext ());
               parser .parseIntoScene (success, error);
               parser .popExecutionContext ();
               return
            }
         }
         catch (exception)
         {
            if (error)
               error (exception);
            else
               throw exception;

            return;
         }
      }

      if (this .getScene () .worldURL .startsWith ("data:"))
         throw new Error ("Couldn't parse X3D. No suitable file handler found for 'data:' URL.");
      else
         throw new Error ("Couldn't parse X3D. No suitable file handler found for '" + this .getScene () .worldURL + "'.");
   },
});

GoldenGate .Parser = [
   Parser_XMLParser,
   Parser_JSONParser,
   Parser_VRMLParser,
];

/* harmony default export */ const Parser_GoldenGate = (GoldenGate);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Plane3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   normal    = new Numbers_Vector3 (0, 0, 0),
   point     = new Numbers_Vector3 (0, 0, 0),
   invMatrix = new Numbers_Matrix4 ();

function Plane3 (point, normal)
{
   this .normal             = normal .copy ();
   this .distanceFromOrigin = normal .dot (point);
}

Plane3 .prototype =
{
   constructor: Plane3,
   copy: function ()
   {
      const copy = Object .create (Plane3 .prototype);
      copy .normal             = this .normal .copy ();
      copy .distanceFromOrigin = this .distanceFromOrigin;
      return copy;
   },
   assign: function (plane)
   {
      this .normal .assign (plane .normal);
      this .distanceFromOrigin = plane .distanceFromOrigin;
      return this;
   },
   set: function (point, normal)
   {
      this .normal .assign (normal);
      this .distanceFromOrigin = normal .dot (point);
      return this;
   },
   multRight: function (matrix)
   {
      // Taken from Inventor:

      // Find the point on the plane along the normal from the origin
      point .assign (this .normal) .multiply (this .distanceFromOrigin);

      // Transform the plane normal by the matrix
      // to get the new normal. Use the inverse transpose
      // of the matrix so that normals are not scaled incorrectly.
      // n' = n * !~m = ~m * n
      invMatrix .assign (matrix) .inverse ();
      invMatrix .multMatrixDir (normal .assign (this .normal)) .normalize ();

      // Transform the point by the matrix
      matrix .multVecMatrix (point);

      // The new distance is the projected distance of the vector to the
      // transformed point onto the (unit) transformed normal. This is
      // just a dot product.
      this .normal .assign (normal);
      this .distanceFromOrigin = normal .dot (point);

      return this;
   },
   multLeft: function (matrix)
   {
      // Taken from Inventor:

      // Find the point on the plane along the normal from the origin
      point .assign (this .normal) .multiply (this .distanceFromOrigin);

      // Transform the plane normal by the matrix
      // to get the new normal. Use the inverse transpose
      // of the matrix so that normals are not scaled incorrectly.
      // n' = !~m * n = n * ~m
      invMatrix .assign (matrix) .inverse ();
      invMatrix .multDirMatrix (normal .assign (this .normal)) .normalize ();

      // Transform the point by the matrix
      matrix .multMatrixVec (point);

      // The new distance is the projected distance of the vector to the
      // transformed point onto the (unit) transformed normal. This is
      // just a dot product.
      this .normal .assign (normal);
      this .distanceFromOrigin = normal .dot (point);

      return this;
   },
   getDistanceToPoint: function (point)
   {
      return Numbers_Vector3.dot (point, this .normal) - this .distanceFromOrigin;
   },
   intersectsLine: function (line, intersection)
   {
      const
         point     = line .point,
         direction = line .direction;

      // Check if the line is parallel to the plane.
      const theta = direction .dot (this .normal);

      // Plane and line are parallel.
      if (theta === 0)
         return false;

      // Plane and line are not parallel. The intersection point can be calculated now.
      const t = (this .distanceFromOrigin - this .normal .dot (point)) / theta;

      intersection .x = point .x + direction .x * t;
      intersection .y = point .y + direction .y * t;
      intersection .z = point .z + direction .z * t;

      return true;
   },
   toString: function ()
   {
      return this .normal .toString () + " " + this .distanceFromOrigin;
   },
};

/* harmony default export */ const Geometry_Plane3 = (Plane3);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Triangle3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ const Triangle3 = ({
   area: (function ()
   {
      const
         B = new Numbers_Vector3 (0, 0, 0),
         C = new Numbers_Vector3 (0, 0, 0);

      return function (a, b, c)
      {
         return B .assign (b) .subtract (a) .cross (C .assign (c) .subtract (a)) .magnitude () / 2;
      };
   })(),
   normal: function (v1, v2, v3, normal)
   {
      const
         x1 = v3 .x - v2 .x,
         y1 = v3 .y - v2 .y,
         z1 = v3 .z - v2 .z,
         x2 = v1 .x - v2 .x,
         y2 = v1 .y - v2 .y,
         z2 = v1 .z - v2 .z;

      normal .set (y1 * z2 - z1 * y2,
                   z1 * x2 - x1 * z2,
                   x1 * y2 - y1 * x2);

      return normal .normalize ();
   },
   quadNormal: function (v1, v2, v3, v4, normal)
   {
      const
         x1 = v3 .x - v1 .x,
         y1 = v3 .y - v1 .y,
         z1 = v3 .z - v1 .z,
         x2 = v4 .x - v2 .x,
         y2 = v4 .y - v2 .y,
         z2 = v4 .z - v2 .z;

      normal .set (y1 * z2 - z1 * y2,
                   z1 * x2 - x1 * z2,
                   x1 * y2 - y1 * x2);

      return normal .normalize ();
   },
   triangulatePolygon: (function ()
   {
      const tessy = (function ()
      {
         // Function called for each vertex of tesselator output.
         function vertexCallback (data, polyVertArray)
         {
            //console .log (data);
            polyVertArray [polyVertArray .length] = data;
         }

         function beginCallback (type)
         {
            if (type !== libtess .primitiveType .GL_TRIANGLES)
               console .log ('expected TRIANGLES but got type: ' + type);
         }

         function errorCallback (errno)
         {
            console .log ('error callback');
            console .log ('error number: ' + errno);
         }

         // Callback for when segments intersect and must be split.
         function combineCallback (coords, data, weight)
         {
            //console.log ('combine callback');
            return data [0];
         }

         function edgeCallback (flag)
         {
            // Don't really care about the flag, but need no-strip/no-fan behavior.
            // console .log ('edge flag: ' + flag);
         }

         const tessy = new libtess .GluTesselator ();

         tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_VERTEX_DATA,  vertexCallback);
         tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_BEGIN,        beginCallback);
         tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_ERROR,        errorCallback);
         tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_COMBINE,      combineCallback);
         tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_EDGE_FLAG,    edgeCallback);
         tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_TOLERANCE,    0);
         tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_WINDING_RULE, libtess .windingRule .GLU_TESS_WINDING_ODD);

         return tessy;
      })();

      return function (/* contour, [ contour, ..., ] triangles */)
      {
         const triangles = arguments [arguments .length - 1];

         tessy .gluTessBeginPolygon (triangles);

         for (let i = 0, length = arguments .length - 1; i < length; ++ i)
         {
            tessy .gluTessBeginContour ();

            for (const contour of arguments [i])
            {
               tessy .gluTessVertex (contour, contour);
            }

            tessy .gluTessEndContour ();
         }

         tessy .gluTessEndPolygon ();

         return triangles;
      };
   })(),
   triangulateConvexPolygon: function (vertices, triangles)
   {
      // Fallback: Very simple triangulation for convex polygons.
      for (let i = 1, length = vertices .length - 1; i < length; ++ i)
         triangles .push (vertices [0], vertices [i], vertices [i + 1]);
   },
   getPolygonNormal: function (vertices, normal)
   {
      // Determine polygon normal.
      // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

      normal .set (0, 0, 0);

      var next = vertices [0];

      for (let i = 0, length = vertices .length; i < length; ++ i)
      {
         var
            current = next,
            next    = vertices [(i + 1) % length];

         normal .x += (current .y - next .y) * (current .z + next .z);
         normal .y += (current .z - next .z) * (current .x + next .x);
         normal .z += (current .x - next .x) * (current .y + next .y);
      }

      return normal .normalize ();
   },
});

;// CONCATENATED MODULE: ./src/standard/Math/Algorithms/SAT.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const
   extents1 = { min: 0, max: 0 },
   extents2 = { min: 0, max: 0 };

/**
 *  Class to represent the Separating Axis Theorem.
 */
function SAT () { }

SAT .isSeparated = function (axes, points1, points2)
{
   // http://gamedev.stackexchange.com/questions/25397/obb-vs-obb-collision-detection

   for (const axis of axes)
   {
      project (points1, axis, extents1);
      project (points2, axis, extents2);

      if (overlaps (extents1 .min, extents1 .max, extents2 .min, extents2 .max))
         continue;

      return true;
   }

   return false;
};

///  Projects @a points to @a axis and returns the minimum and maximum bounds.
function project (points, axis, extents)
{
   extents .min = Number .POSITIVE_INFINITY;
   extents .max = Number .NEGATIVE_INFINITY;

   for (const point of points)
   {
      // Just dot it to get the min and max along this axis.
      // NOTE: the axis must be normalized to get accurate projections to calculate the MTV, but if it is only needed to
      // know whether it overlaps, every axis can be used.

      const dotVal = point .dot (axis);

      if (dotVal < extents .min)
         extents .min = dotVal;

      if (dotVal > extents .max)
         extents .max = dotVal;
   }
}

///  Returns true if both ranges overlap, otherwise false.
function overlaps (min1, max1, min2, max2)
{
   return is_between (min2, min1, max1) || is_between (min1, min2, max2);
}

///  Returns true if @a value is between @a lowerBound and @a upperBound, otherwise false.
function is_between (value, lowerBound, upperBound)
{
   return lowerBound <= value && value <= upperBound;
}

/* harmony default export */ const Algorithms_SAT = (SAT);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/ViewVolume.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










/*
 * p7 -------- p6  far plane
 * | \         | \
 * | p3 --------- p2
 * |  |        |  |
 * |  |        |  |
 * p4 |______ p5  |
 *  \ |         \ |
 *   \|          \|
 *    p0 -------- p1  near plane
 */

function ViewVolume (projectionMatrix, viewport, scissor)
{
   this .viewport = new Numbers_Vector4 (0, 0, 0, 0);
   this .scissor  = new Numbers_Vector4 (0, 0, 0, 0);

   this .points = [
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),

      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
   ];

   this .normals = [
      new Numbers_Vector3 (0, 0, 0), // front
      new Numbers_Vector3 (0, 0, 0), // left
      new Numbers_Vector3 (0, 0, 0), // right
      new Numbers_Vector3 (0, 0, 0), // top
      new Numbers_Vector3 (0, 0, 0), // bottom
      new Numbers_Vector3 (0, 0, 0), // back
   ];

   this .edges = [
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),

      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
      new Numbers_Vector3 (0, 0, 0),
   ];

   this .planes = [
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // front
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // left
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // right
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // top
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // bottom
      new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero), // back
   ];

   if (arguments .length)
      this .set (projectionMatrix, viewport, scissor);
}

ViewVolume .prototype =
{
   constructor: ViewVolume,
   set: (function ()
   {
      const matrix = new Numbers_Matrix4 ();

      return function (projectionMatrix, viewport, scissor)
      {
         this .viewport .assign (viewport);
         this .scissor  .assign (scissor);

         const points = this .points;

         const
            p0 = points [0],
            p1 = points [1],
            p2 = points [2],
            p3 = points [3],
            p4 = points [4],
            p5 = points [5],
            p6 = points [6],
            p7 = points [7];

         const
            x1 = scissor [0],
            x2 = x1 + scissor [2],
            y1 = scissor [1],
            y2 = y1 + scissor [3];

         matrix .assign (projectionMatrix) .inverse ();

         ViewVolume .unProjectPointMatrix (x1, y1, 0, matrix, viewport, p0),
         ViewVolume .unProjectPointMatrix (x2, y1, 0, matrix, viewport, p1),
         ViewVolume .unProjectPointMatrix (x2, y2, 0, matrix, viewport, p2),
         ViewVolume .unProjectPointMatrix (x1, y2, 0, matrix, viewport, p3),
         ViewVolume .unProjectPointMatrix (x1, y1, 1, matrix, viewport, p4),
         ViewVolume .unProjectPointMatrix (x2, y1, 1, matrix, viewport, p5);
         ViewVolume .unProjectPointMatrix (x2, y2, 1, matrix, viewport, p6);
         ViewVolume .unProjectPointMatrix (x1, y2, 1, matrix, viewport, p7);

         const normals = this .normals;

         Triangle3.normal (p0, p1, p2, normals [0]); // front
         Triangle3.normal (p7, p4, p0, normals [1]); // left
         Triangle3.normal (p6, p2, p1, normals [2]); // right
         Triangle3.normal (p2, p6, p7, normals [3]); // top
         Triangle3.normal (p1, p0, p4, normals [4]); // bottom
         Triangle3.normal (p4, p7, p6, normals [5]); // back

         const planes = this .planes;

         planes [0] .set (p1, normals [0]); // front
         planes [1] .set (p4, normals [1]); // left
         planes [2] .set (p2, normals [2]); // right
         planes [3] .set (p6, normals [3]); // top
         planes [4] .set (p0, normals [4]); // bottom
         planes [5] .set (p7, normals [5]); // back

         this .edges .tainted = true;

         return this;
      };
   })(),
   getViewport: function ()
   {
      return this .viewport;
   },
   getScissor: function ()
   {
      return this .scissor;
   },
   getEdges: function ()
   {
      // Return suitable edges for SAT theorem.

      const edges = this .edges;

      if (edges .tainted)
      {
         const points = this .points;

         edges [0] .assign (points [0]) .subtract (points [1]);
         edges [1] .assign (points [1]) .subtract (points [2]);
         edges [2] .assign (points [2]) .subtract (points [3]);
         edges [3] .assign (points [3]) .subtract (points [0]);

         edges [4] .assign (points [0]) .subtract (points [4]);
         edges [5] .assign (points [1]) .subtract (points [5]);
         edges [6] .assign (points [2]) .subtract (points [6]);
         edges [7] .assign (points [3]) .subtract (points [7]);

         // Edges 8 - 11 are equal to edges 0 - 3.

         edges .tainted = false;
      }

      return edges;
   },
   intersectsSphere: function (radius, center)
   {
      const planes = this .planes;

      if (planes [0] .getDistanceToPoint (center) > radius)
         return false;

      if (planes [1] .getDistanceToPoint (center) > radius)
         return false;

      if (planes [2] .getDistanceToPoint (center) > radius)
         return false;

      if (planes [3] .getDistanceToPoint (center) > radius)
         return false;

      if (planes [4] .getDistanceToPoint (center) > radius)
         return false;

      if (planes [5] .getDistanceToPoint (center) > radius)
         return false;

      return true;
   },
   intersectsBox: (function ()
   {
      const points1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const normals1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes = [ ];

      for (let i = 0; i < 3 * 8; ++ i)
         axes .push (new Numbers_Vector3 (0, 0, 0));

      return function (box)
      {
         // Get points.

         box .getPoints (points1);

         const points2 = this .points;

         // Test the three planes spanned by the normal vectors of the faces of the box.

         if (Algorithms_SAT.isSeparated (box .getNormals (normals1), points1, points2))
            return false;

         // Test the six planes spanned by the normal vectors of the faces of the view volume.

         if (Algorithms_SAT.isSeparated (this .normals, points1, points2))
            return false;

         // Test the planes spanned by the edges of each object.

         box .getAxes (axes1);

         const edges = this .getEdges ();

         for (let i1 = 0; i1 < 3; ++ i1)
         {
            for (let i2 = 0; i2 < 8; ++ i2)
               axes [i1 * 3 + i2] .assign (axes1 [i1]) .cross (edges [i2]);
         }

         if (Algorithms_SAT.isSeparated (axes, points1, points2))
            return false;

         // Both boxes intersect.

         return true;
      };
   })(),
};

Object .assign (ViewVolume,
{
   unProjectPoint: (function ()
   {
      const invModelViewProjectionMatrix = new Numbers_Matrix4 ();

      return function (winx, winy, winz, modelViewMatrix, projectionMatrix, viewport, point)
      {
         return this .unProjectPointMatrix (winx, winy, winz, invModelViewProjectionMatrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse (), viewport, point);
      };
   })(),
   unProjectPointMatrix: (function ()
   {
      const vin = new Numbers_Vector4 (0, 0, 0, 0);

      return function (winx, winy, winz, invModelViewProjectionMatrix, viewport, point)
      {
         // Transformation of normalized coordinates between -1 and 1
         vin .set ((winx - viewport [0]) / viewport [2] * 2 - 1,
                   (winy - viewport [1]) / viewport [3] * 2 - 1,
                   2 * winz - 1,
                   1);

         //Objects coordinates
         invModelViewProjectionMatrix .multVecMatrix (vin);

         const d = 1 / vin .w;

         return point .set (vin .x * d, vin .y * d, vin .z * d, 1);
      };
   })(),
   unProjectRay: (function ()
   {
      const invModelViewProjectionMatrix = new Numbers_Matrix4 ();

      return function (winx, winy, modelViewMatrix, projectionMatrix, viewport, result)
      {
         return this .unProjectRayMatrix (winx, winy, invModelViewProjectionMatrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse (), viewport, result);
      };
   })(),
   unProjectRayMatrix: (function ()
   {
      const
         near = new Numbers_Vector3 (0, 0, 0),
         far  = new Numbers_Vector3 (0, 0, 0);

      return function (winx, winy, invModelViewProjectionMatrix, viewport, result)
      {
         ViewVolume .unProjectPointMatrix (winx, winy, 0.0, invModelViewProjectionMatrix, viewport, near);
         ViewVolume .unProjectPointMatrix (winx, winy, 0.9, invModelViewProjectionMatrix, viewport, far);

         return result .setPoints (near, far);
      };
   })(),
   projectPoint: (function ()
   {
      const vin = new Numbers_Vector4 (0, 0, 0, 0);

      return function (point, modelViewMatrix, projectionMatrix, viewport, vout)
      {
         if (point .length === 4)
            vin .assign (point);
         else
            vin .set (point .x, point .y, point .z, 1);

         projectionMatrix .multVecMatrix (modelViewMatrix .multVecMatrix (vin));

         const d = 1 / (2 * vin .w);

         return vout .set ((vin .x * d + 0.5) * viewport [2] + viewport [0],
                           (vin .y * d + 0.5) * viewport [3] + viewport [1],
                           (vin .z * d + 0.5));
      };
   })(),
   projectPointMatrix: (function ()
   {
      const vin = new Numbers_Vector4 (0, 0, 0, 0);

      return function (point, modelViewProjectionMatrix, viewport, vout)
      {
         if (point .length === 4)
            vin .assign (point);
         else
            vin .set (point .x, point .y, point .z, 1);

         modelViewProjectionMatrix .multVecMatrix (vin);

         const d = 1 / (2 * vin .w);

         return vout .set ((vin .x * d + 0.5) * viewport [2] + viewport [0],
                           (vin .y * d + 0.5) * viewport [3] + viewport [1],
                           (vin .z * d + 0.5));
      };
   })(),
   projectLine: (function ()
   {
      const modelViewProjectionMatrix = new Numbers_Matrix4 ();

      return function (line, modelViewMatrix, projectionMatrix, viewport, result)
      {
         return this .projectLineMatrix (line, modelViewProjectionMatrix .assign (modelViewMatrix) .multRight (projectionMatrix), viewport, result);
      };
   })(),
   projectLineMatrix: (function ()
   {
      const
         near      = new Numbers_Vector2 (0, 0),
         far       = new Numbers_Vector2 (0, 0),
         direction = new Numbers_Vector3 (0, 0, 0);

      return function (line, modelViewProjectionMatrix, viewport, result)
      {
         ViewVolume .projectPointMatrix (line .point, modelViewProjectionMatrix, viewport, near);
         ViewVolume .projectPointMatrix (direction .assign (line .direction) .multiply (1e9) .add (line .point), modelViewProjectionMatrix, viewport, far);

         return result .setPoints (near, far);
      };
   })(),
});

/* harmony default export */ const Geometry_ViewVolume = (ViewVolume);

;// CONCATENATED MODULE: ./src/x_ite/Rendering/TextureBuffer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function TextureBuffer (browser, width, height)
{
   const gl = browser .getContext ();

   this .browser = browser;
   this .width   = width;
   this .height  = height;
   this .array   = new Uint8Array (width * height * 4);

   // Create frame buffer.

   this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);
   this .buffer     = gl .createFramebuffer ();

   gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);

   // Create color texture.

   this .colorTexture = gl .createTexture ();

   gl .bindTexture (gl .TEXTURE_2D, this .colorTexture);
   gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
   gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
   gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .LINEAR);
   gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .LINEAR);
   gl .texImage2D (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, null);

   gl .framebufferTexture2D (gl .FRAMEBUFFER, gl .COLOR_ATTACHMENT0, gl .TEXTURE_2D, this .colorTexture, 0);

   // Create depth buffer.

   if (gl .HAS_FEATURE_DEPTH_TEXTURE)
   {
      this .depthTexture = gl .createTexture ();

      gl .bindTexture (gl .TEXTURE_2D, this .depthTexture);

      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .NEAREST);

      const internalFormat = gl .getVersion () >= 2 ? gl .DEPTH_COMPONENT24 : gl .DEPTH_COMPONENT;

      gl .texImage2D (gl .TEXTURE_2D, 0, internalFormat, width, height, 0, gl .DEPTH_COMPONENT, gl .UNSIGNED_INT, null);
      gl .framebufferTexture2D (gl .FRAMEBUFFER, gl .DEPTH_ATTACHMENT, gl .TEXTURE_2D, this .depthTexture, 0);
   }
   else
   {
      this .depthBuffer = gl .createRenderbuffer ();

      gl .bindRenderbuffer (gl .RENDERBUFFER, this .depthBuffer);
      gl .renderbufferStorage (gl .RENDERBUFFER, gl .DEPTH_COMPONENT16, width, height);
      gl .framebufferRenderbuffer (gl .FRAMEBUFFER, gl .DEPTH_ATTACHMENT, gl .RENDERBUFFER, this .depthBuffer);
   }

   // Always check that our framebuffer is ok.

   const complete = gl .checkFramebufferStatus (gl .FRAMEBUFFER) === gl .FRAMEBUFFER_COMPLETE;

   gl .bindTexture (gl .TEXTURE_2D, null);
   gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);

   if (complete)
      return;

   throw new Error ("Couldn't create frame buffer.");
}

TextureBuffer .prototype =
{
   constructor: TextureBuffer,
   getWidth: function ()
   {
      return this .width;
   },
   getHeight: function ()
   {
      return this .height;
   },
   getColorTexture: function ()
   {
      return this .colorTexture;
   },
   getDepthTexture: function ()
   {
      return this .depthTexture;
   },
   readPixels: function ()
   {
      const
         gl     = this .browser .getContext (),
         array  = this .array,
         width  = this .width,
         height = this .height;

      gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);

      return array;
   },
   getDepth: (function ()
   {
      const
         invProjectionMatrix = new Numbers_Matrix4 (),
         point               = new Numbers_Vector3 (0, 0, 0);

      return function (projectionMatrix, viewport)
      {
         const
            gl     = this .browser .getContext (),
            array  = this .array,
            width  = this .width,
            height = this .height;

         let
            winx = 0,
            winy = 0,
            winz = Number .POSITIVE_INFINITY;

         invProjectionMatrix .assign (projectionMatrix) .inverse ();

         gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);

         for (let wy = 0, i = 0; wy < height; ++ wy)
         {
            for (let wx = 0; wx < width; ++ wx, i += 4)
            {
               const wz = array [i] / 255 + array [i + 1] / (255 * 255) + array [i + 2] / (255 * 255 * 255) + array [i + 3] / (255 * 255 * 255 * 255);

               if (wz < winz)
               {
                  winx = wx;
                  winy = wy;
                  winz = wz;
               }
            }
         }

         Geometry_ViewVolume.unProjectPointMatrix (winx, winy, winz, invProjectionMatrix, viewport, point);

         return point .z;
      };
   })(),
   bind: function ()
   {
      const gl = this .browser .getContext ();

      this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);

      gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);
   },
   unbind: function ()
   {
      const gl = this .browser .getContext ();

      gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);
   },
   delete: function ()
   {
      const gl = this .browser .getContext ();

      gl .deleteFramebuffer (this .buffer);
      gl .deleteTexture (this .colorTexture);

      if (gl .HAS_FEATURE_DEPTH_TEXTURE)
         gl .deleteTexture (this .depthTexture);
      else
         gl .deleteRenderbuffer (this .depthBuffer);
    },
};

for (const key of Reflect .ownKeys (TextureBuffer .prototype))
   Object .defineProperty (TextureBuffer .prototype, key, { enumerable: false });

/* harmony default export */ const Rendering_TextureBuffer = (TextureBuffer);

;// CONCATENATED MODULE: ./src/x_ite/Rendering/TraverseType.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let TraverseType_i = 0;

const TraverseType =
{
   POINTER:   TraverseType_i ++,
   CAMERA:    TraverseType_i ++,
   PICKING:   TraverseType_i ++,
   COLLISION: TraverseType_i ++,
   SHADOW:    TraverseType_i ++,
   DISPLAY:   TraverseType_i ++,
};

/* harmony default export */ const Rendering_TraverseType = (TraverseType);

;// CONCATENATED MODULE: ./src/standard/Math/Algorithms/MergeSort.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function MergeSort (array, compare)
{
   this .array     = array;
   this .auxiliary = [ ];

   if (compare)
      this .compare = compare;
}

MergeSort .prototype =
{
   compare: function (lhs, rhs)
   {
      return lhs < rhs;
   },
   sort: function (first, last)
   {
      this .mergeSort (first, last - 1);
   },
   mergeSort: function (lo, hi)
   {
      if (lo < hi)
      {
         const m = (lo + hi) >>> 1;
         this .mergeSort (lo, m);   // Recursion
         this .mergeSort (m + 1, hi); // Recursion
         this .merge (lo, m, hi);
      }
   },
   merge: function (lo, m, hi)
   {
      let i, j, k;

      i = 0, j = lo;
      // Copy first half of array a to auxiliary array b.
      while (j <= m)
         this .auxiliary [i++] = this .array [j++];

      i = 0; k = lo;
      // Copy back next-greatest element at each time.
      while (k < j && j <= hi)
      {
         if (this .compare (this .array [j], this .auxiliary [i]))
            this .array [k++] = this .array [j++];
         else
            this .array [k++] = this .auxiliary [i++];
      }

      // Copy back remaining elements of first half (if any).
      while (k < j)
         this .array [k++] = this .auxiliary [i++];
   }
};

/* harmony default export */ const Algorithms_MergeSort = (MergeSort);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Camera.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ const Camera = ({
   frustum: function (l, r, b, t, n, f, matrix)
   {
      const
         r_l = r - l,
         t_b = t - b,
         f_n = f - n,
         n_2 = 2 * n,

         A = (r + l) / r_l,
         B = (t + b) / t_b,
         C = -(f + n) / f_n,
         D = -(n_2 * f) / f_n,
         E = n_2 / r_l,
         F = n_2 / t_b;

      return matrix .set (E, 0, 0, 0,
                          0, F, 0, 0,
                          A, B, C, -1,
                          0, 0, D, 0);
   },
   perspective: function (fieldOfView, zNear, zFar, width, height, matrix)
   {
      const ratio = Math .tan (fieldOfView / 2) * zNear;

      if (width > height)
      {
         const aspect = width * ratio / height;
         return this .frustum (-aspect, aspect, -ratio, ratio, zNear, zFar, matrix);
      }
      else
      {
         const aspect = height * ratio / width;
         return this .frustum (-ratio, ratio, -aspect, aspect, zNear, zFar, matrix);
      }
   },
   perspective2: function (fieldOfView, zNear, zFar, width, height, matrix)
   {
      const ratio = Math .tan (fieldOfView / 2) * zNear;

      return this .frustum (-ratio, ratio, -ratio, ratio, zNear, zFar, matrix);
   },
   ortho: function (l, r, b, t, n, f, matrix)
   {
      const
         r_l = r - l,
         t_b = t - b,
         f_n = f - n,

         A =  2 / r_l,
         B =  2 / t_b,
         C = -2 / f_n,
         D = -(r + l) / r_l,
         E = -(t + b) / t_b,
         F = -(f + n) / f_n;

      return matrix .set (A, 0, 0, 0,
                          0, B, 0, 0,
                          0, 0, C, 0,
                          D, E, F, 1);
   },
   orthoBox: (function ()
   {
      const
         min = new Numbers_Vector3 (0, 0, 0),
         max = new Numbers_Vector3 (0, 0, 0);

      return function (box, matrix)
      {
         box .getExtents (min, max);

         return this .ortho (min .x, max .x, min .y, max .y, -max .z, -min .z, matrix);
      };
   })(),
});

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Box3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function Box3 (size, center)
{
   switch (arguments .length)
   {
      case 0:
      {
         this .matrix = new Numbers_Matrix4 (0, 0, 0, 0,
                                     0, 0, 0, 0,
                                     0, 0, 0, 0,
                                     0, 0, 0, 0);
         return;
      }
      case 2:
      {
         this .matrix = new Numbers_Matrix4 (size .x / 2, 0, 0, 0,
                                     0, size .y / 2, 0, 0,
                                     0, 0, size .z / 2, 0,
                                     center .x, center .y, center .z, 1);
         return;
      }
      case 3:
      {
         const
            min = arguments [0],
            max = arguments [1],
            sx  = (max .x - min .x) / 2,
            sy  = (max .y - min .y) / 2,
            sz  = (max .z - min .z) / 2,
            cx  = (max .x + min .x) / 2,
            cy  = (max .y + min .y) / 2,
            cz  = (max .z + min .z) / 2;

         this .matrix = new Numbers_Matrix4 (sx, 0,  0,  0,
                                     0,  sy, 0,  0,
                                     0,  0,  sz, 0,
                                     cx, cy, cz, 1);
         return;
      }
   }
}

Box3 .prototype =
{
   constructor: Box3,
   copy: function ()
   {
      const copy = Object .create (Box3 .prototype);
      copy .matrix = this .matrix .copy ();
      return copy;
   },
   assign: function (box)
   {
      this .matrix .assign (box .matrix);
      return this;
   },
   equals: function (box)
   {
      return this .matrix .equals (box .matrix);
   },
   getMatrix: function ()
   {
      return this .matrix;
   },
   set: function (size, center)
   {
      const m = this .matrix;

      switch (arguments .length)
      {
         case 0:
         {
            m [ 0] = 0.5; m [ 1] = 0;   m [ 2] = 0;   m [ 3] = 0;
            m [ 4] = 0;   m [ 5] = 0.5; m [ 6] = 0;   m [ 7] = 0;
            m [ 8] = 0;   m [ 9] = 0;   m [10] = 0.5; m [11] = 0;
            m [12] = 0;   m [13] = 0;   m [14] = 0;   m [15] = 0;
            return this;
         }
         case 2:
         {
            m [ 0] = size .x / 2; m [ 1] = 0;           m [ 2] = 0;           m [ 3] = 0;
            m [ 4] = 0;           m [ 5] = size .y / 2; m [ 6] = 0;           m [ 7] = 0;
            m [ 8] = 0;           m [ 9] = 0;           m [10] = size .z / 2; m [11] = 0;
            m [12] = center .x;   m [13] = center .y;   m [14] = center .z;   m [15] = 1;
            return this;
         }
         case 3:
         {
            const
               min = arguments [0],
               max = arguments [1],
               sx  = (max .x - min .x) / 2,
               sy  = (max .y - min .y) / 2,
               sz  = (max .z - min .z) / 2,
               cx  = (max .x + min .x) / 2,
               cy  = (max .y + min .y) / 2,
               cz  = (max .z + min .z) / 2;

            this .matrix .set (sx, 0,  0,  0,
                               0,  sy, 0,  0,
                               0,  0,  sz, 0,
                               cx, cy, cz, 1);
            return this;
         }
      }
   },
   setExtents: function (min, max)
   {
      const
         m  = this .matrix,
         sx = (max .x - min .x) / 2,
         sy = (max .y - min .y) / 2,
         sz = (max .z - min .z) / 2,
         cx = (max .x + min .x) / 2,
         cy = (max .y + min .y) / 2,
         cz = (max .z + min .z) / 2;

      m [ 0] = sx; m [ 1] = 0;  m [ 2] = 0;  m [ 3] = 0;
      m [ 4] = 0;  m [ 5] = sy; m [ 6] = 0;  m [ 7] = 0;
      m [ 8] = 0;  m [ 9] = 0;  m [10] = sz; m [11] = 0;
      m [12] = cx; m [13] = cy; m [14] = cz; m [15] = 1;
      return this;
   },
   getExtents: function (min, max)
   {
      this .getAbsoluteExtents (min, max);

      min .add (this .center);
      max .add (this .center);
   },
   getAbsoluteExtents: (function ()
   {
      const
         r1 = new Numbers_Vector3 (0, 0, 0),
         p1 = new Numbers_Vector3 (0, 0, 0),
         p4 = new Numbers_Vector3 (0, 0, 0);

      return function (min, max)
      {
         const
            m = this .matrix,
            x = m .xAxis,
            y = m .yAxis,
            z = m .zAxis;

         r1 .assign (y) .add (z);

         const r2 = z .subtract (y);

         p1 .assign (x) .add (r1),
         p4 .assign (x) .add (r2);

         const
            p2 = r1 .subtract (x),
            p3 = r2 .subtract (x);

         min .assign (p1);
         max .assign (p1);

         min .min (p2, p3, p4);
         max .max (p2, p3, p4);

         p1 .negate ();
         p2 .negate ();
         p3 .negate ();
         p4 .negate ();

         min .min (p1, p2, p3, p4);
         max .max (p1, p2, p3, p4);
      };
   })(),
   getPoints: (function ()
   {
      const
         x  = new Numbers_Vector3 (0, 0, 0),
         y  = new Numbers_Vector3 (0, 0, 0),
         z  = new Numbers_Vector3 (0, 0, 0),
         r1 = new Numbers_Vector3 (0, 0, 0);

      return function (points)
      {
         /*
          * p6 ---------- p5
          * | \           | \
          * | p2------------ p1
          * |  |          |  |
          * |  |          |  |
          * p7 |_________ p8 |
          *  \ |           \ |
          *   \|            \|
          *    p3 ---------- p4
          */

         const m = this .matrix;

         x .assign (m .xAxis);
         y .assign (m .yAxis);
         z .assign (m .zAxis);

         r1 .assign (y) .add (z);

         const r2 = z .subtract (y);

         points [0] .assign (x)  .add (r1);
         points [1] .assign (r1) .subtract (x);
         points [2] .assign (r2) .subtract (x);
         points [3] .assign (x)  .add (r2);

         points [4] .assign (points [2]) .negate ();
         points [5] .assign (points [3]) .negate ();
         points [6] .assign (points [0]) .negate ();
         points [7] .assign (points [1]) .negate ();

         const center = this .center;

         points [0] .add (center);
         points [1] .add (center);
         points [2] .add (center);
         points [3] .add (center);

         points [4] .add (center);
         points [5] .add (center);
         points [6] .add (center);
         points [7] .add (center);

         return points;
      };
   })(),
   getAxes: function (axes)
   {
      const m = this .matrix;

      axes [0] .assign (m .xAxis);
      axes [1] .assign (m .yAxis);
      axes [2] .assign (m .zAxis);

      return axes;
   },
   getNormals: (function ()
   {
      const
         x = new Numbers_Vector3 (0, 0, 0),
         y = new Numbers_Vector3 (0, 0, 0),
         z = new Numbers_Vector3 (0, 0, 0);

      const axes = [ Numbers_Vector3.xAxis, Numbers_Vector3.yAxis, Numbers_Vector3.zAxis ];

      return function (normals)
      {
         const m = this .matrix;

         x .assign (m .xAxis);
         y .assign (m .yAxis);
         z .assign (m .zAxis);

         if (x .norm () === 0)
         {
            x .assign (y) .cross (z);

            if (x .norm () === 0)
            {
               for (const axis of axes)
               {
                  x .assign (axis) .cross (y);

                  if (x .norm () !== 0)
                     break;
               }

               if (x .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     x .assign (axis) .cross (z);

                     if (x .norm () !== 0)
                        break;
                  }

                  if (x .norm () === 0)
                     x .assign (Numbers_Vector3.xAxis);
               }
            }
         }

         if (y .norm () === 0)
         {
            y .assign (z) .cross (x);

            if (y .norm () === 0)
            {
               for (const axis of axes)
               {
                  y .assign (axis) .cross (z);

                  if (y .norm () !== 0)
                     break;
               }

               if (y .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     y .assign (axis) .cross (x);

                     if (y .norm () !== 0)
                        break;
                  }

                  if (y .norm () === 0)
                     y .assign (Numbers_Vector3.yAxis);
               }
            }
         }

         if (z .norm () === 0)
         {
            z .assign (x) .cross (y);

            if (z .norm () === 0)
            {
               for (const axis of axes)
               {
                  z .assign (axis) .cross (x);

                  if (z .norm () !== 0)
                     break;
               }

               if (z .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     z .assign (axis) .cross (y);

                     if (z .norm () !== 0)
                        break;
                  }

                  if (z .norm () === 0)
                     z .assign (Numbers_Vector3.zAxis);
               }
            }
         }

         normals [0] .assign (y) .cross (z) .normalize ();
         normals [1] .assign (z) .cross (x) .normalize ();
         normals [2] .assign (x) .cross (y) .normalize ();

         return normals;
      };
   })(),
   isEmpty: function ()
   {
      return this .matrix [15] === 0;
   },
   add: (function ()
   {
      const
         lhs_min = new Numbers_Vector3 (0, 0, 0),
         lhs_max = new Numbers_Vector3 (0, 0, 0),
         rhs_min = new Numbers_Vector3 (0, 0, 0),
         rhs_max = new Numbers_Vector3 (0, 0, 0);

      return function (box)
      {
         if (this .isEmpty ())
            return this .assign (box);

         if (box .isEmpty ())
            return this;

         this .getExtents (lhs_min, lhs_max);
         box  .getExtents (rhs_min, rhs_max);

         return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
      };
   })(),
   multLeft: function (matrix)
   {
      this .matrix .multLeft (matrix);
      return this;
   },
   multRight: function (matrix)
   {
      this .matrix .multRight (matrix);
      return this;
   },
   containsPoint: (function ()
   {
      const
         min = new Numbers_Vector3 (0, 0, 0),
         max = new Numbers_Vector3 (0, 0, 0);

      return function (point)
      {
         this .getExtents (min, max);

         return min .x <= point .x &&
                max .x >= point .x &&
                min .y <= point .y &&
                max .y >= point .y &&
                min .z <= point .z &&
                max .z >= point .z;
      };
   })(),
   intersectsBox: (function ()
   {
      const points1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const points2 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes2 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes9 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const normals = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      return function (other)
      {
         // Test special cases.

         if (this .isEmpty ())
            return false;

         if (other .isEmpty ())
            return false;

         // Get points.

         this  .getPoints (points1);
         other .getPoints (points2);

         // Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

         if (Algorithms_SAT.isSeparated (this .getNormals (normals), points1, points2))
            return false;

         // Test the three planes spanned by the normal vectors of the faces of the second parallelepiped.

         if (Algorithms_SAT.isSeparated (other .getNormals (normals), points1, points2))
            return false;

         // Test the nine other planes spanned by the edges of each parallelepiped.

         this  .getAxes (axes1);
         other .getAxes (axes2);

         for (let i1 = 0; i1 < 3; ++ i1)
         {
            for (let i2 = 0; i2 < 3; ++ i2)
               axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (axes2 [i2]);
         }

         if (Algorithms_SAT.isSeparated (axes9, points1, points2))
            return false;

         // Both boxes intersect.

         return true;
      };
   })(),
   intersectsTriangle: (function ()
   {
      const points1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes1 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const axes9 = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),

         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const normals = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
      ];

      const triangle = [ ];

      const triangleNormal = [ new Numbers_Vector3 (0, 0, 0) ];

      const triangleEdges = [
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0),
         new Numbers_Vector3 (0, 0, 0)
      ];

      return function (a, b, c)
      {
         // Test special cases.

         if (this .isEmpty ())
            return false;

         // Get points.

         this .getPoints (points1);

         triangle [0] = a;
         triangle [1] = b;
         triangle [2] = c;

         // Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

         if (Algorithms_SAT.isSeparated (this .getNormals (normals), points1, triangle))
            return false;

         // Test the normal of the triangle.

         Triangle3.normal (a, b, c, triangleNormal [0]);

         if (Algorithms_SAT.isSeparated (triangleNormal, points1, triangle))
            return false;

         // Test the nine other planes spanned by the edges of each parallelepiped.

         this .getAxes (axes1);

         triangleEdges [0] .assign (a) .subtract (b);
         triangleEdges [1] .assign (b) .subtract (c);
         triangleEdges [2] .assign (c) .subtract (a);

         for (let i1 = 0; i1 < 3; ++ i1)
         {
            for (let i2 = 0; i2 < 3; ++ i2)
               axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (triangleEdges [i2]);
         }

         if (Algorithms_SAT.isSeparated (axes9, points1, triangle))
            return false;

         // Box and triangle intersect.

         return true;
      };
   })(),
   toString: function ()
   {
      return this .size + ", " + this .center;
   },
};

Object .defineProperty (Box3 .prototype, "size",
{
   get: (function ()
   {
      const
         min = new Numbers_Vector3 (0, 0, 0),
         max = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         this .getAbsoluteExtents (min, max);

         return max .subtract (min);
      };
   })(),
   enumerable: true,
   configurable: false
});

Object .defineProperty (Box3 .prototype, "center",
{
   get: function ()
   {
      return this .matrix .origin;
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Geometry_Box3 = (Box3);

;// CONCATENATED MODULE: ./src/standard/Math/Utility/MatrixStack.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function MatrixStack (Type)
{
   return Object .assign ([ new Type () ],
   {
      top: 0,
      set: function (matrix)
      {
         this [this .top] .assign (matrix);
      },
      get: function ()
      {
         return this [this .top];
      },
      push: function ()
      {
         const top = ++ this .top;

         if (top < this .length)
            this [top] .assign (this [top - 1]);
         else
            this [top] = this [top - 1] .copy ();
      },
      pushMatrix: function (matrix)
      {
         const top = ++ this .top;

         if (top < this .length)
            this [top] .assign (matrix);
         else
            this [top] = matrix .copy ();
      },
      pop: function ()
      {
         -- this .top;
      },
      clear: function ()
      {
         this .top = 0;
      },
      size: function ()
      {
         return this .top + 1;
      },
      identity: function ()
      {
         this [this .top] .identity ();
      },
      multLeft: function (matrix)
      {
         this [this .top] .multLeft (matrix);
      },
      translate: function (vector)
      {
         this [this .top] .translate (vector);
      },
      rotate: function (rotation)
      {
         this [this .top] .rotate (rotation);
      },
      scale: function (vector)
      {
         this [this .top] .scale (vector);
      },
   });
}

/* harmony default export */ const Utility_MatrixStack = (MatrixStack);

;// CONCATENATED MODULE: ./src/x_ite/Rendering/X3DRenderObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















const
   DEPTH_BUFFER_WIDTH  = 16,
   DEPTH_BUFFER_HEIGHT = DEPTH_BUFFER_WIDTH;

function compareDistance (lhs, rhs) { return lhs .distance < rhs .distance; }

function X3DRenderObject (executionContext)
{
   this .viewVolumes              = [ ];
   this .cameraSpaceMatrix        = new Utility_MatrixStack (Numbers_Matrix4);
   this .viewMatrix               = new Utility_MatrixStack (Numbers_Matrix4);
   this .projectionMatrix         = new Utility_MatrixStack (Numbers_Matrix4);
   this .modelViewMatrix          = new Utility_MatrixStack (Numbers_Matrix4);
   this .viewportArray            = new Int32Array (4);
   this .projectionMatrixArray    = new Float32Array (16);
   this .cameraSpaceMatrixArray   = new Float32Array (16);
   this .localObjectsCount        = [0, 0, 0];
   this .globalObjects            = [ ];
   this .localObjects             = [ ];
   this .lights                   = [ ];
   this .globalShadows            = [ false ];
   this .localShadows             = [ false ];
   this .localFogs                = [ null ];
   this .layouts                  = [ ];
   this .textureProjectors        = [ ];
   this .generatedCubeMapTextures = [ ];
   this .collisions               = [ ];
   this .numOpaqueShapes          = 0;
   this .numTransparentShapes     = 0;
   this .numCollisionShapes       = 0;
   this .numShadowShapes          = 0;
   this .opaqueShapes             = [ ];
   this .transparentShapes        = [ ];
   this .transparencySorter       = new Algorithms_MergeSort (this .transparentShapes, compareDistance);
   this .collisionShapes          = [ ];
   this .activeCollisions         = new Set ();
   this .shadowShapes             = [ ];
   this .speed                    = 0;

   try
   {
      this .depthBuffer = new Rendering_TextureBuffer (executionContext .getBrowser (), DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT);
   }
   catch (error)
   {
      console .error (error);

      this .getDepth = function () { return 0; };
   }
}

X3DRenderObject .prototype =
{
   constructor: X3DRenderObject,
   initialize: function ()
   { },
   isIndependent: function ()
   {
      return true;
   },
   getRenderTime: function ()
   {
      return this .renderTime;
   },
   getViewVolumes: function ()
   {
      return this .viewVolumes;
   },
   getViewVolume: function ()
   {
      return this .viewVolumes .at (-1);
   },
   getCameraSpaceMatrix: function ()
   {
      return this .cameraSpaceMatrix;
   },
   getViewMatrix: function ()
   {
      return this .viewMatrix;
   },
   getProjectionMatrix: function ()
   {
      return this .projectionMatrix;
   },
   getModelViewMatrix: function ()
   {
      return this .modelViewMatrix;
   },
   getViewportArray: function ()
   {
      return this .viewportArray;
   },
   getProjectionMatrixArray: function ()
   {
      return this .projectionMatrixArray;
   },
   getCameraSpaceMatrixArray: function ()
   {
      return this .cameraSpaceMatrixArray;
   },
   getGlobalObjects: function ()
   {
      return this .globalObjects;
   },
   getLocalObjects: function ()
   {
      return this .localObjects;
   },
   getLocalObjectsCount: function ()
   {
      return this .localObjectsCount;
   },
   getLights: function ()
   {
      return this .lights;
   },
   pushGlobalShadows: function (value)
   {
      this .globalShadows .push (value || this .globalShadows .at (-1));
   },
   pushLocalShadows: function (value)
   {
      this .localShadows .push (value || this .localShadows .at (-1));
   },
   popLocalShadows: function ()
   {
      this .localShadows .pop ();
   },
   setGlobalFog: (function ()
   {
      const modelViewMatrix = new Numbers_Matrix4 ();

      return function (fogNode)
      {
         if (fogNode .getFogType ())
         {
            const fogContainer = this .localFogs [0] || fogNode .getFogs () .pop ();

            modelViewMatrix .assign (fogNode .getModelMatrix ()) .multRight (this .getViewMatrix () .get ());
            fogContainer .set (fogNode, modelViewMatrix);

            this .localFogs [0] = fogContainer;
         }
         else
         {
            this .localFogs [0] = null;
         }
      };
   })(),
   getLocalFogs: function ()
   {
      return this .localFogs;
   },
   getLayouts: function ()
   {
      return this .layouts;
   },
   getParentLayout: function ()
   {
      return this .layouts .at (-1);
   },
   getTextureProjectors: function ()
   {
      return this .textureProjectors;
   },
   getGeneratedCubeMapTextures: function ()
   {
      return this .generatedCubeMapTextures;
   },
   getCollisions: function ()
   {
      return this .collisions;
   },
   setNumCollisionShapes: function (value)
   {
      this .numCollisionShapes = value;
   },
   getNumCollisionShapes: function ()
   {
      return this .numCollisionShapes;
   },
   getCollisionShapes: function ()
   {
      return this .collisionShapes;
   },
   setNumShadowShapes: function (value)
   {
      this .numShadowShapes = value;
   },
   getNumShadowShapes: function ()
   {
      return this .numShadowShapes;
   },
   getShadowShapes: function ()
   {
      return this .shadowShapes;
   },
   setNumOpaqueShapes: function (value)
   {
      this .numOpaqueShapes = value;
   },
   getNumOpaqueShapes: function ()
   {
      return this .numOpaqueShapes;
   },
   getOpaqueShapes: function ()
   {
      return this .opaqueShapes;
   },
   setNumTransparentShapes: function (value)
   {
      this .numTransparentShapes = value;
   },
   getNumTransparentShapes: function ()
   {
      return this .numTransparentShapes;
   },
   getTransparentShapes: function ()
   {
      return this .transparentShapes;
   },
   constrainTranslation: function (translation, stepBack)
   {
      ///  Contrains @a translation to a possible value the avatar can move.  If the avatar reaches and intersects with an
      ///  and obstacle and @a stepBack is true a translation in the opposite directiion is returned.  Future implementation will
      ///  will then return a value where the avatar slides along the wall.  Modifies translation in place.

      // Constrain translation when the viewer collides with an obstacle.

      const distance = this .getDistance (translation) - this .getNavigationInfo () .getCollisionRadius ();

      if (distance > 0)
      {
         // Move.

         const length = translation .magnitude ();

         if (length > distance)
         {
            // Collision, the avatar would intersect with the obstacle.

            return translation .normalize () .multiply (distance);
         }

         // Everything is fine.

         return translation;
      }

      // Collision, the avatar is already within an obstacle.

      if (stepBack)
         return this .constrainTranslation (translation .normalize () .multiply (distance), false);

      return translation .assign (Numbers_Vector3.Zero);
   },
   getDistance: (function ()
   {
      const
         projectionMatrix            = new Numbers_Matrix4 (),
         cameraSpaceProjectionMatrix = new Numbers_Matrix4 (),
         localOrientation            = new Numbers_Rotation4 (0, 0, 1, 0),
         vector                      = new Numbers_Vector3 (0, 0, 0),
         rotation                    = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (direction)
      {
         ///  Returns the distance to the closest object in @a direction.  The maximum determinable value is avatarHeight * 2.

         const t0 = performance .now ();

         const
            viewpoint       = this .getViewpoint (),
            navigationInfo  = this .getNavigationInfo (),
            collisionRadius = navigationInfo .getCollisionRadius (),
            bottom          = navigationInfo .getStepHeight () - navigationInfo .getAvatarHeight (),
            nearValue       = navigationInfo .getNearValue (),
            avatarHeight    = navigationInfo .getAvatarHeight ();

         // Determine width and height of camera

         // Reshape camera

         Camera.ortho (-collisionRadius,
                        collisionRadius,
                        Math .min (bottom, -collisionRadius), /// TODO: bottom could be a positive value if stepHeight > avatarHeight.
                        collisionRadius,
                        nearValue,
                        Math .max (collisionRadius * 2, avatarHeight * 2),
                        projectionMatrix);

         // Translate camera to user position and to look in the direction of the direction.

         localOrientation .assign (viewpoint ._orientation .getValue ()) .inverse () .multRight (viewpoint .getOrientation ());
         rotation .setFromToVec (Numbers_Vector3.zAxis, vector .assign (direction) .negate ()) .multRight (localOrientation);
         viewpoint .straightenHorizon (rotation);

         cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
         cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
         cameraSpaceProjectionMatrix .rotate (rotation);
         cameraSpaceProjectionMatrix .inverse ();

         cameraSpaceProjectionMatrix .multRight (projectionMatrix);
         cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

         this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

         const depth = this .getDepth (projectionMatrix);

         this .getProjectionMatrix () .pop ();

         this .collisionTime += performance .now () - t0;
         return -depth;
      };
   })(),
   getDepth: (function ()
   {
      const
         depthBufferViewport   = new Numbers_Vector4 (0, 0, DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT),
         depthBufferViewVolume = new Geometry_ViewVolume ();

      depthBufferViewVolume .set (Numbers_Matrix4.Identity, depthBufferViewport, depthBufferViewport);

      return function (projectionMatrix)
      {
         ///  Returns the depth value to the closest object.  The maximum determinable value is avatarHeight * 2.

         this .depthBuffer .bind ();
         this .viewVolumes .push (depthBufferViewVolume);

         this .depth (this .collisionShapes, this .numCollisionShapes);

         const depth = this .depthBuffer .getDepth (projectionMatrix, depthBufferViewport);

         this .viewVolumes .pop ();
         this .depthBuffer .unbind ();

         return depth;
      };
   })(),
   render: function (type, callback, group)
   {
      switch (type)
      {
         case Rendering_TraverseType.COLLISION:
         {
            // Collect for collide and gravite
            this .numCollisionShapes = 0;

            callback .call (group, type, this);
            this .collide ();
            this .gravite ();
            break;
         }
         case Rendering_TraverseType.SHADOW:
         {
            this .numShadowShapes = 0;

            callback .call (group, type, this);
            this .depth (this .shadowShapes, this .numShadowShapes);
            break;
         }
         case Rendering_TraverseType.DISPLAY:
         {
            this .lightIndex           = 0;
            this .numOpaqueShapes      = 0;
            this .numTransparentShapes = 0;

            this .setGlobalFog (this .getFog ());

            callback .call (group, type, this);
            this .draw ();
            break;
         }
      }
   },
   addCollisionShape: (function ()
   {
      const
         bboxSize   = new Numbers_Vector3 (0, 0, 0),
         bboxCenter = new Numbers_Vector3 (0, 0, 0);

      return function (shapeNode)
      {
         const modelViewMatrix = this .getModelViewMatrix () .get ();

         modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
         modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

         const
            radius     = bboxSize .magnitude () / 2,
            viewVolume = this .viewVolumes .at (-1);

         if (viewVolume .intersectsSphere (radius, bboxCenter))
         {
            const num = this .numCollisionShapes ++;

            if (num === this .collisionShapes .length)
            {
               this .collisionShapes .push ({ renderObject: this, modelViewMatrix: new Float32Array (16), collisions: [ ], clipPlanes: [ ] });
            }

            const collisionContext = this .collisionShapes [num];

            collisionContext .modelViewMatrix .set (modelViewMatrix);
            collisionContext .shapeNode = shapeNode;
            collisionContext .scissor   = viewVolume .getScissor ();

            // Collisions

            X3DRenderObject_assign (collisionContext .collisions, this .collisions);

            // Clip planes

            X3DRenderObject_assign (collisionContext .clipPlanes, this .localObjects);

            return true;
         }

         return false;
      };
   })(),
   addShadowShape: (function ()
   {
      const
         bboxSize   = new Numbers_Vector3 (0, 0, 0),
         bboxCenter = new Numbers_Vector3 (0, 0, 0);

      return function (shapeNode)
      {
         const modelViewMatrix = this .getModelViewMatrix () .get ();

         modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
         modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

         const
            radius     = bboxSize .magnitude () / 2,
            viewVolume = this .viewVolumes .at (-1);

         if (viewVolume .intersectsSphere (radius, bboxCenter))
         {
            const num = this .numShadowShapes ++;

            if (num === this .shadowShapes .length)
            {
               this .shadowShapes .push ({ renderObject: this, modelViewMatrix: new Float32Array (16), clipPlanes: [ ] });
            }

            const depthContext = this .shadowShapes [num];

            depthContext .modelViewMatrix .set (modelViewMatrix);
            depthContext .shapeNode = shapeNode;
            depthContext .scissor   = viewVolume .getScissor ();

            // Clip planes

            X3DRenderObject_assign (depthContext .clipPlanes, this .localObjects);

            return true;
         }

         return false;
      };
   })(),
   addDisplayShape: (function ()
   {
      const
         bboxSize   = new Numbers_Vector3 (0, 0, 0),
         bboxCenter = new Numbers_Vector3 (0, 0, 0);

      return function (shapeNode)
      {
         const modelViewMatrix = this .getModelViewMatrix () .get ();

         modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
         modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

         const
            radius     = bboxSize .magnitude () / 2,
            viewVolume = this .viewVolumes .at (-1);

         if (viewVolume .intersectsSphere (radius, bboxCenter))
         {
            if (shapeNode .getTransparent ())
            {
               const num = this .numTransparentShapes ++;

               if (num === this .transparentShapes .length)
                  this .transparentShapes .push (this .createRenderContext (true));

               var renderContext = this .transparentShapes [num];
            }
            else
            {
               const num = this .numOpaqueShapes ++;

               if (num === this .opaqueShapes .length)
                  this .opaqueShapes .push (this .createRenderContext (false));

               var renderContext = this .opaqueShapes [num];
            }

            renderContext .modelViewMatrix .set (modelViewMatrix);
            renderContext .scissor .assign (viewVolume .getScissor ());
            renderContext .shadows         = this .localShadows .at (-1);
            renderContext .fogNode         = this .localFogs .at (-1);
            renderContext .shapeNode       = shapeNode;
            renderContext .appearanceNode  = shapeNode .getAppearance ();
            renderContext .distance        = bboxCenter .z;

            // Clip planes and local lights

            X3DRenderObject_assign (renderContext .objectsCount, this .localObjectsCount);
            X3DRenderObject_assign (renderContext .localObjects, this .localObjects);

            return true;
         }

         return false;
      };
   })(),
   createRenderContext: function (transparent)
   {
      return {
         renderObject: this,
         transparent: transparent,
         modelViewMatrix: new Float32Array (16),
         scissor: new Numbers_Vector4 (0, 0, 0, 0),
         localObjects: [ ],
         objectsCount: [0, 0, 0],
      };
   },
   collide: (function ()
   {
      const
         invModelViewMatrix = new Numbers_Matrix4 (),
         modelViewMatrix    = new Numbers_Matrix4 (),
         collisionBox       = new Geometry_Box3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero),
         collisionSize      = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         // Collision nodes are handled here.

         const
            activeCollisions = new Set (), // current active Collision nodes
            collisionRadius2 = 2.2 * this .getNavigationInfo () .getCollisionRadius (); // Make the radius a little bit larger.

         collisionSize .set (collisionRadius2, collisionRadius2, collisionRadius2);

         for (let i = 0, length = this .numCollisionShapes; i < length; ++ i)
         {
            const
               collisionContext = this .collisionShapes [i],
               collisions       = collisionContext .collisions;

            if (collisions .length)
            {
               collisionBox .set (collisionSize, Numbers_Vector3.Zero);
               collisionBox .multRight (invModelViewMatrix .assign (collisionContext .modelViewMatrix) .inverse ());

               if (collisionContext .shapeNode .intersectsBox (collisionBox, collisionContext .clipPlanes, modelViewMatrix .assign (collisionContext .modelViewMatrix)))
               {
                  for (const collision of collisions)
                     activeCollisions .add (collision);
               }
            }
         }

         // Set isActive to FALSE for affected nodes.

         if (this .activeCollisions .size)
         {
            const inActiveCollisions = activeCollisions .size
                                       ? Math_Algorithm.set_difference (this .activeCollisions, activeCollisions, new Set ())
                                       : this .activeCollisions;

            for (const collision of inActiveCollisions)
               collision .set_active (false);
         }

         // Set isActive to TRUE for affected nodes.

         this .activeCollisions = activeCollisions;

         for (const collision of activeCollisions)
            collision .set_active (true);
      };
   })(),
   gravite: (function ()
   {
      const
         projectionMatrix            = new Numbers_Matrix4 (),
         cameraSpaceProjectionMatrix = new Numbers_Matrix4 (),
         translation                 = new Numbers_Vector3 (0, 0, 0),
         rotation                    = new Numbers_Rotation4 (0, 0, 1, 0);

      return function ()
      {
         const browser = this .getBrowser ();

         // Terrain following and gravitation.

         if (browser .getActiveLayer () === this)
         {
            if (browser .getCurrentViewer () !== "WALK")
               return;
         }
         else if (this .getNavigationInfo () .getViewer () !== "WALK")
         {
            return;
         }

         // Get NavigationInfo values.

         const
            navigationInfo  = this .getNavigationInfo (),
            viewpoint       = this .getViewpoint (),
            collisionRadius = navigationInfo .getCollisionRadius (),
            nearValue       = navigationInfo .getNearValue (),
            avatarHeight    = navigationInfo .getAvatarHeight (),
            stepHeight      = navigationInfo .getStepHeight ();

         // Reshape viewpoint for gravite.

         Camera.ortho (-collisionRadius,
                        collisionRadius,
                        -collisionRadius,
                        collisionRadius,
                        nearValue,
                        Math .max (collisionRadius * 2, avatarHeight * 2),
                        projectionMatrix);

         // Transform viewpoint to look down the up vector.

         const
            upVector = viewpoint .getUpVector (),
            down     = rotation .setFromToVec (Numbers_Vector3.zAxis, upVector);

         cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
         cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
         cameraSpaceProjectionMatrix .rotate (down);
         cameraSpaceProjectionMatrix .inverse ();

         cameraSpaceProjectionMatrix .multRight (projectionMatrix);
         cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

         this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

         let distance = -this .getDepth (projectionMatrix);

         this .getProjectionMatrix () .pop ();

         // Gravite or step up.

         distance -= avatarHeight;

         const up = rotation .setFromToVec (Numbers_Vector3.yAxis, upVector);

         if (distance > 0)
         {
            // Gravite and fall down the to the floor.

            const currentFrameRate = this .speed ? browser .getCurrentFrameRate () : 1000000;

            this .speed -= browser .getBrowserOptions () ._Gravity .getValue () / currentFrameRate;

            let y = this .speed / currentFrameRate;

            if (y < -distance)
            {
               // The ground is reached.
               y = -distance;
               this .speed = 0;
            }

            viewpoint ._positionOffset = viewpoint ._positionOffset .getValue () .add (up .multVecRot (translation .set (0, y, 0)));
         }
         else
         {
            this .speed = 0;

            distance = -distance;

            if (distance > 0.01 && distance < stepHeight)
            {
               // Step up.

               this .constrainTranslation (up .multVecRot (translation .set (0, distance, 0)), false);

               //if (getBrowser () -> getBrowserOptions () -> animateStairWalks ())
               //{
               //	float step = getBrowser () -> getCurrentSpeed () / getBrowser () -> getCurrentFrameRate ();
               //	step = abs (getViewMatrix () .mult_matrix_dir (Vector3f (0, step, 0) * up));
               //
               //	Vector3f offset = Vector3f (0, step, 0) * up;
               //
               //	if (math::abs (offset) > math::abs (translation) or getBrowser () -> getCurrentSpeed () == 0)
               //		offset = translation;
               //
               //	getViewpoint () -> positionOffset () += offset;
               //}
               //else
                  viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());
            }
         }
      };
   })(),
   depth: (function ()
   {
      const projectionMatrixArray = new Float32Array (16);

      return function (shapes, numShapes)
      {
         const
            browser  = this .getBrowser (),
            gl       = browser .getContext (),
            viewport = this .getViewVolume () .getViewport ();

         // Configure depth shaders.

         projectionMatrixArray .set (this .getProjectionMatrix () .get ());

         // Configure viewport and background

         gl .viewport (viewport [0],
                       viewport [1],
                       viewport [2],
                       viewport [3]);

         gl .scissor (viewport [0],
                      viewport [1],
                      viewport [2],
                      viewport [3]);

         gl .clearColor (1, 0, 0, 0); // Must be '1, 0, 0, 0'.
         gl .clear (gl .COLOR_BUFFER_BIT | gl .DEPTH_BUFFER_BIT);

         // Render all objects

         gl .depthMask (true);
         gl .enable (gl .DEPTH_TEST);
         gl .disable (gl .BLEND);
         gl .disable (gl .CULL_FACE);

         for (let s = 0; s < numShapes; ++ s)
         {
            const
               depthContext = shapes [s],
               scissor      = depthContext .scissor;

            gl .scissor (scissor .x,
                         scissor .y,
                         scissor .z,
                         scissor .w);

            // Draw

            depthContext .shapeNode .depth (gl, depthContext, projectionMatrixArray);
         }
      };
   })(),
   draw: function ()
   {
      const
         browser                    = this .getBrowser (),
         gl                         = browser .getContext (),
         viewport                   = this .getViewVolume () .getViewport (),
         lights                     = this .lights,
         textureProjectors          = this .textureProjectors,
         generatedCubeMapTextures   = this .generatedCubeMapTextures,
         globalShadows              = this .globalShadows,
         shadows                    = globalShadows .at (-1),
         headlight                  = this .getNavigationInfo () ._headlight .getValue (),
         numGlobalLights            = lights .reduce ((v, c) => v + c .lightNode .getGlobal (), +headlight),
         numGlobalTextureProjectors = textureProjectors .reduce ((v, c) => v + c .textureProjectorNode .getGlobal (), 0);


      this .renderTime = performance .now ();


      // PREPARATIONS


      if (this .isIndependent ())
      {
         // Render shadow maps.

         for (const light of lights)
            light .renderShadowMap (this);

         // Render GeneratedCubeMapTextures.

         for (const generatedCubeMapTexture of generatedCubeMapTextures)
            generatedCubeMapTexture .renderTexture (this);
      }

      // Set up shadow matrix for all lights, and matrix for all projective textures.

      if (headlight)
         browser .getHeadlight () .setGlobalVariables (this);

      for (const light of lights)
         light .setGlobalVariables (this);

      for (const textureProjector of textureProjectors)
         textureProjector .setGlobalVariables (this);

      // Set global uniforms.

      this .viewportArray          .set (viewport);
      this .cameraSpaceMatrixArray .set (this .getCameraSpaceMatrix () .get ());
      this .projectionMatrixArray  .set (this .getProjectionMatrix () .get ());


      // DRAW


      // Configure viewport and background

      gl .viewport (viewport .x,
                    viewport .y,
                    viewport .z,
                    viewport .w);

      gl .scissor (viewport .x,
                   viewport .y,
                   viewport .z,
                   viewport .w);

      // Draw background.

      gl .clear (gl .DEPTH_BUFFER_BIT);

      this .getBackground () .display (gl, this, viewport);

      // Sorted blend

      // Render opaque objects first

      gl .depthMask (true);
      gl .enable (gl .DEPTH_TEST);
      gl .disable (gl .BLEND);

      const opaqueShapes = this .opaqueShapes;

      for (let i = 0, length = this .numOpaqueShapes; i < length; ++ i)
      {
         const
            renderContext = opaqueShapes [i],
            scissor       = renderContext .scissor;

         gl .scissor (scissor .x,
                      scissor .y,
                      scissor .z,
                      scissor .w);

         renderContext .shadows           = renderContext .shadows || shadows;
         renderContext .objectsCount [1] += numGlobalLights;
         renderContext .objectsCount [2] += numGlobalTextureProjectors;

         renderContext .shapeNode .display (gl, renderContext);
         browser .resetTextureUnits ();
      }

      // Render transparent objects

      gl .depthMask (false);
      gl .enable (gl .BLEND);

      const transparentShapes = this .transparentShapes;

      this .transparencySorter .sort (0, this .numTransparentShapes);

      for (let i = 0, length = this .numTransparentShapes; i < length; ++ i)
      {
         const
            renderContext = transparentShapes [i],
            scissor       = renderContext .scissor;

         gl .scissor (scissor .x,
                      scissor .y,
                      scissor .z,
                      scissor .w);

         renderContext .shadows           = renderContext .shadows || shadows;
         renderContext .objectsCount [1] += numGlobalLights;
         renderContext .objectsCount [2] += numGlobalTextureProjectors;

         renderContext .shapeNode .display (gl, renderContext);
         browser .resetTextureUnits ();
      }

      gl .depthMask (true);
      gl .disable (gl .BLEND);


      // POST DRAW

      const globalObjects = this .globalObjects;

      if (this .isIndependent ())
      {
         // Recycle clip planes, local fogs, local lights, and local projective textures.

         const localObjects = browser .getLocalObjects ();

         for (const localObject of localObjects)
            localObject .dispose ();

         localObjects .length = 0;

         // Recycle global lights and global projective textures.

         for (const globalObject of globalObjects)
            globalObject .dispose ();
      }

      // Reset containers.

      globalObjects            .length = 0;
      lights                   .length = 0;
      globalShadows            .length = 1;
      textureProjectors        .length = 0;
      generatedCubeMapTextures .length = 0;
   },
};

function X3DRenderObject_assign (lhs, rhs)
{
   for (var i = 0, length = rhs .length; i < length; ++ i)
      lhs [i] = rhs [i];

   lhs .length = length;
}

/* harmony default export */ const Rendering_X3DRenderObject = (X3DRenderObject);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DChildNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DChildNode (executionContext)
{
   if (this .getExecutionContext ())
      return;

   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DChildNode);

   this .addChildObjects ("isCameraObject",   new x_ite_Fields.SFBool ());
   this .addChildObjects ("isPickableObject", new x_ite_Fields.SFBool ());

   this ._isCameraObject   .setAccessType (Base_X3DConstants.outputOnly);
   this ._isPickableObject .setAccessType (Base_X3DConstants.outputOnly);
}

X3DChildNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DChildNode,
   setCameraObject: function (value)
   {
      if (value !== this ._isCameraObject .getValue ())
         this ._isCameraObject = value;
   },
   getCameraObject: function ()
   {
      return this ._isCameraObject .getValue ();
   },
   setPickableObject: function (value)
   {
      if (value !== this ._isPickableObject .getValue ())
         this ._isPickableObject = value;
   },
   getPickableObject: function ()
   {
      return this ._isPickableObject .getValue ();
   },
});

/* harmony default export */ const Core_X3DChildNode = (X3DChildNode);

;// CONCATENATED MODULE: ./src/x_ite/Base/X3DCast.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ function X3DCast(type, node, innerNode = true)
{
   try
   {
      if (node)
      {
         if (node instanceof x_ite_Fields.SFNode)
            node = node .getValue ();

         if (node)
         {
            if (innerNode)
               node = node .getInnerNode ();

            if (node .getType () .includes (type))
               return node;
         }
      }
   }
   catch (error)
   { }

   return null;
};

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/X3DBoundedObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function X3DBoundedObject (executionContext)
{
   this .addType (Base_X3DConstants.X3DBoundedObject);

   this .addChildObjects ("transformSensors_changed", new x_ite_Fields.SFTime ());

   this ._bboxSize   .setUnit ("length");
   this ._bboxCenter .setUnit ("length");

   this .childBBox            = new Geometry_Box3 (); // Must be unique for each X3DBoundedObject.
   this .transformSensorNodes = new Set ();
}

X3DBoundedObject .prototype =
{
   constructor: X3DBoundedObject,
   initialize: function () { },
   getDefaultBBoxSize: (function ()
   {
      const defaultBBoxSize = new Numbers_Vector3 (-1, -1, -1);

      return function ()
      {
         return defaultBBoxSize;
      };
   })(),
   getBBox: function (nodes, bbox, shadows)
   {
      // Must be unique for each X3DBoundedObject.
      const childBBox = this .childBBox;

      // Add bounding boxes.

      bbox .set ();

      for (var i = 0, length = nodes .length; i < length; ++ i)
      {
         const node = nodes [i];

         if (node .getBBox)
            bbox .add (node .getBBox (childBBox, shadows));
      }

      return bbox;
   },
   displayBBox: (function ()
   {
      const
         bbox   = new Geometry_Box3 (),
         matrix = new Numbers_Matrix4 ();

      return function (type, renderObject)
      {
         const modelViewMatrix = renderObject .getModelViewMatrix ();

         this .getBBox (bbox);

         matrix .set (bbox .center, null, bbox .size);

         modelViewMatrix .push ();
         modelViewMatrix .multLeft (matrix);

         this .getBrowser () .getBBoxNode () .traverse (type, renderObject);

         modelViewMatrix .pop ();
      };
   })(),
   addTransformSensor: function (transformSensorNode)
   {
      this .transformSensorNodes .add (transformSensorNode);

      this ._transformSensors_changed = this .getBrowser () .getCurrentTime ();
   },
   removeTransformSensor: function (transformSensorNode)
   {
      this .transformSensorNodes .delete (transformSensorNode);

      this ._transformSensors_changed = this .getBrowser () .getCurrentTime ();
   },
   getTransformSensors: function ()
   {
      return this .transformSensorNodes;
   },
   dispose: function () { },
};

/* harmony default export */ const Grouping_X3DBoundedObject = (X3DBoundedObject);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/X3DGroupingNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function X3DGroupingNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   Grouping_X3DBoundedObject.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DGroupingNode);

   this .hidden                    = false;
   this .allowedTypes              = new Set ();
   this .clipPlaneNodes            = [ ];
   this .localFogNodes             = [ ];
   this .lightNodes                = [ ];
   this .textureProjectorNodes     = [ ];
   this .pointingDeviceSensorNodes = [ ];
   this .maybeCameraObjects        = [ ];
   this .cameraObjects             = [ ];
   this .maybePickableSensorNodes  = [ ];
   this .pickableSensorNodes       = [ ];
   this .pickableObjects           = [ ];
   this .childNodes                = [ ];
   this .displayNodes              = [ ];
   this .visibleNodes              = [ ];
   this .boundedObjects            = [ ];
   this .sensors                   = new Map ();
}

X3DGroupingNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   Grouping_X3DBoundedObject.prototype,
{
   constructor: X3DGroupingNode,
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      Grouping_X3DBoundedObject.prototype.initialize.call (this);

      this ._transformSensors_changed .addInterest ("set_transformSensors__", this);

      this ._addChildren    .addInterest ("set_addChildren__",    this);
      this ._removeChildren .addInterest ("set_removeChildren__", this);
      this ._children       .addInterest ("set_children__",       this);

      this .set_children__ ();
   },
   getBBox: function (bbox, shadows)
   {
      return this .getSubBBox (bbox, shadows);
   },
   getSubBBox: function (bbox, shadows)
   {
      if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
         return Grouping_X3DBoundedObject.prototype.getBBox.call (this, this .visibleNodes, bbox, shadows);

      return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
   },
   setHidden: function (value)
   {
      if (value !== this .hidden)
      {
         this .hidden = value;

         this .set_children__ ();
      }
   },
   setAllowedTypes: function (/* type, ... */)
   {
      const allowedTypes = this .allowedTypes;

      allowedTypes .clear ();

      for (const type of arguments)
         allowedTypes .add (type);
   },
   set_addChildren__: function ()
   {
      if (this ._addChildren .length === 0)
         return;

      this ._addChildren .setTainted (true);
      this ._addChildren .erase (remove (this ._addChildren, 0, this ._addChildren .length,
                                         this ._children,    0, this ._children    .length),
                                 this ._addChildren .length);

      if (!this ._children .isTainted ())
      {
         this ._children .removeInterest ("set_children__", this);
         this ._children .addInterest ("connectChildren", this);
      }

      this ._children .insert (this ._children .length, this ._addChildren, 0, this ._addChildren .length);
      this .add (this ._addChildren);

      this ._addChildren .length = 0;
      this ._addChildren .setTainted (false);
   },
   set_removeChildren__: function ()
   {
      if (this ._removeChildren .length === 0)
         return;

      this ._removeChildren .setTainted (true);

      if (this ._children .length > 0)
      {
         if (!this ._children .isTainted ())
         {
            this ._children .removeInterest ("set_children__", this);
            this ._children .addInterest ("connectChildren", this);
         }

         this ._children .erase (remove (this ._children,       0, this ._children .length,
                                         this ._removeChildren, 0, this ._removeChildren .length),
                                 this ._children .length);

         this .remove (this ._removeChildren);
      }

      this ._removeChildren .length = 0;
      this ._removeChildren .setTainted (false);
   },
   set_children__: function ()
   {
      this .clear ();
      this .add (this ._children);
   },
   connectChildren: function ()
   {
      this ._children .removeInterest ("connectChildren", this);
      this ._children .addInterest ("set_children__", this);
   },
   clear: function ()
   {
      for (const maybePickableSensorNode of this .maybePickableSensorNodes)
         maybePickableSensorNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

      for (const childNode of this .childNodes)
      {
         childNode ._isCameraObject   .removeInterest ("set_cameraObjects__",   this);
         childNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

         if (X3DCast (Base_X3DConstants.X3DBoundedObject, childNode))
         {
            childNode ._visible     .removeInterest ("set_visibles__",      this);
            childNode ._bboxDisplay .removeInterest ("set_bboxDisplays__",  this);
         }
      }

      this .clipPlaneNodes            .length = 0;
      this .localFogNodes             .length = 0;
      this .lightNodes                .length = 0;
      this .textureProjectorNodes     .length = 0;
      this .pointingDeviceSensorNodes .length = 0;
      this .maybeCameraObjects        .length = 0;
      this .maybePickableSensorNodes  .length = 0;
      this .childNodes                .length = 0;
   },
   add: function (children)
   {
      if (this .hidden)
         return;

      for (const child of children)
      {
         if (child)
         {
            try
            {
               const
                  innerNode = child .getValue () .getInnerNode (),
                  type      = innerNode .getType ();

               for (let t = type .length - 1; t >= 0; -- t)
               {
//							if (this .allowedTypes .size)
//							{
//								if (!innerNode .getType () .some (Set .prototype .has, this .allowedTypes))
//									continue;
//							}

                  switch (type [t])
                  {
                     case Base_X3DConstants.X3DPointingDeviceSensorNode:
                     {
                        this .pointingDeviceSensorNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.ClipPlane:
                     {
                        this .clipPlaneNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.LocalFog:
                     {
                        this .localFogNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.X3DTextureProjectorNode:
                     {
                        this .textureProjectorNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.X3DLightNode:
                     {
                        this .lightNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.X3DBindableNode:
                     {
                        this .maybeCameraObjects .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.TransformSensor:
                     case Base_X3DConstants.X3DPickSensorNode:
                     {
                        innerNode ._isPickableObject .addInterest ("set_pickableObjects__", this);

                        this .maybePickableSensorNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.X3DBackgroundNode:
                     case Base_X3DConstants.X3DChildNode:
                     {
                        innerNode ._isCameraObject   .addInterest ("set_cameraObjects__",   this);
                        innerNode ._isPickableObject .addInterest ("set_pickableObjects__", this);

                        if (X3DCast (Base_X3DConstants.X3DBoundedObject, innerNode))
                        {
                           innerNode ._visible     .addInterest ("set_visibles__",     this);
                           innerNode ._bboxDisplay .addInterest ("set_bboxDisplays__", this);
                        }

                        this .maybeCameraObjects .push (innerNode);
                        this .childNodes .push (innerNode);
                        break;
                     }
                     case Base_X3DConstants.BooleanFilter:
                     case Base_X3DConstants.BooleanToggle:
                     case Base_X3DConstants.NurbsOrientationInterpolator:
                     case Base_X3DConstants.NurbsPositionInterpolator:
                     case Base_X3DConstants.NurbsSurfaceInterpolator:
                     case Base_X3DConstants.TimeSensor:
                     case Base_X3DConstants.X3DFollowerNode:
                     case Base_X3DConstants.X3DInfoNode:
                     case Base_X3DConstants.X3DInterpolatorNode:
                     case Base_X3DConstants.X3DKeyDeviceSensorNode:
                     case Base_X3DConstants.X3DLayoutNode:
                     case Base_X3DConstants.X3DScriptNode:
                     case Base_X3DConstants.X3DSequencerNode:
                     case Base_X3DConstants.X3DTriggerNode:
                        break;
                     default:
                        continue;
                  }

                  break;
               }
            }
            catch (error)
            { }
         }
      }

      this .set_pickableObjects__ ()
      this .set_displayNodes__ ()
      this .set_visibles__ ()
      this .set_bboxDisplays__ ();
   },
   remove: function (children)
   {
      for (const child of children)
      {
         if (child)
         {
            try
            {
               const
                  innerNode = child .getValue () .getInnerNode (),
                  type      = innerNode .getType ();

               for (let t = type .length - 1; t >= 0; -- t)
               {
                  switch (type [t])
                  {
                     case Base_X3DConstants.X3DPointingDeviceSensorNode:
                     {
                        const index = this .pointingDeviceSensorNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .pointingDeviceSensorNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.ClipPlane:
                     {
                        const index = this .clipPlaneNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .clipPlaneNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.LocalFog:
                     {
                        const index = this .localFogNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .localFogNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.X3DTextureProjectorNode:
                     {
                        const index = this .textureProjectorNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .textureProjectorNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.X3DLightNode:
                     {
                        const index = this .lightNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .lightNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.X3DBindableNode:
                     {
                        const index = this .maybeCameraObjects .indexOf (innerNode);

                        if (index >= 0)
                           this .maybeCameraObjects .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.TransformSensor:
                     case Base_X3DConstants.X3DPickSensorNode:
                     {
                        innerNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

                        const index = this .maybePickableSensorNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .maybePickableSensorNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.X3DBackgroundNode:
                     case Base_X3DConstants.X3DChildNode:
                     {
                        innerNode ._isCameraObject   .removeInterest ("set_cameraObjects__",   this);
                        innerNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

                        if (X3DCast (Base_X3DConstants.X3DBoundedObject, innerNode))
                        {
                           innerNode ._visible     .removeInterest ("set_visibles__",     this);
                           innerNode ._bboxDisplay .removeInterest ("set_bboxDisplays__", this);
                        }

                        var index = this .maybeCameraObjects .indexOf (innerNode);

                        if (index >= 0)
                           this .maybeCameraObjects .splice (index, 1);

                        var index = this .childNodes .indexOf (innerNode);

                        if (index >= 0)
                           this .childNodes .splice (index, 1);

                        break;
                     }
                     case Base_X3DConstants.BooleanFilter:
                     case Base_X3DConstants.BooleanToggle:
                     case Base_X3DConstants.NurbsOrientationInterpolator:
                     case Base_X3DConstants.NurbsPositionInterpolator:
                     case Base_X3DConstants.NurbsSurfaceInterpolator:
                     case Base_X3DConstants.TimeSensor:
                     case Base_X3DConstants.X3DFollowerNode:
                     case Base_X3DConstants.X3DInfoNode:
                     case Base_X3DConstants.X3DInterpolatorNode:
                     case Base_X3DConstants.X3DKeyDeviceSensorNode:
                     case Base_X3DConstants.X3DLayoutNode:
                     case Base_X3DConstants.X3DScriptNode:
                     case Base_X3DConstants.X3DSequencerNode:
                     case Base_X3DConstants.X3DTriggerNode:
                        break;
                     default:
                        continue;
                  }

                  break;
               }
            }
            catch (error)
            { }
         }
      }

      this .set_pickableObjects__ ();
      this .set_displayNodes__ ();
      this .set_visibles__ ();
      this .set_bboxDisplays__ ();
   },
   set_cameraObjects__: function ()
   {
      const cameraObjects = this .cameraObjects;

      cameraObjects .length = 0;

      for (const childNode of this .maybeCameraObjects)
      {
         if (childNode .getCameraObject ())
         {
            if (X3DCast (Base_X3DConstants.X3DBoundedObject, childNode))
            {
               if (childNode ._visible .getValue ())
               {
                  cameraObjects .push (childNode);
               }
            }
            else
            {
               cameraObjects .push (childNode);
            }
         }
      }

      this .setCameraObject (Boolean (cameraObjects .length));
   },
   set_pickableObjects__: function ()
   {
      const
         pickableSensorNodes = this .pickableSensorNodes,
         pickableObjects     = this .pickableObjects;

      pickableSensorNodes .length = 0;
      pickableObjects     .length = 0;

      for (const sensorNode of this .maybePickableSensorNodes)
      {
         if (sensorNode .getPickableObject ())
            pickableSensorNodes .push (sensorNode);
      }

      for (const childNode of this .childNodes)
      {
         if (childNode .getPickableObject ())
            pickableObjects .push (childNode);
      }

      this .set_transformSensors__ ()
   },
   set_transformSensors__: function ()
   {
      this .setPickableObject (Boolean (this .getTransformSensors () .size || this .pickableSensorNodes .length || this .pickableObjects .length));
   },
   set_displayNodes__: function ()
   {
      const displayNodes = this .displayNodes;

      displayNodes .length = 0;

      for (const node of this .clipPlaneNodes)
         displayNodes .push (node);

      for (const node of this .localFogNodes)
         displayNodes .push (node);

      for (const node of this .lightNodes)
         displayNodes .push (node);

      for (const node of this .textureProjectorNodes)
         displayNodes .push (node);
   },
   set_visibles__: function ()
   {
      const
         childNodes   = this .childNodes,
         visibleNodes = this .visibleNodes;

      visibleNodes .length = 0;

      for (const childNode of childNodes)
      {
         if (X3DCast (Base_X3DConstants.X3DBoundedObject, childNode))
         {
            if (childNode ._visible .getValue ())
            {
               visibleNodes .push (childNode);
            }
         }
         else
         {
            visibleNodes .push (childNode);
         }
      }

      this .set_cameraObjects__ ();
   },
   set_bboxDisplays__: function ()
   {
      const boundedObjects = this .boundedObjects;

      boundedObjects .length = 0;

      for (const childNode of this .childNodes)
      {
         if (X3DCast (Base_X3DConstants.X3DBoundedObject, childNode))
         {
            if (childNode ._bboxDisplay .getValue ())
            {
               boundedObjects .push (childNode);
            }
         }
      }
   },
   traverse: function (type, renderObject)
   {
      switch (type)
      {
         case Rendering_TraverseType.POINTER:
         {
            const
               pointingDeviceSensorNodes = this .pointingDeviceSensorNodes,
               clipPlaneNodes            = this .clipPlaneNodes,
               sensors                   = this .sensors;

            sensors .clear ();

            if (pointingDeviceSensorNodes .length)
            {
               for (const pointingDeviceSensorNode of pointingDeviceSensorNodes)
                  pointingDeviceSensorNode .push (renderObject, sensors);

               if (sensors .size)
                  this .getBrowser () .getSensors () .push (sensors);
            }

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .push (renderObject);

            for (const childNode of this .childNodes)
               childNode .traverse (type, renderObject);

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .pop (renderObject);

            if (sensors .size)
               this .getBrowser () .getSensors () .pop ();

            return;
         }
         case Rendering_TraverseType.CAMERA:
         {
            for (const cameraObject of this .cameraObjects)
               cameraObject .traverse (type, renderObject);

            return;
         }
         case Rendering_TraverseType.PICKING:
         {
            if (this .getTransformSensors () .size)
            {
               const modelMatrix = renderObject .getModelViewMatrix () .get ();

               for (const transformSensorNode of this .getTransformSensors ())
                  transformSensorNode .collect (modelMatrix);
            }

            for (const pickableSensorNode of this .pickableSensorNodes)
               pickableSensorNode .traverse (type, renderObject);

            const
               browser          = this .getBrowser (),
               pickingHierarchy = browser .getPickingHierarchy ();

            pickingHierarchy .push (this);

            if (browser .getPickable () .at (-1))
            {
               for (const childNode of this .childNodes)
                  childNode .traverse (type, renderObject);
            }
            else
            {
               for (const pickableObject of this .pickableObjects)
                  pickableObject .traverse (type, renderObject);
            }

            pickingHierarchy .pop ();
            return;
         }
         case Rendering_TraverseType.COLLISION:
         {
            const clipPlaneNodes = this .clipPlaneNodes;

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .push (renderObject);

            for (const childNode of this .childNodes)
               childNode .traverse (type, renderObject);

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .pop (renderObject);

            return;
         }
         case Rendering_TraverseType.SHADOW:
         {
            // Nodes that are not visible do not cast shadows.

            const clipPlaneNodes = this .clipPlaneNodes;

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .push (renderObject);

            for (const visibleNode of this .visibleNodes)
               visibleNode .traverse (type, renderObject);

            for (const clipPlaneNode of clipPlaneNodes)
               clipPlaneNode .push (renderObject);

            return;
         }
         case Rendering_TraverseType.DISPLAY:
         {
            const displayNodes = this .displayNodes;

            for (const displayNode of displayNodes)
               displayNode .push (renderObject, this);

            for (const visibleNode of this .visibleNodes)
               visibleNode .traverse (type, renderObject);

            for (const boundedObject of this .boundedObjects)
               boundedObject .displayBBox (type, renderObject);

            for (const displayNode of displayNodes)
               displayNode .pop (renderObject);

            return;
         }
      }
   },
});

function remove (array, first, last, range, rfirst, rlast)
{
   const set = new Set ();

   for (let i = rfirst; i < rlast; ++ i)
      set .add (range [i]);

   function compare (value) { return set .has (value); }

   return array .remove (first, last, compare);
}

/* harmony default export */ const Grouping_X3DGroupingNode = (X3DGroupingNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering/X3DViewportNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DViewportNode (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DViewportNode);
}

X3DViewportNode .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: X3DViewportNode,
});

/* harmony default export */ const Layering_X3DViewportNode = (X3DViewportNode);

;// CONCATENATED MODULE: ./src/x_ite/Execution/BindableStack.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function BindableStack (executionContext, defaultNode)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .array          = [ defaultNode ];
   this .transitionNode = defaultNode .create (executionContext);
}

BindableStack .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BindableStack,
   getTypeName: function ()
   {
      return "BindableStack";
   },
   get: function ()
   {
      return this .array;
   },
   top: function ()
   {
      return this .transitionNode ._transitionActive .getValue () ? this .transitionNode : this .array .at (-1);
   },
   pushOnTop: function (node)
   {
      if (node !== this .array [0])
      {
         this .array .at (-1) ._isBound = false;
         this .array .push (node);
      }

      // Don't do set_bind.
      node ._isBound  = true;
      node ._bindTime = this .getBrowser () .getCurrentTime ();

      this .addNodeEvent ();
   },
   update: function (layerNode, removedNodes, changedNodes)
   {
      if (removedNodes .length === 0 && changedNodes .length === 0)
         return;

      // Save top node for later use.

      const
         fromNode  = this .top (),
         boundNode = this .array .at (-1);

      // Remove invisible nodes and unbind them if needed.

      for (const removedNode of removedNodes)
      {
         const index = this .array .indexOf (removedNode);

         if (index > 0)
            this .array .splice (index, 1);
      }

      // Unbind nodes with set_bind false and pop top node.

      if (boundNode !== this .array [0])
      {
         if (changedNodes .some (node => ! node ._set_bind .getValue () && node === boundNode))
         {
            this .array .pop ();
         }
      }

      // Push nodes with set_bind true to top of stack.

      for (const bindNode of changedNodes)
      {
         if (bindNode ._set_bind .getValue ())
         {
            const index = this .array .indexOf (bindNode);

            if (index > -1)
            {
               this .array .splice (index, 1);
            }

            this .array .push (bindNode);
         }
      }

      // Bind top node if not bound.

      const top = this .array .at (-1);

      if (top === boundNode)
         return;

      // First unbind last bound node.

      boundNode ._set_bind = false;
      boundNode ._isBound  = false;

      // Now bind new top node.

      top ._set_bind  = true;
      top ._isBound   = true;
      top ._bindTime  = this .getBrowser () .getCurrentTime ();

      // Do transition.

      this .transitionNode = top .create (this .getExecutionContext ());

      this .transitionNode .setup ();
      this .transitionNode .transitionStart (layerNode, fromNode, top);

      if (this .transitionNode ._transitionActive .getValue ())
         this .transitionNode ._transitionActive .addInterest ("set_transitionActive__", this);

      this .addNodeEvent ();
   },
   set_transitionActive__: function (transitionActive)
   {
      if (transitionActive .getValue ())
         return;

      this .transitionNode ._transitionActive .removeInterest ("set_transitionActive__", this);

      this .addNodeEvent ();
   },
});

for (const key of Reflect .ownKeys (BindableStack .prototype))
   Object .defineProperty (BindableStack .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_BindableStack = (BindableStack);

;// CONCATENATED MODULE: ./src/x_ite/Execution/BindableList.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function BindableList (executionContext, defaultNode)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .collected    = [ defaultNode ];
   this .array        = [ defaultNode ];
   this .updateTime   = 0;
   this .removedNodes = [ ];
}

BindableList .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BindableList,
   getTypeName: function ()
   {
      return "BindableList";
   },
   get: function ()
   {
      return this .array;
   },
   getBound: function (name)
   {
      if (this .array .length > 1)
      {
         const
            enableInlineBindables = false,
            mainScene             = this .getMainScene ();

         if (name && name .length)
         {
            // Return first viewpoint with @name.

            for (let i = 1, length = this .array .length; i < length; ++ i)
            {
               const
                  node      = this .array [i],
                  outerNode = node .getExecutionContext () .getOuterNode (),
                  scene     = outerNode instanceof Core_X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

               if (!enableInlineBindables && scene !== mainScene)
                  continue;

               if (node .getName () == name)
                  return node;
            }
         }

         // Return first bound viewpoint in scene.

         for (let i = 1, length = this .array .length; i < length; ++ i)
         {
            const
               node      = this .array [i],
               outerNode = node .getExecutionContext () .getOuterNode (),
               scene     = outerNode instanceof Core_X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

            if (!enableInlineBindables && scene !== mainScene)
               continue;

            if (node ._isBound .getValue ())
               return node;
         }

         // Return first viewpoint in scene.

         for (let i = 1, length = this .array .length; i < length; ++ i)
         {
            const
               node      = this .array [i],
               outerNode = node .getExecutionContext () .getOuterNode (),
               scene     = outerNode instanceof Core_X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

            if (!enableInlineBindables && scene !== mainScene)
               continue;

            return node;
         }
      }

      // Return default viewpoint.

      return this .array [0];
   },
   push: function (node)
   {
      return this .collected .push (node);
   },
   update: function (layerNode, stack)
   {
      const
         changedNodes = this .collected .filter (node => node ._set_bind .getModificationTime () > this .updateTime),
         removedNodes = this .removedNodes;

      if (! equals (this .collected, this .array))
      {
         // Unbind nodes not in current list (collected);

         for (const node of this .array)
         {
            if (this .collected .indexOf (node) === -1)
            {
               removedNodes .push (node);
            }
         }

         // Swap arrays.

         const tmp = this .array;

         this .array     = this .collected;
         this .collected = tmp;
      }

      // Clear collected array.

      this .collected .length = 1;

      // Update stack.

      stack .update (layerNode, removedNodes, changedNodes)

      removedNodes .length = 0;

      // Advance updateTime time.

      this .updateTime = performance .now ();
   },
});

for (const key of Reflect .ownKeys (BindableList .prototype))
   Object .defineProperty (BindableList .prototype, key, { enumerable: false });

// Compares two arrays.

function equals (lhs, rhs)
{
   if (lhs .length !== rhs .length)
      return false;

   for (let i = 0; i < lhs .length; ++ i)
   {
      if (lhs [i] !== rhs [i])
         return false
   }

   return true;
}

/* harmony default export */ const Execution_BindableList = (BindableList);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DBindableNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DBindableNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DBindableNode);

   this .addChildObjects ("transitionActive", new x_ite_Fields.SFBool ());
}

X3DBindableNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DBindableNode,
   getCameraObject: function ()
   {
      return true;
   },
   transitionStart: function ()
   { },
});

/* harmony default export */ const Core_X3DBindableNode = (X3DBindableNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/NavigationInfo.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









const TransitionType =
{
   TELEPORT: true,
   LINEAR:   true,
   ANIMATE:  true,
};

function NavigationInfo (executionContext)
{
   Core_X3DBindableNode.call (this, executionContext);

   this .addType (Base_X3DConstants.NavigationInfo);

   this .addChildObjects ("transitionStart",  new x_ite_Fields.SFBool (),
                          "availableViewers", new x_ite_Fields.MFString (),
                          "viewer",           new x_ite_Fields.SFString ("EXAMINE"));

   this ._avatarSize      .setUnit ("length");
   this ._speed           .setUnit ("speed");
   this ._visibilityLimit .setUnit ("speed");
}

NavigationInfo .prototype = Object .assign (Object .create (Core_X3DBindableNode.prototype),
{
   constructor: NavigationInfo,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "type",               new x_ite_Fields.MFString ("EXAMINE", "ANY")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "avatarSize",         new x_ite_Fields.MFFloat (0.25, 1.6, 0.75)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "speed",              new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "headlight",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "visibilityLimit",    new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transitionType",     new x_ite_Fields.MFString ("LINEAR")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transitionTime",     new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "transitionComplete", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",           new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "NavigationInfo";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DBindableNode.prototype.initialize.call (this);

      this ._type               .addInterest ("set_type__",               this);
      this ._headlight          .addInterest ("set_headlight__",          this);
      this ._transitionStart    .addInterest ("set_transitionStart__",    this);
      this ._transitionComplete .addInterest ("set_transitionComplete__", this);
      this ._isBound            .addInterest ("set_isBound__",            this);

      this .set_type__ ();
      this .set_headlight__ ();
   },
   getViewer: function ()
   {
      return this ._viewer .getValue ();
   },
   getCollisionRadius: function ()
   {
      if (this ._avatarSize .length > 0)
      {
         if (this ._avatarSize [0] > 0)
            return this ._avatarSize [0];
      }

      return 0.25;
   },
   getAvatarHeight: function ()
   {
      if (this ._avatarSize .length > 1)
         return this ._avatarSize [1];

      return 1.6;
   },
   getStepHeight: function ()
   {
      if (this ._avatarSize .length > 2)
         return this ._avatarSize [2];

      return 0.75;
   },
   getNearValue: function ()
   {
      const nearValue = this .getCollisionRadius ();

      if (nearValue === 0)
         return 1e-5;

      else
         return nearValue / 2;
   },
   getFarValue: function (viewpoint)
   {
      return this ._visibilityLimit .getValue ()
             ? this ._visibilityLimit .getValue ()
             : viewpoint .getMaxFarValue ();
   },
   getTransitionType: function ()
   {
      for (const value of this ._transitionType)
      {
         const transitionType = TransitionType [value];

         if (transitionType)
            return value;
      }

      return "LINEAR";
   },
   set_type__: function ()
   {
      // Determine active viewer.

      this ._viewer = "EXAMINE";

      for (const string of this ._type)
      {
         switch (string)
         {
            case "EXAMINE":
            case "WALK":
            case "FLY":
            case "LOOKAT":
            case "PLANE":
            case "NONE":
               this ._viewer = string;
               break;
            case "PLANE_create3000.de":
               this ._viewer = "PLANE";
               break;
            default:
               continue;
         }

         // Leave for loop.
         break;
      }

      // Determine available viewers.

      let
         examineViewer = false,
         walkViewer    = false,
         flyViewer     = false,
         planeViewer   = false,
         noneViewer    = false,
         lookAt        = false;

      if (! this ._type .length)
      {
         examineViewer = true;
         walkViewer    = true;
         flyViewer     = true;
         planeViewer   = true;
         noneViewer    = true;
         lookAt        = true;
      }
      else
      {
         for (const string of this ._type)
         {
            switch (string)
            {
               case "EXAMINE":
                  examineViewer = true;
                  continue;
               case "WALK":
                  walkViewer = true;
                  continue;
               case "FLY":
                  flyViewer = true;
                  continue;
               case "LOOKAT":
                  lookAt = true;
                  continue;
               case "PLANE":
                  planeViewer = true;
                  continue;
               case "NONE":
                  noneViewer = true;
                  continue;
               case "ANY":
                  examineViewer = true;
                  walkViewer    = true;
                  flyViewer     = true;
                  planeViewer   = true;
                  noneViewer    = true;
                  lookAt        = true;
                  break;
               default:
                  // Some string defaults to EXAMINE.
                  examineViewer = true;
                  continue;
            }

            break;
         }
      }

      this ._availableViewers .length = 0;

      if (examineViewer)
         this ._availableViewers .push ("EXAMINE");

      if (walkViewer)
         this ._availableViewers .push ("WALK");

      if (flyViewer)
         this ._availableViewers .push ("FLY");

      if (planeViewer)
         this ._availableViewers .push ("PLANE");

      if (lookAt)
         this ._availableViewers .push ("LOOKAT");

      if (noneViewer)
         this ._availableViewers .push ("NONE");
   },
   set_headlight__: function ()
   {
      if (this ._headlight .getValue ())
         delete this .enable;
      else
         this .enable = Function .prototype;
   },
   set_transitionStart__: function ()
   {
      if (! this ._transitionActive .getValue ())
         this ._transitionActive = true;
   },
   set_transitionComplete__: function ()
   {
      if (this ._transitionActive .getValue ())
         this ._transitionActive = false;
   },
   set_isBound__: function ()
   {
      if (this ._isBound .getValue ())
         return;

      if (this ._transitionActive .getValue ())
         this ._transitionActive = false;
   },
   enable: function (type, renderObject)
   {
      if (type !== Rendering_TraverseType.DISPLAY)
         return;

      if (this ._headlight .getValue ())
         renderObject .getGlobalObjects () .push (this .getBrowser () .getHeadlight ());
   },
   traverse: function (type, renderObject)
   {
      if (type !== Rendering_TraverseType.CAMERA)
         return;

      renderObject .getLayer () .getNavigationInfos () .push (this);
   }
});

/* harmony default export */ const Navigation_NavigationInfo = (NavigationInfo);

;// CONCATENATED MODULE: ./src/standard/Utility/ObjectCache.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


/* harmony default export */ function ObjectCache(Type)
{
   const stack = [ ];

   return {
      size: 0,
      pop: function ()
      {
         if (this .size !== 0)
            return stack [-- this .size];

         return new Type ();
      },
      push: function (object)
      {
         stack [this .size ++] = object;
      },
      clear: function ()
      {
         stack .length = 0;
         this .size    = 0;
      },
   };
};

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/X3DFogObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const Fogs = ObjectCache (FogContainer);

function FogContainer ()
{
   this .fogMatrix = new Float32Array (9);
}

FogContainer .prototype =
{
   constructor: FogContainer,
   set: function (fogNode, modelViewMatrix)
   {
      this .fogNode = fogNode;
      this .fogKey  = String (fogNode .getFogType ());

      this .fogMatrix .set (modelViewMatrix .submatrix .inverse ());
   },
   getFogKey: function ()
   {
      return this .fogKey;
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      if (shaderObject .hasFog (this))
         return;

      const fogNode = this .fogNode;

      gl .uniform3fv       (shaderObject .x3d_FogColor,           fogNode .colorArray);
      gl .uniform1f        (shaderObject .x3d_FogVisibilityRange, fogNode .visibilityRange);
      gl .uniformMatrix3fv (shaderObject .x3d_FogMatrix, false,   this .fogMatrix);
   },
   dispose: function ()
   {
      Fogs .push (this);
   },
};

function X3DFogObject (executionContext)
{
   this .addType (Base_X3DConstants.X3DFogObject);

   this ._visibilityRange .setUnit ("length");

   this .hidden     = false;
   this .colorArray = new Float32Array (3);
}

X3DFogObject .prototype =
{
   constructor: X3DFogObject,
   initialize: function ()
   {
      this ._fogType         .addInterest ("set_fogType__",         this);
      this ._color           .addInterest ("set_color__",           this);
      this ._visibilityRange .addInterest ("set_visibilityRange__", this);

      this .set_color__ ();
      this .set_visibilityRange__ ();
   },
   setHidden: function (value)
   {
      this .hidden = value;

      this .set_fogType__ ();

      this .getBrowser () .addBrowserEvent ();
   },
   getHidden: function ()
   {
      return this .hidden;
   },
   getFogType: function ()
   {
      return this .fogType;
   },
   getFogs: function ()
   {
      return Fogs;
   },
   set_fogType__: (function ()
   {
      const fogTypes = new Map ([
         ["LINEAR",      1],
         ["EXPONENTIAL", 2],
      ]);

      return function ()
      {
         if (this .hidden || this .visibilityRange === 0)
            this .fogType = 0;
         else
            this .fogType = fogTypes .get (this ._fogType .getValue ()) || 1;
      };
   })(),
   set_color__: function ()
   {
      const
         color      = this ._color .getValue (),
         colorArray = this .colorArray;

      colorArray [0] = color .r;
      colorArray [1] = color .g;
      colorArray [2] = color .b;
   },
   set_visibilityRange__: function ()
   {
      this .visibilityRange = Math .max (0, this ._visibilityRange .getValue ());

      this .set_fogType__ ();
   },
   dispose: function () { },
};

/* harmony default export */ const EnvironmentalEffects_X3DFogObject = (X3DFogObject);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/Fog.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Fog (executionContext)
{
   Core_X3DBindableNode.call (this, executionContext);
   EnvironmentalEffects_X3DFogObject.call (this, executionContext);

   this .addType (Base_X3DConstants.Fog);

   this .modelMatrix = new Numbers_Matrix4 ();
}

Fog .prototype = Object .assign (Object .create (Core_X3DBindableNode.prototype),
   EnvironmentalEffects_X3DFogObject.prototype,
{
   constructor: Fog,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",        new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fogType",         new x_ite_Fields.SFString ("LINEAR")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",           new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "visibilityRange", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",         new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",        new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "Fog";
   },
   getComponentName: function ()
   {
      return "EnvironmentalEffects";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DBindableNode.prototype.initialize.call (this);
      EnvironmentalEffects_X3DFogObject.prototype.initialize.call (this);
   },
   getModelMatrix: function ()
   {
      return this .modelMatrix;
   },
   traverse: function (type, renderObject)
   {
      if (type !== Rendering_TraverseType.CAMERA)
         return;

      renderObject .getLayer () .getFogs () .push (this);

      this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
   },
});

/* harmony default export */ const EnvironmentalEffects_Fog = (Fog);

;// CONCATENATED MODULE: ./src/x_ite/Rendering/VertexArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function VertexArray ()
{
   this .vertexArray = null;
   this .shaderNode  = null;
   this .tainted     = true;
}

VertexArray .prototype =
{
   update: function (value = true)
   {
      this .tainted = this .tainted || value;

      return this;
   },
   enable: function (gl, shaderNode)
   {
      if (this .tainted || this .shaderNode !== shaderNode)
      {
         gl .deleteVertexArray (this .vertexArray);

         this .vertexArray = gl .createVertexArray ();
         this .shaderNode  = shaderNode;
         this .tainted     = false;

         gl .bindVertexArray (this .vertexArray);

         // console .log ("update vao");

         return true;
      }
      else
      {
         gl .bindVertexArray (this .vertexArray);

         return false;
      }
   },
   disable: function (gl)
   {
      gl .bindVertexArray (null);
   },
   delete: function (gl)
   {
      gl .deleteVertexArray (this .vertexArray);
   },
};

/* harmony default export */ const Rendering_VertexArray = (VertexArray);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DGeometryNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















const ARRAY_TYPE = "Array"; // For color, texCoord, normal, and vertex array, can be MFFloat or Array;

// Box normals for bbox / line intersection.
const boxNormals = [
   new Numbers_Vector3 (0,  0,  1), // front
   new Numbers_Vector3 (0,  0, -1), // back
   new Numbers_Vector3 (0,  1,  0), // top
   new Numbers_Vector3 (0, -1,  0), // bottom
   new Numbers_Vector3 (1,  0,  0)  // right
   // left: We do not have to test for left.
];

function X3DGeometryNode (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DGeometryNode);

   this .addChildObjects ("transparent",  new x_ite_Fields.SFBool (),
                          "bbox_changed", new x_ite_Fields.SFTime (),
                          "rebuild",      new x_ite_Fields.SFTime ());

   this ._transparent  .setAccessType (Base_X3DConstants.outputOnly);
   this ._bbox_changed .setAccessType (Base_X3DConstants.outputOnly);
   this ._rebuild      .setAccessType (Base_X3DConstants.outputOnly);

   // Members

   const browser = this .getBrowser ();

   this .min                      = new Numbers_Vector3 (0, 0, 0);
   this .max                      = new Numbers_Vector3 (0, 0, 0);
   this .bbox                     = new Geometry_Box3 (this .min, this .max, true);
   this .solid                    = true;
   this .primitiveMode            = browser .getContext () .TRIANGLES;
   this .geometryType             = 3;
   this .flatShading              = undefined;
   this .colorMaterial            = false;
   this .attribNodes              = [ ];
   this .attribArrays             = [ ];
   this .textureCoordinateMapping = new Map ();
   this .multiTexCoords           = [ ];
   this .texCoords                = X3DGeometryNode .createArray ();
   this .fogDepths                = X3DGeometryNode .createArray ();
   this .colors                   = X3DGeometryNode .createArray ();
   this .normals                  = X3DGeometryNode .createArray ();
   this .flatNormals              = X3DGeometryNode .createArray ();
   this .vertices                 = X3DGeometryNode .createArray ();
   this .hasFogCoords             = false;
   this .hasNormals               = false;
   this .geometryKey              = "";
   this .vertexCount              = 0;
   this .planes                   = [ ];

   for (let i = 0; i < 5; ++ i)
      this .planes [i] = new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.zAxis);
}

// Function to select ether Array or MFFloat for color/normal/vertex arrays.
X3DGeometryNode .createArray = function ()
{
   if (ARRAY_TYPE == "MFFloat")
      return new x_ite_Fields.MFFloat ();

   const array = [ ];

   array .typedArray = new Float32Array ();

   array .assign = function (value)
   {
      const length = value .length;

      for (let i = 0; i < length; ++ i)
         this [i] = value [i];

      this .length = length;
   };

   array .getValue = function ()
   {
      return this .typedArray;
   };

   array .shrinkToFit = function ()
   {
      if (this .length === this .typedArray .length)
         this .typedArray .set (this);
      else
         this .typedArray = new Float32Array (this);
   };

   return array;
}

X3DGeometryNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DGeometryNode,
   setup: function ()
   {
      Core_X3DNode.prototype.setup.call (this);

      this .rebuild ();
   },
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         gl      = browser .getContext ();

      this .isLive () .addInterest ("set_live__", this);

      this .addInterest ("requestRebuild", this);
      this ._rebuild .addInterest ("rebuild", this);

      this .frontFace             = gl .CCW;
      this .backFace              = new Map ([[gl .CCW, gl .CW], [gl .CW, gl .CCW]]);
      this .attribBuffers         = [ ];
      this .textureCoordinateNode = browser .getDefaultTextureCoordinate ();
      this .texCoordBuffers       = Array .from ({length: browser .getMaxTextures ()}, () => gl .createBuffer ());
      this .fogDepthBuffer        = gl .createBuffer ();
      this .colorBuffer           = gl .createBuffer ();
      this .normalBuffer          = gl .createBuffer ();
      this .vertexBuffer          = gl .createBuffer ();
      this .vertexArrayObject     = new Rendering_VertexArray ();
      this .shadowArrayObject     = new Rendering_VertexArray ();

      this .set_live__ ();
   },
   setGeometryType: function (value)
   {
      this .geometryType = value;
   },
   getGeometryType: function ()
   {
      return this .geometryType;
   },
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
   getBBox: function ()
   {
      // With screen matrix applied.
      return this .bbox;
   },
   setBBox: function (bbox)
   {
      if (bbox .equals (this .bbox))
         return;

      bbox .getExtents (this .min, this .max);

      this .bbox .assign (bbox);

      for (let i = 0; i < 5; ++ i)
         this .planes [i] .set (i % 2 ? this .min : this .max, boxNormals [i]);

      this ._bbox_changed .addEvent ();
   },
   getMin: function ()
   {
      // With screen matrix applied.
      return this .min;
   },
   getMax: function ()
   {
      // With screen matrix applied.
      return this .max;
   },
   getMatrix: function ()
   {
      return Numbers_Matrix4.Identity;
   },
   setPrimitiveMode: function (value)
   {
      this .primitiveMode = value;
   },
   getPrimitiveMode: function ()
   {
      return this .primitiveMode;
   },
   setSolid: function (value)
   {
      this .solid = value;
   },
   setCCW: function (value)
   {
      const gl = this .getBrowser () .getContext ();

      this .frontFace = value ? gl .CCW : gl .CW;
   },
   getAttrib: function ()
   {
      return this .attribNodes;
   },
   getAttribs: function ()
   {
      return this .attribArrays;
   },
   getAttribBuffers: function ()
   {
      return this .attribBuffers;
   },
   setFogDepths: function (value)
   {
      this .fogDepths .assign (value);
   },
   getFogDepths: function ()
   {
      return this .fogDepths;
   },
   setColors: function (value)
   {
      this .colors .assign (value);
   },
   getColors: function ()
   {
      return this .colors;
   },
   setMultiTexCoords: function (value)
   {
      const
         multiTexCoords = this .multiTexCoords,
         length         = value .length;

      for (let i = 0; i < length; ++ i)
         multiTexCoords [i] = value [i];

      multiTexCoords .length = length;
   },
   getMultiTexCoords: function ()
   {
      return this .multiTexCoords;
   },
   getTexCoords: function ()
   {
      return this .texCoords;
   },
   getTextureCoordinate: function ()
   {
      return this .textureCoordinateNode;
   },
   setTextureCoordinate: function (value)
   {
      this .textureCoordinateNode .removeInterest ("updateTextureCoordinateMapping", this);

      if (value)
         this .textureCoordinateNode = value;
      else
         this .textureCoordinateNode = this .getBrowser () .getDefaultTextureCoordinate ();

      this .textureCoordinateNode .addInterest ("updateTextureCoordinateMapping", this);

      this .updateTextureCoordinateMapping ();
   },
   getTextureCoordinateMapping: function ()
   {
      return this .textureCoordinateMapping;
   },
   updateTextureCoordinateMapping: function ()
   {
      this .textureCoordinateMapping .clear ();

      this .textureCoordinateNode .getTextureCoordinateMapping (this .textureCoordinateMapping);
   },
   setNormals: function (value)
   {
      this .normals .assign (value);
   },
   getNormals: function ()
   {
      return this .normals;
   },
   setVertices: function (value)
   {
      this .vertices .assign (value);
   },
   getVertices: function ()
   {
      return this .vertices;
   },
   updateVertexArrays: function ()
   {
      this .vertexArrayObject .update ();
      this .shadowArrayObject .update ();

      this .updateParticlesShadow = true;
      this .updateParticles       = true;
   },
   buildTexCoords: function ()
   {
      const texCoords = this .texCoords;

      if (texCoords .length === 0)
      {
         const
            p         = this .getTexCoordParams (),
            min       = p .min,
            Sindex    = p .Sindex,
            Tindex    = p .Tindex,
            Ssize     = p .Ssize,
            S         = min [Sindex],
            T         = min [Tindex],
            vertices  = this .vertices .getValue ();

         for (let i = 0, length = vertices .length; i < length; i += 4)
         {
            texCoords .push ((vertices [i + Sindex] - S) / Ssize,
                             (vertices [i + Tindex] - T) / Ssize,
                             0,
                             1);
         }

         texCoords .shrinkToFit ();
      }

      this .getMultiTexCoords () .push (texCoords);
   },
   getTexCoordParams: (function ()
   {
      const texCoordParams = { min: new Numbers_Vector3 (0, 0, 0), Ssize: 0, Sindex: 0, Tindex: 0 };

      return function ()
      {
         const
            bbox  = this .getBBox (),
            size  = bbox .size,
            Xsize = size .x,
            Ysize = size .y,
            Zsize = size .z;

         texCoordParams .min .assign (bbox .center) .subtract (size .divide (2));

         if ((Xsize >= Ysize) && (Xsize >= Zsize))
         {
            // X size largest
            texCoordParams .Ssize = Xsize; texCoordParams .Sindex = 0;

            if (Ysize >= Zsize)
               texCoordParams .Tindex = 1;
            else
               texCoordParams .Tindex = 2;
         }
         else if ((Ysize >= Xsize) && (Ysize >= Zsize))
         {
            // Y size largest
            texCoordParams .Ssize = Ysize; texCoordParams .Sindex = 1;

            if (Xsize >= Zsize)
               texCoordParams .Tindex = 0;
            else
               texCoordParams .Tindex = 2;
         }
         else
         {
            // Z is the largest
            texCoordParams .Ssize = Zsize; texCoordParams .Sindex = 2;

            if (Xsize >= Ysize)
               texCoordParams .Tindex = 0;
            else
               texCoordParams .Tindex = 1;
         }

         return texCoordParams;
      };
   })(),
   refineNormals: function (normalIndex, normals, creaseAngle)
   {
      if (creaseAngle === 0)
         return normals;

      const
         cosCreaseAngle = Math .cos (Math_Algorithm.clamp (creaseAngle, 0, Math .PI)),
         normals_       = [ ];

      for (const i in normalIndex) // Don't use forEach
      {
         const vertex = normalIndex [i];

         for (const p of vertex)
         {
            const
               P = normals [p],
               N = new Numbers_Vector3 (0, 0, 0);

            for (const q of vertex)
            {
               const Q = normals [q];

               if (Q .dot (P) >= cosCreaseAngle)
                  N .add (Q);
            }

            normals_ [p] = N .normalize ();
         }
      }

      return normals_;
   },
   transformLine: function (hitRay)
   {
      // Apply sceen nodes transformation in place here.
   },
   transformMatrix: function (hitRay)
   {
      // Apply sceen nodes transformation in place here.
   },
   isClipped: function (point, clipPlanes)
   {
      return clipPlanes .some (function (clipPlane)
      {
         return clipPlane .isClipped (point);
      });
   },
   intersectsLine: function (hitRay, renderObject, invModelViewMatrix, appearanceNode, intersections)
   {
      return this .intersectsLineWithGeometry (hitRay, renderObject .getModelViewMatrix () .get (), renderObject .getLocalObjects (), intersections);
   },
   intersectsLineWithGeometry: (function ()
   {
      const
         modelViewMatrix = new Numbers_Matrix4 (),
         uvt             = { u: 0, v: 0, t: 0 },
         v0              = new Numbers_Vector3 (0, 0, 0),
         v1              = new Numbers_Vector3 (0, 0, 0),
         v2              = new Numbers_Vector3 (0, 0, 0),
         clipPoint       = new Numbers_Vector3 (0, 0, 0);

      return function (hitRay, matrix, clipPlanes, intersections)
      {
         if (this .intersectsBBox (hitRay))
         {
            this .transformLine (hitRay); // Apply screen transformations from screen nodes.
            this .transformMatrix (modelViewMatrix .assign (matrix)); // Apply screen transformations from screen nodes.

            const
               texCoords   = this .multiTexCoords [0] .getValue (),
               normals     = this .normals .getValue (),
               vertices    = this .vertices .getValue (),
               vertexCount = this .vertexCount;

            for (let i = 0; i < vertexCount; i += 3)
            {
               const i4 = i * 4;

               v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
               v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
               v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

               if (hitRay .intersectsTriangle (v0, v1, v2, uvt))
               {
                  // Get barycentric coordinates.

                  const
                     u = uvt .u,
                     v = uvt .v,
                     t = uvt .t;

                  // Determine vectors for X3DPointingDeviceSensors.

                  const point = new Numbers_Vector3 (t * vertices [i4]     + u * vertices [i4 + 4] + v * vertices [i4 +  8],
                                             t * vertices [i4 + 1] + u * vertices [i4 + 5] + v * vertices [i4 +  9],
                                             t * vertices [i4 + 2] + u * vertices [i4 + 6] + v * vertices [i4 + 10]);

                  if (clipPlanes .length)
                  {
                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
                        continue;
                  }

                  const texCoord = new Numbers_Vector2 (t * texCoords [i4]     + u * texCoords [i4 + 4] + v * texCoords [i4 + 8],
                                                t * texCoords [i4 + 1] + u * texCoords [i4 + 5] + v * texCoords [i4 + 9]);

                  const i3 = i * 3;

                  const normal = new Numbers_Vector3 (t * normals [i3]     + u * normals [i3 + 3] + v * normals [i3 + 6],
                                              t * normals [i3 + 1] + u * normals [i3 + 4] + v * normals [i3 + 7],
                                              t * normals [i3 + 2] + u * normals [i3 + 5] + v * normals [i3 + 8]);

                  intersections .push ({ texCoord: texCoord, normal: normal, point: this .getMatrix () .multVecMatrix (point) });
               }
            }
         }

         return intersections .length;
      };
   })(),
   getPlanesWithOffset: (function ()
   {
      const
         min    = new Numbers_Vector3 (0, 0, 0),
         max    = new Numbers_Vector3 (0, 0, 0),
         planes = [ ];

      for (let i = 0; i < 5; ++ i)
         planes [i] = new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.zAxis);

      return function (minX, minY, minZ, maxX, maxY, maxZ)
      {
         min .set (minX, minY, minZ);
         max .set (maxX, maxY, maxZ);

         for (let i = 0; i < 5; ++ i)
            planes [i] .set (i % 2 ? min : max, boxNormals [i]);

         return planes;
      };
   })(),
   intersectsBBox: (function ()
   {
      const intersection = new Numbers_Vector3 (0, 0, 0);

      return function (hitRay, offsets)
      {
         if (offsets)
         {
            var
               min    = this .min,
               max    = this .max,
               minX   = min .x - offsets .x,
               maxX   = max .x + offsets .x,
               minY   = min .y - offsets .y,
               maxY   = max .y + offsets .y,
               minZ   = min .z - offsets .z,
               maxZ   = max .z + offsets .z,
               planes = this .getPlanesWithOffset (minX, minY, minZ, maxX, maxY, maxZ);
         }
         else
         {
            var
               min    = this .min,
               max    = this .max,
               minX   = min .x,
               maxX   = max .x,
               minY   = min .y,
               maxY   = max .y,
               minZ   = min .z,
               maxZ   = max .z,
               planes = this .planes;
         }

         // front
         if (planes [0] .intersectsLine (hitRay, intersection))
         {
            if (intersection .x >= minX && intersection .x <= maxX &&
                intersection .y >= minY && intersection .y <= maxY)
               return true;
         }

         // back
         if (planes [1] .intersectsLine (hitRay, intersection))
         {
            if (intersection .x >= minX && intersection .x <= maxX &&
                intersection .y >= minY && intersection .y <= maxY)
               return true;
         }

         // top
         if (planes [2] .intersectsLine (hitRay, intersection))
         {
            if (intersection .x >= minX && intersection .x <= maxX &&
                intersection .z >= minZ && intersection .z <= maxZ)
               return true;
         }

         // bottom
         if (planes [3] .intersectsLine (hitRay, intersection))
         {
            if (intersection .x >= minX && intersection .x <= maxX &&
                intersection .z >= minZ && intersection .z <= maxZ)
               return true;
         }

         // right
         if (planes [4] .intersectsLine (hitRay, intersection))
         {
            if (intersection .y >= minY && intersection .y <= maxY &&
                intersection .z >= minZ && intersection .z <= maxZ)
               return true;
         }

         return false;
      };
   })(),
   intersectsBox: (function ()
   {
      const
         v0        = new Numbers_Vector3 (0, 0, 0),
         v1        = new Numbers_Vector3 (0, 0, 0),
         v2        = new Numbers_Vector3 (0, 0, 0),
         invMatrix = new Numbers_Matrix4 (),
         clipPoint = new Numbers_Vector3 (0, 0, 0);

      return function (box, clipPlanes, modelViewMatrix)
      {
         if (box .intersectsBox (this .bbox))
         {
            box .multRight (invMatrix .assign (this .getMatrix ()) .inverse ());

            this .transformMatrix (modelViewMatrix); // Apply screen transformations from screen nodes.

            const vertices = this .vertices .getValue ();

            for (let i = 0, length = this .vertexCount; i < length; i += 3)
            {
               const i4 = i * 4;

               v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
               v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
               v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

               if (box .intersectsTriangle (v0, v1, v2))
               {
                  if (clipPlanes .length)
                  {
                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v0)), clipPlanes))
                        continue;

                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v1)), clipPlanes))
                        continue;

                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v2)), clipPlanes))
                        continue;
                  }

                  return true;
               }
            }
         }

         return false;
      };
   })(),
   set_live__: function ()
   {
      if (this .isLive () .getValue ())
         this .getBrowser () .getBrowserOptions () ._Shading .addInterest ("set_shading__", this);
      else
         this .getBrowser () .getBrowserOptions () ._Shading .removeInterest ("set_shading__", this);
   },
   set_shading__: (function ()
   {
      const
         v0     = new Numbers_Vector3 (0, 0, 0),
         v1     = new Numbers_Vector3 (0, 0, 0),
         v2     = new Numbers_Vector3 (0, 0, 0),
         normal = new Numbers_Vector3 (0, 0, 0);

      return function (shading)
      {
         if (this .geometryType < 2)
            return;

         const
            browser     = this .getBrowser (),
            flatShading = browser .getBrowserOptions () .getShading () === Core_Shading.FLAT;

         if (flatShading === this .flatShading)
            return;

         this .flatShading = flatShading;

         // Generate flat normals if needed.

         const gl = browser .getContext ();

         if (flatShading)
         {
            if (! this .flatNormals .length)
            {
               const
                  cw          = this .frontFace === gl .CW,
                  flatNormals = this .flatNormals,
                  vertices    = this .vertices .getValue ();

               for (let i = 0, length = vertices .length; i < length; i += 12)
               {
                  Triangle3.normal (v0 .set (vertices [i],     vertices [i + 1], vertices [i + 2]),
                                     v1 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6]),
                                     v2 .set (vertices [i + 8], vertices [i + 9], vertices [i + 10]),
                                     normal);

                  if (cw)
                     normal .negate ();

                  flatNormals .push (normal .x, normal .y, normal .z,
                                     normal .x, normal .y, normal .z,
                                     normal .x, normal .y, normal .z);
               }

               flatNormals .shrinkToFit ();
            }
         }

         // Transfer normals.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .normalBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, flatShading ? this .flatNormals .getValue () : this .normals .getValue (), gl .DYNAMIC_DRAW);
      };
   })(),
   requestRebuild: function ()
   {
      this ._rebuild .addEvent ();
   },
   rebuild: (function ()
   {
      const point = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         this .clear ();
         this .build ();

         // Shrink arrays before transfer to graphics card.

         for (const attribArray of this .attribArrays)
            attribArray .shrinkToFit ();

         for (const multiTexCoord of this .multiTexCoords)
            multiTexCoord .shrinkToFit ();

         this .fogDepths .shrinkToFit ();
         this .colors    .shrinkToFit ();
         this .normals   .shrinkToFit ();
         this .vertices  .shrinkToFit ();

         // Determine bbox.

         const
            min      = this .min,
            max      = this .max,
            vertices = this .vertices .getValue ();

         if (vertices .length)
         {
            if (min .x === Number .POSITIVE_INFINITY)
            {
               for (let i = 0, length = vertices .length; i < length; i += 4)
               {
                  point .set (vertices [i], vertices [i + 1], vertices [i + 2]);

                  min .min (point);
                  max .max (point);
               }
            }

            this .bbox .setExtents (min, max);
         }
         else
         {
            this .bbox .setExtents (min .set (0, 0, 0), max .set (0, 0, 0));
         }

         this ._bbox_changed .addEvent ();

         for (let i = 0; i < 5; ++ i)
            this .planes [i] .set (i % 2 ? min : max, boxNormals [i]);

         // Generate texCoord if needed.

         if (this .multiTexCoords .length === 0)
            this .buildTexCoords ();

         if (this .multiTexCoords .length)
         {
            const maxTextures = this .getBrowser () .getMaxTextures ();

            for (let i = this .multiTexCoords .length; i < maxTextures; ++ i)
               this .multiTexCoords [i] = this .multiTexCoords .at (-1);

            this .multiTexCoords .length = maxTextures;
         }

         // Transfer arrays and update.

         this .transfer ();
         this .updateGeometryKey ();
         this .updateRenderFunctions ();
      };
   })(),
   clear: function ()
   {
      // BBox

      this .min .set (Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY);
      this .max .set (Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY);

      // Create attribArray arrays.
      {
         const attribArrays = this .attribArrays;

         for (const attribArray of attribArrays)
            attribArray .length = 0;

         const length = this .attribNodes .length;

         for (let a = attribArrays .length; a < length; ++ a)
            attribArrays [a] = X3DGeometryNode .createArray ();

         attribArrays .length = length;
      }

      // Buffer

      this .flatShading = undefined;

      this .fogDepths      .length = 0;
      this .colors         .length = 0;
      this .multiTexCoords .length = 0;
      this .texCoords      .length = 0;
      this .normals        .length = 0;
      this .flatNormals    .length = 0;
      this .vertices       .length = 0;
   },
   transfer: function ()
   {
      const gl = this .getBrowser () .getContext ();

      // Transfer attribArrays.

      for (let i = this .attribBuffers .length, length = this .attribArrays .length; i < length; ++ i)
         this .attribBuffers .push (gl .createBuffer ());

      for (let i = 0, length = this .attribArrays .length; i < length; ++ i)
      {
         gl .bindBuffer (gl .ARRAY_BUFFER, this .attribBuffers [i]);
         gl .bufferData (gl .ARRAY_BUFFER, this .attribArrays [i] .getValue (), gl .DYNAMIC_DRAW);
      }

      // Transfer fog depths.

      const lastHasFogCoords = this .hasFogCoords;

      gl .bindBuffer (gl .ARRAY_BUFFER, this .fogDepthBuffer);
      gl .bufferData (gl .ARRAY_BUFFER, this .fogDepths .getValue (), gl .DYNAMIC_DRAW);

      this .hasFogCoords = !! this .fogDepths .length;

      if (this .hasFogCoords !== lastHasFogCoords)
         this .updateVertexArrays ();

      // Transfer colors.

      const lastColorMaterial = this .colorMaterial;

      gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
      gl .bufferData (gl .ARRAY_BUFFER, this .colors .getValue (), gl .DYNAMIC_DRAW);

      this .colorMaterial = !! this .colors .length;

      if (this .colorMaterial !== lastColorMaterial)
         this .updateVertexArrays ();

      // Transfer multiTexCoords.

      for (let i = 0, length = this .multiTexCoords .length; i < length; ++ i)
      {
         gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [i]);
         gl .bufferData (gl .ARRAY_BUFFER, this .multiTexCoords [i] .getValue (), gl .DYNAMIC_DRAW);
      }

      // Transfer normals or flat normals.

      const lastHasNormals = this .hasNormals;

      this .set_shading__ (this .getBrowser () .getBrowserOptions () ._Shading);

      this .hasNormals = !! this .normals .getValue () .length;

      if (this .hasNormals !== lastHasNormals)
         this .updateVertexArrays ();

      // Transfer vertices.

      gl .bindBuffer (gl .ARRAY_BUFFER, this .vertexBuffer);
      gl .bufferData (gl .ARRAY_BUFFER, this .vertices .getValue (), gl .DYNAMIC_DRAW);

      this .vertexCount = this .vertices .length / 4;
   },
   updateGeometryKey: function ()
   {
      this .geometryKey  = "";
      this .geometryKey += this .geometryType;
      this .geometryKey += this .hasFogCoords  ? "1" : "0";
      this .geometryKey += this .colorMaterial ? "1" : "0";
      this .geometryKey += this .hasNormals    ? "1" : "0";
   },
   updateRenderFunctions: function ()
   {
      if (this .vertexCount)
      {
         // Use default render functions.

         delete this .depth;
         delete this .display;
         delete this .displayParticlesDepth;
         delete this .displayParticles;
      }
      else
      {
         // Use no render function.

         this .depth                 = Function .prototype;
         this .display               = Function .prototype;
         this .displayParticlesDepth = Function .prototype;
         this .displayParticles      = Function .prototype;
      }
   },
   traverse: function (type, renderObject)
   { },
   depth: function (gl, depthContext, shaderNode)
   {
      if (this .shadowArrayObject .enable (gl, shaderNode))
         shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);

      gl .drawArrays (this .primitiveMode, 0, this .vertexCount);
   },
   display: function (gl, renderContext)
   {
      const
         appearanceNode = renderContext .appearanceNode,
         shaderNode     = appearanceNode .getShader (this, renderContext);

      if (this .solid || ! appearanceNode .getBackMaterial () || this .getBrowser () .getWireframe ())
      {
         this .displayGeometry (gl, renderContext, appearanceNode, shaderNode, true, true);
      }
      else
      {
         const backShaderNode = appearanceNode .getBackShader (this, renderContext)

         this .displayGeometry (gl, renderContext, appearanceNode, backShaderNode, true,  false);
         this .displayGeometry (gl, renderContext, appearanceNode, shaderNode,     false, true);
      }
   },
   displayGeometry: function (gl, renderContext, appearanceNode, shaderNode, back, front)
   {
      const
         browser       = this .getBrowser (),
         blendModeNode = appearanceNode .getBlendMode (),
         attribNodes   = this .attribNodes,
         attribBuffers = this .attribBuffers,
         primitiveMode = browser .getPrimitiveMode (this .primitiveMode);

      if (blendModeNode)
         blendModeNode .enable (gl);

      shaderNode .enable (gl);
      shaderNode .setUniforms (gl, this, renderContext, front);

      // Setup vertex attributes.

      if (this .vertexArrayObject .enable (gl, shaderNode))
      {
         for (let i = 0, length = attribNodes .length; i < length; ++ i)
            attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

         if (this .hasFogCoords)
            shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

         if (this .colorMaterial)
            shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

         shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
         shaderNode .enableNormalAttribute   (gl, this .normalBuffer,    0, 0);
         shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);
      }

      // Draw depending on wireframe, solid and transparent.

      if (browser .getWireframe ())
      {
         for (let i = 0, length = this .vertexCount; i < length; i += 3)
            gl .drawArrays (primitiveMode, i, 3);
      }
      else
      {
         const positiveScale = Numbers_Matrix4.prototype.determinant3.call (renderContext .modelViewMatrix) > 0;

         gl .frontFace (positiveScale ? this .frontFace : this .backFace .get (this .frontFace));

         if (renderContext .transparent || back !== front)
         {
            // Render transparent or back or front.

            gl .enable (gl .CULL_FACE);

            // Render back.

            if (back && ! this .solid)
            {
               gl .cullFace (gl .FRONT);
               gl .drawArrays (primitiveMode, 0, this .vertexCount);
            }

            // Render front.

            if (front)
            {
               gl .cullFace (gl .BACK);
               gl .drawArrays (primitiveMode, 0, this .vertexCount);
            }
         }
         else
         {
            // Render solid or both sides.

            if (this .solid)
               gl .enable (gl .CULL_FACE);
            else
               gl .disable (gl .CULL_FACE);

            gl .drawArrays (primitiveMode, 0, this .vertexCount);
         }
      }

      if (blendModeNode)
         blendModeNode .disable (gl);
   },
   displayParticlesDepth: function (gl, depthContext, shaderNode, particleSystem)
   {
      const outputParticles = particleSystem .outputParticles;

      if (outputParticles .shadowArrayObject .update (this .updateParticlesShadow) .enable (gl, shaderNode))
      {
         const particleStride = particleSystem .particleStride;

         shaderNode .enableParticleAttribute       (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
         shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset,   1);
         shaderNode .enableVertexAttribute         (gl, this .vertexBuffer, 0, 0);

         this .updateParticlesShadow = false;
      }

      gl .drawArraysInstanced (this .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
   },
   displayParticles: function (gl, renderContext, particleSystem)
   {
      const
         appearanceNode = renderContext .appearanceNode,
         shaderNode     = appearanceNode .getShader (this, renderContext);

      if (this .solid || ! appearanceNode .getBackMaterial () || this .getBrowser () .getWireframe ())
      {
         this .displayParticlesGeometry (gl, renderContext, appearanceNode, shaderNode, true, true, particleSystem);
      }
      else
      {
         const backShaderNode = appearanceNode .getBackShader (this, renderContext);

         this .displayParticlesGeometry (gl, renderContext, appearanceNode, backShaderNode, true,  false, particleSystem);
         this .displayParticlesGeometry (gl, renderContext, appearanceNode, shaderNode,     false, true,  particleSystem);
      }
   },
   displayParticlesGeometry: function (gl, renderContext, appearanceNode, shaderNode, back, front, particleSystem)
   {
      const
         browser       = this .getBrowser (),
         blendModeNode = appearanceNode .getBlendMode (),
         attribNodes   = this .attribNodes,
         attribBuffers = this .attribBuffers,
         primitiveMode = browser .getPrimitiveMode (this .primitiveMode);

      if (blendModeNode)
         blendModeNode .enable (gl);

      // Setup shader.

      shaderNode .enable (gl);
      shaderNode .setUniforms (gl, this, renderContext, front);

      // Setup vertex attributes.

      const outputParticles = particleSystem .outputParticles;

      if (outputParticles .vertexArrayObject .update (this .updateParticles) .enable (gl, shaderNode))
      {
         const particleStride = particleSystem .particleStride;

         shaderNode .enableParticleAttribute       (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
         shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset,   1);

         for (let i = 0, length = attribNodes .length; i < length; ++ i)
            attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

         if (this .hasFogCoords)
            shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

         if (this .colorMaterial)
            shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

         shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
         shaderNode .enableNormalAttribute   (gl, this .normalBuffer,    0, 0);
         shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);

         this .updateParticles = false;
      }

      // Draw depending on wireframe, solid and transparent.

      const positiveScale = Numbers_Matrix4.prototype.determinant3.call (renderContext .modelViewMatrix) > 0;

      gl .frontFace (positiveScale ? this .frontFace : this .backFace .get (this .frontFace));

      if (renderContext .transparent || back !== front)
      {
         // Render transparent or back or front.

         gl .enable (gl .CULL_FACE);

         if (back && ! this .solid)
         {
            gl .cullFace (gl .FRONT);
            gl .drawArraysInstanced (primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
         }

         if (front)
         {
            gl .cullFace (gl .BACK);
            gl .drawArraysInstanced (primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
         }
      }
      else
      {
         // Render solid or both sides.

         if (this .solid)
            gl .enable (gl .CULL_FACE);
         else
            gl .disable (gl .CULL_FACE);

         gl .drawArraysInstanced (primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
      }

      if (blendModeNode)
         blendModeNode .disable (gl);
   },
});

/* harmony default export */ const Rendering_X3DGeometryNode = (X3DGeometryNode);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Rendering/GeometryContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function GeometryContext (options = { })
{
   Object .assign (this,
   {
      geometryType: 3,
      hasFogCoords: false,
      colorMaterial: false,
      hasNormals: false,
      textureNode: false,
      objectsCount: [0, 0, 0],
      textureCoordinateMapping: new Map (),
      textureCoordinateNode: null,
   },
   options)

   this .updateGeometryKey ();
}

GeometryContext .prototype =
{
   constructor: GeometryContext,
   updateGeometryKey: Rendering_X3DGeometryNode.prototype.updateGeometryKey,
   getTextureCoordinateMapping: function ()
   {
      return this .textureCoordinateMapping;
   },
   getTextureCoordinate: function ()
   {
      return this .textureCoordinateNode;
   },
};

/* harmony default export */ const Rendering_GeometryContext = (GeometryContext);

;// CONCATENATED MODULE: ./src/standard/Math/Numbers/Complex.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function Complex (real, imag)
{
   this .real = real;
   this .imag = imag;
}

Complex .prototype =
{
   constructor: Complex,
   [Symbol .iterator]: function* ()
   {
      yield this .real;
      yield this .imag;
   },
   copy: function ()
   {
      const copy = Object .create (Complex .prototype);
      copy .real = this .real;
      copy .imag = this .imag;
      return copy;
   },
   assign: function (complex)
   {
      this .real = complex .real;
      this .imag = complex .imag;
      return this;
   },
   equals: function (complex)
   {
      return this .real === complex .real &&
             this .imag === complex .imag;
   },
   setPolar: function (magnitude, angle)
   {
      this .real = magnitude * Math .cos (angle);
      this .imag = magnitude * Math .sin (angle);
      return this;
   },
   conjugate: function ()
   {
      this .imag = -this .imag;
      return this;
   },
   negate: function ()
   {
      this .real = -this .real;
      this .imag = -this .imag;
      return this;
   },
   inverse: function ()
   {
      const d = this .real * this .real + this .imag * this .imag;

      this .real /=  d;
      this .imag /= -d;
      return this;
   },
   add: function (value)
   {
      this .real += value .real;
      this .imag += value .imag;
      return this;
   },
   subtract: function (value)
   {
      this .real -= value .real;
      this .imag -= value .imag;
      return this;
   },
   multiply: function (value)
   {
      this .real *= value;
      this .imag *= value;
      return this;
   },
   multComp: function ()
   {
      const
         real = this .real,
         imag = this .imag;

      this .real = real * value .real - imag * value .imag;
      this .imag = real * value .imag + imag * value .real;
      return this;
   },
   //divide: function (value)
   //{
   //	return this;
   //},
   divComp: function (value)
   {
      const
         ar = this .real, ai = this .imag,
         br = value .real, bi = value .imag;

      const d = br * br + bi * bi;

      this .real = (ar * br + ai * bi) / d;
      this .imag = (ai * br - ar * bi) / d;
      return this;
   },
   toString: function ()
   {
      if (this .imag)
         return this .real + " " + this .imag + "i";

      return String (this .real);
   },
};

Object .defineProperty (Complex .prototype, "magnitude",
{
   get: function ()
   {
      if (this .real)
      {
         if (this .imag)
            return Math .hypot (this .real, this .imag);

         return Math .abs (this .real);
      }

      return Math .abs (this .imag);
   },
   set: function (magnitude)
   {
      this .setPolar (magnitude, this .angle);
   },
   enumerable: false,
   configurable: false
});

Object .defineProperty (Complex .prototype, "angle",
{
   get: function ()
   {
      return Math .atan2 (this .imag, this .real);
   },
   set: function (angle)
   {
      this .setPolar (this .magnitude, angle);
   },
   enumerable: false,
   configurable: false
});

Object .assign (Complex,
{
   Polar: function (magnitude, angle)
   {
      return Object .create (Complex .prototype) .setPolar (magnitude, angle);
   },
   multiply: function (lhs, rhs)
   {
      return lhs .copy () .multiply (rhs);
   },
   multComp: function (lhs, rhs)
   {
      return lhs .copy () .multComp (rhs);
   },
});

/* harmony default export */ const Numbers_Complex = (Complex);

;// CONCATENATED MODULE: ./src/standard/Utility/BitSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function BitSet (value = 0)
{
   this .value = value;
}

BitSet .prototype =
{
   constructor: BitSet,
   get: function (index)
   {
      const mask = 1 << index;

      return !! (this .value & mask);
   },
   set: function (index, value)
   {
      const mask = 1 << index;

      if (value)
         this .value |= mask;
      else
         this .value &= ~mask;
   },
   clear: function ()
   {
      this .value = 0;
   },
   valueOf: function ()
   {
      return this .value;
   },
   toString: function (radix)
   {
      return this .value .toString (radix);
   },
};

/* harmony default export */ const Utility_BitSet = (BitSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/X3DBackgroundNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















const
   RADIUS = 1,
   SIZE   = Math .SQRT2 / 2;

function X3DBackgroundNode (executionContext)
{
   Core_X3DBindableNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DBackgroundNode);

   this ._skyAngle    .setUnit ("angle");
   this ._groundAngle .setUnit ("angle");

   const browser = this .getBrowser ();

   this .hidden                = false;
   this .projectionMatrixArray = new Float32Array (16);
   this .modelMatrix           = new Numbers_Matrix4 ();
   this .modelViewMatrixArray  = new Float32Array (16);
   this .clipPlanes            = [ ];
   this .colors                = [ ];
   this .sphere                = [ ];
   this .textureBits           = new Utility_BitSet ();
   this .sphereContext         = new Rendering_GeometryContext ({ colorMaterial: true });
   this .texturesContext       = new Rendering_GeometryContext ({ textureNode: true });
}

X3DBackgroundNode .prototype = Object .assign (Object .create (Core_X3DBindableNode.prototype),
{
   constructor: X3DBackgroundNode,
   initialize: function ()
   {
      Core_X3DBindableNode.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         gl      = browser .getContext ();

      this .colorBuffer       = gl .createBuffer ();
      this .sphereBuffer      = gl .createBuffer ();
      this .texCoordBuffers   = new Array (browser .getMaxTextures ()) .fill (gl .createBuffer ());
      this .frontBuffer       = gl .createBuffer ();
      this .backBuffer        = gl .createBuffer ();
      this .leftBuffer        = gl .createBuffer ();
      this .rightBuffer       = gl .createBuffer ();
      this .topBuffer         = gl .createBuffer ();
      this .bottomBuffer      = gl .createBuffer ();
      this .sphereArrayObject = new Rendering_VertexArray ();
      this .frontArrayObject  = new Rendering_VertexArray ();
      this .backArrayObject   = new Rendering_VertexArray ();
      this .leftArrayObject   = new Rendering_VertexArray ();
      this .rightArrayObject  = new Rendering_VertexArray ();
      this .topArrayObject    = new Rendering_VertexArray ();
      this .bottomArrayObject = new Rendering_VertexArray ();

      this ._groundAngle  .addInterest ("build", this);
      this ._groundColor  .addInterest ("build", this);
      this ._skyAngle     .addInterest ("build", this);
      this ._skyColor     .addInterest ("build", this);

      this .build ();
      this .transferRectangle ();
   },
   set_frontTexture__: function (value)
   {
      this .updateTexture ("frontTexture", value, 0);
   },
   set_backTexture__: function (value)
   {
      this .updateTexture ("backTexture", value, 1);
   },
   set_leftTexture__: function (value)
   {
      this .updateTexture ("leftTexture", value, 2);
   },
   set_rightTexture__: function (value)
   {
      this .updateTexture ("rightTexture", value, 3);
   },
   set_topTexture__: function (value)
   {
      this .updateTexture ("topTexture", value, 4);
   },
   set_bottomTexture__: function (value)
   {
      this .updateTexture ("bottomTexture", value, 5);
   },
   updateTexture: function (name, texture, index)
   {
      if (this [name])
         this [name] ._loadState .removeInterest ("setTextureBit", this);

      this [name] = texture;

      if (texture)
      {
         texture ._loadState .addInterest ("setTextureBit", this, index, texture);

         this .setTextureBit (index, texture, texture ._loadState);
      }
      else
      {
         this .textureBits .set (index, false);
      }
   },
   setTextureBit: function (bit, texture, loadState)
   {
      this .textureBits .set (bit, loadState .getValue () === Base_X3DConstants.COMPLETE_STATE || (texture && texture .getData ()));
   },
   setHidden: function (value)
   {
      this .hidden = value;

      this .getBrowser () .addBrowserEvent ();
   },
   getHidden: function ()
   {
      return this .hidden;
   },
   getTransparent: function ()
   {
      if (this .hidden)
         return true;

      if (this ._transparency .getValue () === 0)
         return false;

      if (! this .frontTexture  || this .frontTexture  ._transparent .getValue ())
            return true;

      if (! this .backTexture   || this .backTexture   ._transparent .getValue ())
            return true;

      if (! this .leftTexture   || this .leftTexture   ._transparent .getValue ())
            return true;

      if (! this .rightTexture  || this .rightTexture  ._transparent .getValue ())
            return true;

      if (! this .topTexture    || this .topTexture    ._transparent .getValue ())
            return true;

      if (! this .bottomTexture || this .bottomTexture ._transparent .getValue ())
            return true;

      return false;
   },
   getColor: function (theta, color, angle)
   {
      const index = Math_Algorithm.upperBound (angle, 0, angle .length, theta);

      return color [index];
   },
   build: function ()
   {
      const s = SIZE;

      this .colors .length = 0;
      this .sphere .length = 0;

      if (this ._groundColor .length === 0 && this ._skyColor .length == 1)
      {
         // Build cube

         this .sphere .vertices = 36;

         this .sphere .push ( s,  s, -s, 1, -s,  s, -s, 1, -s, -s, -s, 1, // Back
                              s,  s, -s, 1, -s, -s, -s, 1,  s, -s, -s, 1,
                             -s,  s,  s, 1,  s,  s,  s, 1, -s, -s,  s, 1, // Front
                             -s, -s,  s, 1,  s,  s,  s, 1,  s, -s,  s, 1,
                             -s,  s, -s, 1, -s,  s,  s, 1, -s, -s,  s, 1, // Left
                             -s,  s, -s, 1, -s, -s,  s, 1, -s, -s, -s, 1,
                              s,  s,  s, 1,  s,  s, -s, 1,  s, -s,  s, 1, // Right
                              s, -s,  s, 1,  s,  s, -s, 1,  s, -s, -s, 1,
                              s,  s,  s, 1, -s,  s,  s, 1, -s,  s, -s, 1, // Top
                              s,  s,  s, 1, -s,  s, -s, 1,  s,  s, -s, 1,
                             -s, -s,  s, 1,  s, -s,  s, 1, -s, -s, -s, 1, // Bottom
                             -s, -s, -s, 1,  s, -s,  s, 1,  s, -s, -s, 1);

         const c = this ._skyColor [0];

         for (let i = 0, vertices = this .sphere .vertices; i < vertices; ++ i)
            this .colors .push (c .r, c .g, c .b, 1);
      }
      else
      {
         // Build sphere

         if (this ._skyColor .length > this ._skyAngle .length)
         {
            const vAngle = this ._skyAngle .slice ();

            if (vAngle .length === 0 || vAngle [0] > 0)
               vAngle .unshift (0);

            if (vAngle .at (-1) < Math .PI)
               vAngle .push (Math .PI);

            if (vAngle .length === 2)
						vAngle .splice (1, 0, (vAngle [0] + vAngle [1]) / 2)

            this .buildSphere (RADIUS, vAngle, this ._skyAngle, this ._skyColor, false);
         }

         if (this ._groundColor .length > this ._groundAngle .length)
         {
            const vAngle = this ._groundAngle .slice () .reverse ();

            if (vAngle .length === 0 || vAngle [0] < Math .PI / 2)
               vAngle .unshift (Math .PI / 2);

            if (vAngle .at (-1) > 0)
               vAngle .push (0);

            this .buildSphere (RADIUS, vAngle, this ._groundAngle, this ._groundColor, true);
         }
      }

      this .transferSphere ();
   },
   buildSphere: (function ()
   {
      const U_DIMENSION = 20;

      const
         z1 = new Numbers_Complex (0, 0),
         z2 = new Numbers_Complex (0, 0),
         y1 = new Numbers_Complex (0, 0),
         y2 = new Numbers_Complex (0, 0),
         y3 = new Numbers_Complex (0, 0),
         y4 = new Numbers_Complex (0, 0);

      return function (radius, vAngle, angle, color, bottom)
      {
         const
            vAngleMax   = bottom ? Math .PI / 2 : Math .PI,
            V_DIMENSION = vAngle .length - 1;

         for (let v = 0; v < V_DIMENSION; ++ v)
         {
            let
               theta1 = Math_Algorithm.clamp (vAngle [v],     0, vAngleMax),
               theta2 = Math_Algorithm.clamp (vAngle [v + 1], 0, vAngleMax);

            if (bottom)
            {
               theta1 = Math .PI - theta1;
               theta2 = Math .PI - theta2;
            }

            z1 .setPolar (radius, theta1);
            z2 .setPolar (radius, theta2);

            const
               c1 = this .getColor (vAngle [v],     color, angle),
               c2 = this .getColor (vAngle [v + 1], color, angle);

            for (let u = 0; u < U_DIMENSION; ++ u)
            {
               // p4 --- p1
               //  |   / |
               //  | /   |
               // p3 --- p2

               // The last point is the first one.
               const u1 = u < U_DIMENSION - 1 ? u + 1 : 0;

               // p1, p2
               let phi = 2 * Math .PI * (u / U_DIMENSION);
               y1 .setPolar (-z1 .imag, phi);
               y2 .setPolar (-z2 .imag, phi);

               // p3, p4
               phi = 2 * Math .PI * (u1 / U_DIMENSION);
               y3 .setPolar (-z2 .imag, phi);
               y4 .setPolar (-z1 .imag, phi);

               // Triangle 1 and 2

               this .colors .push (c1 .r, c1 .g, c1 .b, 1,
                                   c2 .r, c2 .g, c2 .b, 1,
                                   c2 .r, c2 .g, c2 .b, 1,
                                   // Triangle 2
                                   c1 .r, c1 .g, c1 .b, 1,
                                   c1 .r, c1 .g, c1 .b, 1,
                                   c2 .r, c2 .g, c2 .b, 1);

               this .sphere .push (y1 .imag, z1 .real, y1 .real, 1,
                                   y3 .imag, z2 .real, y3 .real, 1,
                                   y2 .imag, z2 .real, y2 .real, 1,
                                   // Triangle 2
                                   y1 .imag, z1 .real, y1 .real, 1,
                                   y4 .imag, z1 .real, y4 .real, 1,
                                   y3 .imag, z2 .real, y3 .real, 1);
            }
         }
      };
   })(),
   transferSphere: function ()
   {
      const gl = this .getBrowser () .getContext ();

      // Transfer colors.

      gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
      gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .colors), gl .DYNAMIC_DRAW);

      // Transfer sphere.

      gl .bindBuffer (gl .ARRAY_BUFFER, this .sphereBuffer);
      gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .sphere), gl .DYNAMIC_DRAW);

      this .sphereCount = this .sphere .length / 4;
   },
   transferRectangle: (function ()
   {
      const s = SIZE;

      const texCoords = [
         1, 1, 0, 1,
         0, 1, 0, 1,
         0, 0, 0, 1,
         1, 1, 0, 1,
         0, 0, 0, 1,
         1, 0, 0, 1,
      ];

      const frontVertices = [
         s,  s, -s, 1,
        -s,  s, -s, 1,
        -s, -s, -s, 1,
         s,  s, -s, 1,
        -s, -s, -s, 1,
         s, -s, -s, 1,
      ];

      const backVertices = [
         -s,  s,  s, 1,
          s,  s,  s, 1,
          s, -s,  s, 1,
         -s,  s,  s, 1,
          s, -s,  s, 1,
         -s, -s,  s, 1,
      ];

      const leftVertices = [
         -s,  s, -s, 1,
         -s,  s,  s, 1,
         -s, -s,  s, 1,
         -s,  s, -s, 1,
         -s, -s,  s, 1,
         -s, -s, -s, 1,
      ];

      const rightVertices = [
         s,  s,  s, 1,
         s,  s, -s, 1,
         s, -s, -s, 1,
         s,  s,  s, 1,
         s, -s, -s, 1,
         s, -s,  s, 1,
      ];

      const topVertices = [
          s, s,  s, 1,
         -s, s,  s, 1,
         -s, s, -s, 1,
          s, s,  s, 1,
         -s, s, -s, 1,
          s, s, -s, 1,
      ];

      const bottomVertices = [
          s, -s, -s, 1,
         -s, -s, -s, 1,
         -s, -s,  s, 1,
          s, -s, -s, 1,
         -s, -s,  s, 1,
          s, -s,  s, 1,
      ];

      return function ()
      {
         const gl = this .getBrowser () .getContext ();

         // Transfer texCoords.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [0]);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (texCoords), gl .DYNAMIC_DRAW);

         // Transfer rectangle.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .frontBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (frontVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .backBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (backVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .leftBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (leftVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .rightBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (rightVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .topBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (topVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .bottomBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (bottomVertices), gl .DYNAMIC_DRAW);
      };
   })(),
   traverse: function (type, renderObject)
   {
      switch (type)
      {
         case Rendering_TraverseType.CAMERA:
         {
            renderObject .getLayer () .getBackgrounds () .push (this);

            this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
            return;
         }
         case Rendering_TraverseType.DISPLAY:
         {
            const
               sourceObjects = renderObject .getLocalObjects (),
               destObjects   = this .clipPlanes;

            let d = 0;

            for (let s = 0, length = sourceObjects .length; s < length; ++ s)
            {
               if (sourceObjects [s] .isClipped)
                  destObjects [d ++] = sourceObjects [s];
            }

            destObjects .length = d;

            this .sphereContext   .objectsCount [0] = destObjects .length;
            this .texturesContext .objectsCount [0] = destObjects .length;
            return;
         }
      }
   },
   display: (function ()
   {
      const
         invProjectionMatrix = new Numbers_Matrix4 (),
         modelViewMatrix     = new Numbers_Matrix4 (),
         rotation            = new Numbers_Rotation4 (),
         scale               = new Numbers_Vector3 (0, 0, 0),
         farVector           = new Numbers_Vector3 (0, 0, 0);

      return function (gl, renderObject, viewport)
      {
         if (this .hidden)
            return;

         // Setup context.

         gl .depthMask (false);
         gl .disable (gl .DEPTH_TEST);
         gl .enable (gl .CULL_FACE);
         gl .frontFace (gl .CCW);

         // Get background scale.

         const farValue = -Geometry_ViewVolume.unProjectPointMatrix (0, 0, 1, invProjectionMatrix .assign (renderObject .getProjectionMatrix () .get ()) .inverse (), viewport, farVector) .z * 0.8;

         // Get projection matrix.

         this .projectionMatrixArray .set (renderObject .getProjectionMatrix () .get ());

         // Rotate and scale background.

         modelViewMatrix .assign (this .modelMatrix);
         modelViewMatrix .multRight (renderObject .getViewMatrix () .get ());
         modelViewMatrix .get (null, rotation);
         modelViewMatrix .identity ();
         modelViewMatrix .rotate (rotation);
         modelViewMatrix .scale (scale .set (farValue, farValue, farValue));

         this .modelViewMatrixArray .set (modelViewMatrix);

         // Draw background sphere and texture cube.

         this .drawSphere (renderObject);

         if (+this .textureBits)
            this .drawCube (renderObject);
      };
   })(),
   drawSphere: function (renderObject)
   {
      const transparency = this ._transparency .getValue ();

      if (transparency >= 1)
         return;

      const
         browser    = this .getBrowser (),
         gl         = browser .getContext (),
         shaderNode = browser .getDefaultMaterial () .getShader (this .sphereContext);

      shaderNode .enable (gl);
      shaderNode .setClipPlanes (gl, this .clipPlanes);

      // Uniforms

      gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, this .projectionMatrixArray);
      gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, this .modelViewMatrixArray);

      gl .uniform1f (shaderNode .x3d_Transparency,                       transparency)
      gl .uniform1i (shaderNode .x3d_TextureCoordinateGeneratorMode [0], 0);

      // Enable vertex attribute arrays.

      if (this .sphereArrayObject .enable (gl, shaderNode))
      {
         shaderNode .enableColorAttribute  (gl, this .colorBuffer,  0, 0);
         shaderNode .enableVertexAttribute (gl, this .sphereBuffer, 0, 0);
      }

      // Draw.

      if (transparency)
         gl .enable (gl .BLEND);
      else
         gl .disable (gl .BLEND);

      gl .drawArrays (gl .TRIANGLES, 0, this .sphereCount);
   },
   drawCube: (function ()
   {
      const textureMatrixArray = new Float32Array (Numbers_Matrix4.Identity);

      return function (renderObject)
      {
         const
            browser    = this .getBrowser (),
            gl         = browser .getContext (),
            shaderNode = browser .getDefaultMaterial () .getShader (this .texturesContext);

         shaderNode .enable (gl);
         shaderNode .setClipPlanes (gl, this .clipPlanes);

         // Set uniforms.

         gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix,  false, this .projectionMatrixArray);
         gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,   false, this .modelViewMatrixArray);
         gl .uniformMatrix4fv (shaderNode .x3d_TextureMatrix [0], false, textureMatrixArray);

         gl .uniform3f (shaderNode .x3d_EmissiveColor,                      1, 1, 1);
         gl .uniform1f (shaderNode .x3d_Transparency,                       0);
         gl .uniform1i (shaderNode .x3d_TextureCoordinateGeneratorMode [0], 0);

         // Draw all textures.

         this .drawRectangle (gl, browser, shaderNode, renderObject, this .frontTexture,  this .frontBuffer,  this .frontArrayObject);
         this .drawRectangle (gl, browser, shaderNode, renderObject, this .backTexture,   this .backBuffer,   this .backArrayObject);
         this .drawRectangle (gl, browser, shaderNode, renderObject, this .leftTexture,   this .leftBuffer,   this .leftArrayObject);
         this .drawRectangle (gl, browser, shaderNode, renderObject, this .rightTexture,  this .rightBuffer,  this .rightArrayObject);
         this .drawRectangle (gl, browser, shaderNode, renderObject, this .topTexture,    this .topBuffer,    this .topArrayObject);
         this .drawRectangle (gl, browser, shaderNode, renderObject, this .bottomTexture, this .bottomBuffer, this .bottomArrayObject);
      };
   })(),
   drawRectangle: function (gl, browser, shaderNode, renderObject, texture, buffer, vertexArray)
   {
      if (texture && (texture .checkLoadState () === Base_X3DConstants.COMPLETE_STATE || texture .getData ()))
      {
         texture .setShaderUniforms (gl, shaderNode, renderObject);

         if (vertexArray .enable (gl, shaderNode))
         {
            shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
            shaderNode .enableVertexAttribute (gl, buffer, 0, 0);
         }

         // Draw.

         if (texture ._transparent .getValue ())
            gl .enable (gl .BLEND);
         else
            gl .disable (gl .BLEND);

         gl .drawArrays (gl .TRIANGLES, 0, 6);

         browser .resetTextureUnits ();
      }
   },
});

/* harmony default export */ const EnvironmentalEffects_X3DBackgroundNode = (X3DBackgroundNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/X3DAppearanceChildNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DAppearanceChildNode (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DAppearanceChildNode);
}

X3DAppearanceChildNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DAppearanceChildNode,
});

/* harmony default export */ const Shape_X3DAppearanceChildNode = (X3DAppearanceChildNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DTextureNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DTextureNode (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTextureNode);

   this .addChildObjects ("transparent", new x_ite_Fields.SFBool ());

   this ._transparent .setAccessType (Base_X3DConstants.outputOnly);
}

X3DTextureNode .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: X3DTextureNode,
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
});

/* harmony default export */ const Texturing_X3DTextureNode = (X3DTextureNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DSingleTextureNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DSingleTextureNode (executionContext)
{
   Texturing_X3DTextureNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSingleTextureNode);
}

X3DSingleTextureNode .prototype = Object .assign (Object .create (Texturing_X3DTextureNode.prototype),
{
   constructor: X3DSingleTextureNode,
   initialize: function ()
   {
      Texturing_X3DTextureNode.prototype.initialize.call (this);

      this ._textureProperties .addInterest ("set_textureProperties__", this, true);

      const gl = this .getBrowser () .getContext ();

      this .texture = gl .createTexture ();

      this .set_textureProperties__ (false);
   },
   set_textureProperties__: function (update)
   {
      if (this .texturePropertiesNode)
         this .texturePropertiesNode .removeInterest ("updateTextureParameters", this);

      this .texturePropertiesNode = X3DCast (Base_X3DConstants.TextureProperties, this ._textureProperties);

      if (! this .texturePropertiesNode)
         this .texturePropertiesNode = this .getBrowser () .getDefaultTextureProperties ();

      this .texturePropertiesNode .addInterest ("updateTextureParameters", this);

      if (update)
         this .updateTextureParameters ();
   },
   getCount: function ()
   {
      return 1;
   },
   getTexture: function ()
   {
      return this .texture;
   },
   updateTextureParameters: (function ()
   {
      // Anisotropic Filtering in WebGL is handled by an extension, use one of getExtension depending on browser:

      const ANISOTROPIC_EXT = [
         "EXT_texture_filter_anisotropic",
         "MOZ_EXT_texture_filter_anisotropic",
         "WEBKIT_EXT_texture_filter_anisotropic",
      ];

      return function (target, haveTextureProperties, textureProperties, width, height, repeatS, repeatT, repeatR)
      {
         const gl = this .getBrowser () .getContext ();

         gl .bindTexture (target, this .getTexture ());

         if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! haveTextureProperties)
         {
            // Dont generate mipmaps.
            gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl .NEAREST);
            gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
         }
         else
         {
            if (textureProperties ._generateMipMaps .getValue ())
               gl .generateMipmap (target);

            gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl [textureProperties .getMinificationFilter ()]);
            gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl [textureProperties .getMagnificationFilter ()]);
         }

         if (haveTextureProperties)
         {
            gl .texParameteri (target, gl .TEXTURE_WRAP_S, gl [textureProperties .getBoundaryModeS ()]);
            gl .texParameteri (target, gl .TEXTURE_WRAP_T, gl [textureProperties .getBoundaryModeT ()]);

            if (gl .getVersion () >= 2)
               gl .texParameteri (target, gl .TEXTURE_WRAP_R, gl [textureProperties .getBoundaryModeR ()]);
         }
         else
         {
            gl .texParameteri (target, gl .TEXTURE_WRAP_S, repeatS ? gl .REPEAT : gl .CLAMP_TO_EDGE);
            gl .texParameteri (target, gl .TEXTURE_WRAP_T, repeatT ? gl .REPEAT : gl .CLAMP_TO_EDGE);

            if (gl .getVersion () >= 2)
               gl .texParameteri (target, gl .TEXTURE_WRAP_R, repeatR ? gl .REPEAT : gl .CLAMP_TO_EDGE);
         }

         //gl .texParameterfv (target, gl .TEXTURE_BORDER_COLOR, textureProperties ._borderColor .getValue ());
         //gl .texParameterf  (target, gl .TEXTURE_PRIORITY,     textureProperties ._texturePriority .getValue ());

         for (const extension of ANISOTROPIC_EXT)
         {
            const ext = gl .getExtension (extension);

            if (ext)
            {
               gl .texParameterf (target, ext .TEXTURE_MAX_ANISOTROPY_EXT, textureProperties ._anisotropicDegree .getValue ());
               break;
            }
         }
      };
   })(),
   updateTextureBits: function (textureBits, channel = 0)
   {
      const textureType = this .getTextureType () - 1;

      textureBits .set (channel * 2 + 0, textureType & 0b01);
      textureBits .set (channel * 2 + 1, textureType & 0b10);
   },
   getShaderOptions: (function ()
   {
      const textureTypes = {
         2: "2D",
         3: "3D",
         4: "CUBE"
      };

      return function (options, channel = 0)
      {
         options .push ("X3D_TEXTURE" + channel + "_" + textureTypes [this .getTextureType ()]);
      };
   })(),
});

/* harmony default export */ const Texturing_X3DSingleTextureNode = (X3DSingleTextureNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DTexture2DNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

function X3DTexture2DNode (executionContext)
{
   Texturing_X3DSingleTextureNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTexture2DNode);

   const gl = this .getBrowser () .getContext ();

   this .target = gl .TEXTURE_2D;
   this .width  = 0;
   this .height = 0;
   this .flipY  = false;
   this .data   = null;
}

X3DTexture2DNode .prototype = Object .assign (Object .create (Texturing_X3DSingleTextureNode.prototype),
{
   constructor: X3DTexture2DNode,
   initialize: function ()
   {
      Texturing_X3DSingleTextureNode.prototype.initialize.call (this);

      this ._repeatS .addInterest ("updateTextureParameters", this);
      this ._repeatT .addInterest ("updateTextureParameters", this);

      const gl = this .getBrowser () .getContext ();

      gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
      gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
   },
   getTarget: function ()
   {
      return this .target;
   },
   getTextureType: function ()
   {
      return 2;
   },
   getTextureTypeString: function ()
   {
      return "2D";
   },
   getWidth: function ()
   {
      return this .width;
   },
   getHeight: function ()
   {
      return this .height;
   },
   getFlipY: function ()
   {
      return this .flipY;
   },
   getData: function ()
   {
      return this .data;
   },
   clearTexture: function ()
   {
      this .setTexture (1, 1, false, defaultData, false);

      this .data = null;
   },
   setTexture: function (width, height, transparent, data, flipY)
   {
      this .width  = width;
      this .height = height;
      this .flipY  = flipY;
      this .data   = data;

      const gl = this .getBrowser () .getContext ();

      gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
      gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
      gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);
      gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, false);

      this .setTransparent (transparent);
      this .updateTextureParameters ();
      this .addNodeEvent ();
   },
   updateTexture: function (data, flipY)
   {
      this .data = data;

      const gl = this .getBrowser () .getContext ();

      gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
      gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
      gl .texSubImage2D (gl .TEXTURE_2D, 0, 0, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);
      gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, false);

      if (this .texturePropertiesNode ._generateMipMaps .getValue ())
         gl .generateMipmap (gl .TEXTURE_2D);

      this .addNodeEvent ();
   },
   updateTextureParameters: function ()
   {
      Texturing_X3DSingleTextureNode.prototype.updateTextureParameters.call (this,
                                                                      this .target,
                                                                      this ._textureProperties .getValue (),
                                                                      this .texturePropertiesNode,
                                                                      this .width,
                                                                      this .height,
                                                                      this ._repeatS .getValue (),
                                                                      this ._repeatT .getValue (),
                                                                      false);
   },
   setShaderUniforms: function (gl, shaderObject, renderObject, channel = shaderObject .x3d_Texture [0])
   {
      const textureUnit = this .getBrowser () .getTexture2DUnit ();

      gl .activeTexture (gl .TEXTURE0 + textureUnit);
      gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
      gl .uniform1i (channel .texture2D, textureUnit);
   },
});

/* harmony default export */ const Texturing_X3DTexture2DNode = (X3DTexture2DNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/ImageTexture.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function ImageTexture (executionContext)
{
   Texturing_X3DTexture2DNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.ImageTexture);

   this .image    = $("<img></img>");
   this .canvas   = $("<canvas></canvas>");
   this .urlStack = new x_ite_Fields.MFString ();
}

ImageTexture .prototype = Object .assign (Object .create (Texturing_X3DTexture2DNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: ImageTexture,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "description",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatS",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatT",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "textureProperties",    new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "ImageTexture";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texture";
   },
   initialize: function ()
   {
      Texturing_X3DTexture2DNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      this .image .on ("load",        this .setImage .bind (this));
      this .image .on ("abort error", this .setError .bind (this));

      this .image [0] .crossOrigin = "Anonymous";

      this .requestImmediateLoad ();
   },
   unLoadNow: function ()
   {
      this .clearTexture ();
   },
   loadNow: function ()
   {
      this .urlStack .setValue (this ._url);
      this .loadNext ();
   },
   loadNext: function ()
   {
      if (this .urlStack .length === 0)
      {
         this .clearTexture ();
         this .setLoadState (Base_X3DConstants.FAILED_STATE);
         return;
      }

      // Get URL.

      this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

      if (this .URL .protocol !== "data:")
      {
         if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
            this .URL .searchParams .set ("_", Date .now ());
      }

      this .image .attr ("src", this .URL .href);
   },
   setError: function (event)
   {
      if (this .URL .protocol !== "data:")
         console .warn ("Error loading image:", decodeURI (this .URL .href), event .type);

      this .loadNext ();
   },
   setImage: function ()
   {
      if (DEBUG)
      {
          if (this .URL .protocol !== "data:")
            console .info ("Done loading image:", decodeURI (this .URL .href));
      }

      try
      {
         const
            gl     = this .getBrowser () .getContext (),
            image  = this .image [0],
            canvas = this .canvas [0],
            cx     = canvas .getContext ("2d", { willReadFrequently: true });

         let
            width  = image .width,
            height = image .height;

         // Scale image if needed and flip vertically.

         if (gl .getVersion () >= 2 || (Math_Algorithm.isPowerOfTwo (width) && Math_Algorithm.isPowerOfTwo (height)))
         {
            // Flip Y

            canvas .width  = width;
            canvas .height = height;

            cx .clearRect (0, 0, width, height);
            cx .save ();
            cx .translate (0, height);
            cx .scale (1, -1);
            cx .drawImage (image, 0, 0);
            cx .restore ();
         }
         else
         {
            // Flip Y and scale image to next power of two.

            width  = Math_Algorithm.nextPowerOfTwo (width);
            height = Math_Algorithm.nextPowerOfTwo (height);

            canvas .width  = width;
            canvas .height = height;

            cx .clearRect (0, 0, width, height);
            cx .save ();
            cx .translate (0, height);
            cx .scale (1, -1);
            cx .drawImage (image, 0, 0, image .width, image .height, 0, 0, width, height);
            cx .restore ();
         }

         // Determine image alpha.

         const data = cx .getImageData (0, 0, width, height) .data;

         let transparent = false;

         for (let i = 3, length = data .length; i < length; i += 4)
         {
            if (data [i] !== 255)
            {
               transparent = true;
               break;
            }
         }

         this .setTexture (width, height, transparent, new Uint8Array (data .buffer), false);
         this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
      }
      catch (error)
      {
         // Catch security error from cross origin requests.
         console .log (error .message);
         this .setError ();
      }
   },
});

/* harmony default export */ const Texturing_ImageTexture = (ImageTexture);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/Background.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function Background (executionContext)
{
   EnvironmentalEffects_X3DBackgroundNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Background);
}

Background .prototype = Object .assign (Object .create (EnvironmentalEffects_X3DBackgroundNode.prototype),
{
   constructor: Background,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",     new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "frontUrl",     new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backUrl",      new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "leftUrl",      new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "rightUrl",     new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "topUrl",       new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "bottomUrl",    new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "skyAngle",     new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "skyColor",     new x_ite_Fields.MFColor (new x_ite_Fields.SFColor ())),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "groundAngle",  new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "groundColor",  new x_ite_Fields.MFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",      new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",     new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "Background";
   },
   getComponentName: function ()
   {
      return "EnvironmentalEffects";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.initialize.call (this);

      const
         frontTexture      = new Texturing_ImageTexture (this .getExecutionContext ()),
         backTexture       = new Texturing_ImageTexture (this .getExecutionContext ()),
         leftTexture       = new Texturing_ImageTexture (this .getExecutionContext ()),
         rightTexture      = new Texturing_ImageTexture (this .getExecutionContext ()),
         topTexture        = new Texturing_ImageTexture (this .getExecutionContext ()),
         bottomTexture     = new Texturing_ImageTexture (this .getExecutionContext ()),
         textureProperties = this .getBrowser () .getBackgroundTextureProperties ();

      this ._frontUrl  .addFieldInterest (frontTexture  ._url);
      this ._backUrl   .addFieldInterest (backTexture   ._url);
      this ._leftUrl   .addFieldInterest (leftTexture   ._url);
      this ._rightUrl  .addFieldInterest (rightTexture  ._url);
      this ._topUrl    .addFieldInterest (topTexture    ._url);
      this ._bottomUrl .addFieldInterest (bottomTexture ._url);

      frontTexture  ._url = this ._frontUrl;
      backTexture   ._url = this ._backUrl;
      leftTexture   ._url = this ._leftUrl;
      rightTexture  ._url = this ._rightUrl;
      topTexture    ._url = this ._topUrl;
      bottomTexture ._url = this ._bottomUrl;

      frontTexture  ._textureProperties = textureProperties;
      backTexture   ._textureProperties = textureProperties;
      leftTexture   ._textureProperties = textureProperties;
      rightTexture  ._textureProperties = textureProperties;
      topTexture    ._textureProperties = textureProperties;
      bottomTexture ._textureProperties = textureProperties;

      frontTexture  .setup ();
      backTexture   .setup ();
      leftTexture   .setup ();
      rightTexture  .setup ();
      topTexture    .setup ();
      bottomTexture .setup ();

      this .set_frontTexture__  (frontTexture);
      this .set_backTexture__   (backTexture);
      this .set_leftTexture__   (leftTexture);
      this .set_rightTexture__  (rightTexture);
      this .set_topTexture__    (topTexture);
      this .set_bottomTexture__ (bottomTexture);
   }
});

/* harmony default export */ const EnvironmentalEffects_Background = (Background);

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering/X3DLayerNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


















var projectionMatrix = new Numbers_Matrix4 ();

function X3DLayerNode (executionContext, defaultViewpoint, groupNode)
{
   Core_X3DNode.call (this, executionContext);
   Rendering_X3DRenderObject.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DLayerNode);

   this .groupNode       = groupNode;
   this .currentViewport = null;

   this .defaultNavigationInfo = new Navigation_NavigationInfo (executionContext);
   this .defaultViewpoint      = defaultViewpoint;
   this .defaultBackground     = new EnvironmentalEffects_Background (executionContext);
   this .defaultFog            = new EnvironmentalEffects_Fog (executionContext);

   this .navigationInfoStack = new Execution_BindableStack (executionContext, this .defaultNavigationInfo);
   this .viewpointStack      = new Execution_BindableStack (executionContext, this .defaultViewpoint);
   this .backgroundStack     = new Execution_BindableStack (executionContext, this .defaultBackground);
   this .fogStack            = new Execution_BindableStack (executionContext, this .defaultFog);

   this .navigationInfos = new Execution_BindableList (executionContext, this .defaultNavigationInfo);
   this .viewpoints      = new Execution_BindableList (executionContext, this .defaultViewpoint);
   this .backgrounds     = new Execution_BindableList (executionContext, this .defaultBackground);
   this .fogs            = new Execution_BindableList (executionContext, this .defaultFog);

   this .defaultBackground .setHidden (true);
   this .defaultFog        .setHidden (true);

   this .collisionTime = 0;
}

X3DLayerNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Rendering_X3DRenderObject.prototype,
{
   constructor: X3DLayerNode,
   layer0: false,
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);
      Rendering_X3DRenderObject.prototype.initialize.call (this);

      this .defaultNavigationInfo .setup ();
      this .defaultViewpoint      .setup ();
      this .defaultBackground     .setup ();
      this .defaultFog            .setup ();

      this .navigationInfoStack .setup ();
      this .viewpointStack      .setup ();
      this .backgroundStack     .setup ();
      this .fogStack            .setup ();

      this .navigationInfos .setup ();
      this .viewpoints      .setup ();
      this .backgrounds     .setup ();
      this .fogs            .setup ();

      this ._viewport .addInterest ("set_viewport__", this);

      this .set_viewport__ ();
   },
   isLayer0: function (value)
   {
      this .layer0 = value;
      this .defaultBackground .setHidden (! value);
   },
   getLayer: function ()
   {
      return this;
   },
   getGroup: function ()
   {
      return this .groupNode;
   },
   getViewport: function ()
   {
      return this .currentViewport;
   },
   getBackground: function ()
   {
      return this .backgroundStack .top ();
   },
   getFog: function ()
   {
      return this .fogStack .top ();
   },
   getNavigationInfo: function ()
   {
      return this .navigationInfoStack .top ();
   },
   getViewpoint: function ()
   {
      return this .viewpointStack .top ();
   },
   getBackgrounds: function ()
   {
      return this .backgrounds;
   },
   getFogs: function ()
   {
      return this .fogs;
   },
   getNavigationInfos: function ()
   {
      return this .navigationInfos;
   },
   getViewpoints: function ()
   {
      return this .viewpoints;
   },
   getUserViewpoints: function ()
   {
      var userViewpoints = [ ];

      for (var i = 0; i < this .viewpoints .get () .length; ++ i)
      {
         var viewpoint = this .viewpoints .get () [i];

         if (viewpoint ._description .length)
            userViewpoints .push (viewpoint);
      }

      return userViewpoints;
   },
   getBackgroundStack: function ()
   {
      return this .backgroundStack;
   },
   getFogStack: function ()
   {
      return this .fogStack;
   },
   getNavigationInfoStack: function ()
   {
      return this .navigationInfoStack;
   },
   getViewpointStack: function ()
   {
      return this .viewpointStack;
   },
   getBBox: function (bbox, shadows)
   {
      return this .groupNode .getBBox (bbox, shadows);
   },
   lookAt: function (factor, straighten)
   {
      this .getViewpoint () .lookAtBBox (this .getBBox (new Geometry_Box3 ()), factor, straighten);
   },
   set_viewport__: function ()
   {
      this .currentViewport = X3DCast (Base_X3DConstants.X3DViewportNode, this ._viewport);

      if (! this .currentViewport)
         this .currentViewport = this .getBrowser () .getDefaultViewport ();
   },
   bindBindables: function (viewpointName)
   {
      this .traverse (Rendering_TraverseType.CAMERA, this);

      // Bind first viewpoint in viewpoint list.

      const
         navigationInfoNode = this .navigationInfos .getBound (),
         backgroundNode     = this .backgrounds     .getBound (),
         fogNode            = this .fogs            .getBound (),
         viewpointNode      = this .viewpoints      .getBound (viewpointName);

      this .navigationInfoStack .pushOnTop (navigationInfoNode);
      this .viewpointStack      .pushOnTop (viewpointNode);
      this .backgroundStack     .pushOnTop (backgroundNode);
      this .fogStack            .pushOnTop (fogNode);

      viewpointNode .resetUserOffsets ();
   },
   traverse: function (type, renderObject)
   {
      renderObject = renderObject || this;

      var viewpoint = this .getViewpoint ();

      this .getProjectionMatrix ()  .pushMatrix (viewpoint .getProjectionMatrix (this));
      this .getCameraSpaceMatrix () .pushMatrix (viewpoint .getCameraSpaceMatrix ());
      this .getViewMatrix ()        .pushMatrix (viewpoint .getViewMatrix ());

      switch (type)
      {
         case Rendering_TraverseType.POINTER:
            this .pointer (type, renderObject);
            break;
         case Rendering_TraverseType.CAMERA:
            this .camera (type, renderObject);
            break;
         case Rendering_TraverseType.PICKING:
            this .picking (type, renderObject);
            break;
         case Rendering_TraverseType.COLLISION:
            this .collision (type, renderObject);
            break;
         case Rendering_TraverseType.SHADOW:
         case Rendering_TraverseType.DISPLAY:
            this .display (type, renderObject);
            break;
      }

      this .getViewMatrix ()        .pop ();
      this .getCameraSpaceMatrix () .pop ();
      this .getProjectionMatrix ()  .pop ();
   },
   pointer: function (type, renderObject)
   {
      if (this ._isPickable .getValue ())
      {
         var
            browser  = this .getBrowser (),
            viewport = this .currentViewport .getRectangle (browser);

         if (browser .getSelectedLayer ())
         {
            if (browser .getSelectedLayer () !== this)
               return;
         }
         else
         {
            if (! browser .isPointerInRectangle (viewport))
               return;
         }

         browser .setHitRay (this .getProjectionMatrix () .get (), viewport);
         this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

         this .currentViewport .push (this);
         this .groupNode .traverse (type, renderObject);
         this .currentViewport .pop (this);

         this .getModelViewMatrix () .pop ()
      }
   },
   camera: function (type, renderObject)
   {
      this .getModelViewMatrix () .pushMatrix (Numbers_Matrix4.Identity);

      this .currentViewport .push (this);
      this .groupNode .traverse (type, renderObject);
      this .currentViewport .pop (this);

      this .getModelViewMatrix () .pop ();

      this .navigationInfos .update (this, this .navigationInfoStack);
      this .viewpoints      .update (this, this .viewpointStack);
      this .backgrounds     .update (this, this .backgroundStack);
      this .fogs            .update (this, this .fogStack);

      this .getViewpoint () .update ();
   },
   picking: function (type, renderObject)
   {
      this .getModelViewMatrix () .pushMatrix (Numbers_Matrix4.Identity);

      this .currentViewport .push (this);
      this .groupNode .traverse (type, renderObject);
      this .currentViewport .pop (this);

      this .getModelViewMatrix () .pop ();
   },
   collision: function (type, renderObject)
   {
      var navigationInfo = this .getNavigationInfo ();

      if (navigationInfo ._transitionActive .getValue ())
         return;

      var
         collisionRadius = navigationInfo .getCollisionRadius (),
         avatarHeight    = navigationInfo .getAvatarHeight (),
         size            = Math .max (collisionRadius * 2, avatarHeight * 2);

      this .collisionTime = 0;

      Camera.ortho (-size, size, -size, size, -size, size, projectionMatrix);

      this .getProjectionMatrix () .pushMatrix (projectionMatrix);
      this .getModelViewMatrix  () .pushMatrix (this .getViewMatrix () .get ());

      // Render
      this .currentViewport .push (this);
      renderObject .render (type, this .groupNode .traverse, this .groupNode);
      this .currentViewport .pop (this);

      this .getModelViewMatrix  () .pop ()
      this .getProjectionMatrix () .pop ()
   },
   display: function (type, renderObject)
   {
      this .getNavigationInfo () .enable (type, renderObject);

      this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

      this .currentViewport .push (this);
      renderObject .render (type, this .groupNode .traverse, this .groupNode);
      this .currentViewport .pop (this);

      this .getModelViewMatrix () .pop ()
   },
});

/* harmony default export */ const Layering_X3DLayerNode = (X3DLayerNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DSensorNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSensorNode);
}

X3DSensorNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DSensorNode,
});

/* harmony default export */ const Core_X3DSensorNode = (X3DSensorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Time/X3DTimeDependentNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DTimeDependentNode (executionContext)
{
   this .addType (Base_X3DConstants.X3DTimeDependentNode);

   this .addChildObjects ("initialized", new x_ite_Fields.SFTime (),
                          "isEvenLive",  new x_ite_Fields.SFBool ());

   this .startTimeValue  = 0;
   this .pauseTimeValue  = 0;
   this .resumeTimeValue = 0;
   this .stopTimeValue   = 0;
   this .start           = 0;
   this .pause           = 0;
   this .pauseInterval   = 0;
   this .startTimeout    = null;
   this .pauseTimeout    = null;
   this .resumeTimeout   = null;
   this .stopTimeout     = null;
   this .disabled        = false;
}

X3DTimeDependentNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DTimeDependentNode,
   initialize: function ()
   {
      this .isLive ()   .addInterest ("set_live__", this);
      this ._isEvenLive .addInterest ("set_live__", this);

      this ._initialized .addInterest ("set_loop__",       this);
      this ._enabled     .addInterest ("set_enabled__",    this);
      this ._loop        .addInterest ("set_loop__",       this);
      this ._startTime   .addInterest ("set_startTime__",  this);
      this ._pauseTime   .addInterest ("set_pauseTime__",  this);
      this ._resumeTime  .addInterest ("set_resumeTime__", this);
      this ._stopTime    .addInterest ("set_stopTime__",   this);

      this .startTimeValue  = this ._startTime  .getValue ();
      this .pauseTimeValue  = this ._pauseTime  .getValue ();
      this .resumeTimeValue = this ._resumeTime .getValue ();
      this .stopTimeValue   = this ._stopTime   .getValue ();

      this ._initialized = this .getBrowser () .getCurrentTime ();
   },
   getDisabled: function ()
   {
      return this .disabled;
   },
   getLiveState: function ()
   {
      ///  Determines the live state of this node.

      return this .getLive () && (this .getExecutionContext () .isLive () .getValue () || this ._isEvenLive .getValue ());
   },
   getElapsedTime: function ()
   {
      return this .getBrowser () .getCurrentTime () - this .start - this .pauseInterval;
   },
   resetElapsedTime: function ()
   {
      this .start         = this .getBrowser () .getCurrentTime ();
      this .pause         = this .getBrowser () .getCurrentTime ();
      this .pauseInterval = 0;
   },
   set_live__: function ()
   {
      if (this .isLive () .getValue () || this ._isEvenLive .getValue ())
      {
         if (this .disabled)
         {
            this .disabled = false;

            if (this ._isActive .getValue () && ! this ._isPaused .getValue ())
               this .real_resume ();
         }
      }
      else
      {
         if (! this .disabled && this ._isActive .getValue () && ! this ._isPaused .getValue ())
         {
            // Only disable if needed, ie. if running!
            this .disabled = true;
            this .real_pause ();
         }
      }
   },
   set_enabled__: function ()
   {
      if (this ._enabled .getValue ())
         this .set_loop__ ();

      else
         this .stop ();
   },
   set_loop__: function ()
   {
      if (this ._enabled .getValue ())
      {
         if (this ._loop .getValue ())
         {
            if (this .stopTimeValue <= this .startTimeValue)
            {
               if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
                  this .do_start ();
            }
         }
      }
   },
   set_startTime__: function ()
   {
      this .startTimeValue = this ._startTime .getValue ();

      if (this ._enabled .getValue ())
      {
         this .removeTimeout ("startTimeout");

         if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
            this .do_start ();

         else
            this .addTimeout ("startTimeout", "do_start", this .startTimeValue);
      }
   },
   set_pauseTime__: function ()
   {
      this .pauseTimeValue = this ._pauseTime .getValue ();

      if (this ._enabled .getValue ())
      {
         this .removeTimeout ("pauseTimeout");

         if (this .pauseTimeValue <= this .resumeTimeValue)
            return;

         if (this .pauseTimeValue <= this .getBrowser () .getCurrentTime ())
            this .do_pause ();

         else
            this .addTimeout ("pauseTimeout", "do_pause", this .pauseTimeValue);
      }
   },
   set_resumeTime__: function ()
   {
      this .resumeTimeValue = this ._resumeTime .getValue ();

      if (this ._enabled .getValue ())
      {
         this .removeTimeout ("resumeTimeout");

         if (this .resumeTimeValue <= this .pauseTimeValue)
            return;

         if (this .resumeTimeValue <= this .getBrowser () .getCurrentTime ())
            this .do_resume ();

         else
            this .addTimeout ("resumeTimeout", "do_resume", this .resumeTimeValue);
      }
   },
   set_stopTime__: function ()
   {
      this .stopTimeValue = this ._stopTime .getValue ();

      if (this ._enabled .getValue ())
      {
         this .removeTimeout ("stopTimeout");

         if (this .stopTimeValue <= this .startTimeValue)
            return;

         if (this .stopTimeValue <= this .getBrowser () .getCurrentTime ())
            this .do_stop ();

         else
            this .addTimeout ("stopTimeout","do_stop", this .stopTimeValue);
      }
   },
   do_start: function ()
   {
      if (!this ._isActive .getValue ())
      {
         this .resetElapsedTime ();

         // The event order below is very important.

         this ._isActive = true;

         this .set_start ();

         if (this .isLive () .getValue ())
         {
            this .getBrowser () .timeEvents () .addInterest ("set_time" ,this);
         }
         else
         {
            this .disabled = true;
            this .real_pause ();
         }

         this ._elapsedTime = 0;
      }
   },
   do_pause: function ()
   {
      if (this ._isActive .getValue () && !this ._isPaused .getValue ())
      {
         this ._isPaused = true;

         if (this .pauseTimeValue !== this .getBrowser () .getCurrentTime ())
            this .pauseTimeValue = this .getBrowser () .getCurrentTime ();

         if (this .isLive () .getValue ())
            this .real_pause ();
      }
   },
   real_pause: function ()
   {
      this .pause = performance .now ();

      this .set_pause ();

      this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
   },
   do_resume: function ()
   {
      if (this ._isActive .getValue () && this ._isPaused .getValue ())
      {
         this ._isPaused = false;

         if (this .resumeTimeValue !== this .getBrowser () .getCurrentTime ())
            this .resumeTimeValue = this .getBrowser () .getCurrentTime ();

         if (this .isLive () .getValue ())
            this .real_resume ();
      }
   },
   real_resume: function ()
   {
      const interval = (performance .now () - this .pause) / 1000;

      this .pauseInterval += interval;

      this .set_resume (interval);

      this .getBrowser () .timeEvents () .addInterest ("set_time", this);
      this .getBrowser () .addBrowserEvent ();
   },
   do_stop: function ()
   {
      this .stop ();
   },
   stop: function ()
   {
      if (this ._isActive .getValue ())
      {
         // The event order below is very important.

         this .set_stop ();

         this ._elapsedTime = this .getElapsedTime ();

         if (this ._isPaused .getValue ())
            this ._isPaused = false;

         this ._isActive = false;

         this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
      }
   },
   timeout: function (callback)
   {
      if (this ._enabled .getValue ())
      {
         this .getBrowser () .advanceTime (performance .now ());

         this [callback] ();
      }
   },
   addTimeout: function (name, callback, time)
   {
      this .removeTimeout (name);
      this [name] = setTimeout (this .timeout .bind (this, callback), (time - this .getBrowser () .getCurrentTime ()) * 1000);
   },
   removeTimeout: function (name)
   {
      clearTimeout (this [name]);
      this [name] = null;
   },
   set_start: function () { },
   set_pause: function () { },
   set_resume: function () { },
   set_stop: function () { },
   set_time: function () { },
});

/* harmony default export */ const Time_X3DTimeDependentNode = (X3DTimeDependentNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Time/TimeSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function TimeSensor (executionContext)
{
   Core_X3DSensorNode.call (this, executionContext);
   Time_X3DTimeDependentNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TimeSensor);

   this .addChildObjects ("range", new x_ite_Fields.MFFloat (0, 0, 1)); // current, first, last (in fractions) - play range starting at current

   this .cycle    = 0;
   this .interval = 0;
   this .fraction = 0;
   this .first    = 0;
   this .last     = 1;
   this .scale    = 1;
}

TimeSensor .prototype = Object .assign (Object .create (Core_X3DSensorNode.prototype),
   Time_X3DTimeDependentNode.prototype,
{
   constructor: TimeSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "cycleInterval",    new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "loop",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "startTime",        new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "resumeTime",       new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pauseTime",        new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "stopTime",         new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isPaused",         new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",         new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "cycleTime",        new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "elapsedTime",      new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "fraction_changed", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "time",             new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "TimeSensor";
   },
   getComponentName: function ()
   {
      return "Time";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DSensorNode.prototype.initialize.call (this);
      Time_X3DTimeDependentNode.prototype.initialize.call (this);

      this ._cycleInterval .addInterest ("set_cycleInterval__", this);
      this ._range         .addInterest ("set_range__",         this);
   },
   setRange: function (currentFraction, firstFraction, lastFraction)
   {
      const
         currentTime   = this .getBrowser () .getCurrentTime (),
         startTime     = this ._startTime .getValue (),
         cycleInterval = this ._cycleInterval .getValue ();

      this .first    = firstFraction;
      this .last     = lastFraction;
      this .scale    = this .last - this .first;
      this .interval = cycleInterval * this .scale;
      this .fraction = Math_Algorithm.fract ((currentFraction >= 1 ? 0 : currentFraction) + (this .interval ? (currentTime - startTime) / this .interval : 0));
      this .cycle    = currentTime - (this .fraction -  this .first) * cycleInterval;
   },
   set_cycleInterval__: function ()
   {
      if (this ._isActive .getValue ())
         this .setRange (this .fraction, this ._range [1], this ._range [2]);
   },
   set_range__: function ()
   {
      if (this ._isActive .getValue ())
      {
         this .setRange (this ._range [0], this ._range [1], this ._range [2]);

         if (!this ._isPaused .getValue ())
            this .set_fraction (this .getBrowser () .getCurrentTime ());
      }
   },
   set_start: function ()
   {
      this .setRange (this ._range [0], this ._range [1], this ._range [2]);

      if (this .isLive () .getValue ())
      {
         this ._fraction_changed = this .fraction;
         this ._time             = this .getBrowser () .getCurrentTime ();
      }
   },
   set_resume: function (pauseInterval)
   {
      const
         currentTime   = this .getBrowser () .getCurrentTime (),
         startTime     = this ._startTime .getValue ();

      this .setRange (this .interval ? Math_Algorithm.fract (this .fraction - (currentTime - startTime) / this .interval) : 0, this ._range [1], this ._range [2]);
   },
   set_fraction: function (time)
   {
      this ._fraction_changed = this .fraction = this .first + (this .interval ? Math_Algorithm.fract ((time - this .cycle) / this .interval) : 0) * this .scale;
   },
   set_time: function ()
   {
      // The event order below is very important.

      const time = this .getBrowser () .getCurrentTime ();

      if (time - this .cycle >= this .interval)
      {
         if (this ._loop .getValue ())
         {
            if (this .interval)
            {
               this .cycle += this .interval * Math .floor ((time - this .cycle) / this .interval);

               this ._elapsedTime = this .getElapsedTime ();
               this ._cycleTime   = time;

               this .set_fraction (time);
            }
         }
         else
         {
            this ._fraction_changed = this .fraction = this .last;
            this .stop ();
         }
      }
      else
      {
         this ._elapsedTime = this .getElapsedTime ();

         this .set_fraction (time);
      }

      this ._time = time;
   },
});

/* harmony default export */ const Time_TimeSensor = (TimeSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/X3DInterpolatorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DInterpolatorNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DInterpolatorNode);
}

X3DInterpolatorNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DInterpolatorNode,
   setup: function ()
   {
      // If an X3DInterpolatorNode value_changed outputOnly field is read before it receives any inputs,
      // keyValue[0] is returned if keyValue is not empty. If keyValue is empty (i.e., [ ]), the initial
      // value for the respective field type is returned (EXAMPLE  (0, 0, 0) for Fields .SFVec3f);

      this .set_key__ ();

      if (this ._key .length)
         this .interpolate (0, 0, 0);

      Core_X3DChildNode.prototype.setup.call (this);
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);

      this ._set_fraction .addInterest ("set_fraction__", this);
      this ._key          .addInterest ("set_key__", this);
   },
   set_fraction__: function ()
   {
      const
         key      = this ._key,
         length   = key .length,
         fraction = this ._set_fraction .getValue ();

      switch (length)
      {
         case 0:
            // Interpolator nodes containing no keys in the key field shall not produce any events.
            return;
         case 1:
            return this .interpolate (0, 0, 0);
         default:
         {
            if (fraction <= key [0])
               return this .interpolate (0, 1, 0);

            const index1 = Math_Algorithm.upperBound (key, 0, length, fraction);

            if (index1 !== length)
            {
               const
                  index0 = index1 - 1,
                  weight = (fraction - key [index0]) / (key [index1] - key [index0]);

               this .interpolate (index0, index1, Math_Algorithm.clamp (weight, 0, 1));
            }
            else
               this .interpolate (length - 2, length - 1, 1);
         }
      }
   },
   set_key__: function ()
   {
      this .set_keyValue__ ();
   },
   set_keyValue__: function () { },
   interpolate: function () { },
});

/* harmony default export */ const Interpolation_X3DInterpolatorNode = (X3DInterpolatorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/EaseInEaseOut.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function EaseInEaseOut (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.EaseInEaseOut);
}

EaseInEaseOut .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: EaseInEaseOut,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",                 new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",             new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",                      new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "easeInEaseOut",            new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "modifiedFraction_changed", new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "EaseInEaseOut";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._easeInEaseOut .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      if (this ._easeInEaseOut .length < this ._key .length)
         this ._easeInEaseOut .resize (this ._key .length, this ._easeInEaseOut .length ? this ._easeInEaseOut [this ._easeInEaseOut .length - 1] : new x_ite_Fields.SFVec2f ());
   },
   interpolate: function (index0, index1, weight)
   {
      let
         easeOut = this ._easeInEaseOut [index0] .y,
         easeIn  = this ._easeInEaseOut [index1] .x;
      
      const sum = easeOut + easeIn;

      if (sum < 0)
      {
         this ._modifiedFraction_changed = weight;
      }
      else
      {
         if (sum > 1)
         {
            easeIn  /= sum;
            easeOut /= sum;
         }

         const t = 1 / (2 - easeOut - easeIn);

         if (weight < easeOut)
         {
            this ._modifiedFraction_changed = (t / easeOut) * weight * weight;
         }
         else if (weight <= 1 - easeIn) // Spec says (weight < 1 - easeIn), but then we get a NaN below if easeIn == 0.
         {
            this ._modifiedFraction_changed = t * (2 * weight - easeOut);
         }
         else
         {
            const w = 1 - weight;

            this ._modifiedFraction_changed = 1 - ((t * w * w) / easeIn);
         }
      }
   },
});

/* harmony default export */ const Interpolation_EaseInEaseOut = (EaseInEaseOut);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/PositionInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionInterpolator);
}

PositionInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: PositionInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "PositionInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFVec3f ());
   },
   interpolate: (function ()
   {
      const keyValue = new Numbers_Vector3 (0, 0, 0);

      return function (index0, index1, weight)
      {
         this ._value_changed = keyValue .assign (this ._keyValue [index0] .getValue ()) .lerp (this ._keyValue [index1] .getValue (), weight);
      };
   })(),
});

/* harmony default export */ const Interpolation_PositionInterpolator = (PositionInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/OrientationInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function OrientationInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.OrientationInterpolator);

   this ._keyValue      .setUnit ("angle");
   this ._value_changed .setUnit ("angle");
}

OrientationInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: OrientationInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFRotation ()),
   ]),
   getTypeName: function ()
   {
      return "OrientationInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFRotation ());
   },
   interpolate: (function ()
   {
      const
         keyValue0 = new Numbers_Rotation4 (0, 0, 1, 0),
         keyValue1 = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (index0, index1, weight)
      {
         // Both values can change in slerp.
         keyValue0 .assign (this ._keyValue [index0] .getValue ());
         keyValue1 .assign (this ._keyValue [index1] .getValue ());

         this ._value_changed = keyValue0 .slerp (keyValue1, weight);
      };
   }) (),
});

/* harmony default export */ const Interpolation_OrientationInterpolator = (OrientationInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/X3DViewpointNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/














function X3DViewpointNode (executionContext)
{
   Core_X3DBindableNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DViewpointNode);

   this .addChildObjects ("positionOffset",         new x_ite_Fields.SFVec3f (),
                          "orientationOffset",      new x_ite_Fields.SFRotation (),
                          "scaleOffset",            new x_ite_Fields.SFVec3f (1, 1, 1),
                          "scaleOrientationOffset", new x_ite_Fields.SFRotation (),
                          "centerOfRotationOffset", new x_ite_Fields.SFVec3f (),
                          "fieldOfViewScale",       new x_ite_Fields.SFFloat (1));

   this .userPosition         = new Numbers_Vector3 (0, 1, 0);
   this .userOrientation      = new Numbers_Rotation4 (0, 0, 1, 0);
   this .userCenterOfRotation = new Numbers_Vector3 (0, 0, 0);
   this .modelMatrix          = new Numbers_Matrix4 ();
   this .cameraSpaceMatrix    = new Numbers_Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  10, 1);
   this .viewMatrix           = new Numbers_Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -10, 1);

   const browser = this .getBrowser ();

   this .timeSensor                   = new Time_TimeSensor              (browser .getPrivateScene ());
   this .easeInEaseOut                = new Interpolation_EaseInEaseOut           (browser .getPrivateScene ());
   this .positionInterpolator         = new Interpolation_PositionInterpolator    (browser .getPrivateScene ());
   this .orientationInterpolator      = new Interpolation_OrientationInterpolator (browser .getPrivateScene ());
   this .scaleInterpolator            = new Interpolation_PositionInterpolator    (browser .getPrivateScene ());
   this .scaleOrientationInterpolator = new Interpolation_OrientationInterpolator (browser .getPrivateScene ());
}

X3DViewpointNode .prototype = Object .assign (Object .create (Core_X3DBindableNode.prototype),
{
   constructor: X3DViewpointNode,
   initialize: function ()
   {
      Core_X3DBindableNode.prototype.initialize.call (this);

      this .timeSensor ._stopTime = 1;
      this .timeSensor .setup ();

      this .easeInEaseOut ._key           = new x_ite_Fields.MFFloat (0, 1);
      this .easeInEaseOut ._easeInEaseOut = new x_ite_Fields.MFVec2f (new x_ite_Fields.SFVec2f (0, 0), new x_ite_Fields.SFVec2f (0, 0));
      this .easeInEaseOut .setup ();

      this .positionInterpolator         ._key = new x_ite_Fields.MFFloat (0, 1);
      this .orientationInterpolator      ._key = new x_ite_Fields.MFFloat (0, 1);
      this .scaleInterpolator            ._key = new x_ite_Fields.MFFloat (0, 1);
      this .scaleOrientationInterpolator ._key = new x_ite_Fields.MFFloat (0, 1);

      this .positionInterpolator         .setup ();
      this .orientationInterpolator      .setup ();
      this .scaleInterpolator            .setup ();
      this .scaleOrientationInterpolator .setup ();

      this .timeSensor ._isActive         .addFieldInterest (this ._transitionActive);
      this .timeSensor ._fraction_changed .addFieldInterest (this .easeInEaseOut ._set_fraction);

      this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .positionInterpolator         ._set_fraction);
      this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .orientationInterpolator      ._set_fraction);
      this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .scaleInterpolator            ._set_fraction);
      this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .scaleOrientationInterpolator ._set_fraction);

      this .positionInterpolator         ._value_changed .addFieldInterest (this ._positionOffset);
      this .orientationInterpolator      ._value_changed .addFieldInterest (this ._orientationOffset);
      this .scaleInterpolator            ._value_changed .addFieldInterest (this ._scaleOffset);
      this .scaleOrientationInterpolator ._value_changed .addFieldInterest (this ._scaleOrientationOffset);

      this ._isBound .addInterest ("set_bound__", this);
   },
   getEaseInEaseOut: function ()
   {
      return this .easeInEaseOut;
   },
   setInterpolators: function () { },
   getPosition: function ()
   {
      return this ._position .getValue ();
   },
   getUserPosition: function ()
   {
      return this .userPosition .assign (this .getPosition ()) .add (this ._positionOffset .getValue ());
   },
   getOrientation: function ()
   {
      return this ._orientation .getValue ();
   },
   getUserOrientation: function ()
   {
      return this .userOrientation .assign (this .getOrientation ()) .multRight (this ._orientationOffset .getValue ());
   },
   getCenterOfRotation: function ()
   {
      return this ._centerOfRotation .getValue ();
   },
   getUserCenterOfRotation: function ()
   {
      return this .userCenterOfRotation .assign (this .getCenterOfRotation ()) .add (this ._centerOfRotationOffset .getValue ());
   },
   getProjectionMatrix: function (renderObject)
   {
      const navigationInfo = renderObject .getNavigationInfo ();

      return this .getProjectionMatrixWithLimits (navigationInfo .getNearValue (),
                                                  navigationInfo .getFarValue (this),
                                                  renderObject .getLayer () .getViewport () .getRectangle (this .getBrowser ()));
   },
   getCameraSpaceMatrix: function ()
   {
      return this .cameraSpaceMatrix;
   },
   getViewMatrix: function ()
   {
      return this .viewMatrix;
   },
   getModelMatrix: function ()
   {
      return this .modelMatrix;
   },
   getMaxFarValue: function ()
   {
      return this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer") ? 1e10 : 1e5;
   },
   getUpVector: function ()
   {
      // Local y-axis,
      // see http://www.web3d.org/documents/specifications/19775-1/V3.3/index.html#NavigationInfo.
      return Numbers_Vector3.yAxis;
   },
   getSpeedFactor: function ()
   {
      return 1;
   },
   setVRMLTransition: function (value)
   {
      // VRML behaviour support.
      this .VRMLTransition = value;
   },
   getVRMLTransition: function ()
   {
      // VRML behaviour support.
      return this .VRMLTransition;
   },
   transitionStart: (function ()
   {
      const
         relativePosition         = new Numbers_Vector3 (0, 0, 0),
         relativeOrientation      = new Numbers_Rotation4 (0, 0, 1, 0),
         relativeScale            = new Numbers_Vector3 (0, 0, 0),
         relativeScaleOrientation = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (layerNode, fromViewpointNode, toViewpointNode)
      {
         this .to = toViewpointNode;

         if (toViewpointNode ._jump .getValue ())
         {
            if (! toViewpointNode ._retainUserOffsets .getValue ())
               toViewpointNode .resetUserOffsets ();

            // Copy from toViewpointNode all fields.

            if (this !== toViewpointNode)
            {
               for (const field of toViewpointNode .getFields ())
                  this .getField (field .getName ()) .assign (field);
            }

            // Respect NavigationInfo.

            const
               navigationInfoNode = layerNode .getNavigationInfo (),
               transitionTime     = navigationInfoNode ._transitionTime .getValue ();

            let transitionType = navigationInfoNode .getTransitionType ();

            // VRML behavior

            if (this .getExecutionContext () .getSpecificationVersion () == "2.0")
            {
               if (toViewpointNode .getVRMLTransition ())
                  transitionType = "LINEAR";
               else
                  transitionType = "TELEPORT";
            }

            toViewpointNode .setVRMLTransition (false);

            // End VRML behavior

            if (transitionTime <= 0)
               transitionType = "TELEPORT";

            switch (transitionType)
            {
               case "TELEPORT":
               {
                  navigationInfoNode ._transitionComplete = true;
                  return;
               }
               case "ANIMATE":
               {
                  this .easeInEaseOut ._easeInEaseOut = new x_ite_Fields.MFVec2f (new x_ite_Fields.SFVec2f (0, 1), new x_ite_Fields.SFVec2f (1, 0));
                  break;
               }
               default:
               {
                  // LINEAR
                  this .easeInEaseOut ._easeInEaseOut = new x_ite_Fields.MFVec2f (new x_ite_Fields.SFVec2f (0, 0), new x_ite_Fields.SFVec2f (0, 0));
                  break;
               }
            }

            this .timeSensor ._cycleInterval = transitionTime;
            this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
            this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

            this .timeSensor ._isActive .addInterest ("set_active__", this, navigationInfoNode);

            toViewpointNode .getRelativeTransformation (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

            this .positionInterpolator         ._keyValue = new x_ite_Fields.MFVec3f    (relativePosition,         toViewpointNode ._positionOffset);
            this .orientationInterpolator      ._keyValue = new x_ite_Fields.MFRotation (relativeOrientation,      toViewpointNode ._orientationOffset);
            this .scaleInterpolator            ._keyValue = new x_ite_Fields.MFVec3f    (relativeScale,            toViewpointNode ._scaleOffset);
            this .scaleOrientationInterpolator ._keyValue = new x_ite_Fields.MFRotation (relativeScaleOrientation, toViewpointNode ._scaleOrientationOffset);

            this ._positionOffset         = relativePosition;
            this ._orientationOffset      = relativeOrientation;
            this ._scaleOffset            = relativeScale;
            this ._scaleOrientationOffset = relativeScaleOrientation;

            this .setInterpolators (fromViewpointNode, toViewpointNode);

            this ._transitionActive = true;
         }
         else
         {
            toViewpointNode .getRelativeTransformation (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

            toViewpointNode ._positionOffset         = relativePosition;
            toViewpointNode ._orientationOffset      = relativeOrientation;
            toViewpointNode ._scaleOffset            = relativeScale;
            toViewpointNode ._scaleOrientationOffset = relativeScaleOrientation;

            toViewpointNode .setInterpolators (fromViewpointNode, toViewpointNode);
         }
      };
   })(),
   transitionStop: function ()
   {
      this .timeSensor ._stopTime = this .getBrowser () .getCurrentTime ();
      this .timeSensor ._isActive .removeInterest ("set_active__", this);
   },
   resetUserOffsets: function ()
   {
      this ._positionOffset         = Numbers_Vector3.Zero;
      this ._orientationOffset      = Numbers_Rotation4.Identity;
      this ._scaleOffset            = Numbers_Vector3.One;
      this ._scaleOrientationOffset = Numbers_Rotation4.Identity;
      this ._centerOfRotationOffset = Numbers_Vector3.Zero;
      this ._fieldOfViewScale       = 1;
   },
   getRelativeTransformation: function (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation)
   {
      const differenceMatrix = this .modelMatrix .copy () .multRight (fromViewpointNode .getViewMatrix ()) .inverse ();

      differenceMatrix .get (relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

      relativePosition .subtract (this .getPosition ());
      relativeOrientation .assign (this .getOrientation () .copy () .inverse () .multRight (relativeOrientation));
   },
   lookAtPoint: function (layerNode, point, factor, straighten)
   {
      this .getCameraSpaceMatrix () .multVecMatrix (point);

      Numbers_Matrix4.inverse (this .getModelMatrix ()) .multVecMatrix (point);

      const minDistance = layerNode .getNavigationInfo () .getNearValue () * 2;

      this .lookAt (layerNode, point, minDistance, factor, straighten);
   },
   lookAtBBox: function (layerNode, bbox, factor, straighten)
   {
      bbox = bbox .copy () .multRight (Numbers_Matrix4.inverse (this .getModelMatrix ()));

      const minDistance = layerNode .getNavigationInfo () .getNearValue () * 2;

      this .lookAt (layerNode, bbox .center, minDistance, factor, straighten);
   },
   lookAt: function (layerNode, point, distance, factor, straighten)
   {
      const
         offset = point .copy () .add (this .getUserOrientation () .multVecRot (new Numbers_Vector3 (0, 0, distance))) .subtract (this .getPosition ());

      layerNode .getNavigationInfo () ._transitionStart = true;

      this .timeSensor ._cycleInterval = 0.2;
      this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
      this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

      this .timeSensor ._isActive .addInterest ("set_active__", this, layerNode .getNavigationInfo ());

      this .easeInEaseOut ._easeInEaseOut = new x_ite_Fields.MFVec2f (new x_ite_Fields.SFVec2f (0, 1), new x_ite_Fields.SFVec2f (1, 0));

      const
         translation = Numbers_Vector3.lerp (this ._positionOffset .getValue (), offset, factor),
         direction   = Numbers_Vector3.add (this .getPosition (), translation) .subtract (point);

      let rotation = Numbers_Rotation4.multRight (this ._orientationOffset .getValue (), new Numbers_Rotation4 (this .getUserOrientation () .multVecRot (new Numbers_Vector3 (0, 0, 1)), direction));

      if (straighten)
      {
         rotation = Numbers_Rotation4.inverse (this .getOrientation ()) .multRight (this .straightenHorizon (Numbers_Rotation4.multRight (this .getOrientation (), rotation)));
      }

      this .positionInterpolator         ._keyValue = new x_ite_Fields.MFVec3f (this ._positionOffset, translation);
      this .orientationInterpolator      ._keyValue = new x_ite_Fields.MFRotation (this ._orientationOffset, rotation);
      this .scaleInterpolator            ._keyValue = new x_ite_Fields.MFVec3f (this ._scaleOffset, this ._scaleOffset);
      this .scaleOrientationInterpolator ._keyValue = new x_ite_Fields.MFRotation (this ._scaleOrientationOffset, this ._scaleOrientationOffset);

      this .setInterpolators (this, this);

      this ._centerOfRotationOffset = Numbers_Vector3.subtract (point, this .getCenterOfRotation ());
      this ._set_bind               = true;
   },
   straighten: function (layerNode, horizon)
   {
      layerNode .getNavigationInfo () ._transitionStart = true;

      this .timeSensor ._cycleInterval = 0.4;
      this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
      this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

      this .timeSensor ._isActive .addInterest ("set_active__", this, layerNode .getNavigationInfo ());

      this .easeInEaseOut ._easeInEaseOut = new x_ite_Fields.MFVec2f (new x_ite_Fields.SFVec2f (0, 1), new x_ite_Fields.SFVec2f (1, 0));

      const rotation = Numbers_Rotation4.multRight (Numbers_Rotation4.inverse (this .getOrientation ()), this .straightenHorizon (this .getUserOrientation ()));

      this .positionInterpolator         ._keyValue = new x_ite_Fields.MFVec3f (this ._positionOffset, this ._positionOffset);
      this .orientationInterpolator      ._keyValue = new x_ite_Fields.MFRotation (this ._orientationOffset, rotation);
      this .scaleInterpolator            ._keyValue = new x_ite_Fields.MFVec3f (this ._scaleOffset, this ._scaleOffset);
      this .scaleOrientationInterpolator ._keyValue = new x_ite_Fields.MFRotation (this ._scaleOrientationOffset, this ._scaleOrientationOffset);

      this .setInterpolators (this, this);

      this ._set_bind = true;
   },
   straightenHorizon: (function ()
   {
      const
         localXAxis  = new Numbers_Vector3 (0, 0, 0),
         localZAxis  = new Numbers_Vector3 (0, 0, 0),
         rotation    = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (orientation, upVector = this .getUpVector ())
      {
         orientation .multVecRot (localXAxis .assign (Numbers_Vector3.xAxis) .negate ());
         orientation .multVecRot (localZAxis .assign (Numbers_Vector3.zAxis));

         const vector = localZAxis .cross (upVector);

         // If viewer looks along the up vector.
         if (Math .abs (localZAxis .dot (upVector)) >= 1)
            return orientation;

         if (Math .abs (vector .dot (localXAxis)) >= 1)
            return orientation;

         rotation .setFromToVec (localXAxis, vector);

         return orientation .multRight (rotation);
      };
   })(),
   set_active__: function (navigationInfoNode, active)
   {
      if (this ._isBound .getValue () && ! active .getValue () && this .timeSensor ._fraction_changed .getValue () === 1)
      {
         navigationInfoNode ._transitionComplete = true;
      }
   },
   set_bound__: function ()
   {
      if (this ._isBound .getValue ())
         this .getBrowser () .getNotification () ._string = this ._description;
      else
         this .timeSensor ._stopTime = this .getBrowser () .getCurrentTime ();
   },
   traverse: function (type, renderObject)
   {
      if (type !== Rendering_TraverseType.CAMERA)
         return;

      renderObject .getLayer () .getViewpoints () .push (this);

      this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
   },
   update: function ()
   {
      this .cameraSpaceMatrix .set (this .getUserPosition (),
                                    this .getUserOrientation (),
                                    this ._scaleOffset .getValue (),
                                    this ._scaleOrientationOffset .getValue ());

      this .cameraSpaceMatrix .multRight ((this .to || this) .modelMatrix);

      this .viewMatrix .assign (this .cameraSpaceMatrix) .inverse ();
   }
});

/* harmony default export */ const Navigation_X3DViewpointNode = (X3DViewpointNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/ScalarInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function ScalarInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ScalarInterpolator);
}

ScalarInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: ScalarInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "ScalarInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : 0);
   },
   interpolate: function (index0, index1, weight)
   {
      this ._value_changed = Math_Algorithm.lerp (this ._keyValue [index0], this ._keyValue [index1], weight);
   },
});

/* harmony default export */ const Interpolation_ScalarInterpolator = (ScalarInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/Viewpoint.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













function Viewpoint (executionContext)
{
   Navigation_X3DViewpointNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Viewpoint);

   this ._position         .setUnit ("length");
   this ._centerOfRotation .setUnit ("length");
   this ._fieldOfView      .setUnit ("angle");

   this .projectionMatrix        = new Numbers_Matrix4 ();
   this .fieldOfViewInterpolator = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
}

Viewpoint .prototype = Object .assign (Object .create (Navigation_X3DViewpointNode.prototype),
{
   constructor: Viewpoint,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",          new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",       new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "position",          new x_ite_Fields.SFVec3f (0, 0, 10)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "orientation",       new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "centerOfRotation",  new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fieldOfView",       new x_ite_Fields.SFFloat (0.7854)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "jump",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "retainUserOffsets", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",          new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "Viewpoint";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Navigation_X3DViewpointNode.prototype.initialize.call (this);

      this .fieldOfViewInterpolator ._key = new x_ite_Fields.MFFloat (0, 1);
      this .fieldOfViewInterpolator .setup ();

      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewInterpolator ._set_fraction);
      this .fieldOfViewInterpolator ._value_changed .addFieldInterest (this ._fieldOfViewScale);
   },
   setInterpolators: function (fromViewpointNode, toViewpointNode)
   {
      if (fromViewpointNode .getType () .includes (Base_X3DConstants.Viewpoint) || fromViewpointNode .getType () .includes (Base_X3DConstants.GeoViewpoint))
      {
         const scale = fromViewpointNode .getFieldOfView () / toViewpointNode .getFieldOfView ();

         this .fieldOfViewInterpolator ._keyValue = new x_ite_Fields.MFFloat (scale, toViewpointNode ._fieldOfViewScale .getValue ());

         this ._fieldOfViewScale = scale;
      }
      else
      {
         this .fieldOfViewInterpolator ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

         this ._fieldOfViewScale = toViewpointNode ._fieldOfViewScale .getValue ();
      }
   },
   getLogarithmicDepthBuffer: function ()
   {
      return false;
   },
   getFieldOfView: function ()
   {
      const fov = this ._fieldOfView .getValue () * this ._fieldOfViewScale .getValue ();

      return fov > 0 && fov < Math .PI ? fov : Math .PI / 4;
   },
   getScreenScale: function (point, viewport, screenScale)
   {
      // Returns the screen scale in meter/pixel for on pixel.

      const
         width  = viewport [2],
         height = viewport [3];

      let size = Math .abs (point .z) * Math .tan (this .getFieldOfView () / 2) * 2;

      if (width > height)
         size /= height;
      else
         size /= width;

      return screenScale .set (size, size, size);
   },
   getViewportSize: (function ()
   {
      const viewportSize = new Numbers_Vector2 (0, 0);

      return function (viewport, nearValue)
      {
         // Returns viewport size in meters.

         const
            width  = viewport [2],
            height = viewport [3],
            size   = nearValue * Math .tan (this .getFieldOfView () / 2) * 2,
            aspect = width / height;

         if (aspect > 1)
            return viewportSize .set (size * aspect, size);

         return viewportSize .set (size, size / aspect);
      };
   })(),
   getLookAtDistance: function (bbox)
   {
      return (bbox .size .magnitude () / 2) / Math .tan (this .getFieldOfView () / 2);
   },
   getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
   {
      return Camera.perspective (this .getFieldOfView (), nearValue, farValue, viewport [2], viewport [3], this .projectionMatrix);
   },
});

/* harmony default export */ const Navigation_Viewpoint = (Viewpoint);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/Group.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Group (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Group);
}

Group .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: Group,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",       new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Group";
   },
   getComponentName: function ()
   {
      return "Grouping";
   },
   getContainerField: function ()
   {
      return "children";
   },
});

/* harmony default export */ const Grouping_Group = (Group);

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering/Layer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function Layer (executionContext)
{
   Layering_X3DLayerNode.call (this,
                       executionContext,
                       new Navigation_Viewpoint (executionContext),
                       new Grouping_Group (executionContext));

   this .addType (Base_X3DConstants.Layer);
}

Layer .prototype = Object .assign (Object .create (Layering_X3DLayerNode.prototype),
{
   constructor: Layer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "isPickable",     new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "viewport",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Layer";
   },
   getComponentName: function ()
   {
      return "Layering";
   },
   getContainerField: function ()
   {
      return "layers";
   },
   initialize: function ()
   {
      Layering_X3DLayerNode.prototype.initialize.call (this);

      this ._addChildren    .addFieldInterest (this .getGroup () ._addChildren);
      this ._removeChildren .addFieldInterest (this .getGroup () ._removeChildren);
      this ._children       .addFieldInterest (this .getGroup () ._children);

      this .getGroup () ._children = this ._children;
      this .getGroup () .setPrivate (true);
      this .getGroup () .setup ();
   },
});

/* harmony default export */ const Layering_Layer = (Layer);

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering/LayerSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function LayerSet (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.LayerSet);

   this .layerNodes      = [ new Layering_Layer (executionContext) ];
   this .layerNode0      = this .layerNodes [0];
   this .activeLayerNode = null;
}

LayerSet .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: LayerSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "activeLayer", new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "order",       new x_ite_Fields.MFInt32 (0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "layers",      new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "LayerSet";
   },
   getComponentName: function ()
   {
      return "Layering";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);

      this .layerNode0 .setPrivate (true);
      this .layerNode0 .setup ();
      this .layerNode0 .isLayer0 (true);

      this ._activeLayer .addInterest ("set_activeLayer__", this);
      this ._order       .addInterest ("set_layers__", this);
      this ._layers      .addInterest ("set_layers__", this);

      this .set_layers__ ();
   },
   getActiveLayer: function ()
   {
      return this .activeLayerNode;
   },
   setLayer0: function (value)
   {
      this .layerNode0 = value;

      this .set_layers__ ();
   },
   getLayer0: function ()
   {
      return this .layerNode0;
   },
   getLayers: function ()
   {
      return this .layerNodes;
   },
   set_activeLayer__: function ()
   {
      if (this ._activeLayer .getValue () === 0)
      {
         if (this .activeLayerNode !== this .layerNode0)
            this .activeLayerNode = this .layerNode0;
      }
      else
      {
         const index = this ._activeLayer - 1;

         if (index >= 0 && index < this ._layers .length)
         {
            if (this .activeLayerNode !== this ._layers [index] .getValue ())
               this .activeLayerNode = X3DCast (Base_X3DConstants.X3DLayerNode, this ._layers [index]);
         }
         else
         {
            if (this .activeLayerNode !== null)
               this .activeLayerNode = null;
         }
      }
   },
   set_layers__: function ()
   {
      const layers = this ._layers .getValue ();

      this .layerNodes .length = 0;

      for (let index of this ._order)
      {
         if (index === 0)
         {
            this .layerNodes .push (this .layerNode0);
         }
         else
         {
            -- index;

            if (index >= 0 && index < layers .length)
            {
               const layerNode = X3DCast (Base_X3DConstants.X3DLayerNode, layers [index]);

               if (layerNode)
                  this .layerNodes .push (layerNode);
            }
         }
      }

      this .set_activeLayer__ ();
   },
   bindBindables: function (viewpointName)
   {
      const layers = this ._layers .getValue ();

      this .layerNode0 .bindBindables (viewpointName);

      for (let i = 0, length = layers .length; i < length; ++ i)
      {
         const layerNode = X3DCast (Base_X3DConstants.X3DLayerNode, layers [i]);

         if (layerNode)
            layerNode .bindBindables (viewpointName);
      }
   },
   traverse: function (type, renderObject)
   {
      const layerNodes = this .layerNodes;

      if (type === Rendering_TraverseType.POINTER)
      {
         for (let i = 0, length = layerNodes .length; i < length; ++ i)
         {
            this .getBrowser () .setLayerNumber (i);
            layerNodes [i] .traverse (type, renderObject);
         }
      }
      else
      {
         for (const layerNode of layerNodes)
         {
            layerNode .traverse (type, renderObject);
         }
      }
   },
});

/* harmony default export */ const Layering_LayerSet = (LayerSet);

;// CONCATENATED MODULE: ./src/x_ite/Execution/X3DWorld.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










Configuration_SupportedNodes.addAbstractType ("X3DWorld", X3DWorld);

function X3DWorld (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DWorld)

   this .addChildObjects ("activeLayer", new Fields_SFNode (this .layer0));

   this .defaultLayerSet = new Layering_LayerSet (executionContext);
   this .layerSet        = this .defaultLayerSet;
   this .layer0          = new Layering_Layer (executionContext);
}

X3DWorld .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: X3DWorld,
   getTypeName: function ()
   {
      return "X3DWorld";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      this .layerSet .setPrivate (true);
      this .layerSet .setup ();
      this .layerSet .setLayer0 (this .layer0);
      this .layerSet ._activeLayer .addInterest ("set_rootNodes__", this);

      this .getExecutionContext () .getRootNodes () .addInterest ("set_rootNodes__", this);

      this .set_rootNodes__ ();

      this .layer0 .setPrivate (true);
      this .layer0 .isLayer0 (true);
      this .layer0 .setup ();

      this .set_activeLayer__ ();
   },
   getCache: function ()
   {
      return true;
   },
   getLayerSet: function ()
   {
      return this .layerSet;
   },
   getActiveLayer: function ()
   {
      return this ._activeLayer .getValue ();
   },
   set_rootNodes__: function ()
   {
      const
         oldLayerSet = this .layerSet,
         rootNodes   = this .getExecutionContext () .getRootNodes ();

      this .layerSet          = this .defaultLayerSet;
      this .layer0 ._children = rootNodes;

      for (const rootNode of rootNodes)
      {
         const layerSet = X3DCast (Base_X3DConstants.LayerSet, rootNode);

         if (layerSet)
            this .layerSet = layerSet;
      }

      if (this .layerSet === oldLayerSet)
         return;

      this .layerSet .setLayer0 (this .layer0);

      oldLayerSet    ._activeLayer .removeInterest ("set_activeLayer__", this);
      this .layerSet ._activeLayer .addInterest ("set_activeLayer__", this);

      this .set_activeLayer__ ();
   },
   set_activeLayer__: function ()
   {
      this ._activeLayer = this .layerSet .getActiveLayer ();
   },
   bindBindables: function ()
   {
      // Bind first X3DBindableNodes found in each layer.

      const worldURL = this .getExecutionContext () .getWorldURL ();

      this .layerSet .bindBindables (decodeURIComponent (new URL (worldURL, worldURL) .hash .substr (1)));
   },
   traverse: function (type, renderObject)
   {
      this .layerSet .traverse (type, renderObject);
   },
});

for (const key of Reflect .ownKeys (X3DWorld .prototype))
   Object .defineProperty (X3DWorld .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_X3DWorld = (X3DWorld);

;// CONCATENATED MODULE: ./src/standard/Networking/BinaryTransport.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


/* harmony default export */ function BinaryTransport($)
{
   // Use this transport for "binary" data type
   $.ajaxTransport ("+binary", function (options, originalOptions, jqXHR)
   {
      // Check for conditions and support for blob / arraybuffer response type
      if (options .dataType && options .dataType == 'binary')
      {
         return {
            send: function (headers, callback)
            {
               // Setup all variables
               const xhr = options .xhr ();

               xhr .open (options .type, options .url, options .async, options .username, options .password);

               // Apply custom fields if provided
               if (options .xhrFields)
               {
                  for (const i in options .xhrFields)
                     xhr [i] = options .xhrFields [i];
               }

               // Override mime type if needed
               if (options .mimeType && xhr .overrideMimeType)
                  xhr .overrideMimeType (options .mimeType);

               // Setup custom headers
               for (const i in headers)
                  xhr .setRequestHeader (i, headers [i]);

               // Setup onload callback
               xhr .onload = function ()
               {
                  xhr .onload = xhr .onerror = null;

                  const data = { };

                  data [options .dataType] = xhr .response;

                  callback (xhr .status || 200, xhr .statusText, data, xhr .getAllResponseHeaders ());
               };

               // Setup onerror callback
               xhr .onerror = function ()
               {
                  xhr .onload = xhr .onerror = null;

                  callback (xhr .status || 404, xhr .statusText);
               };

               // Send data
               xhr .responseType = options .responseType || "blob";
               xhr .send (options .hasContent && options .data || null);
            },
            abort: function ()
            {
               const xhr = options .xhr ();

               xhr .onload = xhr .onerror = null;

               xhr .abort ();
            }
         };
      }
   });
};

;// CONCATENATED MODULE: ./src/x_ite/InputOutput/FileLoader.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









BinaryTransport ($);

const FileLoader_dom = Symbol .for ("X_ITE.dom");

const
   ECMAScript    = /^\s*(?:vrmlscript|javascript|ecmascript)\:([^]*)$/,
   dataURL       = /^data:(.*?)(?:;charset=(.*?))?(?:;(base64))?,([^]*)$/,
   contentTypeRx = /^(?:(.*?);(.*?)$)/;

const foreignExtensions = new RegExp ("\.(?:html|xhtml)$");

const foreign = {
   "text/html":             true,
   "application/xhtml+xml": true,
};

const defaultParameter = new x_ite_Fields.MFString ();

function FileLoader (node, external)
{
   Base_X3DObject.call (this);

   this .node             = node;
   this .browser          = node .getBrowser ();
   this .external         = external === undefined ? this .browser .isExternal () : external;
   this .executionContext = this .external ? node .getExecutionContext () : this .browser .currentScene;
   this .userAgent        = this .browser .getName () + "/" + this .browser .getVersion () + " (X3D Browser; +" + this .browser .getProviderUrl () + ")";
   this .target           = "";
   this .url              = [ ];
   this .URL              = new URL (this .getReferer (), this .getReferer ());
   this .fileReader       = new FileReader ();
   this .text             = true;
}

FileLoader .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: FileLoader,
   abort: function ()
   {
      this .callback      = Function .prototype;
      this .bindViewpoint = Function .prototype;
      this .foreign       = Function .prototype;
   },
   isPrivate: function ()
   {
      return true;
   },
   getWorldURL: function ()
   {
      return this .URL;
   },
   createX3DFromString: function (worldURL, string, success, error)
   {
      try
      {
         const scene = this .browser .createScene ();

         if (this .node instanceof Execution_X3DWorld)
            scene .loader = this;
         else
            scene .setExecutionContext (this .executionContext);

         scene .setWorldURL (decodeURI (new URL (worldURL, this .getReferer ()) .href));

         if (success)
            success = this .setScene .bind (this, scene, success, error);

         new Parser_GoldenGate (scene) .parseIntoScene (string, success, error);

         return scene;
      }
      catch (exception)
      {
         if (error)
            error (exception);
         else
            throw error;
      }
   },
   setScene: function (scene, success, error)
   {
      scene ._initLoadCount .addInterest ("set_initLoadCount__", this, scene, success, error);
      scene ._initLoadCount .addEvent ();
   },
   set_initLoadCount__: function (scene, success, error, field)
   {
      if (field .getValue ())
         return;

      scene ._initLoadCount .removeInterest ("set_initLoadCount__", this);

      delete scene .loader;

      try
      {
         success (scene);
      }
      catch (exception)
      {
         if (error)
            error (exception);
         else
            throw exception;
      }

      if (DEBUG)
      {
         if (this .URL .protocol !== "data:")
            console .info ("Done loading scene " + decodeURI (this .URL .href));
      }
   },
   createX3DFromURL: function (url, parameter, callback, bindViewpoint, foreign)
   {
      this .bindViewpoint = bindViewpoint;
      this .foreign       = foreign;
      this .target        = this .getTarget (parameter || defaultParameter);

      if (callback)
         return this .loadDocument (url, this .createX3DFromURLAsync .bind (this, callback));

      return this .createX3DFromURLSync (url);
   },
   createX3DFromURLAsync: function (callback, data)
   {
      if (data === null)
         callback (null, this .URL);
      else
         this .createX3DFromString (this .URL, data, callback, this .loadDocumentError .bind (this));
   },
   createX3DFromURLSync: function (urls)
   {
      if (urls .length === 0)
         throw new Error ("No URL given.");

      let
         scene   = null,
         success = false;

      for (const url of urls)
      {
         this .URL = new URL (url, this .getReferer ());

         $.ajax ({
            url: decodeURI (this .URL .href),
            dataType: "text",
            async: false,
            cache: this .browser .getBrowserOptions () .getCache () && this .node .getCache (),
            //timeout: 15000,
            global: false,
            context: this,
            success: function (data)
            {
               try
               {
                  scene   = this .createX3DFromString (this .URL, data);
                  success = true;
               }
               catch (exception)
               {
                  this .error (exception);
               }
            },
            error: function (jqXHR, textStatus, errorThrown)
            {
               //console .warn ("Couldn't load URL '" + this .URL .href + "': " + errorThrown + ".");
            },
         });

         if (success)
            return scene;
      }

      throw new Error ("Couldn't load any url of '" + Array .prototype .join .call (urls, ", ") + "'.");
   },
   loadScript: function (url, callback)
   {
      this .script = true;

      this .loadDocument (url, callback);
   },
   loadDocument: function (url, callback)
   {
      this .url       = url .copy ();
      this .callback  = callback;

      if (url .length === 0)
         return this .loadDocumentError (new Error ("No URL given."));

      this .loadDocumentAsync (this .url .shift ());
   },
   loadBinaryDocument: function (url, callback)
   {
      this .url       = url .copy ();
      this .callback  = callback;
      this .text      = false;

      if (url .length === 0)
         return this .loadDocumentError (new Error ("No URL given."));

      this .loadDocumentAsync (this .url .shift ());
   },
   getTarget: function (parameters)
   {
      for (const parameter of parameters)
      {
         const pair = parameter .split ("=");

         if (pair .length !== 2)
            continue;

         if (pair [0] === "target")
            return pair [1];
      }

      return "";
   },
   loadDocumentAsync: function (url)
   {
      try
      {
         if (url .length === 0)
         {
            this .loadDocumentError (new Error ("URL is empty."));
            return;
         }

         // Script

         if (this .script)
         {
            const result = ECMAScript .exec (url);

            if (result)
            {
               this .callback (result [1]);
               return;
            }
         }

         // Test for data URL here.

         {
            const result = dataURL .exec (url);

            if (result)
            {
               //const mimeType = result [1];

               // ??? If called from loadURL and mime type is text/html do a window.open or window.location=URL and return; ???

               let data = result [4];

               if (result [3] === "base64")
                  data = atob (data);
               else
                  data = unescape (data);

               this .callback (data);
               return;
            }
         }

         this .URL = new URL (url, this .getReferer ());

         if (this .bindViewpoint)
         {
            if (this .URL .href .substr (0, this .getReferer () .length) === this .getReferer ())
            {
               this .bindViewpoint (decodeURIComponent (this .URL .hash .substr (1)));
               return;
            }
         }

         if (this .foreign)
         {
            // Handle target

            if (this .target .length && this .target !== "_self")
               return this .foreign (this .URL .href, this .target);

            // Handle well known foreign content depending on extension or if path looks like directory.

            if (this .URL .href .match (foreignExtensions))
               return this .foreign (this .URL .href, this .target);
         }

         // Load URL async

         $.ajax ({
            url: decodeURI (this .URL .href),
            dataType: "binary",
            async: true,
            cache: this .browser .getBrowserOptions () .getCache () && this .node .getCache (),
            //timeout: 15000,
            global: false,
            context: this,
            success: function (blob, status, xhr)
            {
               if (this .foreign)
               {
                  //console .log (this .getContentType (xhr));

                  if (foreign [this .getContentType (xhr)])
                     return this .foreign (this .URL .href, this .target);
               }

               if (this .text)
               {
                  this .fileReader .onload = this .readAsArrayBuffer .bind (this, blob);

                  this .fileReader .readAsArrayBuffer (blob);
               }
               else
               {
                  this .fileReader .onload = this .readAsBinaryString .bind (this);

                  this .fileReader .readAsBinaryString (blob);
               }
            },
            error: function (xhr, textStatus, exception)
            {
               this .loadDocumentError (new Error (exception));
            },
         });
      }
      catch (exception)
      {
         this .loadDocumentError (exception);
         return;
      }
   },
   readAsArrayBuffer: function (blob)
   {
      try
      {
         this .callback (pako .ungzip (this .fileReader .result, { to: "string" }), this .URL);
      }
      catch (exception)
      {
         this .fileReader .onload = this .readAsText .bind (this, blob);

         this .fileReader .readAsText (blob);
      }
   },
   readAsText: function (blob)
   {
      try
      {
         this .callback (this .fileReader .result, this .URL);
      }
      catch (exception)
      {
         this .loadDocumentError (exception);
      }
   },
   readAsBinaryString: function ()
   {
      try
      {
         this .callback (this .fileReader .result, this .URL);
      }
      catch (exception)
      {
         this .loadDocumentError (exception);
      }
   },
   loadDocumentError: function (exception)
   {
      // Output exception.

      this .error (exception);

      // Try to load next URL.

      if (this .url .length)
         this .loadDocumentAsync (this .url .shift ());

      else
         this .callback (null);
   },
   error: function (exception)
   {
      if (this .URL .protocol === "data:")
         console .warn ("Couldn't load URL 'data':", exception .message);
      else
         console .warn ("Couldn't load URL '" + decodeURI (this .URL .href) + "':", exception .message);

      if (DEBUG)
         console .error (exception);
   },
   getReferer: function ()
   {
      if (this .node .getTypeName () === "X3DWorld")
      {
         if (this .external)
            return this .browser .getLocation ();
      }

      return this .executionContext .getWorldURL ();
   },
   getContentType: function (xhr)
   {
      const
         contentType = xhr .getResponseHeader ("Content-Type"),
         result      = contentTypeRx .exec (contentType);

      if (result)
         return result [1];

      return "";
   },
});

for (const key of Reflect .ownKeys (FileLoader .prototype))
   Object .defineProperty (FileLoader .prototype, key, { enumerable: false });

/* harmony default export */ const InputOutput_FileLoader = (FileLoader);

;// CONCATENATED MODULE: ./src/x_ite/Prototype/X3DExternProtoDeclaration.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












Configuration_SupportedNodes.addAbstractType ("X3DExternProtoDeclaration", X3DExternProtoDeclaration);

const
   _proto = Symbol (),
   _scene = Symbol ();

function X3DExternProtoDeclaration (executionContext, url)
{
   Prototype_X3DProtoDeclarationNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DExternProtoDeclaration)

   this .addChildObjects ("load",                 new x_ite_Fields.SFBool (true),
                          "url",                  url .copy (), // Must be of type MFString.
                          "autoRefresh",          new x_ite_Fields.SFTime (),
                          "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600));
}

X3DExternProtoDeclaration .prototype = Object .assign (Object .create (Prototype_X3DProtoDeclarationNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: X3DExternProtoDeclaration,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "X3DExternProtoDeclaration";
   },
   initialize: function ()
   {
      Prototype_X3DProtoDeclarationNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);
   },
   set_live__: function ()
   {
      Networking_X3DUrlObject.prototype.set_live__.call (this);

      if (this .checkLoadState () !== Base_X3DConstants.COMPLETE_STATE)
         return;

      this [_scene] .setLive (this .isLive () .getValue ());
   },
   canUserDefinedFields: function ()
   {
      return true;
   },
   setProtoDeclaration: function (proto)
   {
      this [_proto] = proto;

      if (proto)
      {
         for (const field of this .getUserDefinedFields ())
            this .removeUserDefinedField (field .getName ())

         for (const field of proto .getUserDefinedFields ())
            this .addUserDefinedField (field .getAccessType (), field .getName (), field);
      }

      this .updateInstances ();
   },
   getProtoDeclaration: function ()
   {
      return this [_proto];
   },
   loadNow: function ()
   {
      // 7.73 — ExternProtoDeclaration function

      this .getScene () .addInitLoadCount (this);

      new InputOutput_FileLoader (this) .createX3DFromURL (this ._url, null, this .setInternalSceneAsync .bind (this));
   },
   setInternalSceneAsync: function (value)
   {
      if (value)
         this .setInternalScene (value);

      else
         this .setError (new Error ("File could not be loaded."));

      this .getScene () .removeInitLoadCount (this);
   },
   setInternalScene: function (value)
   {
      this [_scene] = value;

      const
         protoName = decodeURIComponent (new URL (this [_scene] .getWorldURL ()) .hash .substr (1)),
         proto     = protoName ? this [_scene] .protos .get (protoName) : this [_scene] .protos [0];

      if (!proto)
         throw new Error ("PROTO not found");

      this [_scene] .setLive (this .isLive () .getValue ());
      this [_scene] .setPrivate (this .getScene () .isPrivate ());
      this [_scene] .setExecutionContext (this .getExecutionContext ());

      this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
      this .setProtoDeclaration (proto);
   },
   getInternalScene: function ()
   {
      ///  Returns the internal X3DScene of this extern proto, that is loaded from the url given.

      return this [_scene];
   },
   setError: function (error)
   {
      console .error ("Error loading extern prototype:", error);

      this [_scene] = this .getBrowser () .getPrivateScene ();

      this .setLoadState (Base_X3DConstants.FAILED_STATE);
      this .setProtoDeclaration (null);
   },
   toVRMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "EXTERNPROTO";
      stream .string += " ";
      stream .string += this .getName ();
      stream .string += " ";
      stream .string += "[";

      const userDefinedFields = this .getUserDefinedFields ();

      let
         fieldTypeLength   = 0,
         accessTypeLength  = 0;

      if (userDefinedFields .length === 0)
      {
         stream .string += " ";
      }
      else
      {
         for (const field of userDefinedFields)
         {
            fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
            accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
         }

         stream .string += "\n";

         generator .IncIndent ();

         for (const field of userDefinedFields)
         {
            this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
            stream .string += "\n";
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
      }

      stream .string += "]";
      stream .string += "\n";

      stream .string += generator .Indent ();

      this ._url .toVRMLStream (stream);
   },
   toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
      stream .string += " ";
      stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
      stream .string += " ";
      stream .string += field .getName ();
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "<ExternProtoDeclare";
      stream .string += " ";
      stream .string += "name='";
      stream .string += generator .XMLEncode (this .getName ());
      stream .string += "'";
      stream .string += " ";
      stream .string += "url='";

      this ._url .toXMLStream (stream);

      stream .string += "'";
      stream .string += ">\n";

      generator .IncIndent ();

      const userDefinedFields = this .getUserDefinedFields ();

      for (const field of userDefinedFields)
      {
         stream .string += generator .Indent ();
         stream .string += "<field";
         stream .string += " ";
         stream .string += "accessType='";
         stream .string += generator .AccessType (field .getAccessType ());
         stream .string += "'";
         stream .string += " ";
         stream .string += "type='";
         stream .string += field .getTypeName ();
         stream .string += "'";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (field .getName ());
         stream .string += "'";
         stream .string += "/>\n";
      }

      generator .DecIndent ();

      stream .string += generator .Indent ();
      stream .string += "</ExternProtoDeclare>";
   },
});

for (const key of Reflect .ownKeys (X3DExternProtoDeclaration .prototype))
   Object .defineProperty (X3DExternProtoDeclaration .prototype, key, { enumerable: false });

Object .defineProperty (X3DExternProtoDeclaration .prototype, "name",
{
   get: function () { return this .getName (); },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DExternProtoDeclaration .prototype, "fields",
{
   get: function () { return this .getFieldDefinitions (); },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DExternProtoDeclaration .prototype, "isExternProto",
{
   get: function () { return true; },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DExternProtoDeclaration .prototype, "urls",
{
   get: function () { return this ._url; },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DExternProtoDeclaration .prototype, "loadState",
{
   get: function () { return this .checkLoadState (); },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Prototype_X3DExternProtoDeclaration = (X3DExternProtoDeclaration);

;// CONCATENATED MODULE: ./src/x_ite/Routing/RouteArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function RouteArray ()
{
   return Base_X3DInfoArray.call (this);
}

RouteArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: RouteArray,
   getTypeName: function ()
   {
      return "RouteArray";
   },
});

for (const key of Reflect .ownKeys (RouteArray .prototype))
   Object .defineProperty (RouteArray .prototype, key, { enumerable: false });

/* harmony default export */ const Routing_RouteArray = (RouteArray);

;// CONCATENATED MODULE: ./src/x_ite/Routing/X3DRoute.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   X3DRoute_executionContext = Symbol (),
   _sourceNode       = Symbol (),
   _sourceField      = Symbol (),
   _destinationNode  = Symbol (),
   _destinationField = Symbol ();

function X3DRoute (executionContext, sourceNode, sourceField, destinationNode, destinationField)
{
   Base_X3DObject.call (this, executionContext);

   this [X3DRoute_executionContext] = executionContext;
   this [_sourceNode]       = sourceNode;
   this [_sourceField]      = sourceField;
   this [_destinationNode]  = destinationNode;
   this [_destinationField] = destinationField;

   // Must connect in every context, to make X3DBaseNode.hasRoutes work.

   sourceField .addFieldInterest (destinationField);

   sourceField      .addOutputRoute (this);
   destinationField .addInputRoute (this);
}

X3DRoute .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   getTypeName: function ()
   {
      return "X3DRoute";
   },
   getExecutionContext: function ()
   {
      return this [X3DRoute_executionContext];
   },
   getSourceNode: function ()
   {
      ///  SAI
      return this [_sourceNode];
   },
   getSourceField: function ()
   {
      ///  SAI
      return this [_sourceField];
   },
   getDestinationNode: function ()
   {
      ///  SAI
      return this [_destinationNode];
   },
   getDestinationField: function ()
   {
      ///  SAI
      return this [_destinationField];
   },
   disconnect: function ()
   {
      this [_sourceField] .removeFieldInterest (this [_destinationField]);

      this [_sourceField]      .removeOutputRoute (this);
      this [_destinationField] .removeInputRoute (this);
   },
   toVRMLStream: function (stream)
   {
      const
         generator           = InputOutput_Generator.Get (stream),
         sourceNodeName      = generator .LocalName (this [_sourceNode]),
         destinationNodeName = generator .LocalName (this [_destinationNode]);

      stream .string += generator .Indent ();
      stream .string += "ROUTE";
      stream .string += " ";
      stream .string += sourceNodeName;
      stream .string += ".";
      stream .string += this [_sourceField] .getName ();

      if (this [_sourceField] .getAccessType () === Base_X3DConstants.inputOutput)
         stream .string += "_changed";

      stream .string += " ";
      stream .string += "TO";
      stream .string += " ";
      stream .string += destinationNodeName;
      stream .string += ".";

      if (this [_destinationField] .getAccessType () === Base_X3DConstants.inputOutput)
         stream .string += "set_";

      stream .string += this [_destinationField] .getName ();
   },
   toXMLStream: function (stream)
   {
      const
         generator           = InputOutput_Generator.Get (stream),
         sourceNodeName      = generator .LocalName (this [_sourceNode]),
         destinationNodeName = generator .LocalName (this [_destinationNode]);

      stream .string += generator .Indent ();
      stream .string += "<ROUTE";
      stream .string += " ";
      stream .string += "fromNode='";
      stream .string += generator .XMLEncode (sourceNodeName);
      stream .string += "'";
      stream .string += " ";
      stream .string += "fromField='";
      stream .string += generator .XMLEncode (this [_sourceField] .getName ());

      if (this [_sourceField] .getAccessType () === Base_X3DConstants.inputOutput)
         stream .string += "_changed";

      stream .string += "'";
      stream .string += " ";
      stream .string += "toNode='";
      stream .string += generator .XMLEncode (destinationNodeName);
      stream .string += "'";
      stream .string += " ";
      stream .string += "toField='";

      if (this [_destinationField] .getAccessType () === Base_X3DConstants.inputOutput)
         stream .string += "set_";

      stream .string += generator .XMLEncode (this [_destinationField] .getName ());
      stream .string += "'";
      stream .string += "/>";
   },
   dispose: function ()
   {
      this .disconnect ();

      this [X3DRoute_executionContext] .deleteRoute (this);

      Base_X3DObject.prototype.dispose.call (this);
   }
});

for (const key of Reflect .ownKeys (X3DRoute .prototype))
   Object .defineProperty (X3DRoute .prototype, key, { enumerable: false });

Object .defineProperty (X3DRoute .prototype, "sourceNode",
{
   get: function ()
   {
      return Fields_SFNodeCache.get (this [_sourceNode]);
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DRoute .prototype, "sourceField",
{
   get: function ()
   {
      return this [_sourceField] .getName ();
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DRoute .prototype, "destinationNode",
{
   get: function ()
   {
      return Fields_SFNodeCache.get (this [_destinationNode]);
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DRoute .prototype, "destinationField",
{
   get: function ()
   {
      return this [_destinationField] .getName ();
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Routing_X3DRoute = (X3DRoute);

;// CONCATENATED MODULE: ./src/x_ite/Execution/X3DExecutionContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




















 const
    _namedNodes     = Symbol (),
    _importedNodes  = Symbol (),
    _protos         = Symbol (),
    _externprotos   = Symbol (),
    X3DExecutionContext_routes         = Symbol (),
    _outerNode      = Symbol ();

 Configuration_SupportedNodes.addAbstractType ("X3DExecutionContext", X3DExecutionContext);

 function X3DExecutionContext (executionContext)
 {
    Base_X3DBaseNode.call (this, executionContext);

    this .addType (Base_X3DConstants.X3DExecutionContext)

    this .addChildObjects ("rootNodes",          new x_ite_Fields.MFNode (),
                           "worldInfos",         new x_ite_Fields.MFNode (),
                           "sceneGraph_changed", new x_ite_Fields.SFTime ());

    this ._rootNodes .setAccessType (Base_X3DConstants.initializeOnly);
    this ._rootNodes .addCloneCount (1);

    this [_namedNodes]     = new Execution_NamedNodesArray ();
    this [_importedNodes]  = new Execution_ImportedNodesArray ();
    this [_protos]         = new Prototype_ProtoDeclarationArray ();
    this [_externprotos]   = new Prototype_ExternProtoDeclarationArray ();
    this [X3DExecutionContext_routes]         = new Routing_RouteArray ();

    this .addChildObjects ("namedNodes_changed",    new x_ite_Fields.SFTime (),
                           "importedNodes_changed", new x_ite_Fields.SFTime (),
                           "protos_changed",        new x_ite_Fields.SFTime (),
                           "externprotos_changed",  new x_ite_Fields.SFTime (),
                           "routes_changed",        new x_ite_Fields.SFTime ())

 }

 X3DExecutionContext .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
 {
    constructor: X3DExecutionContext,
    initialize: function ()
    {
       Base_X3DBaseNode.prototype.initialize.call (this);

       if (! this .isScene ())
          this ._sceneGraph_changed .addInterest ("set_sceneGraph", this)
    },
    set_sceneGraph: function ()
    {
       this .getExecutionContext () ._sceneGraph_changed = this .getBrowser () .getCurrentTime ();
    },
    isScene: function ()
    {
       return false;
    },
    getTypeName: function ()
    {
       return "X3DExecutionContext";
    },
    [_outerNode]: null,
    getOuterNode: function ()
    {
       // Can be either of type X3DProtoDeclaration or X3DPrototypeInstance, or null.
       return this [_outerNode];
    },
    setOuterNode: function (value)
    {
       this [_outerNode] = value;
    },
    getSpecificationVersion: function ()
    {
       return this .getExecutionContext () .getSpecificationVersion ();
    },
    getEncoding: function ()
    {
       return this .getExecutionContext () .getEncoding ();
    },
    getWorldURL: function ()
    {
       return this .getExecutionContext () .getWorldURL ();
    },
    getProfile: function ()
    {
       return this .getExecutionContext () .getProfile ();
    },
    getComponents: function ()
    {
       return this .getExecutionContext () .getComponents ();
    },
    fromUnit: function (category, value)
    {
       return this .getExecutionContext () .fromUnit (category, value);
    },
    toUnit: function (category, value)
    {
       return this .getExecutionContext () .toUnit (category, value);
    },
    getUnits: function ()
    {
       return this .getExecutionContext () .getUnits ();
    },
    createNode: function (typeName, setup = true)
    {
       typeName = String (typeName);

       if (setup === false)
       {
          const Type = this .getBrowser () .getSupportedNode (typeName);

          if (! Type)
             return null;

          return new Type (this);
       }
       else
       {
          const Type = this .getBrowser () .getSupportedNode (typeName);

          if (! Type)
             throw new Error ("Unknown node type '" + typeName + "'.");

          const baseNode = new Type (this);

          baseNode .setup ();

          return Fields_SFNodeCache.get (baseNode);
       }
    },
    createProto: function (name, setup = true)
    {
       name = String (name);

       let executionContext = this;

       for (;;)
       {
          const proto = executionContext .protos .get (name);

          if (proto)
             return proto .createInstance (this, setup);

          const externproto = executionContext .externprotos .get (name);

          if (externproto)
             return externproto .createInstance (this, setup);

          if (executionContext .isScene ())
             break;

          executionContext = executionContext .getExecutionContext ();
       }

       if (setup === false)
          return null;

       throw new Error ("Unknown proto or externproto type '" + name + "'.");
    },
    addNamedNode: function (name, node)
    {
       if (this [_namedNodes] .has (name))
          throw new Error ("Couldn't add named node: node named '" + name + "' is already in use.");

       this .updateNamedNode (name, node);
    },
    updateNamedNode: function (name, node)
    {
       name = String (name);
       node = X3DCast (Base_X3DConstants.X3DNode, node, false);

       if (! node)
          throw new Error ("Couldn't update named node: node must be of type X3DNode.");

       if (node .getExecutionContext () !== this)
          throw new Error ("Couldn't update named node: node does not belong to this execution context.");

       if (name .length === 0)
          throw new Error ("Couldn't update named node: node name is empty.");

       // Remove named node.

       this .removeNamedNode (node .getName ());
       this .removeNamedNode (name);

       // Update named node.

       node .setName (name);

       this [_namedNodes] .add (name, node);

       this ._namedNodes_changed = this .getBrowser () .getCurrentTime ();
    },
    removeNamedNode: function (name)
    {
       name = String (name);

       const node = this [_namedNodes] .get (name);

       if (! node)
          return;

       node .setName ("");

       this [_namedNodes] .remove (name);

       this ._namedNodes_changed = this .getBrowser () .getCurrentTime ();
    },
    getNamedNode: function (name)
    {
       name = String (name);

       const node = this [_namedNodes] .get (name);

       if (node)
          return Fields_SFNodeCache.get (node);

       throw new Error ("Named node '" + name + "' not found.");
    },
    getNamedNodes: function ()
    {
       return this [_namedNodes];
    },
    getUniqueName: function (name = "")
    {
       return getUniqueName .call (this, _namedNodes, name);
    },
    addImportedNode: function (inlineNode, exportedName, importedName)
    {
       if (importedName === undefined)
          importedName = exportedName;

       exportedName = String (exportedName);
       importedName = String (importedName);

       if (this [_importedNodes] .has (importedName))
          throw new Error ("Couldn't add imported node: imported name '" + importedName + "' already in use.");

       this .updateImportedNode (inlineNode, exportedName, importedName);
    },
    updateImportedNode: function (inlineNode, exportedName, importedName)
    {
       inlineNode   = X3DCast (Base_X3DConstants.Inline, inlineNode, false);
       exportedName = String (exportedName);
       importedName = importedName === undefined ? exportedName : String (importedName);

       if (! inlineNode)
          throw new Error ("Node must be of type Inline node.");

       if (inlineNode .getExecutionContext () !== this)
          throw new Error ("Couldn't update imported node: Inline node does not belong to this execution context.");

       if (exportedName .length === 0)
          throw new Error ("Couldn't update imported node: exported name is empty.");

       if (importedName .length === 0)
          throw new Error ("Couldn't update imported node: imported name is empty.");

       // Update imported node.

       this .removeImportedNode (importedName);

       const importedNode = new Execution_X3DImportedNode (this, inlineNode, exportedName, importedName);

       this [_importedNodes] .add (importedName, importedNode);

       importedNode .setup ();

       this ._importedNodes_changed = this .getBrowser () .getCurrentTime ();
    },
    removeImportedNode: function (importedName)
    {
       importedName = String (importedName);

       const importedNode = this [_importedNodes] .get (importedName);

       if (! importedNode)
          return;

       importedNode .dispose ();

       this [_importedNodes] .remove (importedName);

       this ._importedNodes_changed = this .getBrowser () .getCurrentTime ();
    },
    getImportedNode: function (importedName)
    {
       importedName = String (importedName);

       const importedNode = this [_importedNodes] .get (importedName);

       if (importedNode)
          return Fields_SFNodeCache.get (importedNode .getExportedNode ());

       throw new Error ("Imported node '" + importedName + "' not found.");
    },
    getImportedNodes: function ()
    {
       return this [_importedNodes];
    },
    getLocalNode: function (name)
    {
       name = String (name);

       try
       {
          return this .getNamedNode (name);
       }
       catch (error)
       {
          const importedNode = this [_importedNodes] .get (name);

          if (importedNode)
             return Fields_SFNodeCache.get (importedNode);

          throw new Error ("Unknown named or imported node '" + name + "'.");
       }
    },
    getLocalName: function (node)
    {
       node = X3DCast (Base_X3DConstants.X3DNode, node, false);

       if (! node)
          throw new Error ("Couldn't get local name: node must be of type X3DNode.");

       if (node .getExecutionContext () === this)
          return node .getName ();

       for (const importedNode of this [_importedNodes])
       {
          try
          {
             if (importedNode .getExportedNode () === node)
                return importedNode .getImportedName ();
          }
          catch (error)
          {
             //console .error (error);
          }
       }

       throw new Error ("Couldn't get local name: node is shared.");
    },
    setRootNodes: function () { },
    getRootNodes: function ()
    {
       return this ._rootNodes;
    },
    getProtoDeclaration: function (name)
    {
       name = String (name);

       const proto = this [_protos] .get (name);

       if (proto)
          return proto;

       throw new Error ("Proto declaration '" + name + "' not found.");
    },
    addProtoDeclaration (name, proto)
    {
       name = String (name);

       if (! (proto instanceof Prototype_X3DProtoDeclaration))
          throw new Error ("Couldn't add proto declaration: proto must be of type X3DProtoDeclaration.");

       if (this [_protos] .get (name))
          throw new Error ("Couldn't add proto declaration: proto '" + name + "' already in use.");

       name = String (name);

       if (name .length === 0)
          throw new Error ("Couldn't add proto declaration: proto name is empty.");

       this [_protos] .add (name, proto);
       proto .setName (name);

       this ._protos_changed = this .getBrowser () .getCurrentTime ();
    },
    updateProtoDeclaration (name, proto)
    {
       name = String (name);

       if (! (proto instanceof Prototype_X3DProtoDeclaration))
          throw new Error ("Couldn't add proto declaration: proto must be of type X3DProtoDeclaration.");

       name = String (name);

       if (name .length === 0)
          throw new Error ("Couldn't add proto declaration: proto name is empty.");

       this [_protos] .update (proto .getName (), name, proto);
       proto .setName (name);

       this ._protos_changed = this .getBrowser () .getCurrentTime ();
    },
    removeProtoDeclaration (name)
    {
       name = String (name);

       this [_protos] .remove (name);

       this ._protos_changed = this .getBrowser () .getCurrentTime ();
    },
    getProtoDeclarations: function ()
    {
       return this [_protos];
    },
    getUniqueProtoName: function (name = "")
    {
       return getUniqueName .call (this, _protos, name);
    },
    getExternProtoDeclaration: function (name)
    {
       name = String (name);

       const externproto = this [_externprotos] .get (name);

       if (externproto)
          return externproto;

       throw new Error ("Extern proto declaration '" + name + "' not found.");
    },
    addExternProtoDeclaration (name, externproto)
    {
       name = String (name);

       if (! (externproto instanceof Prototype_X3DExternProtoDeclaration))
          throw new Error ("Couldn't add extern proto declaration: extern proto must be of type X3DExternProtoDeclaration.");

       if (this [_externprotos] .get (name))
          throw new Error ("Couldn't add extern proto declaration: extern proto '" + name + "' already in use.");

       name = String (name);

       if (name .length === 0)
          throw new Error ("Couldn't add extern proto declaration: extern proto name is empty.");

       this [_externprotos] .add (name, externproto);
       externproto .setName (name);

       this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
    },
    updateExternProtoDeclaration (name, externproto)
    {
       name = String (name);

       if (! (externproto instanceof Prototype_X3DExternProtoDeclaration))
          throw new Error ("Couldn't add extern proto declaration: extern proto must be of type X3DExternProtoDeclaration.");

       name = String (name);

       if (name .length === 0)
          throw new Error ("Couldn't add extern proto declaration: extern proto name is empty.");

       this [_externprotos] .update (externproto .getName (), name, externproto);
       externproto .setName (name);

       this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
    },
    removeExternProtoDeclaration (name)
    {
       name = String (name);

       this [_externprotos] .remove (name);

       this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
    },
    getExternProtoDeclarations: function ()
    {
       return this [_externprotos];
    },
    getUniqueExternProtoName: function (name = "")
    {
       return getUniqueName .call (this, _externprotos, name);
    },
    addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
    {
       sourceNode       = X3DCast (Base_X3DConstants.X3DNode, sourceNode, false);
       sourceField      = String (sourceField);
       destinationNode  = X3DCast (Base_X3DConstants.X3DNode, destinationNode, false);
       destinationField = String (destinationField);

       if (! sourceNode)
          throw new Error ("Bad ROUTE specification: source node must be of type X3DNode.");

       if (! destinationNode)
          throw new Error ("Bad ROUTE specification: destination node must be of type X3DNode.");

       // Imported nodes handling.

       let
          importedSourceNode      = sourceNode      instanceof Execution_X3DImportedNode ? sourceNode      : null,
          importedDestinationNode = destinationNode instanceof Execution_X3DImportedNode ? destinationNode : null;

       try
       {
          // If sourceNode is shared node try to find the corresponding X3DImportedNode.
          if (sourceNode .getExecutionContext () !== this)
             importedSourceNode = this .getLocalNode (this .getLocalName (sourceNode)) .getValue ();
       }
       catch (error)
       {
          // Source node is shared but not imported.
       }

       try
       {
          // If destinationNode is shared node try to find the corresponding X3DImportedNode.
          if (destinationNode .getExecutionContext () !== this)
             importedDestinationNode = this .getLocalNode (this .getLocalName (destinationNode)) .getValue ();
       }
       catch (error)
       {
          // Destination node is shared but not imported.
       }

       if (importedSourceNode instanceof Execution_X3DImportedNode && importedDestinationNode instanceof Execution_X3DImportedNode)
       {
          importedSourceNode      .addRoute (importedSourceNode, sourceField, importedDestinationNode, destinationField);
          importedDestinationNode .addRoute (importedSourceNode, sourceField, importedDestinationNode, destinationField);
       }
       else if (importedSourceNode instanceof Execution_X3DImportedNode)
       {
          importedSourceNode .addRoute (importedSourceNode, sourceField, destinationNode, destinationField);
       }
       else if (importedDestinationNode instanceof Execution_X3DImportedNode)
       {
          importedDestinationNode .addRoute (sourceNode, sourceField, importedDestinationNode, destinationField);
       }

       // If either sourceNode or destinationNode is an X3DImportedNode return here without value.
       if (importedSourceNode === sourceNode || importedDestinationNode === destinationNode)
          return;

       // Create route and return.

       return this .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
    },
    addSimpleRoute: function (sourceNode, sourceField, destinationNode, destinationField)
    {
       // Source and dest node are here X3DBaseNode.

       try
       {
          // Private function.
          // Create route and return.

          sourceField      = sourceNode      .getField (sourceField),
          destinationField = destinationNode .getField (destinationField);

          if (! sourceField .isOutput ())
             throw new Error ("Field named '" + sourceField .getName () + "' in node named '" + sourceNode .getName () + "' of type " + sourceNode .getTypeName () + " is not an output field.");

          if (! destinationField .isInput ())
             throw new Error ("Field named '" + destinationField .getName () + "' in node named '" + destinationNode .getName () + "' of type " + destinationNode .getTypeName () + " is not an input field.");

          if (sourceField .getType () !== destinationField .getType ())
             throw new Error ("ROUTE types " + sourceField .getTypeName () + " and " + destinationField .getTypeName () + " do not match.");

          const id = sourceField .getId () + "." + destinationField .getId ();

          let route = this [X3DExecutionContext_routes] .get (id);

          if (route)
             return route;

          route = new Routing_X3DRoute (this, sourceNode, sourceField, destinationNode, destinationField);

          this [X3DExecutionContext_routes] .add (id, route);

          this ._routes_changed = this .getBrowser () .getCurrentTime ();

          return route;
       }
       catch (error)
       {
          throw new Error ("Bad ROUTE specification: " + error .message);
       }
    },
    deleteRoute: function (route)
    {
       // sourceNode, sourceField, destinationNode, destinationField
       if (arguments .length === 4)
       {
          route = this .getRoute .apply (this, arguments);

          if (! route)
             return false;
       }

       if (this .deleteSimpleRoute (route))
          this .deleteImportedRoute (route .sourceNode, route .destinationNode, route);
    },
    deleteSimpleRoute: function (route)
    {
       try
       {
          const
             sourceField      = route .getSourceField (),
             destinationField = route .getDestinationField (),
             id               = sourceField .getId () + "." + destinationField .getId ();

          this [X3DExecutionContext_routes] .remove (id);
          route .disconnect ();

          this ._routes_changed = this .getBrowser () .getCurrentTime ();

          return true;
       }
       catch (error)
       {
          console .error (error);
          return false;
       }
    },
    deleteImportedRoute (sourceNode, destinationNode, route)
    {
       // Imported nodes handling.

       let
          importedSourceNode      = null,
          importedDestinationNode = null;

       try
       {
          // If sourceNode is shared node try to find the corresponding X3DImportedNode.
          if (sourceNode .getValue () .getExecutionContext () !== this)
             importedSourceNode = this .getLocalNode (this .getLocalName (sourceNode)) .getValue ();
       }
       catch (error)
       {
          // Source node is shared but not imported.
       }

       try
       {
          // If destinationNode is shared node try to find the corresponding X3DImportedNode.
          if (destinationNode .getValue () .getExecutionContext () !== this)
             importedDestinationNode = this .getLocalNode (this .getLocalName (destinationNode)) .getValue ();
       }
       catch (error)
       {
          // Destination node is shared but not imported.
       }

       if (importedSourceNode instanceof Execution_X3DImportedNode && importedDestinationNode instanceof Execution_X3DImportedNode)
       {
          importedSourceNode      .deleteRoute (route);
          importedDestinationNode .deleteRoute (route);
       }
       else if (importedSourceNode instanceof Execution_X3DImportedNode)
       {
          importedSourceNode .deleteRoute (route);
       }
       else if (importedDestinationNode instanceof Execution_X3DImportedNode)
       {
          importedDestinationNode .deleteRoute (route);
       }
    },
    getRoute: function (sourceNode, sourceField, destinationNode, destinationField)
    {
       sourceNode       = X3DCast (Base_X3DConstants.X3DNode, sourceNode, false);
       sourceField      = String (sourceField)
       destinationNode  = X3DCast (Base_X3DConstants.X3DNode, destinationNode, false);
       destinationField = String (destinationField)

       if (! sourceNode)
          throw new Error ("Bad ROUTE specification: sourceNode must be of type X3DNode.");

       if (! destinationNode)
          throw new Error ("Bad ROUTE specification: destinationNode must be of type X3DNode.");

       sourceField      = sourceNode      .getField (sourceField);
       destinationField = destinationNode .getField (destinationField);

       const id = sourceField .getId () + "." + destinationField .getId ();

       return this [X3DExecutionContext_routes] .get (id);
    },
    getRoutes: function ()
    {
       return this [X3DExecutionContext_routes];
    },
    getWorldInfos: function ()
    {
       return this ._worldInfos;
    },
    addWorldInfo: function (worldInfoNode)
    {
       this ._worldInfos .push (worldInfoNode);
    },
    removeWorldInfo: function (worldInfoNode)
    {
       for (let i = this ._worldInfos .length - 1; i >= 0; -- i)
       {
          if (this ._worldInfos [i] .getValue () === worldInfoNode)
             this ._worldInfos .splice (i, 1);
       }
    },
    toVRMLStream: function (stream)
    {
       const generator = InputOutput_Generator.Get (stream);

       generator .PushExecutionContext (this);
       generator .EnterScope ();
       generator .ImportedNodes (this .getImportedNodes ());

       // Output extern protos

       this .getExternProtoDeclarations () .toVRMLStream (stream);

       // Output protos

       this .getProtoDeclarations () .toVRMLStream (stream);

       // Output root nodes

       const rootNodes = this .getRootNodes ();

       for (let i = 0, length = rootNodes .length; i < length; ++ i)
       {
          const rootNode = rootNodes [i];

          stream .string += generator .Indent ();

          if (rootNode)
             rootNode .toVRMLStream (stream);
          else
             stream .string += "NULL";

          stream .string += "\n";

          if (i !== length - 1)
             stream .string += "\n";
       }

       // Output imported nodes

       const importedNodes = this .getImportedNodes ();

       if (importedNodes .size)
       {
          stream .string += "\n";

          importedNodes .forEach (function (importedNode)
          {
             try
             {
                importedNode .toVRMLStream (stream);

                stream .string += "\n";
             }
             catch (error)
             { }
          });
       }

       // Output routes

       const routes = this .getRoutes ();

       if (routes .length)
       {
          stream .string += "\n";

          routes .toVRMLStream (stream);
       }

       generator .LeaveScope ();
       generator .PopExecutionContext ();
    },
    toXMLStream: function (stream)
    {
       const generator = InputOutput_Generator.Get (stream);

       generator .PushExecutionContext (this);
       generator .EnterScope ();
       generator .ImportedNodes (this .getImportedNodes ());

       // Output extern protos

       this .getExternProtoDeclarations () .toXMLStream (stream);

       // Output protos

       this .getProtoDeclarations () .toXMLStream (stream);

       // Output root nodes

       const rootNodes = this .getRootNodes ();

       if (rootNodes .length)
       {
          rootNodes .toXMLStream (stream);

          stream .string += "\n";
       }

       // Output imported nodes

       const importedNodes = this .getImportedNodes ();

       importedNodes .forEach (function (importedNode)
       {
          try
          {
             importedNode .toXMLStream (stream);

             stream .string += "\n";
          }
          catch (error)
          { }
       });

       // Output routes

       this .getRoutes () .toXMLStream (stream);

       generator .LeaveScope ();
       generator .PopExecutionContext ();
    },
    dispose: function ()
    {
       this ._rootNodes .dispose ();

       for (const route of this [X3DExecutionContext_routes])
          this .deleteRoute (route);

       Base_X3DBaseNode.prototype.dispose.call (this);
    },
 });

 const getUniqueName = (function ()
 {
    const _TrailingNumbers = /_\d+$/;

    return function (array, name = "")
    {
       name = String (name) .replace (_TrailingNumbers, "");

       let
          newName = name,
          i       = 64;

       for (; i;)
       {
          if (! (this [array] .has (newName) || newName .length === 0))
             break;

          const
             min = i,
             max = i <<= 1;

          newName  = name;
          newName += '_';
          newName += Math .round (Math_Algorithm.random (min, max));
       }

       return newName;
    };
 })();

 for (const key of Reflect .ownKeys (X3DExecutionContext .prototype))
    Object .defineProperty (X3DExecutionContext .prototype, key, { enumerable: false });

 Object .defineProperty (X3DExecutionContext .prototype, "specificationVersion",
 {
    get: function () { return this .getSpecificationVersion (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "encoding",
 {
    get: function () { return this .getEncoding (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "profile",
 {
    get: function () { return this .getProfile (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "components",
 {
    get: function () { return this .getComponents (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "worldURL",
 {
    get: function () { return this .getWorldURL (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "units",
 {
    get: function () { return this .getUnits (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "rootNodes",
 {
    get: function () { return this .getRootNodes (); },
    set: function (value) { this .setRootNodes (value); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "protos",
 {
    get: function () { return this .getProtoDeclarations (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "externprotos",
 {
    get: function () { return this .getExternProtoDeclarations (); },
    enumerable: true,
    configurable: false
 });

 Object .defineProperty (X3DExecutionContext .prototype, "routes",
 {
    get: function () { return this .getRoutes (); },
    enumerable: true,
    configurable: false
 });

 /* harmony default export */ const Execution_X3DExecutionContext = (X3DExecutionContext);

;// CONCATENATED MODULE: ./src/x_ite/Configuration/ComponentInfo.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function ComponentInfo (name, level, title, providerUrl)
{
   this .name        = name;
   this .level       = level;
   this .title       = title;
   this .providerUrl = providerUrl;
}

ComponentInfo .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: ComponentInfo,
   getTypeName: function ()
   {
      return "ComponentInfo";
   },
   toVRMLStream: function (stream)
   {
      stream .string += "COMPONENT";
      stream .string += " ";
      stream .string += this .name;
      stream .string += " ";
      stream .string += ":";
      stream .string += " ";
      stream .string += this .level;
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "<component";
      stream .string += " ";
      stream .string += "name='";
      stream .string += this .name;
      stream .string += "'";
      stream .string += " ";
      stream .string += "level='";
      stream .string += this .level;
      stream .string += "'";
      stream .string += "/>";
   },
});

for (const key of Reflect .ownKeys (ComponentInfo .prototype))
   Object .defineProperty (ComponentInfo .prototype, key, { enumerable: false });

/* harmony default export */ const Configuration_ComponentInfo = (ComponentInfo);

;// CONCATENATED MODULE: ./src/x_ite/Configuration/ComponentInfoArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function ComponentInfoArray (values)
{
   return Base_X3DInfoArray.call (this, values);
}

ComponentInfoArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: ComponentInfoArray,
   getTypeName: function ()
   {
      return "ComponentInfoArray";
   },
   addComponent: function (value)
   {
      this .add (value .name, new Configuration_ComponentInfo (value .name, value .level, value .title, value .providerUrl));
   },
});

for (const key of Reflect .ownKeys (ComponentInfoArray .prototype))
   Object .defineProperty (ComponentInfoArray .prototype, key, { enumerable: false });

/* harmony default export */ const Configuration_ComponentInfoArray = (ComponentInfoArray);

;// CONCATENATED MODULE: ./src/x_ite/Configuration/UnitInfo.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function UnitInfo (category, name, conversionFactor)
{
   Object .defineProperty (this, "category", {
       value: category,
       writable: false,
   });

   this .name             = name;
   this .conversionFactor = conversionFactor;
}

UnitInfo .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: UnitInfo,
   getTypeName: function ()
   {
      return "UnitInfo";
   },
   toVRMLStream: function (stream)
   {
      stream .string += "UNIT";
      stream .string += " ";
      stream .string += this .category;
      stream .string += " ";
      stream .string += this .name;
      stream .string += " ";
      stream .string += this .conversionFactor;
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      stream .string += generator .Indent ();
      stream .string += "<unit";
      stream .string += " ";
      stream .string += "category='";
      stream .string += this .category;
      stream .string += "'";
      stream .string += " ";
      stream .string += "name='";
      stream .string += generator .XMLEncode (this .name);
      stream .string += "'";
      stream .string += " ";
      stream .string += "conversionFactor='";
      stream .string += this .conversionFactor;
      stream .string += "'";
      stream .string += "/>";
   },
});

for (const key of Reflect .ownKeys (UnitInfo .prototype))
   Object .defineProperty (UnitInfo .prototype, key, { enumerable: false });

Object .defineProperty (UnitInfo .prototype, "conversion_factor",
{
   get: function () { return this .conversionFactor; },
   enumerable: false,
   configurable: false
});

/* harmony default export */ const Configuration_UnitInfo = (UnitInfo);

;// CONCATENATED MODULE: ./src/x_ite/Configuration/UnitInfoArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function UnitInfoArray (values)
{
   return Base_X3DInfoArray.call (this, values);
}

UnitInfoArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: UnitInfoArray,
   getTypeName: function ()
   {
      return "UnitInfoArray";
   },
});

for (const key of Reflect .ownKeys (UnitInfoArray .prototype))
   Object .defineProperty (UnitInfoArray .prototype, key, { enumerable: false });

/* harmony default export */ const Configuration_UnitInfoArray = (UnitInfoArray);

;// CONCATENATED MODULE: ./src/x_ite/Execution/X3DExportedNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const
   X3DExportedNode_exportedName = Symbol (),
   _localNode    = Symbol ();

function X3DExportedNode (exportedName, localNode)
{
   Base_X3DObject.call (this);

   this [X3DExportedNode_exportedName] = exportedName;
   this [_localNode]    = localNode;
}

X3DExportedNode .prototype = Object .assign (Object .create (Base_X3DObject.prototype),
{
   constructor: X3DExportedNode,
   getExportedName: function ()
   {
      return this [X3DExportedNode_exportedName];
   },
   getLocalNode: function ()
   {
      return this [_localNode];
   },
   toVRMLStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         localName = generator .LocalName (this [_localNode]);

      stream .string += generator .Indent ();
      stream .string += "EXPORT";
      stream .string += " ";
      stream .string += localName;

      if (this [X3DExportedNode_exportedName] !== localName)
      {
         stream .string += " ";
         stream .string += "AS";
         stream .string += " ";
         stream .string += this [X3DExportedNode_exportedName];
      }
   },
   toXMLStream: function (stream)
   {
      const
         generator = InputOutput_Generator.Get (stream),
         localName = generator .LocalName (this [_localNode]);

      stream .string += generator .Indent ();
      stream .string += "<EXPORT";
      stream .string += " ";
      stream .string += "localDEF='";
      stream .string += generator .XMLEncode (localName);
      stream .string += "'";

      if (this [X3DExportedNode_exportedName] !== localName)
      {
         stream .string += " ";
         stream .string += "AS='";
         stream .string += generator .XMLEncode (this [X3DExportedNode_exportedName]);
         stream .string += "'";
      }

      stream .string += "/>";
   },
});

for (const key of Reflect .ownKeys (X3DExportedNode .prototype))
   Object .defineProperty (X3DExportedNode .prototype, key, { enumerable: false });

Object .defineProperty (X3DExportedNode .prototype, "exportedName",
{
   get: function ()
   {
      return Fields_SFNodeCache.get (this [X3DExportedNode_exportedName]);
   },
   enumerable: true,
   configurable: false
});

Object .defineProperty (X3DExportedNode .prototype, "localNode",
{
   get: function ()
   {
      return Fields_SFNodeCache.get (this [_localNode]);
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Execution_X3DExportedNode = (X3DExportedNode);

;// CONCATENATED MODULE: ./src/x_ite/Execution/ExportedNodesArray.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function ExportedNodesArray (array)
{
   return Base_X3DInfoArray.call (this, array);
}

ExportedNodesArray .prototype = Object .assign (Object .create (Base_X3DInfoArray.prototype),
{
   constructor: ExportedNodesArray,
   getTypeName: function ()
   {
      return "ExportedNodesArray";
   },
});

for (const key of Reflect .ownKeys (ExportedNodesArray .prototype))
   Object .defineProperty (ExportedNodesArray .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_ExportedNodesArray = (ExportedNodesArray);

;// CONCATENATED MODULE: ./src/x_ite/Execution/X3DScene.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















const
   _specificationVersion = Symbol (),
   _encoding             = Symbol (),
   _profile              = Symbol (),
   _components           = Symbol (),
   _worldURL             = Symbol (),
   _units                = Symbol (),
   _metadata             = Symbol (),
   _exportedNodes        = Symbol ();

Configuration_SupportedNodes.addAbstractType ("X3DScene", X3DScene);

function X3DScene (executionContext)
{
   Execution_X3DExecutionContext.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DScene)

   this [_specificationVersion] = "3.3";
   this [_encoding]             = "SCRIPTED";
   this [_profile]              = null;
   this [_components]           = new Configuration_ComponentInfoArray ([ ]);
   this [_worldURL]             = location .toString ();
   this [_units]                = new Configuration_UnitInfoArray ();

   this [_units] .add ("angle",  new Configuration_UnitInfo ("angle",  "radian",   1));
   this [_units] .add ("force",  new Configuration_UnitInfo ("force",  "newton",   1));
   this [_units] .add ("length", new Configuration_UnitInfo ("length", "metre",    1));
   this [_units] .add ("mass",   new Configuration_UnitInfo ("mass",   "kilogram", 1));

   this [_metadata]      = new Map ();
   this [_exportedNodes] = new Execution_ExportedNodesArray ();

   this .addChildObjects ("profile_changed",       new x_ite_Fields.SFTime (),
                          "components_changed",    new x_ite_Fields.SFTime (),
                          "units_changed",         new x_ite_Fields.SFTime (),
                          "metadata_changed",      new x_ite_Fields.SFTime (),
                          "exportedNodes_changed", new x_ite_Fields.SFTime ())

   this .getRootNodes () .setAccessType (Base_X3DConstants.inputOutput);

   this .setLive (false);
}

X3DScene .prototype = Object .assign (Object .create (Execution_X3DExecutionContext.prototype),
{
   constructor: X3DScene,
   getTypeName: function ()
   {
      return "X3DScene";
   },
   isMainScene: function ()
   {
      return this === this .getExecutionContext ();
   },
   isScene: function ()
   {
      return true;
   },
   setSpecificationVersion: function (specificationVersion)
   {
      this [_specificationVersion] = String (specificationVersion);
   },
   getSpecificationVersion: function ()
   {
      return this [_specificationVersion];
   },
   setEncoding: function (encoding)
   {
      this [_encoding] = String (encoding);
   },
   getEncoding: function ()
   {
      return this [_encoding];
   },
   setWorldURL: function (url)
   {
      this [_worldURL] = String (url);
   },
   getWorldURL: function ()
   {
      return this [_worldURL];
   },
   setProfile: function (profile)
   {
      this [_profile] = profile;

      this ._profile_changed = this .getBrowser () .getCurrentTime ();
   },
   getProfile: function ()
   {
      return this [_profile];
   },
   addComponent: function (component)
   {
      this [_components] .add (component .name, component);

      this ._components_changed = this .getBrowser () .getCurrentTime ();
   },
   removeComponent: function (component)
   {
      this [_components] .remove (component .name);

      this ._components_changed = this .getBrowser () .getCurrentTime ();
   },
   getComponents: function ()
   {
      return this [_components];
   },
   updateUnit: function (category, name, conversionFactor)
   {
      // Private function.

      const unit = this [_units] .get (category);

      if (!unit)
         return;

      unit .name             = String (name);
      unit .conversionFactor = Number (conversionFactor);

      this ._units_changed = this .getBrowser () .getCurrentTime ();
   },
   getUnit: function (category)
   {
      return this [_units] .get (category);
   },
   getUnits: function ()
   {
      return this [_units];
   },
   fromUnit: function (category, value)
   {
      switch (category)
      {
         // Base units

         case "angle":
         case "force":
         case "length":
         case "mass":
            return value * this .getUnits () .get (category) .conversionFactor;

         // Derived units

         case "acceleration:":
            return value * this .getUnits () .get ("length") .conversionFactor;
         case "angularRate":
            return value * this .getUnits () .get ("angle") .conversionFactor;
         case "area":
            return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
         case "speed":
            return value * this .getUnits () .get ("length") .conversionFactor;
         case "volume":
            return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
      }

      return value;
   },
   toUnit: function (category, value)
   {
      switch (category)
      {
         // Base units

         case "angle":
         case "force":
         case "length":
         case "mass":
            return value / this .getUnits () .get (category) .conversionFactor;

         // Derived units

         case "acceleration:":
            return value / this .getUnits () .get ("length") .conversionFactor;
         case "angularRate":
            return value / this .getUnits () .get ("angle") .conversionFactor;
         case "area":
            return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
         case "speed":
            return value / this .getUnits () .get ("length") .conversionFactor;
         case "volume":
            return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
      }

      return value;
   },
   setMetaData: function (name, value)
   {
      name = String (name)

      if (!name .length)
         return;

      this [_metadata] .set (name, String (value));

      this ._metadata_changed = this .getBrowser () .getCurrentTime ();
   },
   removeMetaData: function (name)
   {
      name = String (name);

      this [_metadata] .delete (name);

      this ._metadata_changed = this .getBrowser () .getCurrentTime ();
   },
   getMetaData: function (name)
   {
      name = String (name);

      return this [_metadata] .get (name);
   },
   getMetaDatas: function ()
   {
      return this [_metadata];
   },
   addExportedNode: function (exportedName, node)
   {
      exportedName = String (exportedName);

      if (this [_exportedNodes] .has (exportedName))
         throw new Error ("Couldn't add exported node: exported name '" + exportedName + "' already in use.");

      this .updateExportedNode (exportedName, node);

      this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
   },
   updateExportedNode: function (exportedName, node)
   {
      exportedName = String (exportedName);
      node         = X3DCast (Base_X3DConstants.X3DNode, node, false);

      if (exportedName .length === 0)
         throw new Error ("Couldn't update exported node: node exported name is empty.");

      if (!node)
         throw new Error ("Couldn't update exported node: node must be of type X3DNode.");

      //if (node .getExecutionContext () !== this)
      //	throw new Error ("Couldn't update exported node: node does not belong to this execution context.");

      this .removeExportedNode (exportedName);

      const exportedNode = new Execution_X3DExportedNode (exportedName, node);

      this [_exportedNodes] .add (exportedName, exportedNode);

      this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
   },
   removeExportedNode: function (exportedName)
   {
      exportedName = String (exportedName);

      this [_exportedNodes] .remove (exportedName);

      this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
   },
   getExportedNode: function (exportedName)
   {
      exportedName = String (exportedName);

      const exportedNode = this [_exportedNodes] .get (exportedName);

      if (exportedNode)
         return Fields_SFNodeCache.get (exportedNode .getLocalNode ());

      throw new Error ("Exported node '" + exportedName + "' not found.");
   },
   getExportedNodes: function ()
   {
      return this [_exportedNodes];
   },
   addRootNode: function (node)
   {
      node = Fields_SFNodeCache.get (X3DCast (Base_X3DConstants.X3DNode, node, false));

      const rootNodes = this .getRootNodes ();

      for (const rootNode of rootNodes)
      {
         if (rootNode .equals (node))
            return;
      }

      rootNodes .push (node);
   },
   removeRootNode: function (node)
   {
      node = Fields_SFNodeCache.get (X3DCast (Base_X3DConstants.X3DNode, node, false));

      const
         rootNodes = this .getRootNodes (),
         length    = rootNodes .length;

      rootNodes .erase (rootNodes .remove (0, length, node), length);
   },
   setRootNodes: function (value)
   {
      if (!(value instanceof x_ite_Fields.MFNode))
         throw new Error ("Value must be of type MFNode.");

      this .getRootNodes () .assign (value);
   },
   toVRMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      let specificationVersion = this .getSpecificationVersion ();

      if (specificationVersion === "2.0")
         specificationVersion = "3.3";

      stream .string += "#X3D V";
      stream .string += specificationVersion;
      stream .string += " ";
      stream .string += "utf8";
      stream .string += " ";
      stream .string += this .getBrowser () .name;
      stream .string += " ";
      stream .string += "V";
      stream .string += this .getBrowser () .version;
      stream .string += "\n";
      stream .string += "\n";

      const profile = this .getProfile ();

      if (profile)
      {
         profile .toVRMLStream (stream);

         stream .string += "\n";
         stream .string += "\n";
      }

      const components = this .getComponents ();

      if (components .length)
      {
         components .toVRMLStream (stream);

         stream .string += "\n";
      }

      // Units
      {
         let empty = true;

         for (const unit of this .getUnits ())
         {
            if (unit .conversionFactor !== 1)
            {
               empty = false;

               unit .toVRMLStream (stream);

               stream .string += "\n";
            }
         }

         if (!empty)
            stream .string += "\n";
      }

      const metadata = this .getMetaDatas ();

      if (metadata .size)
      {
         metadata .forEach (function (value, key)
         {
            stream .string += "META";
            stream .string += " ";
            stream .string += new x_ite_Fields.SFString (key) .toString ();
            stream .string += " ";
            stream .string += new x_ite_Fields.SFString (value) .toString ();
            stream .string += "\n";
         });

         stream .string += "\n";
      }

      const exportedNodes = this .getExportedNodes ();

      generator .PushExecutionContext (this);
      generator .EnterScope ();
      generator .ExportedNodes (exportedNodes);

      Execution_X3DExecutionContext.prototype.toVRMLStream.call (this, stream);

      if (exportedNodes .size)
      {
         stream .string += "\n";

         exportedNodes .forEach (function (exportedNode)
         {
            try
            {
               exportedNode .toVRMLStream (stream);

               stream .string += "\n";
            }
            catch (error)
            {
               console .error (error);
            }
         });
      }

      generator .LeaveScope ();
      generator .PopExecutionContext ();
   },
   toXMLStream: function (stream)
   {
      const generator = InputOutput_Generator.Get (stream);

      let specificationVersion = this .getSpecificationVersion ();

      if (specificationVersion === "2.0")
         specificationVersion = "3.3";

      stream .string += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
      stream .string += "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D ";
      stream .string += specificationVersion;
      stream .string += "//EN\" \"http://www.web3d.org/specifications/x3d-";
      stream .string += specificationVersion;
      stream .string += ".dtd\">\n";

      stream .string += "<X3D";
      stream .string += " ";
      stream .string += "profile='";
      stream .string += this .getProfile () ? this .getProfile () .name : "Full";
      stream .string += "'";
      stream .string += " ";
      stream .string += "version='";
      stream .string += specificationVersion;
      stream .string += "'";
      stream .string += " ";
      stream .string += "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance'";
      stream .string += " ";
      stream .string += "xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-";
      stream .string += specificationVersion;
      stream .string += ".xsd'>\n";

      generator .IncIndent ();

      stream .string += generator .Indent ();
      stream .string += "<head>\n";

      generator .IncIndent ();

      // <head>

      this .getComponents () .toXMLStream (stream);

      for (const unit of this .getUnits ())
      {
         if (unit .conversionFactor !== 1)
         {
            unit .toXMLStream (stream);

            stream .string += "\n";
         }
      }

      this .getMetaDatas () .forEach (function (value, key)
      {
         stream .string += generator .Indent ();
         stream .string += "<meta";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (key);
         stream .string += "'";
         stream .string += " ";
         stream .string += "content='";
         stream .string += generator .XMLEncode (value);
         stream .string += "'";
         stream .string += "/>\n";
      });

      // </head>

      generator .DecIndent ();

      stream .string += generator .Indent ();
      stream .string += "</head>\n";
      stream .string += generator .Indent ();
      stream .string += "<Scene>\n";

      generator .IncIndent ();

      // <Scene>

      const exportedNodes = this .getExportedNodes ();

      generator .PushExecutionContext (this);
      generator .EnterScope ();
      generator .ExportedNodes (exportedNodes);

      Execution_X3DExecutionContext.prototype.toXMLStream.call (this, stream);

      for (const exportedNode of exportedNodes)
      {
         try
         {
            exportedNode .toXMLStream (stream);

            stream .string += "\n";
         }
         catch (error)
         {
            console .error (error);
         }
      }

      generator .LeaveScope ();
      generator .PopExecutionContext ();

      // </Scene>

      generator .DecIndent ();

      stream .string += generator .Indent ();
      stream .string += "</Scene>\n";

      generator .DecIndent ();

      stream .string += "</X3D>\n";
   },
});

for (const key of Reflect .ownKeys (X3DScene .prototype))
   Object .defineProperty (X3DScene .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_X3DScene = (X3DScene);

;// CONCATENATED MODULE: ./src/x_ite/Execution/Scene.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   Scene_browser        = Symbol .for ("X3DEventObject.browser"),
   _loadingObjects = Symbol ();

function Scene (browser)
{
   this [Scene_browser] = browser;

   Execution_X3DScene.call (this, this);

   this .addChildObjects ("initLoadCount", new x_ite_Fields.SFInt32 (),  // Pre load count, must be zero before the scene can be passed to the requester.
                          "loadCount",     new x_ite_Fields.SFInt32 ()); // Load count of all X3DUrlObjects.

   this [_loadingObjects] = new Set ();
}

Scene .prototype = Object .assign (Object .create (Execution_X3DScene.prototype),
{
   constructor: Scene,
   setExecutionContext: function (value)
   {
      if (! this .isMainScene ())
      {
         const scene = this .getScene ();

         for (const object of this [_loadingObjects])
            scene .removeLoadCount (object);
      }

      Execution_X3DScene.prototype.setExecutionContext.call (this, value);

      if (! this .isMainScene ())
      {
         const scene = this .getScene ();

         for (const object of this [_loadingObjects])
            scene .addLoadCount (object);
      }
   },
   addInitLoadCount: function (node)
   {
      this ._initLoadCount = this ._initLoadCount .getValue () + 1;
   },
   removeInitLoadCount: function (node)
   {
      this ._initLoadCount = this ._initLoadCount .getValue () - 1;
   },
   addLoadCount: function (node)
   {
      if (this [_loadingObjects] .has (node))
         return;

      this [_loadingObjects] .add (node);

      this ._loadCount = this [_loadingObjects] .size;

      const
         browser = this .getBrowser (),
         scene   = this .getScene ();

      if (this === browser .getExecutionContext () || this .loader === browser .loader)
         browser .addLoadCount (node);

      if (! this .isMainScene ())
         scene .addLoadCount (node);
   },
   removeLoadCount: function (node)
   {
      if (!this [_loadingObjects] .has (node))
         return;

      this [_loadingObjects] .delete (node);

      this ._loadCount = this [_loadingObjects] .size;

      const
         browser = this .getBrowser (),
         scene   = this .getScene ();

      if (this === browser .getExecutionContext () || this .loader === browser .loader)
         browser .removeLoadCount (node);

      if (! this .isMainScene ())
         scene .removeLoadCount (node);
   },
   getLoadingObjects: function ()
   {
      return this [_loadingObjects];
   },
});

for (const key of Reflect .ownKeys (Scene .prototype))
   Object .defineProperty (Scene .prototype, key, { enumerable: false });

/* harmony default export */ const Execution_Scene = (Scene);

;// CONCATENATED MODULE: ./src/standard/Utility/DataStorage.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const
   storages   = new WeakMap (),
   namespaces = new WeakMap (),
   defaults   = new WeakMap ();

const DataStorage_handler =
{
   get: function (target, key)
   {
      const property = target [key];

      if (property !== undefined)
         return property;

      const string = target .getStorage () [target .getNameSpace () + key];

      if (string === undefined || string === "undefined" || string === null)
         return target .getDefaultValue (key);

      const value = JSON .parse (string);

      return value;
   },
   set: function (target, key, value)
   {
      if (value === undefined)
         target .getStorage () .removeItem (target .getNameSpace () + key);

      else
         target .getStorage () [target .getNameSpace () + key] = JSON .stringify (value);

      return true;
   },
};

function DataStorage (storage, namespace)
{
   this .target  = this;

   storages   .set (this, storage);
   namespaces .set (this, namespace);
   defaults   .set (this, { });

   return new Proxy (this, DataStorage_handler);
}

DataStorage .prototype = {
   constructor: DataStorage,
   getStorage: function ()
   {
      return storages .get (this .target);
   },
   getNameSpace: function ()
   {
      return namespaces .get (this .target);
   },
   addNameSpace: function (namespace)
   {
      return new DataStorage (this .getStorage (), this .getNameSpace () + namespace);
   },
   addDefaultValues: function (object)
   {
      Object .assign (defaults .get (this .target), object);
   },
   getDefaultValue (key)
   {
      const value = defaults .get (this .target) [key];

      return value === undefined ? undefined : JSON .parse (JSON .stringify (value));
   },
   clear: function ()
   {
      const
         storage   = this .getStorage (),
         namespace = this .getNameSpace ();

      for (const key of Object .keys (storage))
      {
         if (key .startsWith (namespace))
            storage .removeItem (key)
      }
   },
}

/* harmony default export */ const Utility_DataStorage = (DataStorage);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Core/X3DCoreContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/
















const WEBGL_LATEST_VERSION = 2;

const
   _instanceId          = Symbol (),
   _element             = Symbol (),
   _shadow              = Symbol (),
   _surface             = Symbol (),
   _canvas              = Symbol (),
   _context             = Symbol (),
   _splashScreen        = Symbol (),
   _localStorage        = Symbol (),
   _mobile              = Symbol (),
   _browserTimings      = Symbol (),
   _browserOptions      = Symbol (),
   _browserProperties   = Symbol (),
   _renderingProperties = Symbol (),
   _notification        = Symbol (),
   _contextMenu         = Symbol (),
   _observer            = Symbol (),
   _privateScene        = Symbol (),
   _keydown             = Symbol (),
   _keyup               = Symbol (),
   _pixelPerPoint       = Symbol ();

let instanceId = 0;

function X3DCoreContext (element)
{
   // Get canvas & context.

   const
      shadow       = $(element .prop ("shadowRoot")),
      browser      = $("<div></div>") .addClass ("x_ite-private-browser") .attr ("tabindex", 0),
      surface      = $("<div></div>") .addClass ("x_ite-private-surface") .appendTo (browser),
      splashScreen = $("<div></div>") .hide () .addClass ("x_ite-private-splash-screen") .appendTo (browser),
      spinner      = $("<div></div>") .addClass ("x_ite-private-spinner") .appendTo (splashScreen),
      progress     = $("<div></div>") .addClass ("x_ite-private-progress") .appendTo (splashScreen);

   $("<div></div>") .addClass ("x_ite-private-x_ite") .html (this .getName () + "<span class='x_ite-private-x3d'>X3D</span>") .appendTo (progress);
   $("<div></div>") .addClass ("x_ite-private-progressbar")  .appendTo (progress) .append ($("<div></div>"));
   $("<div></div>") .addClass ("x_ite-private-spinner-text") .appendTo (progress);

   this [_instanceId]   = ++ instanceId;
   this [_element]      = element;
   this [_shadow]       = shadow .length ? shadow .append (browser .hide ()) : this [_element] .prepend (browser);
   this [_surface]      = surface;
   this [_canvas]       = $("<canvas></canvas>") .addClass ("x_ite-private-canvas") .prependTo (surface);
   this [_context]      = Core_Context.create (this [_canvas] [0], WEBGL_LATEST_VERSION, element .attr ("preserveDrawingBuffer") === "true");
   this [_splashScreen] = splashScreen;

   if (shadow .length)
      shadow .prop ("loaded") .then (function () { browser .show (); });

   this [_localStorage] = new Utility_DataStorage (localStorage, "X_ITE.X3DBrowser(" + this [_instanceId] + ").");
   this [_mobile]       = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i .test (navigator .userAgent);

   this [_browserTimings]      = new Core_BrowserTimings      (this .getPrivateScene ());
   this [_browserOptions]      = new Core_BrowserOptions      (this .getPrivateScene ());
   this [_browserProperties]   = new Core_BrowserProperties   (this .getPrivateScene ());
   this [_renderingProperties] = new Core_RenderingProperties (this .getPrivateScene ());
   this [_notification]        = new Core_Notification        (this .getPrivateScene ());
   this [_contextMenu]         = new Core_ContextMenu         (this .getPrivateScene ());

   const inches = $("<div></div>") .hide () .css ("height", "10in") .appendTo (this [_shadow]);
   this [_pixelPerPoint] = inches .height () / 720;
   inches .remove ();

   $(".x_ite-console") .empty ();

   this .addChildObjects ("controlKey",  new x_ite_Fields.SFBool (),
                          "shiftKey",    new x_ite_Fields.SFBool (),
                          "altKey",      new x_ite_Fields.SFBool (),
                          "altGrKey",    new x_ite_Fields.SFBool ());
}

X3DCoreContext .prototype =
{
   initialize: function ()
   {
      // Setup browser nodes.

      this [_browserTimings]      .setup ();
      this [_browserOptions]      .setup ();
      this [_browserProperties]   .setup ();
      this [_renderingProperties] .setup ();
      this [_notification]        .setup ();
      this [_contextMenu]         .setup ();

      // Observe Element's attributes.

      this [_observer] = new MutationObserver (this .processMutations .bind (this));

      this [_observer] .observe (this [_element] [0], { attributes: true, childList: false, characterData: false, subtree: false });

      // Define src and url property.

      Object .defineProperty (this .getElement () .get (0), "src",
      {
         get: function ()
         {
            return this .getExecutionContext () .getWorldURL ();
         }
         .bind (this),
         set: function (value)
         {
            this .loadURL (new x_ite_Fields.MFString (value), new x_ite_Fields.MFString ());
         }
         .bind (this),
         enumerable: true,
         configurable: false,
      });

      Object .defineProperty (this .getElement () .get (0), "url",
      {
         get: function ()
         {
            return new x_ite_Fields.MFString (this .getExecutionContext () .getWorldURL ());
         }
         .bind (this),
         set: function (value)
         {
            this .loadURL (value, new x_ite_Fields.MFString ());
         }
         .bind (this),
         enumerable: true,
         configurable: false,
      });

      // Configure browser event handlers.

      this .getElement () .on ("keydown.X3DCoreContext", this [_keydown] .bind (this));
      this .getElement () .on ("keyup.X3DCoreContext",   this [_keyup]   .bind (this));
   },
   getDebug: function ()
   {
      return this .getBrowserOptions () .getDebug ();
   },
   getInstanceId: function ()
   {
      return this [_instanceId];
   },
   isStrict: function ()
   {
      return false;
   },
   getElement: function ()
   {
      return this [_element];
   },
   getShadow: function ()
   {
      return this [_shadow];
   },
   getSurface: function ()
   {
      return this [_surface];
   },
   getSplashScreen: function ()
   {
      return this [_splashScreen];
   },
   getCanvas: function ()
   {
      return this [_canvas];
   },
   getContext: function ()
   {
      return this [_context];
   },
   getMobile: function ()
   {
      return this [_mobile];
   },
   getLocalStorage: function ()
   {
      return this [_localStorage];
   },
   getBrowserTimings: function ()
   {
      return this [_browserTimings];
   },
   getBrowserOptions: function ()
   {
      return this [_browserOptions];
   },
   getBrowserProperties: function ()
   {
      return this [_browserProperties];
   },
   getRenderingProperties: function ()
   {
      return this [_renderingProperties];
   },
   getNotification: function ()
   {
      return this [_notification];
   },
   getContextMenu: function ()
   {
      return this [_contextMenu];
   },
   getPrivateScene: function ()
   {
      if (this [_privateScene])
         return this [_privateScene];

      // Scene for default nodes.

      this [_privateScene] = new Execution_Scene (this);

      this [_privateScene] .setPrivate (true);
      this [_privateScene] .setLive (true);
      this [_privateScene] .setup ();

      return this [_privateScene];
   },
   parseUrlAttribute: function (urlCharacters)
   {
      const url = new x_ite_Fields.MFString ();

      url .fromString (urlCharacters, this .getExecutionContext ());

      return url;
   },
   processMutations: function (mutations)
   {
      for (const mutation of mutations)
         this .processMutation (mutation);
   },
   processMutation: function (mutation)
   {
      const element = mutation .target;

      switch (mutation .type)
      {
         case "attributes":
         {
            this .processAttribute (mutation, element);
            break;
         }
      }
   },
   processAttribute: function (mutation, element)
   {
      const attributeName = mutation .attributeName;

      switch (attributeName .toLowerCase ())
      {
         case "splashscreen":
         {
            this .getBrowserOptions () .setAttributeSplashScreen ();
            break;
         }
         case "src":
         {
            const urlCharacters = this .getElement () .attr ("src");

            this .loadURL (new x_ite_Fields.MFString (urlCharacters), new x_ite_Fields.MFString ());
            break;
         }
         case "url":
         {
            const urlCharacters = this .getElement () .attr ("url");

            this .loadURL (this .parseUrlAttribute (urlCharacters), new x_ite_Fields.MFString ());
            break;
         }
      }
   },
   callBrowserEventHandler: function (events)
   {
      const element = window .jQuery
         ? window .jQuery (this .getElement () .get (0))
         : this .getElement ();

      for (const event of events .split (" "))
         element .trigger (event);
   },
   getShiftKey: function ()
   {
      return this ._shiftKey .getValue ();
   },
   getControlKey: function ()
   {
      return this ._controlKey .getValue ();
   },
   getAltKey: function ()
   {
      return this ._altKey .getValue ();
   },
   getAltGrKey: function ()
   {
      return this ._altGrKey .getValue ();
   },
   [_keydown]: function (event)
   {
      //console .log (event .keyCode);

      switch (event .keyCode)
      {
         case 16: // Shift
         {
            this ._shiftKey = true;
            break;
         }
         case 17: // Ctrl
         {
            this ._controlKey = true;
            break;
         }
         case 18: // Alt
         {
            this ._altKey = true;
            break;
         }
         case 49: // 1
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Shading", "POINT");
                  this .getNotification () ._string = "Shading: Pointset";
               }
            }

            break;
         }
         case 50: // 2
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Shading", "WIREFRAME");
                  this .getNotification () ._string = "Shading: Wireframe";
               }
            }

            break;
         }
         case 51: // 3
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Shading", "FLAT");
                  this .getNotification () ._string = "Shading: Flat";
               }
            }

            break;
         }
         case 52: // 4
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Shading", "GOURAUD");
                  this .getNotification () ._string = "Shading: Gouraud";
               }
            }

            break;
         }
         case 53: // 5
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Shading", "PHONG");
                  this .getNotification () ._string = "Shading: Phong";
               }
            }

            break;
         }
         case 83: // s
         {
            if (this .getDebug ())
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();

                  if (this .isLive () .getValue ())
                     this .endUpdate ();
                  else
                     this .beginUpdate ();

                  this .getNotification () ._string = this .isLive () .getValue () ? "Begin Update" : "End Update";
               }
            }

            break;
         }
         case 225: // Alt Gr
         {
            this ._altGrKey = true;
            break;
         }
         case 171: // Plus // Firefox
         case 187: // Plus // Opera
         {
            if (this .getControlKey ())
            {
               event .preventDefault ();
               this .setBrowserOption ("Timings", !this .getBrowserOption ("Timings"));
            }

            break;
         }
         case 36: // Pos 1
         {
            event .preventDefault ();
            this .firstViewpoint ();
            break;
         }
         case 35: // End
         {
            event .preventDefault ();
            this .lastViewpoint ();
            break;
         }
         case 33: // Page Up
         {
            event .preventDefault ();
            this .previousViewpoint ();
            break;
         }
         case 34: // Page Down
         {
            event .preventDefault ();
            this .nextViewpoint ();
            break;
         }
         case 119: // F8
         {
            if (this .getShiftKey ())
            {
               event .preventDefault ();

               const viewpoint = this .getActiveViewpoint ();

               if (!viewpoint)
                  break;

               const vp = this .getPrivateScene () .createNode (viewpoint .getTypeName ());

               switch (viewpoint .getTypeName ())
               {
                  case "Viewpoint":
                  {
                     vp .position         = viewpoint .getUserPosition ();
                     vp .orientation      = viewpoint .getUserOrientation ();
                     vp .centerOfRotation = viewpoint .getUserCenterOfRotation ();
                     vp .fieldOfView      = viewpoint .getFieldOfView ();
                     break;
                  }
                  case "OrthoViewpoint":
                  {
                     vp .position         = viewpoint .getUserPosition ();
                     vp .orientation      = viewpoint .getUserOrientation ();
                     vp .centerOfRotation = viewpoint .getUserCenterOfRotation ();
                     vp .fieldOfView      = new x_ite_Fields.MFFloat (viewpoint .getMinimumX (), viewpoint .getMinimumY (), viewpoint .getMaximumX (), viewpoint .getMaximumY ());
                     break;
                  }
                  case "GeoViewpoint":
                  {
                     const
                        geoOrigin = viewpoint ._geoOrigin,
                        geoCoord  = new Numbers_Vector3 (0, 0, 0);

                     if (geoOrigin .getValue () && geoOrigin .getNodeTypeName () === "GeoOrigin")
                     {
                        const go = this .getPrivateScene () .createNode ("GeoOrigin");

                        vp .geoOrigin = go;
                        go .geoSystem = geoOrigin .geoSystem;
                        go .geoCoords = geoOrigin .geoCoords;
                        go .rotateYUp = geoOrigin .rotateYUp;
                     }

                     vp .geoSystem        = viewpoint ._geoSystem;
                     vp .position         = viewpoint .getGeoCoord (viewpoint .getUserPosition (), geoCoord);
                     vp .orientation      = viewpoint .getUserOrientation ();
                     vp .centerOfRotation = viewpoint .getGeoCoord (viewpoint .getUserCenterOfRotation (), geoCoord);
                     vp .fieldOfView      = viewpoint .getFieldOfView ();
                     break;
                  }
               }

               let text;

               switch (this .getExecutionContext () .getEncoding ())
               {
                  case "ASCII":
                  case "VRML": text = vp .toVRMLString (); break;
                  case "JSON": text = vp .toJSONString (); break;
                  default:     text = vp .toXMLString ();  break;
               }

               text += "\n";

               this .copyToClipboard (text);
               this .getNotification () ._string = locale_gettext ("Viewpoint is copied to clipboard.");

               console .log ("Copied Viewpoint to Clipboard.");
               console .debug (text);
            }

            break;
         }
      }
   },
   [_keyup]: function (event)
   {
      //console .log (event .which);

      switch (event .which)
      {
         case 16: // Shift
         {
            this ._shiftKey = false;
            break;
         }
         case 17: // Ctrl
         {
            this ._controlKey = false;
            break;
         }
         case 18: // Alt
         {
            this ._altKey = false;
            break;
         }
         case 225: // Alt Gr
         {
            this ._altGrKey = false;
            break;
         }
      }
   },
   copyToClipboard: function (text)
   {
      // The textarea must be visible to make copy work.
      const $temp = $("<textarea></textarea>");
      this .getShadow () .find (".x_ite-private-browser") .prepend ($temp);
      $temp .text (text) .select ();
      document .execCommand ("copy");
      $temp .remove ();
   },
   getPixelPerPoint: function ()
   {
      return this [_pixelPerPoint];
   },
};

/* harmony default export */ const Core_X3DCoreContext = (X3DCoreContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/TextureProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function TextureProperties (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TextureProperties);
}

TextureProperties .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: TextureProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "borderColor",         new x_ite_Fields.SFColorRGBA ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "borderWidth",         new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "anisotropicDegree",   new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "generateMipMaps",     new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "minificationFilter",  new x_ite_Fields.SFString ("DEFAULT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "magnificationFilter", new x_ite_Fields.SFString ("DEFAULT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "boundaryModeS",       new x_ite_Fields.SFString ("REPEAT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "boundaryModeT",       new x_ite_Fields.SFString ("REPEAT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "boundaryModeR",       new x_ite_Fields.SFString ("REPEAT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "textureCompression",  new x_ite_Fields.SFString ("DEFAULT")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texturePriority",     new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "TextureProperties";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "textureProperties";
   },
   getBorderWidth: function ()
   {
      // https://stackoverflow.com/questions/27760277/webgl-border-color-shader?lq=1
      return Math_Algorithm.clamp (this ._borderWidth .getValue (), 0, 1);
   },
   getBoundaryMode: (function ()
   {
      const boundaryModes = new Map ([
         ["CLAMP",             "CLAMP_TO_EDGE"], // "CLAMP"
         ["CLAMP_TO_EDGE",     "CLAMP_TO_EDGE"],
         ["CLAMP_TO_BOUNDARY", "CLAMP_TO_EDGE"], // "CLAMP_TO_BORDER"
         ["MIRRORED_REPEAT",   "MIRRORED_REPEAT"],
         ["REPEAT",            "REPEAT"],
      ]);

      return function (string)
      {
         const boundaryMode = boundaryModes .get (string);

         if (boundaryMode !== undefined)
            return boundaryMode;

         return "REPEAT";
      };
   })(),
   getBoundaryModeS: function ()
   {
      return this .getBoundaryMode (this ._boundaryModeS .getValue ());
   },
   getBoundaryModeT: function ()
   {
      return this .getBoundaryMode (this ._boundaryModeT .getValue ());
   },
   getBoundaryModeR: function ()
   {
      return this .getBoundaryMode (this ._boundaryModeR .getValue ());
   },
   getMinificationFilter: (function ()
   {
      const minificationFilters = new Map ([
         ["AVG_PIXEL_AVG_MIPMAP",         "LINEAR_MIPMAP_LINEAR"],
         ["AVG_PIXEL",                    "LINEAR"],
         ["AVG_PIXEL_NEAREST_MIPMAP",     "LINEAR_MIPMAP_NEAREST"],
         ["NEAREST_PIXEL_AVG_MIPMAP",     "NEAREST_MIPMAP_LINEAR"],
         ["NEAREST_PIXEL_NEAREST_MIPMAP", "NEAREST_MIPMAP_NEAREST"],
         ["NEAREST_PIXEL",                "NEAREST"],
         ["NICEST",                       "LINEAR_MIPMAP_LINEAR"],
         ["FASTEST",                      "NEAREST"],
      ]);

      return function ()
      {
         if (this ._generateMipMaps .getValue ())
         {
            const minificationFilter = minificationFilters .get (this ._minificationFilter .getValue ());

            if (minificationFilter !== undefined)
               return minificationFilter;

            return this .getBrowser () .getDefaultTextureProperties () .getMinificationFilter ();
         }

         return "LINEAR";
      };
   })(),
   getMagnificationFilter: (function ()
   {
      const magnificationFilters = new Map ([
         ["AVG_PIXEL",     "LINEAR"],
         ["NEAREST_PIXEL", "NEAREST"],
         ["NICEST",        "LINEAR"],
         ["FASTEST",       "NEAREST"],
      ]);

      return function ()
      {
         const magnificationFilter = magnificationFilters .get (this ._magnificationFilter .getValue ());

         if (magnificationFilter !== undefined)
            return magnificationFilter;

         // DEFAULT
         return this .getBrowser () .getDefaultTextureProperties () .getMagnificationFilter ();
      };
   })(),
   getTextureCompression: (function ()
   {
      const textureCompressions = new Map ([
         ["DEFAULT", "RGBA"],
         ["NICEST",  "RGBA"],
         ["FASTEST", "RGBA"],
         ["LOW",     "RGBA"],
         ["MEDIUM",  "RGBA"],
         ["HIGH",    "RGBA"],
      ]);

      return function ()
      {
         const
            browser            = this .getBrowser (),
            gl                 = browser .getContext (),
            compressedTexture  = gl .getExtension ("WEBGL_compressed_texture_etc"), // TODO: find suitable compression.
            textureCompression = compressedTexture ? compressedTexture [textureCompressions .get (this ._textureCompression .getValue ())] : undefined;

         if (textureCompression !== undefined)
            return textureCompression;

         // DEFAULT
         return gl .RGBA;
      };
   })(),
});

/* harmony default export */ const Texturing_TextureProperties = (TextureProperties);

;// CONCATENATED MODULE: ./src/x_ite/Browser/EnvironmentalEffects/X3DEnvironmentalEffectsContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const _backgroundTextureProperties = Symbol ();

function X3DEnvironmentalEffectsContext () { }

X3DEnvironmentalEffectsContext .prototype =
{
   initialize: function () { },
   getBackgroundTextureProperties: function ()
   {
      this [_backgroundTextureProperties] = new Texturing_TextureProperties (this .getPrivateScene ());

      this [_backgroundTextureProperties] ._boundaryModeS       = "CLAMP_TO_EDGE";
      this [_backgroundTextureProperties] ._boundaryModeT       = "CLAMP_TO_EDGE";
      this [_backgroundTextureProperties] ._boundaryModeR       = "CLAMP_TO_EDGE";
      this [_backgroundTextureProperties] ._minificationFilter  = "NICEST";
      this [_backgroundTextureProperties] ._magnificationFilter = "NICEST";
      this [_backgroundTextureProperties] .setup ();

      this .getBackgroundTextureProperties = function () { return this [_backgroundTextureProperties]; };

      Object .defineProperty (this, "getBackgroundTextureProperties", { enumerable: false });

      return this [_backgroundTextureProperties];
   },
};

/* harmony default export */ const EnvironmentalEffects_X3DEnvironmentalEffectsContext = (X3DEnvironmentalEffectsContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DComposedGeometryNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DComposedGeometryNode (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DComposedGeometryNode);

   this .fogCoordNode = null;
   this .colorNode    = null;
   this .texCoordNode = null;
   this .normalNode   = null;
   this .coordNode    = null;
}

X3DComposedGeometryNode .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: X3DComposedGeometryNode,
   initialize: function ()
   {
      Rendering_X3DGeometryNode.prototype.initialize.call (this);

      this ._attrib   .addInterest ("set_attrib__",   this);
      this ._fogCoord .addInterest ("set_fogCoord__", this);
      this ._color    .addInterest ("set_color__",    this);
      this ._texCoord .addInterest ("set_texCoord__", this);
      this ._normal   .addInterest ("set_normal__",   this);
      this ._coord    .addInterest ("set_coord__",    this);

      this .set_attrib__ ();
      this .set_fogCoord__ ();
      this .set_color__ ();
      this .set_texCoord__ ();
      this .set_normal__ ();
      this .set_coord__ ();
   },
   getFogCoord: function ()
   {
      return this .fogCoordNode;
   },
   getColor: function ()
   {
      return this .colorNode;
   },
   getTexCoord: function ()
   {
      return this .texCoordNode;
   },
   getNormal: function ()
   {
      return this .normalNode;
   },
   getCoord: function ()
   {
      return this .coordNode;
   },
   set_attrib__: function ()
   {
      const attribNodes = this .getAttrib ();

      for (const attribNode of attribNodes)
      {
         attribNode .removeInterest ("requestRebuild", this);
         attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
      }

      attribNodes .length = 0;

      for (const node of this ._attrib)
      {
         const attribNode = X3DCast (Base_X3DConstants.X3DVertexAttributeNode, node);

         if (attribNode)
            attribNodes .push (attribNode);
      }

      for (const attribNode of attribNodes)
      {
         attribNode .addInterest ("requestRebuild", this);
         attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
      }

      this .updateVertexArrays ();
   },
   set_fogCoord__: function ()
   {
      if (this .fogCoordNode)
         this .fogCoordNode .removeInterest ("requestRebuild", this);

      this .fogCoordNode = X3DCast (Base_X3DConstants.FogCoordinate, this ._fogCoord);

      if (this .fogCoordNode)
         this .fogCoordNode .addInterest ("requestRebuild", this);
   },
   set_color__: function ()
   {
      if (this .colorNode)
      {
         this .colorNode .removeInterest ("requestRebuild", this);
         this .colorNode ._transparent .removeInterest ("set_transparent__", this);
      }

      this .colorNode = X3DCast (Base_X3DConstants.X3DColorNode, this ._color);

      if (this .colorNode)
      {
         this .colorNode .addInterest ("requestRebuild", this);
         this .colorNode ._transparent .addInterest ("set_transparent__", this);

         this .set_transparent__ ();
      }
      else
         this .setTransparent (false);
   },
   set_transparent__: function ()
   {
      this .setTransparent (this .colorNode .getTransparent ());
   },
   set_texCoord__: function ()
   {
      if (this .texCoordNode)
         this .texCoordNode .removeInterest ("requestRebuild", this);

      this .texCoordNode = X3DCast (Base_X3DConstants.X3DTextureCoordinateNode, this ._texCoord);

      if (this .texCoordNode)
         this .texCoordNode .addInterest ("requestRebuild", this);

      this .setTextureCoordinate (this .texCoordNode);
   },
   set_normal__: function ()
   {
      if (this .normalNode)
         this .normalNode .removeInterest ("requestRebuild", this);

      this .normalNode = X3DCast (Base_X3DConstants.X3DNormalNode, this ._normal);

      if (this .normalNode)
         this .normalNode .addInterest ("requestRebuild", this);
   },
   set_coord__: function ()
   {
      if (this .coordNode)
         this .coordNode .removeInterest ("requestRebuild", this);

      this .coordNode = X3DCast (Base_X3DConstants.X3DCoordinateNode, this ._coord);

      if (this .coordNode)
         this .coordNode .addInterest ("requestRebuild", this);
   },
   getPolygonIndex: function (index)
   {
      return index;
   },
   getTriangleIndex: function (index)
   {
      return index;
   },
   build: function (verticesPerPolygon, polygonsSize, verticesPerFace, trianglesSize)
   {
      if (!this .coordNode || this .coordNode .isEmpty ())
         return;

      // Set size to a multiple of verticesPerPolygon.

      polygonsSize  -= polygonsSize % verticesPerPolygon;
      trianglesSize -= trianglesSize % verticesPerFace;

      const
         colorPerVertex     = this ._colorPerVertex .getValue (),
         normalPerVertex    = this ._normalPerVertex .getValue (),
         attribNodes        = this .getAttrib (),
         numAttribNodes     = attribNodes .length,
         attribArrays       = this .getAttribs (),
         fogCoordNode       = this .getFogCoord (),
         colorNode          = this .getColor (),
         texCoordNode       = this .getTexCoord (),
         normalNode         = this .getNormal (),
         coordNode          = this .getCoord (),
         fogDepthArray      = this .getFogDepths (),
         colorArray         = this .getColors (),
         multiTexCoordArray = this .getMultiTexCoords (),
         normalArray        = this .getNormals (),
         vertexArray        = this .getVertices ();

      if (texCoordNode)
         texCoordNode .init (multiTexCoordArray);

      // Fill GeometryNode

      for (let i = 0; i < trianglesSize; ++ i)
      {
         const
            face  = Math .floor (i / verticesPerFace),
            index = this .getPolygonIndex (this .getTriangleIndex (i));

         for (let a = 0; a < numAttribNodes; ++ a)
            attribNodes [a] .addValue (index, attribArrays [a]);

         if (fogCoordNode)
            fogCoordNode .addDepth (index, fogDepthArray);

         if (colorNode)
         {
            if (colorPerVertex)
               colorNode .addColor (index, colorArray);
            else
               colorNode .addColor (face, colorArray);
         }

         if (texCoordNode)
            texCoordNode .addTexCoord (index, multiTexCoordArray);

         if (normalNode)
         {
            if (normalPerVertex)
               normalNode .addVector (index, normalArray);
            else
               normalNode .addVector (face, normalArray);
         }

         coordNode .addPoint (index, vertexArray);
      }

      // Autogenerate normal if not specified.

      if (!this .getNormal ())
         this .buildNormals (verticesPerPolygon, polygonsSize, trianglesSize);

      this .setSolid (this ._solid .getValue ());
      this .setCCW (this ._ccw .getValue ());
   },
   buildNormals: function (verticesPerPolygon, polygonsSize, trianglesSize)
   {
      const
         normals     = this .createNormals (verticesPerPolygon, polygonsSize),
         normalArray = this .getNormals ();

      for (let i = 0; i < trianglesSize; ++ i)
      {
         const normal = normals [this .getTriangleIndex (i)];

         normalArray .push (normal .x, normal .y, normal .z);
      }
   },
   createNormals: function (verticesPerPolygon, polygonsSize)
   {
      const normals = this .createFaceNormals (verticesPerPolygon, polygonsSize);

      if (this ._normalPerVertex .getValue ())
      {
         const normalIndex = [ ];

         for (let i = 0; i < polygonsSize; ++ i)
         {
            const index = this .getPolygonIndex (i);

            let pointIndex = normalIndex [index];

            if (!pointIndex)
               pointIndex = normalIndex [index] = [ ];

            pointIndex .push (i);
         }

         return this .refineNormals (normalIndex, normals, Math .PI);
      }

      return normals;
   },
   createFaceNormals: function (verticesPerPolygon, polygonsSize)
   {
      const
         cw      = !this ._ccw .getValue (),
         coord   = this .coordNode,
         normals = [ ];

      for (let i = 0; i < polygonsSize; i += verticesPerPolygon)
      {
         const normal = this .getPolygonNormal (i, verticesPerPolygon, coord);

         if (cw)
            normal .negate ();

         for (let n = 0; n < verticesPerPolygon; ++ n)
            normals .push (normal);
      }

      return normals;
   },
   getPolygonNormal: (function ()
   {
      let
         current = new Numbers_Vector3 (0, 0, 0),
         next    = new Numbers_Vector3 (0, 0, 0);

      return function (index, verticesPerPolygon, coord)
      {
         // Determine polygon normal.
         // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

         const normal = new Numbers_Vector3 (0, 0, 0);

         coord .get1Point (this .getPolygonIndex (index), next);

         for (let i = 0; i < verticesPerPolygon; ++ i)
         {
            const tmp = current;
            current = next;
            next    = tmp;

            coord .get1Point (this .getPolygonIndex (index + (i + 1) % verticesPerPolygon), next);

            normal .x += (current .y - next .y) * (current .z + next .z);
            normal .y += (current .z - next .z) * (current .x + next .x);
            normal .z += (current .x - next .x) * (current .y + next .y);
         }

         return normal .normalize ();
      };
   })(),
});

/* harmony default export */ const Rendering_X3DComposedGeometryNode = (X3DComposedGeometryNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/IndexedFaceSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function IndexedFaceSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.IndexedFaceSet);

   this ._creaseAngle .setUnit ("angle");
}

IndexedFaceSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: IndexedFaceSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_colorIndex",    new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_texCoordIndex", new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_normalIndex",   new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_coordIndex",    new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",               new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "convex",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "creaseAngle",       new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",    new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex",   new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorIndex",        new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "texCoordIndex",     new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalIndex",       new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "coordIndex",        new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",            new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",             new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "IndexedFaceSet";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._set_colorIndex    .addFieldInterest (this ._colorIndex);
      this ._set_texCoordIndex .addFieldInterest (this ._texCoordIndex);
      this ._set_normalIndex   .addFieldInterest (this ._normalIndex);
      this ._set_coordIndex    .addFieldInterest (this ._coordIndex);
   },
   getTexCoordPerVertexIndex: function (index)
   {
      if (index < this ._texCoordIndex .length)
         return this ._texCoordIndex [index];

      return this ._coordIndex [index];
   },
   getColorPerVertexIndex: function (index)
   {
      if (index < this ._colorIndex .length)
         return this ._colorIndex [index];

      return this ._coordIndex [index];
   },
   getColorIndex: function (index)
   {
      if (index < this ._colorIndex .length)
         return this ._colorIndex [index];

      return index;
   },
   getNormalPerVertexIndex: function (index)
   {
      if (index < this ._normalIndex .length)
         return this ._normalIndex [index];

      return this ._coordIndex [index];
   },
   getNormalIndex: function (index)
   {
      if (index < this ._normalIndex .length)
         return this ._normalIndex [index];

      return index;
   },
   build: function ()
   {
      // Triangulate

      const polygons = this .triangulate ();

      // Build arrays

      if (polygons .length === 0)
         return;

      // Fill GeometryNode

      const
         colorPerVertex     = this ._colorPerVertex .getValue (),
         normalPerVertex    = this ._normalPerVertex .getValue (),
         coordIndex         = this ._coordIndex .getValue (),
         attribNodes        = this .getAttrib (),
         numAttribNodes     = attribNodes .length,
         attribArrays       = this .getAttribs (),
         fogCoordNode       = this .getFogCoord (),
         colorNode          = this .getColor (),
         texCoordNode       = this .getTexCoord (),
         normalNode         = this .getNormal (),
         coordNode          = this .getCoord (),
         fogDepthArray      = this .getFogDepths (),
         colorArray         = this .getColors (),
         multiTexCoordArray = this .getMultiTexCoords (),
         normalArray        = this .getNormals (),
         vertexArray        = this .getVertices ();

      if (texCoordNode)
         texCoordNode .init (multiTexCoordArray);

      for (const polygon of polygons)
      {
         const
            triangles = polygon .triangles,
            face      = polygon .face;

         for (const i of triangles)
         {
            const index = coordIndex [i];

            for (let a = 0; a < numAttribNodes; ++ a)
               attribNodes [a] .addValue (index, attribArrays [a]);

            if (fogCoordNode)
               fogCoordNode .addDepth (index, fogDepthArray);

            if (colorNode)
            {
               if (colorPerVertex)
                  colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
               else
                  colorNode .addColor (this .getColorIndex (face), colorArray);
            }

            if (texCoordNode)
               texCoordNode .addTexCoord (this .getTexCoordPerVertexIndex (i), multiTexCoordArray);

            if (normalNode)
            {
               if (normalPerVertex)
                  normalNode .addVector (this .getNormalPerVertexIndex (i), normalArray);

               else
                  normalNode .addVector (this .getNormalIndex (face), normalArray);
            }

            coordNode .addPoint (index, vertexArray);
         }
      }

      // Autogenerate normal if not specified.

      if (!this .getNormal ())
         this .buildNormals (polygons);

      this .setSolid (this ._solid .getValue ());
      this .setCCW (this ._ccw .getValue ());
   },
   triangulate: function ()
   {
      const
         convex      = this ._convex .getValue (),
         coordLength = this ._coordIndex .length,
         polygons    = [ ];

      if (!this .getCoord ())
         return polygons;

      // Add -1 (polygon end marker) to coordIndex if not present.
      if (coordLength && this ._coordIndex [coordLength - 1] > -1)
         this ._coordIndex .push (-1);

      if (coordLength)
      {
         const
            coordIndex  = this ._coordIndex .getValue (),
            coordLength = this ._coordIndex .length;

         // Construct triangle array and determine the number of used points.

         let vertices = [ ];

         for (let i = 0, face = 0; i < coordLength; ++ i)
         {
            const index = coordIndex [i];

            if (index > -1)
            {
               // Add vertex index.
               vertices .push (i);
            }
            else
            {
               // Negativ index.

               if (vertices .length)
               {
                  // Closed polygon.
                  //if (coordIndex [vertices [0]] === coordIndex [vertices [vertices .length - 1]])
                  //	vertices .pop ();

                  switch (vertices .length)
                  {
                     case 0:
                     case 1:
                     case 2:
                     {
                        vertices .length = 0;
                        break;
                     }
                     case 3:
                     {
                        // Add polygon with one triangle.
                        polygons .push ({ vertices: vertices, triangles: vertices, face: face });
                        vertices = [ ];
                        break;
                     }
                     default:
                     {
                        // Triangulate polygons.
                        const
                           triangles = [ ],
                           polygon   = { vertices: vertices, triangles: triangles, face: face };

                        if (convex)
                           this .triangulateConvexPolygon (vertices, triangles);
                        else
                           this .triangulatePolygon (vertices, triangles);

                        if (triangles .length < 3)
                        {
                           vertices .length = 0;
                        }
                        else
                        {
                           polygons .push (polygon);
                           vertices = [ ];
                        }

                        break;
                     }
                  }
               }

               ++ face;
            }
         }
      }

      return polygons;
   },
   triangulatePolygon: (function ()
   {
      const polygon = [ ];

      return function (vertices, triangles)
      {
         const
            coordIndex = this ._coordIndex .getValue (),
            coord      = this .getCoord (),
            length     = vertices .length;

         for (let v = 0; v < length; ++ v)
         {
            const i = vertices [v];

            let vertex = polygon [v];

            if (!vertex)
               vertex = polygon [v] = new Numbers_Vector3 (0, 0, 0);

            vertex .index = i;

            coord .get1Point (coordIndex [i], vertex);
         }

         polygon .length = length;

         Triangle3.triangulatePolygon (polygon, triangles);

         for (let i = 0, length = triangles .length; i < length; ++ i)
            triangles [i] = triangles [i] .index;
      };
   })(),
   triangulateConvexPolygon: function (vertices, triangles)
   {
      // Fallback: Very simple triangulation for convex polygons.
      for (let i = 1, length = vertices .length - 1; i < length; ++ i)
         triangles .push (vertices [0], vertices [i], vertices [i + 1]);
   },
   buildNormals: function (polygons)
   {
      const
         normals     = this .createNormals (polygons),
         normalArray = this .getNormals ();

      for (const polygon of polygons)
      {
         for (const triangle of polygon .triangles)
         {
            const normal = normals [triangle];

            normalArray .push (normal .x, normal .y, normal .z);
         }
      }
   },
   createNormals: (function ()
   {
      const
         normals     = [ ],
         normalIndex = [ ];

      return function (polygons)
      {
         const
            cw          = ! this ._ccw .getValue (),
            coordIndex  = this ._coordIndex .getValue (),
            coord       = this .getCoord ();

         normals     .length = 0;
         normalIndex .length = 0;

         for (const polygon of polygons)
         {
            const
               vertices = polygon .vertices,
               length   = vertices .length;

            switch (length)
            {
               case 3:
               {
                  var normal = coord .getNormal (coordIndex [vertices [0]],
                                                 coordIndex [vertices [1]],
                                                 coordIndex [vertices [2]]);
                  break;
               }
               case 4:
               {
                  var normal = coord .getQuadNormal (coordIndex [vertices [0]],
                                                     coordIndex [vertices [1]],
                                                     coordIndex [vertices [2]],
                                                     coordIndex [vertices [3]]);
                  break;
               }
               default:
               {
                  var normal = this .getPolygonNormal (vertices, coordIndex, coord);
                  break;
               }
            }

            // Add a normal index for each point.

            for (let i = 0; i < length; ++ i)
            {
               const
                  index = vertices [i],
                  point = coordIndex [index];

               let pointNormals = normalIndex [point];

               if (!pointNormals)
                  pointNormals = normalIndex [point] = [ ];

               pointNormals .push (index);
            }

            if (cw)
               normal .negate ();

            // Add this normal for each vertex.

            for (let i = 0; i < length; ++ i)
               normals [vertices [i]] = normal;
         }

         return this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());
      };
   })(),
   getPolygonNormal: (function ()
   {
      let
         current = new Numbers_Vector3 (0, 0, 0),
         next    = new Numbers_Vector3 (0, 0, 0);

      return function (vertices, coordIndex, coord)
      {
         // Determine polygon normal.
         // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

         const normal = new Numbers_Vector3 (0, 0, 0);

         coord .get1Point (coordIndex [vertices [0]], next);

         for (let i = 0, length = vertices .length; i < length; ++ i)
         {
            const tmp = current;
            current = next;
            next    = tmp;

            coord .get1Point (coordIndex [vertices [(i + 1) % length]], next);

            normal .x += (current .y - next .y) * (current .z + next .z);
            normal .y += (current .z - next .z) * (current .x + next .x);
            normal .z += (current .x - next .x) * (current .y + next .y);
         }

         return normal .normalize ();
      };
   })(),
});

/* harmony default export */ const Geometry3D_IndexedFaceSet = (IndexedFaceSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DGeometricPropertyNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DGeometricPropertyNode (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DGeometricPropertyNode);
}

X3DGeometricPropertyNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DGeometricPropertyNode,
});

/* harmony default export */ const Rendering_X3DGeometricPropertyNode = (X3DGeometricPropertyNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DCoordinateNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DCoordinateNode (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DCoordinateNode);
}

X3DCoordinateNode .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: X3DCoordinateNode,
   initialize: function ()
   {
      Rendering_X3DGeometricPropertyNode.prototype.initialize.call (this);

      this ._point .addInterest ("set_point__", this);

      this .set_point__ ();
   },
   set_point__: function ()
   {
      this .point  = this ._point .getValue ();
      this .length = this ._point .length;
   },
   isEmpty: function ()
   {
      return this .length === 0;
   },
   getSize: function ()
   {
      return this .length;
   },
   set1Point: function (index, point)
   {
      this ._point [index] = point;
   },
   get1Point: function (index, result)
   {
      if (index < this .length)
      {
         const point = this .point;

         index *= 3;

         return result .set (point [index], point [index + 1], point [index + 2]);
      }
      else
      {
         return result .set (0, 0, 0);
      }
   },
   addPoint: function (index, array)
   {
      if (index < this .length)
      {
         const point = this .point;

         index *= 3;

         array .push (point [index], point [index + 1], point [index + 2], 1);
      }
      else
      {
         array .push (0, 0, 0, 1);
      }
   },
   addPoints: function (array, min)
   {
      const point = this .point;

      for (var index = 0, length = this .length * 3; index < length; index += 3)
         array .push (point [index], point [index + 1], point [index + 2], 1);

      for (var index = length, length = min * 3; index < length; index += 3)
         array .push (0, 0, 0, 1);
   },
   getNormal: (function ()
   {
      const
         point1 = new Numbers_Vector3 (0, 0, 0),
         point2 = new Numbers_Vector3 (0, 0, 0),
         point3 = new Numbers_Vector3 (0, 0, 0);

      return function (index1, index2, index3)
      {
         // The index[1,2,3] cannot be less than 0.

         const length = this .length;

         if (index1 < length && index2 < length && index3 < length)
         {
            return Triangle3.normal (this .get1Point (index1, point1),
                                      this .get1Point (index2, point2),
                                      this .get1Point (index3, point3),
                                      new Numbers_Vector3 (0, 0, 0));
         }

         return new Numbers_Vector3 (0, 0, 0);
      };
   })(),
   getQuadNormal: (function ()
   {
      const
         point1 = new Numbers_Vector3 (0, 0, 0),
         point2 = new Numbers_Vector3 (0, 0, 0),
         point3 = new Numbers_Vector3 (0, 0, 0),
         point4 = new Numbers_Vector3 (0, 0, 0);

      return function (index1, index2, index3, index4)
      {
         // The index[1,2,3,4] cannot be less than 0.

         const length = this .length;

         if (index1 < length && index2 < length && index3 < length && index4 < length)
         {
            return Triangle3.quadNormal (this .get1Point (index1, point1),
                                          this .get1Point (index2, point2),
                                          this .get1Point (index3, point3),
                                          this .get1Point (index4, point4),
                                          new Numbers_Vector3 (0, 0, 0));
         }

         return new Numbers_Vector3 (0, 0, 0);
      };
   })(),
});

/* harmony default export */ const Rendering_X3DCoordinateNode = (X3DCoordinateNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/Coordinate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Coordinate (executionContext)
{
   Rendering_X3DCoordinateNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Coordinate);

   this ._point .setUnit ("length");
}

Coordinate .prototype = Object .assign (Object .create (Rendering_X3DCoordinateNode.prototype),
{
   constructor: Coordinate,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "point",    new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "Coordinate";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "coord";
   },
});

/* harmony default export */ const Rendering_Coordinate = (Coordinate);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DTextureCoordinateNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DTextureCoordinateNode (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTextureCoordinateNode);
}

X3DTextureCoordinateNode .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: X3DTextureCoordinateNode,
});

/* harmony default export */ const Texturing_X3DTextureCoordinateNode = (X3DTextureCoordinateNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DSingleTextureCoordinateNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DSingleTextureCoordinateNode (executionContext)
{
   Texturing_X3DTextureCoordinateNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSingleTextureCoordinateNode);

   this .texCoordArray = Rendering_X3DGeometryNode.createArray ();
}

X3DSingleTextureCoordinateNode .prototype = Object .assign (Object .create (Texturing_X3DTextureCoordinateNode.prototype),
{
   constructor: X3DSingleTextureCoordinateNode,
   init: function (multiArray)
   {
      this .texCoordArray .length = 0;

      multiArray .push (this .texCoordArray);
   },
   getCount: function ()
   {
      return 1;
   },
   addTexCoord: function (index, multiArray)
   {
      this .addTexCoordToChannel (index, multiArray [0]);
   },
   getTextureCoordinateMapping: function (textureCoordinateMapping, channel = 0)
   {
      if (this ._mapping .getValue ())
         textureCoordinateMapping .set (this ._mapping .getValue (), channel);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      for (let i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
         this .setShaderUniformsToChannel (gl, shaderObject, i);
   },
   setShaderUniformsToChannel: function (gl, shaderObject, channel = 0)
   {
      gl .uniform1i (shaderObject .x3d_TextureCoordinateGeneratorMode [channel], 0);
   },
});

/* harmony default export */ const Texturing_X3DSingleTextureCoordinateNode = (X3DSingleTextureCoordinateNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/TextureCoordinate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function TextureCoordinate (executionContext)
{
   Texturing_X3DSingleTextureCoordinateNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TextureCoordinate);
}

TextureCoordinate .prototype = Object .assign (Object .create (Texturing_X3DSingleTextureCoordinateNode.prototype),
{
   constructor: TextureCoordinate,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "mapping",  new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "point",    new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "TextureCoordinate";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texCoord";
   },
   initialize: function ()
   {
      Texturing_X3DSingleTextureCoordinateNode.prototype.initialize.call (this);

      this ._point .addInterest ("set_point__", this);

      this .set_point__ ();
   },
   set_point__: function ()
   {
      this .point  = this ._point .getValue ();
      this .length = this ._point .length;
   },
   isEmpty: function ()
   {
      return this .length === 0;
   },
   getSize: function ()
   {
      return this .length;
   },
   get1Point: function (index, vector)
   {
      if (index >= 0 && index < this .length)
      {
         const point = this .point;

         index *= 2;

         return vector .set (point [index], point [index + 1], 0, 1);
      }
      else if (index >= 0 && this .length)
      {
         const point = this .point;

         index %= this .length;
         index *= 2;

         return vector .set (point [index], point [index + 1], 0, 1);
      }
      else
      {
         return vector .set (0, 0, 0, 1);
      }
   },
   addTexCoordToChannel: function (index, array)
   {
      if (index >= 0 && index < this .length)
      {
         const point = this .point;

         index *= 2;

         array .push (point [index], point [index + 1], 0, 1);
      }
      else if (index >= 0 && this .length)
      {
         const point = this .point;

         index %= this .length;
         index *= 2;

         array .push (point [index], point [index + 1], 0, 1);
      }
      else
      {
         array .push (0, 0, 0, 1);
      }
   },
   getTexCoord: function (array)
   {
      const
         point  = this .point,
         length = this .length;

      for (let i = 0, p = 0; i < length; ++ i, p += 2)
         array .push (point [p], point [p + 1], 0, 1);

      return array;
   },
});

/* harmony default export */ const Texturing_TextureCoordinate = (TextureCoordinate);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry3D/BoxOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function BoxOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);
}

BoxOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: BoxOptions,
   getTypeName: function ()
   {
      return "BoxOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "boxOptions";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);
   },
   getGeometry: function ()
   {
      if (this .geometry)
         return this .geometry;

      this .geometry            = new Geometry3D_IndexedFaceSet (this .getExecutionContext ());
      this .geometry ._texCoord = new Texturing_TextureCoordinate (this .getExecutionContext ());
      this .geometry ._coord    = new Rendering_Coordinate (this .getExecutionContext ());

      const
         geometry = this .geometry,
         texCoord = this .geometry ._texCoord .getValue (),
         coord    = this .geometry ._coord .getValue ();

      geometry ._texCoordIndex = new x_ite_Fields.MFInt32 (
         0, 1, 2, 3, -1, // front
         0, 1, 2, 3, -1, // back
         0, 1, 2, 3, -1, // left
         0, 1, 2, 3, -1, // right
         0, 1, 2, 3, -1, // top
         0, 1, 2, 3, -1  // bottom
      );

      geometry ._coordIndex = new x_ite_Fields.MFInt32 (
         0, 1, 2, 3, -1, // front
         5, 4, 7, 6, -1, // back
         1, 5, 6, 2, -1, // left
         4, 0, 3, 7, -1, // right
         4, 5, 1, 0, -1, // top
         3, 2, 6, 7, -1  // bottom
      );

      texCoord ._point = new x_ite_Fields.MFVec2f (
         new x_ite_Fields.SFVec2f (1, 1), new x_ite_Fields.SFVec2f (0, 1), new x_ite_Fields.SFVec2f (0, 0), new x_ite_Fields.SFVec2f (1, 0)
      );

      coord ._point = new x_ite_Fields.MFVec3f (
         new x_ite_Fields.SFVec3f ( 1,  1,  1), new x_ite_Fields.SFVec3f (-1,  1,  1), new x_ite_Fields.SFVec3f (-1, -1,  1), new x_ite_Fields.SFVec3f ( 1, -1,  1),
         new x_ite_Fields.SFVec3f ( 1,  1, -1), new x_ite_Fields.SFVec3f (-1,  1, -1), new x_ite_Fields.SFVec3f (-1, -1, -1), new x_ite_Fields.SFVec3f ( 1, -1, -1)
      );

      texCoord .setup ();
      coord    .setup ();
      geometry .setup ();

      return this .geometry;
   },
});

/* harmony default export */ const Geometry3D_BoxOptions = (BoxOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry3D/ConeOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function ConeOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("xDimension", new x_ite_Fields.SFInt32 (20),
                          "yDimension", new x_ite_Fields.SFInt32 (1))
}

ConeOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: ConeOptions,
   getTypeName: function ()
   {
      return "ConeOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "coneOptions";
   },
});

/* harmony default export */ const Geometry3D_ConeOptions = (ConeOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry3D/CylinderOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function CylinderOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("xDimension", new x_ite_Fields.SFInt32 (20),
                          "yDimension", new x_ite_Fields.SFInt32 (1))
}

CylinderOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: CylinderOptions,
   getTypeName: function ()
   {
      return "CylinderOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "cylinderOptions";
   },
});

/* harmony default export */ const Geometry3D_CylinderOptions = (CylinderOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry3D/QuadSphereOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function QuadSphereOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("xDimension", new x_ite_Fields.SFInt32 (32),
                          "yDimension", new x_ite_Fields.SFInt32 (15))
}

QuadSphereOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: QuadSphereOptions,
   getTypeName: function ()
   {
      return "QuadSphereOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "quadSphereOptions";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);

      this .addInterest ("eventsProcessed", this);
   },
   getGeometry: function ()
   {
      if (! this .geometry)
         this .eventsProcessed ();

      return this .geometry;
   },
   createTexCoordIndex: function ()
   {
      const
         xDimension    = this ._xDimension .getValue () + 1,
         yDimension    = this ._yDimension .getValue (),
         texCoordIndex = this .geometry ._texCoordIndex;

      // North pole

      for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u)
      {
         texCoordIndex .push (u);
         texCoordIndex .push (u + xDimension - 1);
         texCoordIndex .push (u + xDimension);
         texCoordIndex .push (-1);
      }

      // Sphere segments

      for (let p = xDimension - 1, v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
      {
         for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
         {
            texCoordIndex .push (p);
            texCoordIndex .push (p + xDimension);
            texCoordIndex .push (p + xDimension + 1);
            texCoordIndex .push (p + 1);
            texCoordIndex .push (-1);
         }
      }

      // South pole

      let p = (yDimension - 2) * xDimension - 1;

      for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
      {
         texCoordIndex .push (p + xDimension);
         texCoordIndex .push (p + 1);
         texCoordIndex .push (p);
         texCoordIndex .push (-1);
      }
   },
   createTexCoord: function ()
   {
      const
         xDimension = this ._xDimension .getValue () + 1,
         yDimension = this ._yDimension .getValue (),
         point      = this .geometry ._texCoord .getValue () ._point;

      const poleOffset = -0.5 / (xDimension - 1);

      // North pole

      for (let u = 1; u < xDimension; ++ u)
      {
         const x = u / (xDimension - 1) + poleOffset;

         point .push (new Numbers_Vector2 (x, 1));
      }

      // Sphere segments

      for (let v = 1, vLength = yDimension - 1; v < vLength; ++ v)
      {
         const y = 1 - v / (yDimension - 1);

         for (let u = 0; u < xDimension; ++ u)
         {
            const x = u / (xDimension - 1);

            point .push (new Numbers_Vector2 (x, y));
         }
      }

      // South pole

      for (let u = 1; u < xDimension; ++ u)
      {
         const x = u / (xDimension - 1) + poleOffset;

         point .push (new Numbers_Vector2 (x, 0));
      }
   },
   createCoordIndex: function ()
   {
      const
         xDimension = this ._xDimension .getValue () + 1,
         yDimension = this ._yDimension .getValue (),
         coordIndex = this .geometry ._coordIndex;

      // North pole

      let u = 1;

      for (const uLength = xDimension - 1; u < uLength; ++ u)
      {
         coordIndex .push (0);
         coordIndex .push (u);
         coordIndex .push (u + 1);
         coordIndex .push (-1);
      }

      coordIndex .push (0);
      coordIndex .push (u);
      coordIndex .push (1);
      coordIndex .push (-1);

      // Sphere segments

      let p = 1;

      for (let v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
      {
         for (let u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
         {
            coordIndex .push (p);
            coordIndex .push (p + xDimension - 1);
            coordIndex .push (p + xDimension);
            coordIndex .push (p + 1);
            coordIndex .push (-1);
         }

         coordIndex .push (p);
         coordIndex .push (p + xDimension - 1);
         coordIndex .push (p + 1);
         coordIndex .push (p - xDimension + 2);
         coordIndex .push (-1);
      }

      // South pole

      const last = p + xDimension - 1;

      for (let u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
      {
         coordIndex .push (last);
         coordIndex .push (p + 1);
         coordIndex .push (p);
         coordIndex .push (-1);
      }

      coordIndex .push (last);
      coordIndex .push (last - xDimension + 1);
      coordIndex .push (p);
      coordIndex .push (-1);
   },
   createPoints: function ()
   {
      const
         xDimension = this ._xDimension .getValue () + 1,
         yDimension = this ._yDimension .getValue (),
         point      = this .geometry ._coord .getValue () ._point;

      // North pole
      point .push (new Numbers_Vector3 (0, 1, 0));

      // Sphere segments
      for (let v = 1, vLength = yDimension - 1; v < vLength; ++ v)
      {
         const zPlane = Numbers_Complex.Polar (1, -Math .PI * v / vLength);

         for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u)
         {
            const yPlane = Numbers_Complex.Polar (zPlane .imag, 2 * Math .PI * u / uLength);

            point .push (new Numbers_Vector3 (yPlane .imag, zPlane .real, yPlane .real));
         }
      }

      // South pole
      point .push (new Numbers_Vector3 (0, -1, 0));
   },
   eventsProcessed: function ()
   {
      this .geometry            = new Geometry3D_IndexedFaceSet (this .getExecutionContext ());
      this .geometry ._texCoord = new Texturing_TextureCoordinate (this .getExecutionContext ());
      this .geometry ._coord    = new Rendering_Coordinate (this .getExecutionContext ());

      this .createTexCoordIndex ();
      this .createTexCoord ();
      this .createCoordIndex ();
      this .createPoints ();

      const
         geometry = this .geometry,
         texCoord = this .geometry ._texCoord .getValue (),
         coord    = this .geometry ._coord .getValue ();

      geometry ._creaseAngle = Math .PI;

      texCoord .setup ();
      coord    .setup ();
      geometry .setup ();
   },
});

/* harmony default export */ const Geometry3D_QuadSphereOptions = (QuadSphereOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry3D/X3DGeometry3DContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function X3DGeometry3DContext () { }

X3DGeometry3DContext .prototype =
{
   initialize: function ()
   {
      this .setPrimitiveQuality3D (this .getBrowserOptions () .getPrimitiveQuality ());
   },
   getBoxOptions: function ()
   {
      return getOptionNode .call (this, "getBoxOptions", Geometry3D_BoxOptions);
   },
   getConeOptions: function ()
   {
      return getOptionNode .call (this, "getConeOptions", Geometry3D_ConeOptions);
   },
   getCylinderOptions: function ()
   {
      return getOptionNode .call (this, "getCylinderOptions", Geometry3D_CylinderOptions);
   },
   getSphereOptions: function ()
   {
      return getOptionNode .call (this, "getSphereOptions", Geometry3D_QuadSphereOptions);
   },
   setPrimitiveQuality3D: function (primitiveQuality)
   {
      const
         cone     = this .getConeOptions (),
         cylinder = this .getCylinderOptions (),
         sphere   = this .getSphereOptions ();

      switch (primitiveQuality)
      {
         case Core_PrimitiveQuality.LOW:
         {
            cone     ._xDimension = 16;
            cylinder ._xDimension = 16;
            sphere   ._xDimension = 20;
            sphere   ._yDimension = 9;
            break;
         }
         case Core_PrimitiveQuality.MEDIUM:
         {
            cone     ._xDimension = 20;
            cylinder ._xDimension = 20;
            sphere   ._xDimension = 32;
            sphere   ._yDimension = 15;
            break;
         }
         case Core_PrimitiveQuality.HIGH:
         {
            cone     ._xDimension = 32;
            cylinder ._xDimension = 32;
            sphere   ._xDimension = 64;
            sphere   ._yDimension = 31;
            break;
         }
      }
   },
};

function getOptionNode (key, OptionNode)
{
   const optionNode = new OptionNode (this .getPrivateScene ());

   optionNode .setup ();

   this [key] = function () { return optionNode; };

   Object .defineProperty (this, key, { enumerable: false });

   return optionNode;
}

/* harmony default export */ const Geometry3D_X3DGeometry3DContext = (X3DGeometry3DContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shape/AlphaMode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let AlphaMode_i = 0;

const AlphaMode =
{
   AUTO:   AlphaMode_i ++,
   OPAQUE: AlphaMode_i ++,
   MASK:   AlphaMode_i ++,
   BLEND:  AlphaMode_i ++,
};

/* harmony default export */ const Shape_AlphaMode = (AlphaMode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/X3DShapeNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function X3DShapeNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   Grouping_X3DBoundedObject.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DShapeNode);

   this .bbox       = new Geometry_Box3 ();
   this .bboxSize   = new Numbers_Vector3 (0, 0, 0);
   this .bboxCenter = new Numbers_Vector3 (0, 0, 0);
}

X3DShapeNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   Grouping_X3DBoundedObject.prototype,
{
   constructor: X3DShapeNode,
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      Grouping_X3DBoundedObject.prototype.initialize.call (this);

      this ._bboxSize   .addInterest ("set_bbox__",      this);
      this ._bboxCenter .addInterest ("set_bbox__",      this);
      this ._appearance .addInterest ("set_apparance__", this);
      this ._geometry   .addInterest ("set_geometry__",  this);

      this ._appearance .addInterest ("set_transparent__", this);
      this ._geometry   .addInterest ("set_transparent__", this);

      this .set_apparance__ ();
      this .set_geometry__ ();
      this .set_transparent__ ();
   },
   getBBox: function (bbox, shadows)
   {
      if (shadows)
      {
         if (this ._castShadow .getValue ())
            return bbox .assign (this .bbox);
         else
            return bbox .set ();
      }
      else
      {
         return bbox .assign (this .bbox);
      }
   },
   getBBoxSize: function ()
   {
      return this .bboxSize;
   },
   getBBoxCenter: function ()
   {
      return this .bboxCenter;
   },
   getAppearance: function ()
   {
      return this .apparanceNode;
   },
   getGeometry: function ()
   {
      return this .geometryNode;
   },
   setTransparent: function (value)
   {
      this .transparent = value;
   },
   getTransparent: function ()
   {
      return this .transparent;
   },
   set_bbox__: function ()
   {
      if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
      {
         if (this .getGeometry ())
            this .bbox .assign (this .getGeometry () .getBBox ());

         else
            this .bbox .set ();
      }
      else
         this .bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());

      this .bboxSize   .assign (this .bbox .size);
      this .bboxCenter .assign (this .bbox .center);
   },
   set_apparance__: function ()
   {
      if (this .apparanceNode)
         this .apparanceNode ._transparent .removeInterest ("set_transparent__", this);

      this .apparanceNode = X3DCast (Base_X3DConstants.X3DAppearanceNode, this ._appearance);

      if (this .apparanceNode)
      {
         this .apparanceNode ._alphaMode   .addInterest ("set_transparent__", this);
         this .apparanceNode ._transparent .addInterest ("set_transparent__", this);
      }
      else
         this .apparanceNode = this .getBrowser () .getDefaultAppearance ();
   },
   set_geometry__: function ()
   {
      if (this .geometryNode)
      {
         this .geometryNode ._transparent  .addInterest ("set_transparent__", this);
         this .geometryNode ._bbox_changed .addInterest ("set_bbox__",        this);
      }

      this .geometryNode = X3DCast (Base_X3DConstants.X3DGeometryNode, this ._geometry);

      if (this .geometryNode)
      {
         this .geometryNode ._transparent  .addInterest ("set_transparent__", this);
         this .geometryNode ._bbox_changed .addInterest ("set_bbox__",        this);
      }

      this .set_bbox__ ();
   },
   set_transparent__: function ()
   {
      if (this .apparanceNode .getAlphaMode () === Shape_AlphaMode.AUTO)
      {
         this .transparent = this .apparanceNode .getTransparent () ||
                             (this .geometryNode && this .geometryNode .getTransparent ());
      }
      else
      {
         this .transparent = this .apparanceNode .getTransparent ();
      }
   },
});

/* harmony default export */ const Shape_X3DShapeNode = (X3DShapeNode);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Line3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function Line3 (point, direction)
{
   this .point     = point     .copy ();
   this .direction = direction .copy ();
}

Line3 .prototype =
{
   constructor: Line3,
   copy: function ()
   {
      const copy = Object .create (Line3 .prototype);
      copy .point     = this .point .copy ();
      copy .direction = this .direction .copy ();
      return copy;
   },
   assign: function (line)
   {
      this .point     .assign (line .point);
      this .direction .assign (line .direction);
      return this;
   },
   set: function (point, direction)
   {
      this .point     .assign (point);
      this .direction .assign (direction);
      return this;
   },
   setPoints: function (point1, point2)
   {
      this .point .assign (point1);
      this .direction .assign (point2) .subtract (point1) .normalize ();
      return this;
   },
   multMatrixLine: function (matrix)
   {
      matrix .multMatrixVec (this .point);
      matrix .multMatrixDir (this .direction) .normalize ();
      return this;
   },
   multLineMatrix: function (matrix)
   {
      matrix .multVecMatrix (this .point);
      matrix .multDirMatrix (this .direction) .normalize ();
      return this;
   },
   getClosestPointToPoint: function (point, result)
   {
      const
         r = result .assign (point) .subtract (this .point),
         d = r .dot (this .direction);

      return result .assign (this .direction) .multiply (d) .add (this .point);
   },
   getClosestPointToLine: (function ()
   {
      const u = new Numbers_Vector3 (0, 0, 0);

      return function (line, point)
      {
         const
            p1 = this .point,
            p2 = line .point,
            d1 = this .direction,
            d2 = line .direction;

         let t = d1 .dot (d2);

         if (Math .abs (t) >= 1)
            return false;  // lines are parallel

         u .assign (p2) .subtract (p1);

         t = (u .dot (d1) - t * u .dot (d2)) / (1 - t * t);

         point .assign (d1) .multiply (t) .add (p1);
         return true;
      };
   })(),
   getPerpendicularVectorToPoint: (function ()
   {
      const t = new Numbers_Vector3 (0, 0, 0);

      return function (point, result)
      {
         result .assign (this .point) .subtract (point);

         return result .subtract (t .assign (this .direction) .multiply (result .dot (this .direction)));
      };
   })(),
   getPerpendicularVectorToLine: (function ()
   {
      const
         d  = new Numbers_Vector3 (0, 0, 0),
         ad = new Numbers_Vector3 (0, 0, 0);

      return function (line, result)
      {
         const bd = result;

         d .assign (this .point) .subtract (line .point);

         const
            re1 = d .dot (this .direction),
            re2 = d .dot (line .direction),
            e12 = this .direction .dot (line .direction),
            E12 = e12 * e12;

         const
            a =  (re1 - re2 * e12) / (1 - E12),
            b = -(re2 - re1 * e12) / (1 - E12);

         ad .assign (this .direction) .multiply (a);
         bd .assign (line .direction) .multiply (b);

         return bd .subtract (ad) .add (d);
      };
   })(),
   intersectsTriangle: (function ()
   {
      const
         pvec = new Numbers_Vector3 (0, 0, 0),
         tvec = new Numbers_Vector3 (0, 0, 0);

      return function (A, B, C, uvt)
      {
         // Find vectors for two edges sharing vert0.
         const
            edge1 = B .subtract (A),
            edge2 = C .subtract (A);

         // Begin calculating determinant - also used to calculate U parameter.
         pvec .assign (this .direction) .cross (edge2);

         // If determinant is near zero, ray lies in plane of triangle.
         const det = edge1 .dot (pvec);

         // Non culling intersection.

         if (det === 0)
            return false;

            const inv_det = 1 / det;

         // Calculate distance from vert0 to ray point.
         tvec .assign (this .point) .subtract (A);

         // Calculate U parameter and test bounds.
         const u = tvec .dot (pvec) * inv_det;

         if (u < 0 || u > 1)
            return false;

         // Prepare to test V parameter.
         const qvec = tvec .cross (edge1);

         // Calculate V parameter and test bounds.
         const v = this .direction .dot (qvec) * inv_det;

         if (v < 0 || u + v > 1)
            return false;

         //let t = edge2 .dot (qvec) * inv_det;

         uvt .u = u;
         uvt .v = v;
         uvt .t = 1 - u - v;

         return true;
      };
   })(),
   toString: function ()
   {
      return this .point + ", " + this .direction;
   },
};

Line3 .Points = function (point1, point2)
{
   const line = Object .create (Line3 .prototype);
   line .point     = point1 .copy ();
   line .direction = Numbers_Vector3.subtract (point2, point1) .normalize ();
   return line;
};

/* harmony default export */ const Geometry_Line3 = (Line3);

;// CONCATENATED MODULE: ./src/standard/Math/Algorithms/QuickSort.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


function QuickSort (array, compare)
{
   this .array = array;

   if (compare)
      this .compare = compare;
}

QuickSort .prototype =
{
   compare: function (lhs, rhs)
   {
      return lhs < rhs;
   },
   sort: function (first, last)
   {
      if (last - first > 1)
         this .quicksort (first, last - 1);
   },
   quicksort: function (lo, hi)
   {
      let
         i = lo,
         j = hi;

      const
         array   = this .array,
         compare = this .compare;

      // Vergleichs­element x
      const x = array [(lo + hi) >>> 1];

      for (;;)
      {
         while (compare (array [i], x)) ++ i;
         while (compare (x, array [j])) -- j;

         if (i < j)
         {
            // Exchange

            const t = array [i];
            array [i] = array [j];
            array [j] = t;

            i ++; j --;
         }
         else
         {
            if (i === j) ++ i, -- j;
            break;
         }
      }

      // Rekursion
      if (lo < j) this .quicksort (lo, j);
      if (i < hi) this .quicksort (i, hi);
   },
};

/* harmony default export */ const Algorithms_QuickSort = (QuickSort);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/Shape.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/














function Shape (executionContext)
{
   Shape_X3DShapeNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Shape);
}

Shape .prototype = Object .assign (Object .create (Shape_X3DShapeNode.prototype),
{
   constructor: Shape,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",     new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "castShadow",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",    new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",  new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "appearance",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "geometry",    new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Shape";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Shape_X3DShapeNode.prototype.initialize.call (this);

      this ._transformSensors_changed .addInterest ("set_transformSensors__", this);

      this .set_transformSensors__ ();
   },
   getShapeKey: function ()
   {
      return 0;
   },
   set_geometry__: function ()
   {
      Shape_X3DShapeNode.prototype.set_geometry__.call (this);

      if (this .getGeometry ())
         delete this .traverse;
      else
         this .traverse = Function .prototype;
   },
   set_transformSensors__: function ()
   {
      this .setPickableObject (this .getTransformSensors () .size);
   },
   intersectsBox: function (box, clipPlanes, modelViewMatrix)
   {
      return this .getGeometry () .intersectsBox (box, clipPlanes, modelViewMatrix);
   },
   traverse: function (type, renderObject)
   {
      // Always look at ParticleSystem if you do modify something here and there.

      switch (type)
      {
         case Rendering_TraverseType.POINTER:
         {
            this .pointer (renderObject);
            break;
         }
         case Rendering_TraverseType.PICKING:
         {
            this .picking (renderObject);
            break;
         }
         case Rendering_TraverseType.COLLISION:
         {
            renderObject .addCollisionShape (this);
            break;
         }
         case Rendering_TraverseType.SHADOW:
         {
            if (this ._castShadow .getValue ())
               renderObject .addShadowShape (this);

            break;
         }
         case Rendering_TraverseType.DISPLAY:
         {
            if (renderObject .addDisplayShape (this))
               this .getAppearance () .traverse (type, renderObject); // Currently used for GeneratedCubeMapTexture.

            break;
         }
      }

      this .getGeometry () .traverse (type, renderObject); // Currently used for ScreenText.
   },
   pointer: (function ()
   {
      const
         modelViewMatrix    = new Numbers_Matrix4 (),
         invModelViewMatrix = new Numbers_Matrix4 (),
         hitRay             = new Geometry_Line3 (new Numbers_Vector3 (0, 0, 0), new Numbers_Vector3 (0, 0, 0)),
         intersections      = [ ],
         intersectionSorter = new Algorithms_QuickSort (intersections, function (lhs, rhs)
         {
            return lhs .point .z > rhs .point .z;
         }),
         distanceCompare    = function (lhs, rhs) { return lhs .point .z > rhs; };

      return function (renderObject)
      {
         const browser = this .getBrowser ();

         if (browser .getPickOnlySensors () && browser .getSensors () .length === 1)
            return;

         const geometryNode = this .getGeometry ();

         modelViewMatrix    .assign (renderObject .getModelViewMatrix () .get ());
         invModelViewMatrix .assign (modelViewMatrix) .inverse ();

         hitRay .assign (browser .getHitRay ()) .multLineMatrix (invModelViewMatrix);

         if (geometryNode .intersectsLine (hitRay, renderObject, invModelViewMatrix, this .getAppearance (), intersections))
         {
            // Finally we have intersections and must now find the closest hit in front of the camera.

            // Transform hitPoints to absolute space.
            for (const intersection of intersections)
               modelViewMatrix .multVecMatrix (intersection .point);

            intersectionSorter .sort (0, intersections .length);

            // Find first point that is not greater than near plane;
            const index = Math_Algorithm.lowerBound (intersections, 0, intersections .length, -renderObject .getNavigationInfo () .getNearValue (), distanceCompare);

            // Are there intersections before the camera?
            if (index !== intersections .length)
            {
               // Transform hitNormal to absolute space.
               invModelViewMatrix .multMatrixDir (intersections [index] .normal) .normalize ();

               browser .addHit (intersections [index], renderObject .getLayer (), this, modelViewMatrix .multRight (renderObject .getCameraSpaceMatrix () .get ()));
            }

            intersections .length = 0;
         }
      };
   })(),
   picking: function (renderObject)
   {
      const modelMatrix = renderObject .getModelViewMatrix () .get ();

      if (this .getTransformSensors () .size)
      {
         for (const transformSensorNode of this .getTransformSensors ())
            transformSensorNode .collect (modelMatrix);
      }

      const
         browser          = this .getBrowser (),
         pickSensorStack  = browser .getPickSensors (),
         pickingHierarchy = browser .getPickingHierarchy ();

      pickingHierarchy .push (this);

      for (const pickSensor of pickSensorStack .at (-1))
      {
         pickSensor .collect (this .getGeometry (), modelMatrix, pickingHierarchy);
      }

      pickingHierarchy .pop ();
   },
   depth: function (gl, depthContext, projectionMatrix)
   {
      const
         clipPlanes = depthContext .clipPlanes,
         shaderNode = this .getBrowser () .getDepthShader (clipPlanes .length, false);

      shaderNode .enable (gl);
      shaderNode .setClipPlanes (gl, clipPlanes);

      gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrix);
      gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, depthContext .modelViewMatrix);

      this .getGeometry () .depth (gl, depthContext, shaderNode);
   },
   display: function (gl, renderContext)
   {
      this .getGeometry () .display (gl, renderContext);
   },
});

/* harmony default export */ const Shape_Shape = (Shape);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Line2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function Line2 (point, direction)
{
   this .point     = point     .copy ();
   this .direction = direction .copy ();
}

Line2 .prototype =
{
   constructor: Line2,
   copy: function ()
   {
      const copy = Object .create (Line2 .prototype);
      copy .point     = this .point .copy ();
      copy .direction = this .direction .copy ();
      return copy;
   },
   assign: function (line)
   {
      this .point     .assign (line .point);
      this .direction .assign (line .direction);
      return this;
   },
   set: function (point, direction)
   {
      this .point     .assign (point);
      this .direction .assign (direction);
      return this;
   },
   setPoints: function (point1, point2)
   {
      this .point .assign (point1);
      this .direction .assign (point2) .subtract (point1) .normalize ();
      return this;
   },
   multMatrixLine: function (matrix)
   {
      matrix .multMatrixVec (this .point);
      matrix .multMatrixDir (this .direction) .normalize ();
      return this;
   },
   multLineMatrix: function (matrix)
   {
      matrix .multVecMatrix (this .point);
      matrix .multDirMatrix (this .direction) .normalize ();
      return this;
   },
   getClosestPointToPoint: function (point, result)
   {
      const
         r = result .assign (point) .subtract (this .point),
         d = r .dot (this .direction);

      return result .assign (this .direction) .multiply (d) .add (this .point);
   },
   getPerpendicularVectorToPoint: (function ()
   {
      const t = new Numbers_Vector2 (0, 0);

      return function (point, result)
      {
         result .assign (this .point) .subtract (point);

         return result .subtract (t .assign (this .direction) .multiply (result .dot (this .direction)));
      };
   })(),
   intersectsLine: (function ()
   {
      const u = new Numbers_Vector2 (0, 0);

      return function (line, point)
      {
         const
            p1 = this .point,
            p2 = line .point,
            d1 = this .direction,
            d2 = line .direction;

         const theta = d1 .dot (d2); // angle between both lines

         if (Math .abs (theta) >= 1)
            return false; // lines are parallel

         u .assign (p2) .subtract (p1);

         const t = (u .dot (d1) - theta * u .dot (d2)) / (1 - theta * theta);

         point .assign (d1) .multiply (t) .add (p1);

         return true;
      };
   })(),
   toString: function ()
   {
      return this .point + ", " + this .direction;
   },
};

Line2 .Points = function (point1, point2)
{
   const line = Object .create (Line2 .prototype);
   line .point     = point1 .copy ();
   line .direction = Numbers_Vector2.subtract (point2, point1) .normalize ();
   return line;
};

/* harmony default export */ const Geometry_Line2 = (Line2);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DLineGeometryNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/














function X3DLineGeometryNode (executionContext)
{
   if (!this .getExecutionContext ())
      Rendering_X3DGeometryNode.call (this, executionContext);

   const
      browser = this .getBrowser (),
      gl      = browser .getContext ();

   this .transformVertexArrayObject = new Rendering_VertexArray ();
   this .thickVertexArrayObject     = new Rendering_VertexArray ();
   this .lineStippleBuffer          = gl .createBuffer ();
   this .trianglesBuffer            = gl .createBuffer ();

   this .setGeometryType (1);
   this .setPrimitiveMode (gl .LINES);
   this .setSolid (false);
}

X3DLineGeometryNode .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: X3DLineGeometryNode,
   updateVertexArrays: function ()
   {
      Rendering_X3DGeometryNode.prototype.updateVertexArrays.call (this);

      this .transformVertexArrayObject .update ();
      this .thickVertexArrayObject     .update ();
   },
   intersectsLine: (function ()
   {
      const
         bbox                      = new Geometry_Box3 (),
         min                       = new Numbers_Vector3 (0, 0, 0),
         max                       = new Numbers_Vector3 (0, 0, 0),
         screenScale1_             = new Numbers_Vector3 (0, 0, 0),
         screenScale2_             = new Numbers_Vector3 (0, 0, 0),
         modelViewProjectionMatrix = new Numbers_Matrix4 (),
         point1                    = new Numbers_Vector3 (0, 0, 0),
         point2                    = new Numbers_Vector3 (0, 0, 0),
         projected1                = new Numbers_Vector2 (0, 0),
         projected2                = new Numbers_Vector2 (0, 0),
         projected                 = new Geometry_Line2 (Numbers_Vector2.Zero, Numbers_Vector2.yAxis),
         closest                   = new Numbers_Vector2 (0, 0),
         ray                       = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.zAxis),
         line                      = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.zAxis),
         point                     = new Numbers_Vector3 (0, 0, 0),
         rotation                  = new Numbers_Matrix2 (),
         clipPoint                 = new Numbers_Vector3 (0, 0, 0);

      return function (hitRay, renderObject, invModelViewMatrix, appearanceNode, intersections)
      {
         const
            modelViewMatrix    = renderObject .getModelViewMatrix () .get (),
            viewport           = renderObject .getViewVolume () .getViewport (),
            extents            = bbox .assign (this .getBBox ()) .multRight (modelViewMatrix) .getExtents (min, max),
            linePropertiesNode = appearanceNode .getLineProperties (),
            lineWidth1_2       = Math .max (1.5, linePropertiesNode && linePropertiesNode .getApplied () ? linePropertiesNode .getLinewidthScaleFactor () / 2 : 1),
            screenScale1       = renderObject .getViewpoint () .getScreenScale (min, viewport, screenScale1_), // in m/px
            offsets1           = invModelViewMatrix .multDirMatrix (screenScale1 .multiply (lineWidth1_2)),
            screenScale2       = renderObject .getViewpoint () .getScreenScale (max, viewport, screenScale2_), // in m/px
            offsets2           = invModelViewMatrix .multDirMatrix (screenScale2 .multiply (lineWidth1_2));

         if (this .intersectsBBox (hitRay, offsets1 .abs () .max (offsets2 .abs ())))
         {
            const
               pointer          = this .getBrowser () .getPointer (),
               projectionMatrix = renderObject .getProjectionMatrix () .get (),
               clipPlanes       = renderObject .getLocalObjects (),
               vertices         = this .getVertices (),
               numVertices      = vertices .length;

            modelViewProjectionMatrix .assign (modelViewMatrix) .multRight (projectionMatrix);

            for (let i = 0; i < numVertices; i += 8)
            {
               point1 .set (vertices [i + 0], vertices [i + 1], vertices [i + 2]);
               point2 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6]);

               Geometry_ViewVolume.projectPointMatrix (point1, modelViewProjectionMatrix, viewport, projected1);
               Geometry_ViewVolume.projectPointMatrix (point2, modelViewProjectionMatrix, viewport, projected2);

               projected .setPoints (projected1, projected2);

               if (projected .getClosestPointToPoint (pointer, closest))
               {
                  const
                     distance  = projected1 .distance (projected2),
                     distance1 = projected1 .distance (closest),
                     distance2 = projected2 .distance (closest);

                  if (distance1 <= distance && distance2 <= distance)
                  {
                     if (closest .distance (pointer) <= lineWidth1_2)
                     {
                        if (clipPlanes .length)
                        {
                           if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (closest)), clipPlanes))
                              continue;
                        }

                        const
                           direction = projected .direction,
                           texCoordY = rotation .set (direction .x, direction .y, -direction .y, direction .x) .inverse () .multVecMatrix (pointer .copy () .subtract (closest)),
                           texCoord  = texCoordY .set (distance1 / distance, (texCoordY .y / lineWidth1_2 + 1) / 2),
                           normal    = point2 .copy () .subtract (point1) .normalize ();

                        Geometry_ViewVolume.unProjectRay (closest .x, closest .y, modelViewMatrix, projectionMatrix, viewport, ray);

                        line .setPoints (point1, point2) .getClosestPointToLine (ray, point);

                        intersections .push ({ texCoord: texCoord, normal: normal, point: point .copy () });
                     }
                  }
               }
            }
         }

         return intersections .length;
      };
   })(),
   intersectsLineWithGeometry: function ()
   {
      return false;
   },
   intersectsBox: function (box, clipPlanes, modelViewMatrix)
   {
      return false;
   },
   buildTexCoords: function ()
   {
      // Line stipple support.

      const lineStipple = this .getTexCoords ();

      if (lineStipple .getValue () .length / 6 !== this .getVertices () .length / 8)
      {
         const
            gl       = this .getBrowser () .getContext (),
            numLines = this .getVertices () .length / 8;

         lineStipple .length = numLines * 6;

         lineStipple .fill (0);
         lineStipple .shrinkToFit ();

         gl .bindBuffer (gl .ARRAY_BUFFER, this .lineStippleBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, lineStipple .getValue (), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .trianglesBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (12 * 6 * numLines), gl .DYNAMIC_DRAW);
      }
   },
   updateLengthSoFar: (function ()
   {
      const
         modelViewProjectionMatrix = new Numbers_Matrix4 (),
         point0                    = new Numbers_Vector4 (0, 0, 0),
         point1                    = new Numbers_Vector4 (0, 0, 0),
         projectedPoint0           = new Numbers_Vector2 (0, 0),
         projectedPoint1           = new Numbers_Vector2 (0, 0);

      return function (gl, renderContext)
      {
         const
            viewport         = renderContext .renderObject .getViewVolume () .getViewport (),
            projectionMatrix = renderContext .renderObject .getProjectionMatrix () .get (),
            lineStippleArray = this .getTexCoords () .getValue (),
            vertices         = this .getVertices (),
            numVertices      = vertices .length;

         modelViewProjectionMatrix .assign (renderContext .modelViewMatrix) .multRight (projectionMatrix);

         let lengthSoFar = 0;

         for (let i = 0, l = 0; i < numVertices; i += 8, l += 6)
         {
            point0 .set (vertices [i],     vertices [i + 1], vertices [i + 2], vertices [i + 3]);
            point1 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6], vertices [i + 7]);

            Geometry_ViewVolume.projectPointMatrix (point0, modelViewProjectionMatrix, viewport, projectedPoint0);
            Geometry_ViewVolume.projectPointMatrix (point1, modelViewProjectionMatrix, viewport, projectedPoint1);

            lineStippleArray [l]     = projectedPoint1 .x;
            lineStippleArray [l + 1] = projectedPoint1 .y;

            lineStippleArray [l + 3] = projectedPoint0 .x;
            lineStippleArray [l + 4] = projectedPoint0 .y;
            lineStippleArray [l + 5] = lengthSoFar;

            lengthSoFar += projectedPoint1 .subtract (projectedPoint0) .magnitude ();
         }

         gl .bindBuffer (gl .ARRAY_BUFFER, this .lineStippleBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, lineStippleArray, gl .DYNAMIC_DRAW);
      };
   })(),
   display: (function ()
   {
      const
         matrix                            = new Numbers_Matrix4 (),
         modelViewProjectionMatrixArray    = new Float32Array (16),
         invModelViewProjectionMatrixArray = new Float32Array (16);

      return function (gl, renderContext)
      {
         const
            browser            = this .getBrowser (),
            appearanceNode     = renderContext .appearanceNode,
            linePropertiesNode = appearanceNode .getLineProperties (),
            shaderNode         = appearanceNode .getShader (this, renderContext),
            blendModeNode      = appearanceNode .getBlendMode (),
            attribNodes        = this .getAttrib (),
            attribBuffers      = this .getAttribBuffers ();

         if (linePropertiesNode)
         {
            if (linePropertiesNode .getApplied () && linePropertiesNode .getLinetype () !== 1)
               this .updateLengthSoFar (gl, renderContext);

            if (linePropertiesNode .getTransformLines ())
            {
               const
                  renderObject        = renderContext .renderObject,
                  viewport            = renderObject .getViewVolume () .getViewport (),
                  projectionMatrix    = renderObject .getProjectionMatrix () .get (),
                  primitiveMode       = browser .getPrimitiveMode (gl .TRIANGLES),
                  transformShaderNode = browser .getLineTransformShader ();

               modelViewProjectionMatrixArray .set (matrix .assign (renderContext .modelViewMatrix) .multRight (projectionMatrix));
               invModelViewProjectionMatrixArray .set (matrix .inverse ());

               // Start

               transformShaderNode .enable (gl);

               gl .uniform4f (transformShaderNode .viewport, viewport .x, viewport .y, viewport .z, viewport .w);
               gl .uniformMatrix4fv (transformShaderNode .modelViewProjectionMatrix,    false, modelViewProjectionMatrixArray);
               gl .uniformMatrix4fv (transformShaderNode .invModelViewProjectionMatrix, false, invModelViewProjectionMatrixArray);
               gl .uniform1f (transformShaderNode .scale, linePropertiesNode .getLinewidthScaleFactor () / 2);

               // Setup vertex attributes.

               if (this .transformVertexArrayObject .enable (gl, shaderNode))
               {
                  const
                     lineStippleStride  = 6 * Float32Array .BYTES_PER_ELEMENT,
                     lineStippleOffset0 = 0,
                     lineStippleOffset1 = 3 * Float32Array .BYTES_PER_ELEMENT,
                     fogDepthStride     = 2 * Float32Array .BYTES_PER_ELEMENT,
                     fogDepthOffset0    = 0,
                     fogDepthOffset1    = 1 * Float32Array .BYTES_PER_ELEMENT,
                     colorStride        = 8 * Float32Array .BYTES_PER_ELEMENT,
                     colorOffset0       = 0,
                     colorOffset1       = 4 * Float32Array .BYTES_PER_ELEMENT,
                     vertexStride       = 8 * Float32Array .BYTES_PER_ELEMENT,
                     vertexOffset0      = 0,
                     vertexOffset1      = 4 * Float32Array .BYTES_PER_ELEMENT;

                  // for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  //    attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

                  transformShaderNode .enableFloatAttrib (gl, "x3d_LineStipple0", this .lineStippleBuffer, 3, lineStippleStride, lineStippleOffset0);
                  transformShaderNode .enableFloatAttrib (gl, "x3d_LineStipple1", this .lineStippleBuffer, 3, lineStippleStride, lineStippleOffset1);

                  if (this .hasFogCoords)
                  {
                     transformShaderNode .enableFloatAttrib (gl, "x3d_FogDepth0", this .fogDepthBuffer, 1, fogDepthStride, fogDepthOffset0);
                     transformShaderNode .enableFloatAttrib (gl, "x3d_FogDepth1", this .fogDepthBuffer, 1, fogDepthStride, fogDepthOffset1);
                  }

                  if (this .colorMaterial)
                  {
                     transformShaderNode .enableFloatAttrib (gl, "x3d_Color0", this .colorBuffer, 4, colorStride, colorOffset0);
                     transformShaderNode .enableFloatAttrib (gl, "x3d_Color1", this .colorBuffer, 4, colorStride, colorOffset1);
                  }

                  transformShaderNode .enableFloatAttrib (gl, "x3d_Vertex0", this .vertexBuffer, 4, vertexStride, vertexOffset0);
                  transformShaderNode .enableFloatAttrib (gl, "x3d_Vertex1", this .vertexBuffer, 4, vertexStride, vertexOffset1);
               }

               // Transform lines.

               gl .bindTransformFeedback (gl .TRANSFORM_FEEDBACK, browser .getLineTransformFeedback ());
               gl .bindBufferBase (gl .TRANSFORM_FEEDBACK_BUFFER, 0, this .trianglesBuffer);
               gl .enable (gl .RASTERIZER_DISCARD);
               gl .beginTransformFeedback (gl .POINTS);
               gl .drawArraysInstanced (gl .POINTS, 0, this .vertexCount / 2, 2);
               gl .endTransformFeedback ();
               gl .disable (gl .RASTERIZER_DISCARD);
               gl .bindTransformFeedback (gl .TRANSFORM_FEEDBACK, null);

               // DEBUG

               // const data = new Float32Array (13 * 6 * this .vertexCount / 2);
               // gl .bindBuffer (gl .ARRAY_BUFFER, this .trianglesBuffer);
               // gl .getBufferSubData (gl .ARRAY_BUFFER, 0, data);
               // console .log (data);

               // Render triangles.

               if (blendModeNode)
                  blendModeNode .enable (gl);

               // Setup shader.

               shaderNode .enable (gl);
               shaderNode .setUniforms (gl, this, renderContext);

               // Setup vertex attributes.

               if (this .thickVertexArrayObject .enable (gl, shaderNode))
               {
                  const
                     stride            = 12 * Float32Array .BYTES_PER_ELEMENT,
                     lineStippleOffset = 0,
                     fogCoordOffset    = 3 * Float32Array .BYTES_PER_ELEMENT,
                     colorOffset       = 4 * Float32Array .BYTES_PER_ELEMENT,
                     vertexOffset      = 8 * Float32Array .BYTES_PER_ELEMENT;

                  // for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  //    attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

                  shaderNode .enableLineStippleAttribute (gl, this .trianglesBuffer, stride, lineStippleOffset);

                  if (this .hasFogCoords)
                     shaderNode .enableFogDepthAttribute (gl, this .trianglesBuffer, stride, fogCoordOffset);

                  if (this .colorMaterial)
                     shaderNode .enableColorAttribute (gl, this .trianglesBuffer, stride, colorOffset);

                  shaderNode .enableVertexAttribute (gl, this .trianglesBuffer, stride, vertexOffset);

                  gl .bindBuffer (gl .ARRAY_BUFFER, null);
               }

               if (browser .getWireframe ())
               {
                  for (let i = 0, length = this .vertexCount * 3; i < length; i += 3)
                     gl .drawArrays (primitiveMode, i, 3);
               }
               else
               {
                  gl .frontFace (gl .CCW);
                  gl .enable (gl .CULL_FACE);
                  gl .drawArrays (primitiveMode, 0, this .vertexCount * 3);
               }

               if (blendModeNode)
                  blendModeNode .disable (gl);

               return;
            }
         }

         const primitiveMode = browser .getPrimitiveMode (this .getPrimitiveMode ());

         if (blendModeNode)
            blendModeNode .enable (gl);

         // Setup shader.

         shaderNode .enable (gl);
         shaderNode .setUniforms (gl, this, renderContext);

         // Setup vertex attributes.

         if (this .vertexArrayObject .enable (gl, shaderNode))
         {
            for (let i = 0, length = attribNodes .length; i < length; ++ i)
               attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

            shaderNode .enableLineStippleAttribute (gl, this .lineStippleBuffer, 0, 0);

            if (this .hasFogCoords)
               shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

            if (this .colorMaterial)
               shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

            shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);
         }

         gl .drawArrays (primitiveMode, 0, this .vertexCount);

         if (blendModeNode)
            blendModeNode .disable (gl);

         gl .lineWidth (1);
      };
   })(),
   displayParticles: function (gl, renderContext, particleSystem)
   {
      const
         browser        = this .getBrowser (),
         appearanceNode = renderContext .appearanceNode,
         shaderNode     = appearanceNode .getShader (this, renderContext),
         blendModeNode  = appearanceNode .getBlendMode (),
         attribNodes    = this .getAttrib (),
         attribBuffers  = this .getAttribBuffers (),
         primitiveMode  = browser .getPrimitiveMode (this .getPrimitiveMode ());

      if (blendModeNode)
         blendModeNode .enable (gl);

      // Setup shader.

      shaderNode .enable (gl);
      shaderNode .setUniforms (gl, this, renderContext);

      // Setup vertex attributes.

      const outputParticles = particleSystem .outputParticles;

      if (outputParticles .vertexArrayObject .update (this .updateParticles) .enable (gl, shaderNode))
      {
         const particleStride = particleSystem .particleStride;

         shaderNode .enableParticleAttribute (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
         shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset, 1);

         for (let i = 0, length = attribNodes .length; i < length; ++ i)
            attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

         if (this .hasFogCoords)
            shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

         if (this .colorMaterial)
            shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

         shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
         shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);

         this .updateParticles = false;
      }

      // Wireframes are always solid so only one drawing call is needed.

      gl .drawArraysInstanced (primitiveMode, 0, this .vertexCount, particleSystem .numParticles);

      if (blendModeNode)
         blendModeNode .disable (gl);

      gl .lineWidth (1);
   },
});

/* harmony default export */ const Rendering_X3DLineGeometryNode = (X3DLineGeometryNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/IndexedLineSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function IndexedLineSet (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.IndexedLineSet);

   this .fogCoordNode = null;
   this .colorNode    = null;
   this .normalNode   = null;
   this .coordNode    = null;
}

IndexedLineSet .prototype = Object .assign (Object .create (Rendering_X3DLineGeometryNode.prototype),
{
   constructor: IndexedLineSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_colorIndex", new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_coordIndex", new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorIndex",     new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "coordIndex",     new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",         new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",          new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "IndexedLineSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DLineGeometryNode.prototype.initialize.call (this);

      this ._set_colorIndex .addFieldInterest (this ._colorIndex);
      this ._set_coordIndex .addFieldInterest (this ._coordIndex);
      this ._attrib         .addInterest ("set_attrib__",   this);
      this ._fogCoord       .addInterest ("set_fogCoord__", this);
      this ._color          .addInterest ("set_color__",    this);
      this ._normal         .addInterest ("set_normal__",   this);
      this ._coord          .addInterest ("set_coord__",    this);

      this .set_attrib__ ();
      this .set_fogCoord__ ();
      this .set_color__ ();
      this .set_normal__ ();
      this .set_coord__ ();
   },
   set_attrib__: function ()
   {
      const attribNodes = this .getAttrib ();

      for (const attribNode of attribNodes)
      {
         attribNode .removeInterest ("requestRebuild", this);
         attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
      }

      attribNodes .length = 0;

      for (const node of this ._attrib)
      {
         const attribNode = X3DCast (Base_X3DConstants.X3DVertexAttributeNode, node);

         if (attribNode)
            attribNodes .push (attribNode);
      }

      for (const attribNode of attribNodes)
      {
         attribNode .addInterest ("requestRebuild", this);
         attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
      }

      this .updateVertexArrays ();
   },
   set_fogCoord__: function ()
   {
      if (this .fogCoordNode)
         this .fogCoordNode .removeInterest ("requestRebuild", this);

      this .fogCoordNode = X3DCast (Base_X3DConstants.FogCoordinate, this ._fogCoord);

      if (this .fogCoordNode)
         this .fogCoordNode .addInterest ("requestRebuild", this);
   },
   set_color__: function ()
   {
      if (this .colorNode)
      {
         this .colorNode .removeInterest ("requestRebuild", this);
         this .colorNode ._transparent .removeInterest ("set_transparent__", this);
      }

      this .colorNode = X3DCast (Base_X3DConstants.X3DColorNode, this ._color);

      if (this .colorNode)
      {
         this .colorNode .addInterest ("requestRebuild", this);
         this .colorNode ._transparent .addInterest ("set_transparent__", this);

         this .set_transparent__ ();
      }
      else
         this .setTransparent (false);
   },
   set_transparent__: function ()
   {
      this .setTransparent (this .colorNode .getTransparent ());
   },
   set_normal__: function ()
   {
      if (this .normalNode)
         this .normalNode .removeInterest ("requestRebuild", this);

      this .normalNode = X3DCast (Base_X3DConstants.X3DNormalNode, this ._normal);

      if (this .normalNode)
         this .normalNode .addInterest ("requestRebuild", this);
   },
   set_coord__: function ()
   {
      if (this .coordNode)
         this .coordNode .removeInterest ("requestRebuild", this);

      this .coordNode = X3DCast (Base_X3DConstants.X3DCoordinateNode, this ._coord);

      if (this .coordNode)
         this .coordNode .addInterest ("requestRebuild", this);
   },
   getColorPerVertexIndex: function (index)
   {
      if (index < this ._colorIndex .length)
         return this ._colorIndex [index];

      return this ._coordIndex [index];
   },
   getColorIndex: function (index)
   {
      if (index < this ._colorIndex .length)
         return this ._colorIndex [index];

      return index;
   },
   getPolylineIndices: function ()
   {
      const
         coordIndex = this ._coordIndex,
         polylines  = [ ];

      let polyline = [ ];

      if (coordIndex .length)
      {
         for (let i = 0, length = coordIndex .length; i < length; ++ i)
         {
            const index = coordIndex [i];

            if (index >= 0)
               // Add vertex.
               polyline .push (i);

            else
            {
               // Negativ index.
               // Add polylines.
               polylines .push (polyline);

               polyline = [ ];
            }
         }

         if (coordIndex [coordIndex .length - 1] >= 0)
         {
            polylines .push (polyline);
         }
      }

      return polylines;
   },
   build: function ()
   {
      if (! this .coordNode || this .coordNode .isEmpty ())
         return;

      const
         coordIndex     = this ._coordIndex,
         polylines      = this .getPolylineIndices (),
         colorPerVertex = this ._colorPerVertex .getValue (),
         attribNodes    = this .getAttrib (),
         numAttribNodes = attribNodes .length,
         attribArrays   = this .getAttribs (),
         fogCoordNode   = this .fogCoordNode,
         colorNode      = this .colorNode,
         coordNode      = this .coordNode,
         fogDepthArray  = this .getFogDepths (),
         colorArray     = this .getColors (),
         vertexArray    = this .getVertices ();

      // Fill GeometryNode

      let face = 0;

      for (const polyline of polylines)
      {
         // Create two vertices for each line.

         if (polyline .length > 1)
         {
            for (let line = 0, l_end = polyline .length - 1; line < l_end; ++ line)
            {
               for (let l = line, i_end = line + 2; l < i_end; ++ l)
               {
                  const
                     i     = polyline [l],
                     index = coordIndex [i];

                  for (let a = 0; a < numAttribNodes; ++ a)
                     attribNodes [a] .addValue (index, attribArrays [a]);

                  if (fogCoordNode)
                     fogCoordNode .addDepth (index, fogDepthArray);

                  if (colorNode)
                  {
                     if (colorPerVertex)
                        colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
                     else
                        colorNode .addColor (this .getColorIndex (face), colorArray);
                  }

                  coordNode .addPoint (index, vertexArray);
               }
            }
         }

         ++ face;
      }
   },
});

/* harmony default export */ const Rendering_IndexedLineSet = (IndexedLineSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DColorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DColorNode (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DColorNode);

   this .addChildObjects ("transparent", new x_ite_Fields.SFBool ());

   this ._transparent .setAccessType (Base_X3DConstants.outputOnly);
}

X3DColorNode .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: X3DColorNode,
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
});

/* harmony default export */ const Rendering_X3DColorNode = (X3DColorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/Color.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Color (executionContext)
{
   Rendering_X3DColorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Color);
}

Color .prototype = Object .assign (Object .create (Rendering_X3DColorNode.prototype),
{
   constructor: Color,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",    new x_ite_Fields.MFColor ()),
   ]),
   getTypeName: function ()
   {
      return "Color";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "color";
   },
   initialize: function ()
   {
      Rendering_X3DColorNode.prototype.initialize.call (this);

      this ._color .addInterest ("set_color__", this);

      this .set_color__ ();
   },
   set_color__: function ()
   {
      this .color  = this ._color .getValue ();
      this .length = this ._color .length;
   },
   addColor: function (index, array)
   {
      if (index >= 0 && index < this .length)
      {
         const color = this .color;

         index *= 3;

         array .push (color [index], color [index + 1], color [index + 2], 1);
      }
      else if (this .length)
      {
         const color = this .color;

         index = (this .length - 1) * 3;

         array .push (color [index], color [index + 1], color [index + 2], 1);
      }
      else
      {
         array .push (1, 1, 1, 1);
      }
   },
   addColors: function (array, min)
   {
      if (this .length)
      {
         const color = this .color;

         for (var index = 0, length = Math .min (min, this .length) * 3; index < length; index += 3)
            array .push (color [index], color [index + 1], color [index + 2], 1);

         if (this .length < min)
         {
            var index = (this .length - 1) * 3;

            const
               r = color [index],
               g = color [index + 1],
               b = color [index + 2];

            for (var index = length, length = min * 3; index < length; index += 3)
               array .push (r, g, b, 1);
         }
      }
      else
      {
         for (let index = 0; index < min; ++ index)
            array .push (1, 1, 1, 1);
      }

      return array;
   },
});

/* harmony default export */ const Rendering_Color = (Color);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Grouping/X3DGroupingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const _bboxNode = Symbol ();

function X3DGroupingContext () { }

X3DGroupingContext .prototype =
{
   initialize: function () { },
   getBBoxNode: function ()
   {
      const
         bboxNode       = new Shape_Shape (this .getPrivateScene ()),
         bboxGeometry   = new Rendering_IndexedLineSet (this .getPrivateScene ()),
         bboxColor      = new Rendering_Color (this .getPrivateScene ()),
         bboxCoordinate = new Rendering_Coordinate (this .getPrivateScene ());

      bboxNode ._geometry       = bboxGeometry;
      bboxGeometry ._coordIndex = new x_ite_Fields.MFFloat (0, 1, 2, 3, 0, -1, 4, 5, 6, 7, 4, -1, 0, 4, -1, 1, 5, -1, 2, 6, -1, 3, 7, -1);
      bboxGeometry ._color      = bboxColor;
      bboxGeometry ._coord      = bboxCoordinate;
      bboxColor ._color         = new x_ite_Fields.MFColor (new x_ite_Fields.SFColor (1, 1, 1));
      bboxCoordinate ._point    = new x_ite_Fields.MFVec3f (new x_ite_Fields.SFVec3f (0.5, 0.5, 0.5), new x_ite_Fields.SFVec3f (-0.5, 0.5, 0.5), new x_ite_Fields.SFVec3f (-0.5, -0.5, 0.5), new x_ite_Fields.SFVec3f (0.5, -0.5, 0.5), new x_ite_Fields.SFVec3f (0.5, 0.5, -0.5), new x_ite_Fields.SFVec3f (-0.5, 0.5, -0.5), new x_ite_Fields.SFVec3f (-0.5, -0.5, -0.5), new x_ite_Fields.SFVec3f (0.5, -0.5, -0.5));

      bboxCoordinate .setup ();
      bboxColor      .setup ();
      bboxGeometry   .setup ();
      bboxNode       .setup ();

      this [_bboxNode] = bboxNode;

      this .getBBoxNode = function () { return this [_bboxNode]; };

      Object .defineProperty (this, "getBBoxNode", { enumerable: false });

      return bboxNode;
   }
};

/* harmony default export */ const Grouping_X3DGroupingContext = (X3DGroupingContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering/Viewport.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const ViewVolumes = ObjectCache (Geometry_ViewVolume);

function Viewport (executionContext)
{
   Layering_X3DViewportNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Viewport);

   this .rectangle = new Numbers_Vector4 (0, 0, 0, 0);
}

Viewport .prototype = Object .assign (Object .create (Layering_X3DViewportNode.prototype),
{
   constructor: Viewport,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "clipBoundary",   new x_ite_Fields.MFFloat (0, 1, 0, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",       new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Viewport";
   },
   getComponentName: function ()
   {
      return "Layering";
   },
   getContainerField: function ()
   {
      return "viewport";
   },
   getRectangle: function (browser)
   {
      const viewport = browser .getViewport ();

      const
         left   = Math .floor (viewport [2] * this .getLeft ()),
         right  = Math .floor (viewport [2] * this .getRight ()),
         bottom = Math .floor (viewport [3] * this .getBottom ()),
         top    = Math .floor (viewport [3] * this .getTop ());

      this .rectangle .set (left,
                            bottom,
                            Math .max (0, right - left),
                            Math .max (0, top - bottom));

      return this .rectangle;
   },
   getLeft: function ()
   {
      return this ._clipBoundary .length > 0 ? this ._clipBoundary [0] : 0;
   },
   getRight: function ()
   {
      return this ._clipBoundary .length > 1 ? this ._clipBoundary [1] : 1;
   },
   getBottom: function ()
   {
      return this ._clipBoundary .length > 2 ? this ._clipBoundary [2] : 0;
   },
   getTop: function ()
   {
      return this ._clipBoundary .length > 3 ? this ._clipBoundary [3] : 1;
   },
   traverse: function (type, renderObject)
   {
      this .push (renderObject);

      switch (type)
      {
         case Rendering_TraverseType.POINTER:
         {
            if (this .getBrowser () .isPointerInRectangle (this .rectangle))
               Layering_X3DViewportNode.prototype.traverse.call (this, type, renderObject);

            break;
         }
         default:
            Layering_X3DViewportNode.prototype.traverse.call (this, type, renderObject);
            break;
      }

      this .pop (renderObject);
   },
   push: function (renderObject)
   {
      const
         viewVolumes = renderObject .getViewVolumes (),
         rectangle   = this .getRectangle (this .getBrowser ()),
         viewport    = viewVolumes .length ? viewVolumes .at (-1) .getViewport () : rectangle,
         viewVolume  = ViewVolumes .pop ();

      viewVolume .set (renderObject .getProjectionMatrix () .get (), viewport, rectangle);

      viewVolumes .push (viewVolume);
   },
   pop: function (renderObject)
   {
      ViewVolumes .push (renderObject .getViewVolumes () .pop ());
   },
});

/* harmony default export */ const Layering_Viewport = (Viewport);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Layering/X3DLayeringContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const _defaultViewport = Symbol ();

function X3DLayeringContext ()
{
   this [_defaultViewport] = new Layering_Viewport (this .getPrivateScene ());
}

X3DLayeringContext .prototype =
{
   initialize: function ()
   {
      this [_defaultViewport] .setPrivate (true);
      this [_defaultViewport] .setup ();
   },
   getDefaultViewport: function ()
   {
      return this [_defaultViewport];
   },
};

/* harmony default export */ const Layering_X3DLayeringContext = (X3DLayeringContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Lighting/X3DLightingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _maxLights     = Symbol (),
   _shadowBuffers = Symbol ();

function X3DLightingContext ()
{
   const
      gl                   = this .getContext (),
      maxTextureImageUnits = gl .getParameter (gl .MAX_TEXTURE_IMAGE_UNITS);

   if (maxTextureImageUnits > 8)
      this [_maxLights] = 8;
   else
      this [_maxLights] = 2;

   this [_shadowBuffers] = [ ]; // Shadow buffer cache
}

X3DLightingContext .prototype =
{
   initialize: function ()
   { },
   getMaxLights: function ()
   {
      return this [_maxLights];
   },
   popShadowBuffer: function (shadowMapSize)
   {
      try
      {
         const shadowBuffers = this [_shadowBuffers] [shadowMapSize];

         if (shadowBuffers)
         {
            if (shadowBuffers .length)
               return shadowBuffers .pop ();
         }
         else
            this [_shadowBuffers] [shadowMapSize] = [ ];

         return new Rendering_TextureBuffer (this, shadowMapSize, shadowMapSize);
      }
      catch (error)
      {
         // Couldn't create texture buffer.
         console .error (error);

         return null;
      }
   },
   pushShadowBuffer: function (buffer)
   {
      if (buffer)
         this [_shadowBuffers] [buffer .getWidth ()] .push (buffer);
   },
};

/* harmony default export */ const Lighting_X3DLightingContext = (X3DLightingContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/OrthoViewpoint.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













function OrthoViewpoint (executionContext)
{
   Navigation_X3DViewpointNode.call (this, executionContext);

   this .addType (Base_X3DConstants.OrthoViewpoint);

   this .addChildObjects ("fieldOfViewOffset", new x_ite_Fields.MFFloat (0, 0, 0, 0));

   this ._position         .setUnit ("length");
   this ._centerOfRotation .setUnit ("length");
   this ._fieldOfView      .setUnit ("length");

   this .projectionMatrix               = new Numbers_Matrix4 ();
   this .fieldOfViewOffsetInterpolator0 = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   this .fieldOfViewOffsetInterpolator1 = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   this .fieldOfViewOffsetInterpolator2 = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   this .fieldOfViewOffsetInterpolator3 = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   this .fieldOfViewScaleInterpolator   = new Interpolation_ScalarInterpolator (this .getBrowser () .getPrivateScene ());
}

OrthoViewpoint .prototype = Object .assign (Object .create (Navigation_X3DViewpointNode.prototype),
{
   constructor: OrthoViewpoint,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",          new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",       new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "position",          new x_ite_Fields.SFVec3f (0, 0, 10)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "orientation",       new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "centerOfRotation",  new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fieldOfView",       new x_ite_Fields.MFFloat (-1, -1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "jump",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "retainUserOffsets", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",          new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "OrthoViewpoint";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Navigation_X3DViewpointNode.prototype.initialize.call (this);

      this ._fieldOfView       .addInterest ("set_fieldOfView__", this);
      this ._fieldOfViewOffset .addInterest ("set_fieldOfView__", this);
      this ._fieldOfViewScale  .addInterest ("set_fieldOfView__", this);

      this .fieldOfViewOffsetInterpolator0 ._key = new x_ite_Fields.MFFloat (0, 1);
      this .fieldOfViewOffsetInterpolator1 ._key = new x_ite_Fields.MFFloat (0, 1);
      this .fieldOfViewOffsetInterpolator2 ._key = new x_ite_Fields.MFFloat (0, 1);
      this .fieldOfViewOffsetInterpolator3 ._key = new x_ite_Fields.MFFloat (0, 1);
      this .fieldOfViewScaleInterpolator   ._key = new x_ite_Fields.MFFloat (0, 1);

      this .fieldOfViewOffsetInterpolator0 .setup ();
      this .fieldOfViewOffsetInterpolator1 .setup ();
      this .fieldOfViewOffsetInterpolator2 .setup ();
      this .fieldOfViewOffsetInterpolator3 .setup ();
      this .fieldOfViewScaleInterpolator   .setup ();

      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator0 ._set_fraction);
      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator1 ._set_fraction);
      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator2 ._set_fraction);
      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator3 ._set_fraction);
      this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewScaleInterpolator   ._set_fraction);

      this .fieldOfViewOffsetInterpolator0 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
      this .fieldOfViewOffsetInterpolator1 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
      this .fieldOfViewOffsetInterpolator2 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
      this .fieldOfViewOffsetInterpolator3 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);

      this .fieldOfViewScaleInterpolator ._value_changed .addFieldInterest (this ._fieldOfViewScale);

      this .set_fieldOfView__ ();
   },
   set_fieldOfView__: function ()
   {
      const
         length           = this ._fieldOfView .length,
         fieldOfViewScale = this ._fieldOfViewScale .getValue ();

      this .minimumX = ((length > 0 ? this ._fieldOfView [0] : -1) + this ._fieldOfViewOffset [0]) * fieldOfViewScale;
      this .minimumY = ((length > 1 ? this ._fieldOfView [1] : -1) + this ._fieldOfViewOffset [1]) * fieldOfViewScale;
      this .maximumX = ((length > 2 ? this ._fieldOfView [2] :  1) + this ._fieldOfViewOffset [2]) * fieldOfViewScale;
      this .maximumY = ((length > 3 ? this ._fieldOfView [3] :  1) + this ._fieldOfViewOffset [3]) * fieldOfViewScale;

      this .sizeX = this .maximumX - this .minimumX;
      this .sizeY = this .maximumY - this .minimumY;
   },
   set_fieldOfViewOffset__: function ()
   {
      this ._fieldOfViewOffset [0] = this .fieldOfViewOffsetInterpolator0 ._value_changed .getValue ();
      this ._fieldOfViewOffset [1] = this .fieldOfViewOffsetInterpolator1 ._value_changed .getValue ();
      this ._fieldOfViewOffset [2] = this .fieldOfViewOffsetInterpolator2 ._value_changed .getValue ();
      this ._fieldOfViewOffset [3] = this .fieldOfViewOffsetInterpolator3 ._value_changed .getValue ();
   },
   setInterpolators: function (fromViewpointNode, toViewpointNode)
   {
      if (fromViewpointNode .getType () .includes (Base_X3DConstants.OrthoViewpoint))
      {
         const
            toLength   = toViewpointNode   ._fieldOfView .length,
            fromLength = fromViewpointNode ._fieldOfView .length;

         const
            offset0 = (fromLength > 0 ? fromViewpointNode ._fieldOfView [0] : -1) - (toLength > 0 ? toViewpointNode ._fieldOfView [0] : -1),
            offset1 = (fromLength > 1 ? fromViewpointNode ._fieldOfView [1] : -1) - (toLength > 1 ? toViewpointNode ._fieldOfView [1] : -1),
            offset2 = (fromLength > 2 ? fromViewpointNode ._fieldOfView [2] :  1) - (toLength > 2 ? toViewpointNode ._fieldOfView [2] :  1),
            offset3 = (fromLength > 3 ? fromViewpointNode ._fieldOfView [3] :  1) - (toLength > 3 ? toViewpointNode ._fieldOfView [3] :  1);

         this .fieldOfViewOffsetInterpolator0 ._keyValue = new x_ite_Fields.MFFloat (offset0, toViewpointNode ._fieldOfViewOffset [0]);
         this .fieldOfViewOffsetInterpolator1 ._keyValue = new x_ite_Fields.MFFloat (offset1, toViewpointNode ._fieldOfViewOffset [1]);
         this .fieldOfViewOffsetInterpolator2 ._keyValue = new x_ite_Fields.MFFloat (offset2, toViewpointNode ._fieldOfViewOffset [2]);
         this .fieldOfViewOffsetInterpolator3 ._keyValue = new x_ite_Fields.MFFloat (offset3, toViewpointNode ._fieldOfViewOffset [3]);

         this .fieldOfViewScaleInterpolator ._keyValue = new x_ite_Fields.MFFloat (fromViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

         this ._fieldOfViewOffset [0] = offset0;
         this ._fieldOfViewOffset [1] = offset1;
         this ._fieldOfViewOffset [2] = offset2;
         this ._fieldOfViewOffset [3] = offset3;

         this ._fieldOfViewScale = fromViewpointNode ._fieldOfViewScale .getValue ();
      }
      else
      {
         this .fieldOfViewOffsetInterpolator0 ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewOffset [0], toViewpointNode ._fieldOfViewOffset [0]);
         this .fieldOfViewOffsetInterpolator1 ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewOffset [1], toViewpointNode ._fieldOfViewOffset [1]);
         this .fieldOfViewOffsetInterpolator2 ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewOffset [2], toViewpointNode ._fieldOfViewOffset [2]);
         this .fieldOfViewOffsetInterpolator3 ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewOffset [3], toViewpointNode ._fieldOfViewOffset [3]);

         this .fieldOfViewScaleInterpolator ._keyValue = new x_ite_Fields.MFFloat (toViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

         this ._fieldOfViewOffset = toViewpointNode ._fieldOfViewOffset .getValue ();
         this ._fieldOfViewScale  = toViewpointNode ._fieldOfViewScale  .getValue ();
      }
   },
   getLogarithmicDepthBuffer: function ()
   {
      return false;
   },
   getMinimumX: function ()
   {
      return this .minimumX;
   },
   getMinimumY: function ()
   {
      return this .minimumY;
   },
   getMaximumX: function ()
   {
      return this .maximumX;
   },
   getMaximumY: function ()
   {
      return this .maximumY;
   },
   getSizeX: function ()
   {
      return this .sizeX;
   },
   getSizeY: function ()
   {
      return this .sizeY;
   },
   getMaxFarValue: function ()
   {
      return 1e5;
   },
   getScreenScale: function (point, viewport, screenScale)
   {
      const
         width  = viewport [2],
         height = viewport [3],
         sizeX  = this .sizeX,
         sizeY  = this .sizeY,
         aspect = width / height;

      if (aspect > sizeX / sizeY)
      {
         const s = sizeY / height;

         return screenScale .set (s, s, s);
      }
      else
      {
         const s = sizeX / width;

         return screenScale .set (s, s, s);
      }
   },
   getViewportSize: (function ()
   {
      const viewportSize = new Numbers_Vector2 (0, 0);

      return function (viewport, nearValue)
      {
         const
            width  = viewport [2],
            height = viewport [3],
            sizeX  = this .sizeX,
            sizeY  = this .sizeY,
            aspect = width / height;

         if (aspect > sizeX / sizeY)
            return viewportSize .set (sizeY * aspect, sizeY);

         return viewportSize .set (sizeX, sizeX / aspect);
      };
   })(),
   getLookAtDistance: function (bbox)
   {
      return bbox .size .magnitude () / 2 + 10;
   },
   getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
   {
      const
         width  = viewport [2],
         height = viewport [3],
         aspect = width / height,
         sizeX  = this .sizeX,
         sizeY  = this .sizeY;

      if (aspect > sizeX / sizeY)
      {
         const
            center  = (this .minimumX + this .maximumX) / 2,
            size1_2 = (sizeY * aspect) / 2;

         return Camera.ortho (center - size1_2, center + size1_2, this .minimumY, this .maximumY, nearValue, farValue, this .projectionMatrix);
      }
      else
      {
         const
            center  = (this .minimumY + this .maximumY) / 2,
            size1_2 = (sizeX / aspect) / 2;

         return Camera.ortho (this .minimumX, this .maximumX, center - size1_2, center + size1_2, nearValue, farValue, this .projectionMatrix);
      }
   },
});

/* harmony default export */ const Navigation_OrthoViewpoint = (OrthoViewpoint);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/X3DViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function X3DViewer (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);
}

X3DViewer .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: X3DViewer,
   getTypeName: function ()
   {
      return "X3DViewer";
   },
   initialize: function ()
   { },
   getActiveLayer: function ()
   {
      return this .getBrowser () .getActiveLayer ();
   },
   getViewport: function ()
   {
      return this .getBrowser () .getActiveLayer () .getViewport ();
   },
   getNavigationInfo: function ()
   {
      return this .getBrowser () .getActiveLayer () .getNavigationInfo ();
   },
   getActiveViewpoint: function ()
   {
      return this .getBrowser () .getActiveLayer () .getViewpoint ();
   },
   getStraightenHorizon: function ()
   {
      return this .getBrowser () .getBrowserOption ("StraightenHorizon");
   },
   getButton: function (button)
   {
      // If Alt key is pressed and button 0, then emulate button 1 (middle).
      if (button === 0)
      {
         if (this .getBrowser () .getAltKey ())
         {
            return 1;
         }
      }

      return button;
   },
   getPointOnCenterPlane: (function ()
   {
      const
         axis     = new Numbers_Vector3 (0, 0, -1),
         distance = new Numbers_Vector3 (0, 0, 0),
         far      = new Numbers_Vector3 (0, 0, 0);

      return function (x, y, result)
      {
         const
            navigationInfo   = this .getNavigationInfo (),
            viewpoint        = this .getActiveViewpoint (),
            viewport         = this .getViewport () .getRectangle (this .getBrowser ()),
            projectionMatrix = viewpoint .getProjectionMatrixWithLimits (navigationInfo .getNearValue (), navigationInfo .getFarValue (viewpoint), viewport);

         // Far plane point
         Geometry_ViewVolume.unProjectPoint (x, this .getBrowser () .getViewport () [3] - y, 0.9, Numbers_Matrix4.Identity, projectionMatrix, viewport, far);

         if (viewpoint instanceof Navigation_OrthoViewpoint)
            return result .set (far .x, far .y, -this .getDistanceToCenter (distance) .magnitude ());

         const direction = far .normalize ();

         return result .assign (direction) .multiply (this .getDistanceToCenter (distance) .magnitude () / direction .dot (axis));
      };
   })(),
   getDistanceToCenter: function (distance, positionOffset)
   {
      const viewpoint = this .getActiveViewpoint ();

      return (distance
         .assign (viewpoint .getPosition ())
         .add (positionOffset || viewpoint ._positionOffset .getValue ())
         .subtract (viewpoint .getUserCenterOfRotation ()));
   },
   trackballProjectToSphere: function (x, y, vector)
   {
      const viewport = this .getViewport () .getRectangle (this .getBrowser ());

      y = this .getBrowser () .getViewport () [3] - y;

      x = (x - viewport [0]) / viewport [2] - 0.5;
      y = (y - viewport [1]) / viewport [3] - 0.5;

      return vector .set (x, y, tbProjectToSphere (0.5, x, y));
   },
   lookAtPoint: function (x, y, straightenHorizon)
   {
      if (! this .touch (x, y))
         return;

      const hit = this .getBrowser () .getNearestHit ();

      this .getActiveViewpoint () .lookAtPoint (this .getActiveLayer (), hit .intersection .point, 2 - 1.618034, straightenHorizon);
   },
   lookAtBBox: (function ()
   {
      const bbox = new Geometry_Box3 ();

      return function (x, y, straightenHorizon)
      {
         if (! this .touch (x, y))
            return;

         const hit = this .getBrowser () .getNearestHit ();

         hit .shape .getBBox (bbox) .multRight (hit .modelViewMatrix);

         this .getActiveViewpoint () .lookAtBBox (this .getActiveLayer (), bbox, 2 - 1.618034, straightenHorizon);
      };
   })(),
   touch: function (x, y)
   {
      this .getBrowser () .touch (x, y, false);

      return this .getBrowser () .getHits () .length;
   },
   dispose: function () { },
});

function tbProjectToSphere (r, x, y)
{
   const d = Math .hypot (x, y);

   if (d < r * Math .sqrt (0.5)) // Inside sphere
   {
      return Math .sqrt (r * r - d * d);
   }

   // On hyperbola

   const t = r / Math .sqrt (2);

   return t * t / d;
}

/* harmony default export */ const Navigation_X3DViewer = (X3DViewer);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/X3DFollowerNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DFollowerNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DFollowerNode);

   this .buffer = [ ];

   // Auxillary variables
   this .a      = this .getVector ();
   this .vector = this .getVector ();
}

X3DFollowerNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DFollowerNode,
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);

      this .isLive () .addInterest ("set_live__", this);
   },
   getBuffer: function ()
   {
      return this .buffer;
   },
   getValue: function ()
   {
      return this ._set_value .getValue ();
   },
   getDestination: function ()
   {
      return this ._set_destination .getValue ();
   },
   getInitialValue: function ()
   {
      return this ._initialValue .getValue ();
   },
   getInitialDestination: function ()
   {
      return this ._initialDestination .getValue ();
   },
   setValue: function (value)
   {
      this ._value_changed = value;
   },
   setDestination: function (value)
   {
      this .destination .assign (value);
   },
   duplicate: function (value)
   {
      return value .copy ();
   },
   assign: function (buffer, i, value)
   {
      buffer [i] .assign (value);
   },
   equals: function (lhs, rhs, tolerance)
   {
      return this .a .assign (lhs) .subtract (rhs) .magnitude () < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return this .vector .assign (source) .lerp (destination, weight);
   },
   set_live__: function ()
   {
      if ((this .isLive () .getValue () || this .isPrivate ()) && this ._isActive .getValue ())
      {
         this .getBrowser () .prepareEvents () .addInterest ("prepareEvents", this);
         this .getBrowser () .addBrowserEvent ();
      }
      else
         this .getBrowser () .prepareEvents () .removeInterest ("prepareEvents", this);
   },
   set_active: function (value)
   {
      if (value !== this ._isActive .getValue ())
      {
         this ._isActive = value;

         this .set_live__ ();
      }
   },
});

/* harmony default export */ const Followers_X3DFollowerNode = (X3DFollowerNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/X3DChaserNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DChaserNode (executionContext)
{
   Followers_X3DFollowerNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DChaserNode);

   this .destination   = null;
   this .previousValue = null;
   this .bufferEndTime = 0;
   this .stepTime      = 0;

   // Auxillary variables
   this .deltaOut = this .getVector ();
}

X3DChaserNode .prototype = Object .assign (Object .create (Followers_X3DFollowerNode.prototype),
{
   constructor: X3DChaserNode,
   initialize: function ()
   {
      Followers_X3DFollowerNode.prototype.initialize.call (this);

      this ._set_value       .addInterest ("set_value__",       this);
      this ._set_destination .addInterest ("set_destination__", this);
      this ._duration        .addInterest ("set_duration__",    this);

      this .set_duration__ ();

      var
         buffer             = this .getBuffer (),
         initialValue       = this .getInitialValue (),
         initialDestination = this .getInitialDestination (),
         numBuffers         = this .getNumBuffers ();

      this .bufferEndTime = this .getBrowser () .getCurrentTime ();
      this .previousValue = this .duplicate (initialValue);

      buffer [0] = this .duplicate (initialDestination);

      for (var i = 1; i < numBuffers; ++ i)
         buffer [i] = this .duplicate (initialValue);

      this .destination = this .duplicate (initialDestination);

      if (this .equals (initialDestination, initialValue, this .getTolerance ()))
         this .setValue (initialDestination);

      else
         this .set_active (true);
   },
   getNumBuffers: function ()
   {
      return 60;
   },
   getTolerance: function ()
   {
      return 1e-8;
   },
   getArray: function ()
   {
      return this .getVector ();
   },
   setPreviousValue: function (value)
   {
      this .previousValue .assign (value);
   },
   step: function (value1, value2, t)
   {
      this .output .add (this .deltaOut .assign (value1) .subtract (value2) .multiply (t));
   },
   stepResponse: function (t)
   {
      if (t <= 0)
         return 0;

      var duration = this ._duration .getValue ();

      if (t >= duration)
         return 1;

      return 0.5 - 0.5 * Math .cos ((t / duration) * Math .PI);
   },
   set_value__: function ()
   {
      if (! this ._isActive .getValue ())
         this .bufferEndTime = this .getBrowser () .getCurrentTime ();

      var
         buffer = this .getBuffer (),
         value  = this .getValue ();

      for (var i = 0, length = buffer .length; i < length; ++ i)
         this .assign (buffer, i, value);

      this .setPreviousValue (value);
      this .setValue (value);

      this .set_active (true);
   },
   set_destination__: function ()
   {
      this .setDestination (this .getDestination ());

      if (! this ._isActive .getValue ())
         this .bufferEndTime = this .getBrowser () .getCurrentTime ();

      this .set_active (true);
   },
   set_duration__: function ()
   {
      this .stepTime = this ._duration .getValue () / this .getNumBuffers ();
   },
   prepareEvents: function ()
   {
      var
         buffer     = this .getBuffer (),
         numBuffers = buffer .length,
         fraction   = this .updateBuffer ();

      this .output = this .interpolate (this .previousValue,
                                          buffer [numBuffers - 1],
                                          this .stepResponse ((numBuffers - 1 + fraction) * this .stepTime));

      for (var i = numBuffers - 2; i >= 0; -- i)
      {
         this .step (buffer [i], buffer [i + 1], this .stepResponse ((i + fraction) * this .stepTime));
      }

      this .setValue (this .output);

      if (this .equals (this .output, this .destination, this .getTolerance ()))
         this .set_active (false);
   },
   updateBuffer: function ()
   {
      var
         buffer     = this .getBuffer (),
         numBuffers = buffer .length,
         fraction   = (this .getBrowser () .getCurrentTime () - this .bufferEndTime) / this .stepTime;

      if (fraction >= 1)
      {
         var seconds = Math .floor (fraction);

         fraction -= seconds;

         if (seconds < numBuffers)
         {
            this .setPreviousValue (buffer [numBuffers - seconds]);

            for (var i = numBuffers - 1; i >= seconds; -- i)
            {
               this .assign (buffer, i, buffer [i - seconds])
            }

            for (var i = 0; i < seconds; ++ i)
            {
               var alpha = i / seconds;

               this .assign (buffer, i, this .interpolate (this .destination, buffer [seconds], alpha))
            }
         }
         else
         {
            this .setPreviousValue (seconds == numBuffers ? buffer [0] : this .destination);

            for (var i = 0; i < numBuffers; ++ i)
               this .assign (buffer, i, this .destination);
         }

         this .bufferEndTime += seconds * this .stepTime;
      }

      return fraction;
   },
});

/* harmony default export */ const Followers_X3DChaserNode = (X3DChaserNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/PositionChaser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionChaser (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionChaser);
}

PositionChaser .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
{
   constructor: PositionChaser,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "PositionChaser";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
});

/* harmony default export */ const Followers_PositionChaser = (PositionChaser);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/OrientationChaser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









var
   OrientationChaser_a        = new Numbers_Rotation4 (0, 0, 1, 0),
   rotation = new Numbers_Rotation4 (0, 0, 1, 0);

function OrientationChaser (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);

   this .addType (Base_X3DConstants.OrientationChaser);

   this ._set_value          .setUnit ("angle");
   this ._set_destination    .setUnit ("angle");
   this ._initialValue       .setUnit ("angle");
   this ._initialDestination .setUnit ("angle");
   this ._value_changed      .setUnit ("angle");
}

OrientationChaser .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
{
   constructor: OrientationChaser,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFRotation ()),
   ]),
   getTypeName: function ()
   {
      return "OrientationChaser";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Rotation4 (0, 0, 1, 0);
   },
   equals: function (lhs, rhs, tolerance)
   {
      OrientationChaser_a .assign (lhs) .inverse () .multRight (rhs);

      return Math .abs (OrientationChaser_a .angle) < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return rotation .assign (source) .slerp (destination, weight);
   },
   step: function (value1, value2, t)
   {
      this .deltaOut .assign (value2) .inverse () .multRight (value1) .multLeft (this .output);

      this .output .slerp (this .deltaOut, t);
   },
});

/* harmony default export */ const Followers_OrientationChaser = (OrientationChaser);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/ExamineViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













const macOS = /Mac OS X/i .test (navigator .userAgent)

const
   MOTION_TIME       = 0.05 * 1000,
   SPIN_RELEASE_TIME = 0.04 * 1000,
   SPIN_ANGLE        = 0.003,
   SPIN_FACTOR       = 0.6,
   SCROLL_FACTOR     = macOS ? 1 / 120 : 1 / 20,
   MOVE_TIME         = 0.2,
   ROTATE_TIME       = 0.2,
   MAX_ANGLE         = 0.97;

function ExamineViewer (executionContext)
{
   Navigation_X3DViewer.call (this, executionContext);

   this .button                   = -1;
   this .orientationOffset        = new Numbers_Rotation4 (0, 0, 1, 0);
   this .fromVector               = new Numbers_Vector3 (0, 0, 0);
   this .toVector                 = new Numbers_Vector3 (0, 0, 0);
   this .fromPoint                = new Numbers_Vector3 (0, 0, 0);
   this .toPoint                  = new Numbers_Vector3 (0, 0, 0);
   this .rotation                 = new Numbers_Rotation4 (0, 0, 1, 0);
   this .pressTime                = 0;
   this .motionTime               = 0;

   this .touchMode                = 0;
   this .touch1                   = new Numbers_Vector2 (0, 0);
   this .touch2                   = new Numbers_Vector2 (0, 0);
   this .tapStart                 = 0;
   this .dblTapInterval           = 0.4;

   this .initialPositionOffset    = new Numbers_Vector3 (0, 0, 0);
   this .initialOrientationOffset = new Numbers_Rotation4 (0, 0, 1, 0);
   this .positionChaser           = new Followers_PositionChaser (executionContext);
   this .centerOfRotationChaser   = new Followers_PositionChaser (executionContext);
   this .rotationChaser           = new Followers_OrientationChaser (executionContext);
}

ExamineViewer .prototype = Object .assign (Object .create (Navigation_X3DViewer.prototype),
{
   constructor: ExamineViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
   initialize: function ()
   {
      Navigation_X3DViewer.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         element = browser .getSurface ();

      // Disconnect from spin.

      this .getNavigationInfo () ._transitionStart .addInterest ("disconnect", this);
      browser ._activeViewpoint .addInterest ("set_activeViewpoint__", this);

      // Bind pointing device events.

      element .on ("mousedown.ExamineViewer",  this .mousedown  .bind (this));
      element .on ("mouseup.ExamineViewer",    this .mouseup    .bind (this));
      element .on ("dblclick.ExamineViewer",   this .dblclick   .bind (this));
      element .on ("mousewheel.ExamineViewer", this .mousewheel .bind (this));

      element .on ("touchstart.ExamineViewer",  this .touchstart .bind (this));
      element .on ("touchend.ExamineViewer",    this .touchend   .bind (this));

      // Setup scroll chaser.

      this .positionChaser ._duration = MOVE_TIME;
      this .positionChaser .setPrivate (true);
      this .positionChaser .setup ();

      this .centerOfRotationChaser ._duration = MOVE_TIME;
      this .centerOfRotationChaser .setPrivate (true);
      this .centerOfRotationChaser .setup ();

      this .rotationChaser ._duration = ROTATE_TIME;
      this .rotationChaser .setPrivate (true);
      this .rotationChaser .setup ();

      this .set_activeViewpoint__ ();
   },
   set_activeViewpoint__: function ()
   {
      if (this .getStraightenHorizon ())
      {
         const viewpoint = this .getActiveViewpoint ();

         if (viewpoint)
            viewpoint ._orientationOffset = this .getOrientationOffset (Numbers_Rotation4.Identity, viewpoint ._orientationOffset .getValue (), false);
      }

      this .disconnect ();
   },
   mousedown: function (event)
   {
      if (this .button >= 0)
         return;

      this .pressTime = performance .now ();

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .getButton (event .button))
      {
         case 0:
         {
            // Start rotate.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            $(document) .on ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
            $(document) .on ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
            $(document) .on ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

            this .disconnect ();
            this .getActiveViewpoint () .transitionStop ();
            this .getBrowser () .setCursor ("MOVE");

            this .trackballProjectToSphere (x, y, this .fromVector);
            this .rotation .assign (Numbers_Rotation4.Identity);

            this .motionTime = 0;

            this ._isActive = true;
            break;
         }
         case 1:
         {
            // Start pan.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            $(document) .on ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
            $(document) .on ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
            $(document) .on ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

            this .disconnect ();
            this .getActiveViewpoint () .transitionStop ();
            this .getBrowser () .setCursor ("MOVE");

            this .getPointOnCenterPlane (x, y, this .fromPoint);

            this ._isActive = true;
            break;
         }
      }
   },
   mouseup: function (event)
   {
      if (event .button !== this .button)
         return;

      this .button = -1;

      $(document) .off (".ExamineViewer" + this .getId ());

      switch (this .getButton (event .button))
      {
         case 0:
         {
            // End rotate.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            const viewpoint = this .getActiveViewpoint ();

            this .getBrowser () .setCursor ("DEFAULT");

            if (Math .abs (this .rotation .angle) > SPIN_ANGLE && performance .now () - this .motionTime < SPIN_RELEASE_TIME)
            {
               if (this .getStraightenHorizon ())
                  this .rotation = this .getHorizonRotation (this .rotation);

               this .addSpinning (this .rotation);
            }

            this ._isActive = false;
            break;
         }
         case 1:
         {
            // End pan.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .getBrowser () .setCursor ("DEFAULT");

            this ._isActive = false;
            break;
         }
      }
   },
   dblclick: function (event)
   {
      // Stop event propagation.
      event .preventDefault ();
      event .stopImmediatePropagation ();

      const
         element = this .getBrowser () .getSurface (),
         offset  = element .offset (),
         x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
         y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

      this .disconnect ();
      this .lookAtBBox (x, y, this .getStraightenHorizon ());
   },
   mousemove: (function ()
   {
      const fromPoint = new Numbers_Vector3 (0, 0, 0);

      return function (event)
      {
         const
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (this .button))
         {
            case 0:
            {
               // Rotate view around Viewpoint.centerOfRotation.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               const toVector = this .trackballProjectToSphere (x, y, this .toVector);

               this .rotation .setFromToVec (toVector, this .fromVector);

               if (Math .abs (this .rotation .angle) < SPIN_ANGLE && performance .now () - this .pressTime < MOTION_TIME)
                  return;

               this .addRotate (this .rotation);

               this .fromVector .assign (toVector);
               this .motionTime = performance .now ();
               break;
            }
            case 1:
            {
               // Move view along center plane.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               const
                  viewpoint   = this .getActiveViewpoint (),
                  toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
                  translation = viewpoint .getUserOrientation () .multVecRot (fromPoint .assign (this .fromPoint) .subtract (toPoint));

               this .addMove (translation, translation);

               this .fromPoint .assign (toPoint);
               break;
            }
         }
      };
   })(),
   mousewheel: (function ()
   {
      const
         step        = new Numbers_Vector3 (0, 0, 0),
         translation = new Numbers_Vector3 (0, 0, 0);

      return function (event)
      {
         // Stop event propagation.
         event .preventDefault ();
         event .stopImmediatePropagation ();

         // Change viewpoint position.

         const
            browser   = this .getBrowser (),
            viewpoint = this .getActiveViewpoint ();

         browser .prepareEvents () .removeInterest ("spin", this);
         viewpoint .transitionStop ();

         this .getDistanceToCenter (step) .multiply (event .zoomFactor || SCROLL_FACTOR);
         viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .magnitude ()));

         if (event .deltaY > 0)
            this .addMove (translation .negate (), Numbers_Vector3.Zero);

         else if (event .deltaY < 0)
            this .addMove (translation, Numbers_Vector3.Zero);
      };
   })(),
   touchstart: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // Start rotate (button 0).

            event .button = 0;
            event .pageX  = touches [0] .pageX;
            event .pageY  = touches [0] .pageY;

            this .mousedown (event);

            // Remember tap.

            this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
            break;
         }
         case 2:
         {
            // End rotate (button 0).

            this .touchend (event);

            // Start move (button 1).

            event .button = 1;
            event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
            event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

            this .mousedown (event);

            // Start zoom (mouse wheel).

            this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
            this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
            break;
         }
         case 3:
         {
            // End move (button 1).
            this .touchend (event);
            break;
         }
      }
   },
   touchend: function (event)
   {
      switch (this .button)
      {
         case 0:
         {
            // End rotate (button 0).

            event .button = 0;
            event .pageX  = this .touch1 .x;
            event .pageY  = this .touch1 .y;

            this .mouseup (event);

            // Start dblclick (button 0).

            if (this .tapedTwice)
            {
               this .dblclick (event);
            }
            else
            {
               this .tapedTwice = true;

               setTimeout (function () { this .tapedTwice = false; } .bind (this), 300);
            }

            break;
         }
         case 1:
         {
            // End move (button 1).

            this .touchMode = 0;
            event .button   = 1;

            this .mouseup (event);
            break;
         }
      }
   },
   touchmove: (function ()
   {
      const
         MOVE_ANGLE   = 0.7,
         ZOOM_ANGLE   = -0.7,
         touch1Change = new Numbers_Vector2 (0, 0),
         touch2Change = new Numbers_Vector2 (0, 0);

      return function (event)
      {
         const touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Rotate (button 0).

               event .pageX = touches [0] .pageX;
               event .pageY = touches [0] .pageY;

               this .mousemove (event);
               break;
            }
            case 2:
            {
               touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
               touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

               const
                  move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
                  zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE,
                  mode = this .touchMode || (move ? 1 : (zoom ? 2 : 0));

               switch (mode)
               {
                  case 1:
                  {
                     // Move (button 1).

                     this .touchMode = 1;

                     event .pageX = (touches [0] .pageX + touches [1] .pageX) / 2;
                     event .pageY = (touches [0] .pageY + touches [1] .pageY) / 2;

                     this .mousemove (event);

                     break;
                  }
                  case 2:
                  {
                     // Zoom (mouse wheel).

                     this .touchMode = 2;

                     const distance1 = this .touch1 .distance (this .touch2);

                     this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                     this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

                     const
                        distance2 = this .touch1 .distance (this .touch2),
                        delta     = distance2 - distance1;

                     event .deltaY     = delta;
                     event .zoomFactor = Math .abs (delta) / $(window) .width ();

                     this .mousewheel (event);

                     break;
                  }
               }

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
               break;
            }
         }
      };
   })(),
   spin: function ()
   {
      const viewpoint = this .getActiveViewpoint ();

      this .orientationOffset .assign (viewpoint ._orientationOffset .getValue ());

      viewpoint ._orientationOffset = this .getOrientationOffset (this .rotation, this .orientationOffset);
      viewpoint ._positionOffset    = this .getPositionOffset (viewpoint ._positionOffset .getValue (), this .orientationOffset, viewpoint ._orientationOffset .getValue ());
   },
   set_positionOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._positionOffset = value;
   },
   set_centerOfRotationOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._centerOfRotationOffset = value;
   },
   set_rotation__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._orientationOffset = this .getOrientationOffset (value .getValue (), this .initialOrientationOffset, false);
      viewpoint ._positionOffset    = this .getPositionOffset (this .initialPositionOffset, this .initialOrientationOffset, viewpoint ._orientationOffset .getValue ());
   },
   addRotate: (function ()
   {
      const destination = new Numbers_Rotation4 ();

      return function (rotationChange)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .rotationChaser ._isActive .getValue () && this .rotationChaser ._value_changed .hasInterest ("set_rotation__", this))
         {
            try
            {
               destination .assign (this .rotationChaser ._set_destination .getValue ())
                  .multLeft (rotationChange);

               // Check for critical angle.
               this .getOrientationOffset (destination, this .initialOrientationOffset, true);

               this .rotationChaser ._set_destination = destination;
            }
            catch (error)
            {
               // Slide along critical angle.

               rotationChange = this .getHorizonRotation (rotationChange);

               destination .assign (this .rotationChaser ._set_destination .getValue ())
                  .multLeft (rotationChange);

               this .rotationChaser ._set_destination = destination;
            }
         }
         else
         {
            try
            {
               this .initialOrientationOffset .assign (viewpoint ._orientationOffset .getValue ());
               this .initialPositionOffset    .assign (viewpoint ._positionOffset    .getValue ());

               // Check for critical angle.
               this .getOrientationOffset (rotationChange, this .initialOrientationOffset, true);

               this .rotationChaser ._set_value       = Numbers_Rotation4.Identity;
               this .rotationChaser ._set_destination = rotationChange;
            }
            catch (error)
            {
               // Slide along critical angle.

               this .rotationChaser ._set_value       = Numbers_Rotation4.Identity;
               this .rotationChaser ._set_destination = this .getHorizonRotation (rotationChange);
            }
         }

         this .disconnect ();
         this .rotationChaser ._value_changed .addInterest ("set_rotation__", this);
      };
   })(),
   addSpinning: (function ()
   {
      const rotation = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (rotationChange)
      {
         this .disconnect ();
         this .getBrowser () .prepareEvents () .addInterest ("spin", this);

         this .rotation .assign (rotation .assign (Numbers_Rotation4.Identity) .slerp (rotationChange, SPIN_FACTOR));
      };
   })(),
   addMove: (function ()
   {
      const
         positionOffset         = new Numbers_Vector3 (0, 0, 0),
         centerOfRotationOffset = new Numbers_Vector3 (0, 0, 0);

      return function (positionOffsetChange, centerOfRotationOffsetChange)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .positionChaser ._isActive .getValue () && this .positionChaser ._value_changed .hasInterest ("set_positionOffset__", this))
         {
            positionOffset
               .assign (this .positionChaser ._set_destination .getValue ())
               .add (positionOffsetChange);

            this .positionChaser ._set_destination = positionOffset;
         }
         else
         {
            positionOffset
               .assign (viewpoint ._positionOffset .getValue ())
               .add (positionOffsetChange);

            this .positionChaser ._set_value       = viewpoint ._positionOffset;
            this .positionChaser ._set_destination = positionOffset;
         }

         if (this .centerOfRotationChaser ._isActive .getValue () && this .centerOfRotationChaser ._value_changed .hasInterest ("set_centerOfRotationOffset__", this))
         {
            centerOfRotationOffset
               .assign (this .centerOfRotationChaser ._set_destination .getValue ())
               .add (centerOfRotationOffsetChange);

            this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
         }
         else
         {
            centerOfRotationOffset
               .assign (viewpoint ._centerOfRotationOffset .getValue ())
               .add (centerOfRotationOffsetChange);

            this .centerOfRotationChaser ._set_value       = viewpoint ._centerOfRotationOffset;
            this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
         }

         this .disconnect ();
         this .positionChaser         ._value_changed .addInterest ("set_positionOffset__",         this);
         this .centerOfRotationChaser ._value_changed .addInterest ("set_centerOfRotationOffset__", this);
      };
   })(),
   getPositionOffset: (function ()
   {
      const
         distance = new Numbers_Vector3 (0, 0, 0),
         d        = new Numbers_Vector3 (0, 0, 0),
         oob      = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (positionOffsetBefore, orientationOffsetBefore, orientationOffsetAfter)
      {
         this .getDistanceToCenter (distance, positionOffsetBefore);

         return (oob
            .assign (orientationOffsetBefore)
            .inverse ()
            .multRight (orientationOffsetAfter)
            .multVecRot (d .assign (distance))
            .subtract (distance)
            .add (positionOffsetBefore));
      };
   })(),
   getOrientationOffset: (function ()
   {
      const
         userOrientation   = new Numbers_Rotation4 (0, 0, 1, 0),
         orientationOffset = new Numbers_Rotation4 (0, 0, 1, 0),
         zAxis             = new Numbers_Vector3 (0, 0, 0);

      return function (rotation, orientationOffsetBefore, _throw)
      {
         const
            viewpoint         = this .getActiveViewpoint (),
            straightenHorizon = this .getStraightenHorizon ();

         userOrientation
            .assign (rotation)
            .multRight (viewpoint .getOrientation ())
            .multRight (orientationOffsetBefore);

         if (straightenHorizon)
            viewpoint .straightenHorizon (userOrientation, this .getUpVector (viewpoint));

         const orientationOffsetAfter = orientationOffset
            .assign (viewpoint .getOrientation ())
            .inverse ()
            .multRight (userOrientation);

         if (straightenHorizon)
         {
            if (! _throw)
               return orientationOffsetAfter;

            const userVector = userOrientation .multVecRot (zAxis .assign (Numbers_Vector3.zAxis));

            if (Math .abs (this .getUpVector (viewpoint) .dot (userVector)) < MAX_ANGLE)
               return orientationOffsetAfter;

            throw new Error ("Critical angle");
         }
         else
         {
            return orientationOffsetAfter;
         }
      };
   })(),
   getHorizonRotation: (function ()
   {
      const zAxis = new Numbers_Vector3 (0, 0, 0);

      return function (rotation)
      {
         const
            V = rotation .multVecRot (zAxis .assign (Numbers_Vector3.zAxis)),
            N = Numbers_Vector3.cross (Numbers_Vector3.yAxis, V),
            H = Numbers_Vector3.cross (N, Numbers_Vector3.yAxis);

         return new Numbers_Rotation4 (Numbers_Vector3.zAxis, H);
      };
   })(),
   getUpVector: function (viewpoint)
   {
      if (viewpoint .getTypeName () !== "GeoViewpoint")
         return viewpoint .getUpVector ();

      if (viewpoint .getUserPosition () .magnitude () < 6.5e6)
         return viewpoint .getUpVector ();

      return Numbers_Vector3.zAxis;
   },
   disconnect: function ()
   {
      const browser = this .getBrowser ();

      this .positionChaser         ._value_changed .removeInterest ("set_positionOffset__",         this);
      this .centerOfRotationChaser ._value_changed .removeInterest ("set_centerOfRotationOffset__", this);
      this .rotationChaser         ._value_changed .removeInterest ("set_rotation__",               this);

      browser .prepareEvents () .removeInterest ("spin", this);
   },
   dispose: function ()
   {
      const browser = this .getBrowser ();

      this .disconnect ();
      browser ._activeViewpoint .removeInterest ("set_activeViewpoint__", this);
      browser .getSurface () .off (".ExamineViewer");
      $(document) .off (".ExamineViewer" + this .getId ());
   },
});

/* harmony default export */ const Navigation_ExamineViewer = (ExamineViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/X3DFlyViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











const X3DFlyViewer_macOS = /Mac OS X/i .test (navigator .userAgent)

const
   SPEED_FACTOR           = 0.007,
   SHIFT_SPEED_FACTOR     = 4 * SPEED_FACTOR,
   ROTATION_SPEED_FACTOR  = 1.4,
   ROTATION_LIMIT         = 40,
   PAN_SPEED_FACTOR       = SPEED_FACTOR,
   PAN_SHIFT_SPEED_FACTOR = 1.4 * PAN_SPEED_FACTOR,
   ROLL_ANGLE             = X3DFlyViewer_macOS ? Math .PI / 512 : Math .PI / 32,
   X3DFlyViewer_ROTATE_TIME            = 0.3;

const
   MOVE = 0,
   PAN  = 1;

function X3DFlyViewer (executionContext)
{
   Navigation_X3DViewer.call (this, executionContext);

   const
      browser = this .getBrowser (),
      gl      = browser .getContext ();

   this .button            = -1;
   this .fromVector        = new Numbers_Vector3 (0, 0, 0);
   this .toVector          = new Numbers_Vector3 (0, 0, 0);
   this .direction         = new Numbers_Vector3 (0, 0, 0);
   this .startTime         = 0;
   this .event             = null;
   this .lookAround        = false;
   this .orientationChaser = new Followers_OrientationChaser (executionContext);
   this .lineCount         = 2;
   this .lineArray         = new Float32Array (this .lineCount * 4) .fill (1);
   this .lineBuffer        = gl .createBuffer ();
   this .lineArrayObject   = new Rendering_VertexArray ();
   this .geometryContext   = new Rendering_GeometryContext ({ geometryType: 1 });
}

X3DFlyViewer .prototype = Object .assign (Object .create (Navigation_X3DViewer.prototype),
{
   constructor: X3DFlyViewer,
   initialize: function ()
   {
      Navigation_X3DViewer.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         element = browser .getSurface ();

      // Bind pointing device events.

      element .on ("mousedown.X3DFlyViewer",  this .mousedown  .bind (this));
      element .on ("mouseup.X3DFlyViewer",    this .mouseup    .bind (this));
      element .on ("mousewheel.X3DFlyViewer", this .mousewheel .bind (this));

      element .on ("touchstart.X3DFlyViewer", this .touchstart .bind (this));
      element .on ("touchend.X3DFlyViewer",   this .touchend   .bind (this));

      browser ._controlKey .addInterest ("set_controlKey__", this);

      // Setup look around chaser.

      this .orientationChaser ._duration = X3DFlyViewer_ROTATE_TIME;
      this .orientationChaser .setPrivate (true);
      this .orientationChaser .setup ();
   },
   addCollision: function () { },
   removeCollision: function () { },
   set_controlKey__: function ()
   {
      if (this .event && this .event .button === 0)
      {
         this .button = -1;
         this .mousedown (this .event);
      }
   },
   mousedown: function (event)
   {
      if (this .button >= 0)
         return;

      this .event = event;

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .getButton (event .button))
      {
         case 0:
         {
            // Start walk or fly.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            $(document) .on ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));
            $(document) .on ("touchend.X3DFlyViewer"  + this .getId (), this .touchend  .bind (this));
            $(document) .on ("touchmove.X3DFlyViewer" + this .getId (), this .touchmove .bind (this));

            this .disconnect ();
            this .getActiveViewpoint () .transitionStop ();
            this .getBrowser () .setCursor ("MOVE");
            this .addCollision ();

            if (this .getBrowser () .getControlKey () || this .lookAround)
            {
               // Look around.

               this .trackballProjectToSphere (x, y, this .fromVector);
            }
            else
            {
               // Move.

               this .fromVector .set (x, 0, y);
               this .toVector   .assign (this .fromVector);

               this .getFlyDirection (this .fromVector, this .toVector, this .direction);
               this .addFly ();

               if (this .getBrowser () .getBrowserOption ("Rubberband"))
                  this .getBrowser () .finished () .addInterest ("display", this, MOVE);
            }

            this ._isActive = true;
            break;
         }
         case 1:
         {
            // Start pan.

            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            $(document) .on ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));

            this .disconnect ();
            this .getActiveViewpoint () .transitionStop ();
            this .getBrowser () .setCursor ("MOVE");
            this .addCollision ();

            this .fromVector .set (x, -y, 0);
            this .toVector   .assign (this .fromVector);
            this .direction  .set (0, 0, 0);

            this .addPan ();

            if (this .getBrowser () .getBrowserOption ("Rubberband"))
               this .getBrowser () .finished () .addInterest ("display", this, PAN);

            this ._isActive = true;
            break;
         }
      }
   },
   mouseup: function (event)
   {
      event .preventDefault ();

      if (event .button !== this .button)
         return;

      this .event  = null;
      this .button = -1;

      $(document) .off (".X3DFlyViewer" + this .getId ());

      this .disconnect ();
      this .getBrowser () .setCursor ("DEFAULT");
      this .removeCollision ();

      this ._isActive = false;
   },
   mousemove: function (event)
   {
      this .getBrowser () .addBrowserEvent ();

      this .event = event;

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .getButton (this .button))
      {
         case 0:
         {
            if (this .getBrowser () .getControlKey () || this .lookAround)
            {
               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               // Look around

               const toVector = this .trackballProjectToSphere (x, y, this .toVector);

               this .addRotation (this .fromVector, toVector);
               this .fromVector .assign (toVector);
               break;
            }
            else
            {
               // Fly

               this .toVector .set (x, 0, y);
               this .getFlyDirection (this .fromVector, this .toVector, this .direction);
               break;
            }
         }
         case 1:
         {
            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            // Pan

            this .toVector  .set (x, -y, 0);
            this .direction .assign (this .toVector) .subtract (this .fromVector);
            break;
         }
      }
   },
   mousewheel: function (event)
   {
      // Stop event propagation.

      event .preventDefault ();
      event .stopImmediatePropagation ();

      // Change viewpoint position.

      const viewpoint = this .getActiveViewpoint ();

      viewpoint .transitionStop ();

      if (event .deltaY > 0)
         this .addRoll (-ROLL_ANGLE);

      else if (event .deltaY < 0)
         this .addRoll (ROLL_ANGLE);
   },
   touchstart: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // Start fly or walk (button 0).

            event .button = 0;
            event .pageX  = touches [0] .pageX;
            event .pageY  = touches [0] .pageY;

            this .mousedown (event);
            break;
         }
         case 2:
         {
            // End fly or walk (button 0).

            this .touchend (event);

            // Start look around (button 0).

            this .lookAround = true;
            event .button    = 0;
            event .pageX     = (touches [0] .pageX + touches [1] .pageX) / 2;
            event .pageY     = (touches [0] .pageY + touches [1] .pageY) / 2;

            this .mousedown (event);
            break;
         }
         case 3:
         {
            // End look around (button 0).

            this .touchend (event);
            break;
         }
      }
   },
   touchend: function (event)
   {
      switch (this .button)
      {
         case 0:
         {
            // End move or look around (button 0).
            this .lookAround = false;
            event .button    = 0;

            this .mouseup (event);
            break;
         }
      }
   },
   touchmove: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // Fly or walk (button 0).

            event .button = 0;
            event .pageX  = touches [0] .pageX;
            event .pageY  = touches [0] .pageY;

            this .mousemove (event);
            break;
         }
         case 2:
         {
            // Fly or walk (button 0).

            event .button = 0;
            event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
            event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

            this .mousemove (event);
            break;
         }
      }
   },
   fly: (function ()
   {
      const
         upVector           = new Numbers_Vector3 (0, 0, 0),
         direction          = new Numbers_Vector3 (0, 0, 0),
         axis               = new Numbers_Vector3 (0, 0, 0),
         userOrientation    = new Numbers_Rotation4 (0, 0, 1, 0),
         orientationOffset  = new Numbers_Rotation4 (0, 0, 1, 0),
         rubberBandRotation = new Numbers_Rotation4 (0, 0, 1, 0);

      return function ()
      {
         const
            navigationInfo = this .getNavigationInfo (),
            viewpoint      = this .getActiveViewpoint (),
            now            = performance .now (),
            dt             = (now - this .startTime) / 1000;

         upVector .assign (viewpoint .getUpVector ());

         // Rubberband values

         if (this .direction .z > 0)
            rubberBandRotation .setFromToVec (this .direction, axis .set (0, 0, 1));
         else
            rubberBandRotation .setFromToVec (axis .set (0, 0, -1), this .direction);

            const rubberBandLength = this .direction .magnitude ();

         // Determine positionOffset.

         let speedFactor = 1 - rubberBandRotation .angle / (Math .PI / 2);

         speedFactor *= navigationInfo ._speed .getValue ();
         speedFactor *= viewpoint .getSpeedFactor ();
         speedFactor *= this .getBrowser () .getShiftKey () ? SHIFT_SPEED_FACTOR : SPEED_FACTOR;
         speedFactor *= dt;

         const translation = this .getTranslationOffset (direction .assign (this .direction) .multiply (speedFactor));

         this .getActiveLayer () .constrainTranslation (translation, true);

         viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());

         // Determine weight for rubberBandRotation.

         const weight = ROTATION_SPEED_FACTOR * dt * Math .pow (rubberBandLength / (rubberBandLength + ROTATION_LIMIT), 2);

         // Determine userOrientation.

         userOrientation
            .assign (Numbers_Rotation4.Identity)
            .slerp (rubberBandRotation, weight)
            .multRight (viewpoint .getUserOrientation ());

         // Straighten horizon of userOrientation.

         if (this .getStraightenHorizon ())
            viewpoint .straightenHorizon (userOrientation);

         // Determine orientationOffset.

         orientationOffset
            .assign (viewpoint .getOrientation ())
            .inverse ()
            .multRight (userOrientation);

         // Set orientationOffset.

         viewpoint ._orientationOffset = orientationOffset;

         this .startTime = now;
      };
   })(),
   pan: (function ()
   {
      const
         direction = new Numbers_Vector3 (0, 0, 0),
         axis      = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         const
            navigationInfo = this .getNavigationInfo (),
            viewpoint      = this .getActiveViewpoint (),
            now            = performance .now (),
            dt             = (now - this .startTime) / 1000,
            upVector       = viewpoint .getUpVector ();

         this .constrainPanDirection (direction .assign (this .direction));

         let speedFactor = 1;

         speedFactor *= navigationInfo ._speed .getValue ();
         speedFactor *= viewpoint .getSpeedFactor ();
         speedFactor *= this .getBrowser () .getShiftKey () ? PAN_SHIFT_SPEED_FACTOR : PAN_SPEED_FACTOR;
         speedFactor *= dt;

         const
            orientation = viewpoint .getUserOrientation () .multRight (new Numbers_Rotation4 (viewpoint .getUserOrientation () .multVecRot (axis .assign (Numbers_Vector3.yAxis)), upVector)),
            translation = orientation .multVecRot (direction .multiply (speedFactor));

         this .getActiveLayer () .constrainTranslation (translation, true);

         viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());

         this .startTime = now;
      };
   })(),
   set_orientationOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._orientationOffset = value;
   },
   addFly: function ()
   {
      if (this .startTime)
         return;

      this .getBrowser () .prepareEvents () .addInterest ("fly", this);
      this .getBrowser () .addBrowserEvent ();

      this .startTime = performance .now ();
   },
   addPan: function ()
   {
      if (this .startTime)
         return;

      this .disconnect ();
      this .getBrowser () .prepareEvents () .addInterest ("pan", this);
      this .getBrowser () .addBrowserEvent ();

      this .startTime = performance .now ();
   },
   addRoll: (function ()
   {
      const
         orientationOffset = new Numbers_Rotation4 (0, 0, 1, 0),
         roll              = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (rollAngle)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
         {
            orientationOffset
               .assign (viewpoint .getOrientation ())
               .inverse ()
               .multRight (roll .set (1, 0, 0, rollAngle))
               .multRight (viewpoint .getOrientation ())
               .multRight (this .orientationChaser ._set_destination .getValue ());

            this .orientationChaser ._set_destination = orientationOffset;
         }
         else
         {
            orientationOffset
               .assign (viewpoint .getOrientation ())
               .inverse ()
               .multRight (roll .set (1, 0, 0, rollAngle))
               .multRight (viewpoint .getUserOrientation ());

            this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
            this .orientationChaser ._set_destination = orientationOffset;
         }

         this .disconnect ();
         this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
      };
   })(),
   addRotation: (function ()
   {
      const
         userOrientation   = new Numbers_Rotation4 (0, 0, 1, 0),
         orientationOffset = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (fromVector, toVector)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
         {
            userOrientation
               .setFromToVec (toVector, fromVector)
               .multRight (viewpoint .getOrientation ())
               .multRight (this .orientationChaser ._set_destination .getValue ());

            if (this .getStraightenHorizon ())
               viewpoint .straightenHorizon (userOrientation);

            orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

            this .orientationChaser ._set_destination = orientationOffset;
         }
         else
         {
            userOrientation
               .setFromToVec (toVector, fromVector)
               .multRight (viewpoint .getUserOrientation ());

            if (this .getStraightenHorizon ())
               viewpoint .straightenHorizon (userOrientation);

            orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

            this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
            this .orientationChaser ._set_destination = orientationOffset;
         }

         this .disconnect ();
         this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
      };
   })(),
   display: (function ()
   {
      const
         fromPoint             = new Numbers_Vector3 (0, 0, 0),
         toPoint               = new Numbers_Vector3 (0, 0, 0),
         projectionMatrix      = new Numbers_Matrix4 (),
         projectionMatrixArray = new Float32Array (Numbers_Matrix4.Identity),
         modelViewMatrixArray  = new Float32Array (Numbers_Matrix4.Identity),
         clipPlanes            = [ ];

      return function (type)
      {
         // Configure HUD

         const
            browser  = this .getBrowser (),
            gl       = browser .getContext (),
            viewport = browser .getViewport (),
            width    = viewport [2],
            height   = viewport [3];

         projectionMatrixArray .set (Camera.ortho (0, width, 0, height, -1, 1, projectionMatrix));

         // Display Rubberband.

         if (type === MOVE)
         {
            fromPoint .set (this .fromVector .x, height - this .fromVector .z, 0);
            toPoint   .set (this .toVector   .x, height - this .toVector   .z, 0);
         }
         else
         {
            fromPoint .set (this .fromVector .x, height + this .fromVector .y, 0);
            toPoint   .set (this .toVector   .x, height + this .toVector   .y, 0);
         }

         // Set line vertices.

         this .lineArray .set (fromPoint, 0);
         this .lineArray .set (toPoint,   4);

         // Transfer line.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .lineBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, this .lineArray, gl .DYNAMIC_DRAW);

         // Set uniforms and attributes.

         const shaderNode = browser .getDefaultMaterial () .getShader (this .geometryContext);

         shaderNode .enable (gl);
         shaderNode .setClipPlanes (gl, clipPlanes);

         gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrixArray);
         gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, modelViewMatrixArray);

         if (this .lineArrayObject .enable (gl, shaderNode))
            shaderNode .enableVertexAttribute (gl, this .lineBuffer, 0, 0);

         // Draw a black and a white line.

         gl .disable (gl .DEPTH_TEST);

         gl .uniform3f (shaderNode .x3d_EmissiveColor, 0, 0, 0);
         gl .uniform1f (shaderNode .x3d_Transparency,  0);
         gl .drawArrays (gl .LINES, 0, this .lineCount);

         gl .uniform3f (shaderNode .x3d_EmissiveColor, 1, 1, 1);
         gl .drawArrays (gl .LINES, 0, this .lineCount);
      };
   })(),
   disconnect: function ()
   {
      const browser = this .getBrowser ();

      browser .addBrowserEvent ();

      browser .prepareEvents () .removeInterest ("fly", this);
      browser .prepareEvents () .removeInterest ("pan", this);
      browser .finished ()      .removeInterest ("display", this);

      this .orientationChaser ._value_changed .removeInterest ("set_orientationOffset__", this);

      this .startTime = 0;
   },
   dispose: function ()
   {
      const gl = this .getBrowser () .getContext ();

      gl .deleteBuffer (this .lineBuffer);
      this .lineArrayObject .delete (gl);

      this .disconnect ();
      this .getBrowser () ._controlKey .removeInterest ("set_controlKey__", this);
      this .getBrowser () .getSurface () .off (".X3DFlyViewer");
      $(document) .off (".X3DFlyViewer" + this .getId ());
   },
});

/* harmony default export */ const Navigation_X3DFlyViewer = (X3DFlyViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/WalkViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function WalkViewer (executionContext)
{
   Navigation_X3DFlyViewer.call (this, executionContext);
}

WalkViewer .prototype = Object .assign (Object .create (Navigation_X3DFlyViewer.prototype),
{
   constructor: WalkViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
   initialize: function ()
   {
      Navigation_X3DFlyViewer.prototype.initialize.call (this);

      this .getBrowser () .addCollision (this);
   },
   getStraightenHorizon: function ()
   {
      return true;
   },
   getFlyDirection: function (fromVector, toVector, direction)
   {
      return direction .assign (toVector) .subtract (fromVector);
   },
   getTranslationOffset: (function ()
   {
      const
         localYAxis      = new Numbers_Vector3 (0, 0, 0),
         userOrientation = new Numbers_Rotation4 (0, 0, 1, 0),
         rotation        = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (velocity)
      {
         const
            viewpoint = this .getActiveViewpoint (),
            upVector  = viewpoint .getUpVector ();

         userOrientation .assign (viewpoint .getUserOrientation ());
         userOrientation .multVecRot (localYAxis .assign (Numbers_Vector3.yAxis));
         rotation        .setFromToVec (localYAxis, upVector);

         const orientation = userOrientation .multRight (rotation);

         return orientation .multVecRot (velocity);
      };
   })(),
   constrainPanDirection: function (direction)
   {
      if (direction .y < 0)
         direction .y = 0;

      return direction;
   },
   dispose: function ()
   {
      this .getBrowser () .removeCollision (this);

      Navigation_X3DFlyViewer.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Navigation_WalkViewer = (WalkViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/FlyViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function FlyViewer (executionContext)
{
   Navigation_X3DFlyViewer.call (this, executionContext);
}

FlyViewer .prototype = Object .assign (Object .create (Navigation_X3DFlyViewer.prototype),
{
   constructor: FlyViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
   addCollision: function ()
   {
      this .getBrowser () .addCollision (this);
   },
   removeCollision: function ()
   {
      this .getBrowser () .removeCollision (this);
   },
   getFlyDirection: function (fromVector, toVector, direction)
   {
      return direction .assign (toVector) .subtract (fromVector);
   },
   getTranslationOffset: function (velocity)
   {
      return this .getActiveViewpoint () .getUserOrientation () .multVecRot (velocity);
   },
   constrainPanDirection: function (direction)
   {
      return direction;
   },
});

/* harmony default export */ const Navigation_FlyViewer = (FlyViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/PlaneViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









const PlaneViewer_macOS = /Mac OS X/i .test (navigator .userAgent)

const PlaneViewer_SCROLL_FACTOR = PlaneViewer_macOS ? 1 / 160 : 1 / 20;

const
   vector                 = new Numbers_Vector3 (0 ,0, 0),
   positionOffset         = new Numbers_Vector3 (0 ,0, 0),
   centerOfRotationOffset = new Numbers_Vector3 (0, 0, 0);

function PlaneViewer (executionContext)
{
   Navigation_X3DViewer.call (this, executionContext);

   this .button    = -1;
   this .fromPoint = new Numbers_Vector3 (0, 0, 0);
   this .toPoint   = new Numbers_Vector3 (0, 0, 0);
}

PlaneViewer .prototype = Object .assign (Object .create (Navigation_X3DViewer.prototype),
{
   constructor: PlaneViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
   initialize: function ()
   {
      Navigation_X3DViewer.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         element = browser .getSurface ();

      element .on ("mousedown.PlaneViewer",  this .mousedown  .bind (this));
      element .on ("mouseup.PlaneViewer",    this .mouseup    .bind (this));
      element .on ("mousemove.PlaneViewer",  this .mousemove  .bind (this));
      element .on ("mousewheel.PlaneViewer", this .mousewheel .bind (this));
   },
   mousedown: function (event)
   {
      if (this .button >= 0)
         return;

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .getButton (event .button))
      {
         case 1:
         {
            // Stop event propagation.

            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            this .getBrowser () .getSurface () .off ("mousemove.PlaneViewer");
            $(document) .on ("mouseup.PlaneViewer"   + this .getId (), this .mouseup .bind (this));
            $(document) .on ("mousemove.PlaneViewer" + this .getId (), this .mousemove .bind (this));

            this .getActiveViewpoint () .transitionStop ();
            this .getBrowser () .setCursor ("MOVE");

            this .getPointOnCenterPlane (x, y, this .fromPoint);

            this ._isActive = true;
            break;
         }
      }
   },
   mouseup: function (event)
   {
      // Stop event propagation.

      event .preventDefault ();
      event .stopImmediatePropagation ();

      if (event .button !== this .button)
         return;

      this .button = -1;

      $(document) .off (".PlaneViewer" + this .getId ());
      this .getBrowser () .getSurface () .on ("mousemove.PlaneViewer", this .mousemove .bind (this));

      this .getBrowser () .setCursor ("DEFAULT");

      this ._isActive = false;
   },
   mousemove: function (event)
   {
      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .getButton (this .button))
      {
         case 1:
         {
            // Stop event propagation.

            event .preventDefault ();
            event .stopImmediatePropagation ();

            // Move.

            const
               viewpoint   = this .getActiveViewpoint (),
               toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
               translation = viewpoint .getUserOrientation () .multVecRot (this .fromPoint .subtract (toPoint));

            viewpoint ._positionOffset         = positionOffset         .assign (viewpoint ._positionOffset         .getValue ()) .add (translation);
            viewpoint ._centerOfRotationOffset = centerOfRotationOffset .assign (viewpoint ._centerOfRotationOffset .getValue ()) .add (translation);

            this .fromPoint .assign (toPoint);
            break;
         }
      }
   },
   mousewheel: function (event)
   {
      // Stop event propagation.

      event .preventDefault ();
      event .stopImmediatePropagation ();

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      // Change viewpoint position.

      const
         viewpoint = this .getActiveViewpoint (),
         fromPoint = this .getPointOnCenterPlane (x, y, this .fromPoint);

      viewpoint .transitionStop ();

      if (event .deltaY > 0) // Move backwards.
      {
         viewpoint ._fieldOfViewScale = Math .max (0.00001, viewpoint ._fieldOfViewScale .getValue () * (1 - PlaneViewer_SCROLL_FACTOR));
      }
      else if (event .deltaY < 0) // Move forwards.
      {
         viewpoint ._fieldOfViewScale = viewpoint ._fieldOfViewScale .getValue () * (1 + PlaneViewer_SCROLL_FACTOR);

         this .constrainFieldOfViewScale ();
      }

      if (viewpoint .set_fieldOfView___)
         viewpoint .set_fieldOfView___ (); // XXX: Immediately apply fieldOfViewScale;

      const
         toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
         translation = viewpoint .getUserOrientation () .multVecRot (vector .assign (fromPoint) .subtract (toPoint));

      viewpoint ._positionOffset         = positionOffset         .assign (viewpoint ._positionOffset         .getValue ()) .add (translation);
      viewpoint ._centerOfRotationOffset = centerOfRotationOffset .assign (viewpoint ._centerOfRotationOffset .getValue ()) .add (translation);
   },
   constrainFieldOfViewScale: function ()
   {
      const viewpoint = this .getActiveViewpoint ();

      if (viewpoint .getTypeName () .match (/^(?:Viewpoint|GeoViewpoint)$/))
      {
         if (viewpoint ._fieldOfView .getValue () * viewpoint ._fieldOfViewScale .getValue () >= Math .PI)
            viewpoint ._fieldOfViewScale = (Math .PI - 0.001) / viewpoint ._fieldOfView .getValue ();
      }
   },
   dispose: function ()
   {
      this .getBrowser () .getSurface () .off (".PlaneViewer");
      $(document) .off (".PlaneViewer" + this .getId ());
   },
});

/* harmony default export */ const Navigation_PlaneViewer = (PlaneViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/NoneViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function NoneViewer (executionContext)
{
   Navigation_X3DViewer.call (this, executionContext);
}

NoneViewer .prototype = Object .assign (Object .create (Navigation_X3DViewer.prototype),
{
   constructor: NoneViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
});

/* harmony default export */ const Navigation_NoneViewer = (NoneViewer);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/LookAtViewer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













const LookAtViewer_macOS = /Mac OS X/i .test (navigator .userAgent)

const
   LookAtViewer_SCROLL_FACTOR = LookAtViewer_macOS ? 1 / 120 : 1 / 20,
   LookAtViewer_MOVE_TIME     = 0.3,
   LookAtViewer_ROTATE_TIME   = 0.3;

function LookAtViewer (executionContext)
{
   Navigation_X3DViewer.call (this, executionContext);

   this .button                 = -1;
   this .fromVector             = new Numbers_Vector3 (0, 0, 0);
   this .toVector               = new Numbers_Vector3 (0, 0, 0);

   this .touch1                 = new Numbers_Vector2 (0, 0);
   this .touch2                 = new Numbers_Vector2 (0, 0);
   this .tapStart               = 0;
   this .dblTapInterval         = 0.4;

   this .positionChaser         = new Followers_PositionChaser (executionContext);
   this .centerOfRotationChaser = new Followers_PositionChaser (executionContext);
   this .orientationChaser      = new Followers_OrientationChaser (executionContext);
}

LookAtViewer .prototype = Object .assign (Object .create (Navigation_X3DViewer.prototype),
{
   constructor: LookAtViewer,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly, "isActive", new x_ite_Fields.SFBool ()),
   ]),
   initialize: function ()
   {
      Navigation_X3DViewer.prototype.initialize.call (this);

      const
         browser = this .getBrowser (),
         element = browser .getSurface ();

      // Bind pointing device events.

      element .on ("mousedown.LookAtViewer",  this .mousedown  .bind (this));
      element .on ("mouseup.LookAtViewer",    this .mouseup    .bind (this));
      element .on ("dblclick.LookAtViewer",   this .dblclick   .bind (this));
      element .on ("mousewheel.LookAtViewer", this .mousewheel .bind (this));

      element .on ("touchstart.LookAtViewer", this .touchstart .bind (this));
      element .on ("touchend.LookAtViewer",   this .touchend   .bind (this));

      // Setup chaser.

      this .positionChaser ._duration = LookAtViewer_MOVE_TIME;
      this .positionChaser .setPrivate (true);
      this .positionChaser .setup ();

      this .centerOfRotationChaser ._duration = LookAtViewer_MOVE_TIME;
      this .centerOfRotationChaser .setPrivate (true);
      this .centerOfRotationChaser .setup ();

      this .orientationChaser ._duration = LookAtViewer_ROTATE_TIME;
      this .orientationChaser .setPrivate (true);
      this .orientationChaser .setup ();
   },
   mousedown: function (event)
   {
      if (this .button >= 0)
         return;

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (event .button)
      {
         case 0:
         {
            // Stop event propagation.

            event .preventDefault ();
            event .stopImmediatePropagation ();

            this .button = event .button;

            $(document) .on ("mouseup.LookAtViewer"   + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("mousemove.LookAtViewer" + this .getId (), this .mousemove .bind (this));
            $(document) .on ("touchend.LookAtViewer"  + this .getId (), this .mouseup   .bind (this));
            $(document) .on ("touchmove.LookAtViewer" + this .getId (), this .touchmove .bind (this));

            this .getActiveViewpoint () .transitionStop ();

            // Look around.

            this .trackballProjectToSphere (x, y, this .fromVector);

            this ._isActive = true;
            break;
         }
      }
   },
   mouseup: function (event)
   {
      if (event .button !== this .button)
         return;

      this .button = -1;

      $(document) .off (".LookAtViewer" + this .getId ());

      switch (event .button)
      {
         case 0:
         {
            // Stop event propagation.

            event .preventDefault ();
            event .stopImmediatePropagation ();

            this ._isActive = false;
            break;
         }
      }
   },
   dblclick: function (event)
   {
      // Stop event propagation.
      event .preventDefault ();
      event .stopImmediatePropagation ();

      const
         element = this .getBrowser () .getSurface (),
         offset  = element .offset (),
         x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
         y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

      this .disconnect ();
      this .lookAtPoint (x, y, this .getStraightenHorizon ());
   },
   mousemove: function (event)
   {
      this .getBrowser () .addBrowserEvent ();

      this .event = event;

      const
         offset = this .getBrowser () .getSurface () .offset (),
         x      = event .pageX - offset .left,
         y      = event .pageY - offset .top;

      switch (this .button)
      {
         case 0:
         {
            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            // Look around

            const toVector = this .trackballProjectToSphere (x, y, this .toVector);

            this .addRotation (this .fromVector, toVector);
            this .fromVector .assign (toVector);
            break;
         }
      }
   },
   mousewheel: (function ()
   {
      const
         step        = new Numbers_Vector3 (0, 0, 0),
         translation = new Numbers_Vector3 (0, 0, 0);

      return function (event)
      {
         // Stop event propagation.
         event .preventDefault ();
         event .stopImmediatePropagation ();

         // Change viewpoint position.

         const viewpoint = this .getActiveViewpoint ();

         viewpoint .transitionStop ();

         step        = this .getDistanceToCenter (step) .multiply (event .zoomFactor || LookAtViewer_SCROLL_FACTOR),
         translation = viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .magnitude ()));

         if (event .deltaY > 0)
            this .addMove (translation .negate (), Numbers_Vector3.Zero);

         else if (event .deltaY < 0)
            this .addMove (translation, Numbers_Vector3.Zero);
      };
   })(),
   touchstart: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // Start move (button 0).

            this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
            break;
         }
         case 2:
         {
            // End move (button 0).

            this .touchend (event);

            // Start look around (button 0).

            event .button = 0;
            event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
            event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

            this .mousedown (event);

            // Start zoom (mouse wheel).

            this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
            this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
            break;
         }
         case 3:
         {
            this .touchend (event);
            break;
         }
      }
   },
   touchend: function (event)
   {
      switch (this .button)
      {
         case 0:
         {
            // End look around (button 0).
            this .mouseup (event);
            break;
         }
      }

      // Start dblclick (button 0).

      if (this .getBrowser () .getCurrentTime () - this .tapStart < this .dblTapInterval)
      {
         event .button = 1;
         event .pageX  = this .touch1 .x;
         event .pageY  = this .touch1 .y;

         this .dblclick (event);
      }

      this .tapStart = this .getBrowser () .getCurrentTime ();
   },
   touchmove: (function ()
   {
      const
         MOVE_ANGLE   = 0.7,
         ZOOM_ANGLE   = -0.7,
         touch1Change = new Numbers_Vector2 (0, 0),
         touch2Change = new Numbers_Vector2 (0, 0);

      return function (event)
      {
         const touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Move (button 0).
               break;
            }
            case 2:
            {
               touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
               touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

               const
                  move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
                  zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE;

               if (move)
               {
                  // Look around (button 0).

                  event .button = 0;
                  event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
                  event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

                  this .mousemove (event);
               }
               else if (zoom)
               {
                  // Zoom (mouse wheel).

                  const distance1 = this .touch1 .distance (this .touch2);

                  this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                  this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

                  const
                     distance2 = this .touch1 .distance (this .touch2),
                     delta     = distance2 - distance1;

                  event .deltaY     = delta;
                  event .zoomFactor = Math .abs (delta) / $(window) .width ();

                  this .mousewheel (event);
               }

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
               break;
            }
         }
      };
   })(),
   set_positionOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._positionOffset = value;
   },
   set_centerOfRotationOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._centerOfRotationOffset = value;
   },
   set_orientationOffset__: function (value)
   {
      const viewpoint = this .getActiveViewpoint ();

      viewpoint ._orientationOffset = value;
   },
   addMove: (function ()
   {
      const
         positionOffset         = new Numbers_Vector3 (0, 0, 0),
         centerOfRotationOffset = new Numbers_Vector3 (0, 0, 0);

      return function (positionOffsetChange, centerOfRotationOffsetChange)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .positionChaser ._isActive .getValue () && this .positionChaser ._value_changed .hasInterest ("set_positionOffset__", this))
         {
            positionOffset
               .assign (this .positionChaser ._set_destination .getValue ())
               .add (positionOffsetChange);

            this .positionChaser ._set_destination = positionOffset;
         }
         else
         {
            positionOffset
               .assign (viewpoint ._positionOffset .getValue ())
               .add (positionOffsetChange);

            this .positionChaser ._set_value       = viewpoint ._positionOffset;
            this .positionChaser ._set_destination = positionOffset;
         }

         if (this .centerOfRotationChaser ._isActive .getValue () && this .centerOfRotationChaser ._value_changed .hasInterest ("set_centerOfRotationOffset__", this))
         {
            centerOfRotationOffset
               .assign (this .centerOfRotationChaser ._set_destination .getValue ())
               .add (centerOfRotationOffsetChange);

            this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
         }
         else
         {
            centerOfRotationOffset
               .assign (viewpoint ._centerOfRotationOffset .getValue ())
               .add (centerOfRotationOffsetChange);

            this .centerOfRotationChaser ._set_value       = viewpoint ._centerOfRotationOffset;
            this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
         }

         this .disconnect ();
         this .positionChaser         ._value_changed .addInterest ("set_positionOffset__",         this);
         this .centerOfRotationChaser ._value_changed .addInterest ("set_centerOfRotationOffset__", this);
      };
   })(),
   addRotation: (function ()
   {
      const
         userOrientation   = new Numbers_Rotation4 (0, 0, 1, 0),
         orientationOffset = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (fromVector, toVector)
      {
         const viewpoint = this .getActiveViewpoint ();

         if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
         {
            userOrientation
               .setFromToVec (toVector, fromVector)
               .multRight (viewpoint .getOrientation ())
               .multRight (this .orientationChaser ._set_destination .getValue ());

            viewpoint .straightenHorizon (userOrientation);

            orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

            this .orientationChaser ._set_destination = orientationOffset;
         }
         else
         {
            userOrientation
               .setFromToVec (toVector, fromVector)
               .multRight (viewpoint .getUserOrientation ());

            viewpoint .straightenHorizon (userOrientation);

            orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

            this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
            this .orientationChaser ._set_destination = orientationOffset;
         }

         this .disconnect ();
         this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
      };
   })(),
   disconnect: function ()
   {
      this .orientationChaser      ._value_changed .removeInterest ("set_orientationOffset__", this);
      this .positionChaser         ._value_changed .removeInterest ("set_positionOffset__",         this)
      this .centerOfRotationChaser ._value_changed .removeInterest ("set_centerOfRotationOffset__", this)
   },
   dispose: function ()
   {
      this .getBrowser () .getSurface () .off (".LookAtViewer");
      $(document) .off (".LookAtViewer" + this .getId ());
   },
});

/* harmony default export */ const Navigation_LookAtViewer = (LookAtViewer);

;// CONCATENATED MODULE: ./src/x_ite/Components/Lighting/X3DLightNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DLightNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DLightNode);
}

X3DLightNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DLightNode,
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);

      this ._on        .addInterest ("set_on__", this);
      this ._intensity .addInterest ("set_on__", this);

      this .set_on__ ();
   },
   set_on__: function ()
   {
      if (this ._on .getValue () && this .getIntensity () > 0)
      {
         delete this .push;
         delete this .pop;
      }
      else
      {
         this .push = Function .prototype;
         this .pop  = Function .prototype;
      }
   },
   getGlobal: function ()
   {
      return this ._global .getValue ();
   },
   getColor: function ()
   {
      return this ._color .getValue ();
   },
   getIntensity: function ()
   {
      return Math .max (this ._intensity .getValue (), 0);
   },
   getAmbientIntensity: function ()
   {
      return Math_Algorithm.clamp (this ._ambientIntensity .getValue (), 0, 1);
   },
   getDirection: function ()
   {
      return this ._direction .getValue ();
   },
   getShadows: function ()
   {
      return this ._shadows .getValue ();
   },
   getShadowColor: function ()
   {
      return this ._shadowColor .getValue ();
   },
   getShadowIntensity: function ()
   {
      return this .getShadows () ? Math_Algorithm.clamp (this ._shadowIntensity .getValue (), 0, 1) : 0;
   },
   getShadowBias: function ()
   {
      return Math_Algorithm.clamp (this ._shadowBias .getValue (), 0, 1);
   },
   getShadowMapSize: function ()
   {
      return Math .min (this ._shadowMapSize .getValue (), this .getBrowser () .getMaxTextureSize ());
   },
   getBiasMatrix: (function ()
   {
      // Transforms normalized coords from range (-1, 1) to (0, 1).
      const biasMatrix = new Numbers_Matrix4 (0.5, 0.0, 0.0, 0.0,
                                      0.0, 0.5, 0.0, 0.0,
                                      0.0, 0.0, 0.5, 0.0,
                                      0.5, 0.5, 0.5, 1.0);

      return function ()
      {
         return biasMatrix;
      };
   })(),
   push: function (renderObject, group)
   {
      if (renderObject .isIndependent ())
      {
         const lightContainer = this .getLights () .pop ();

         if (this ._global .getValue ())
         {
            lightContainer .set (this,
                                 renderObject .getLayer () .getGroup (),
                                 renderObject .getModelViewMatrix () .get ());

            renderObject .getGlobalObjects () .push (lightContainer);
            renderObject .getLights ()        .push (lightContainer);

            renderObject .pushGlobalShadows (!! this .getShadowIntensity ());
         }
         else
         {
            lightContainer .set (this,
                                 group,
                                 renderObject .getModelViewMatrix () .get ());

            renderObject .getLocalObjects () .push (lightContainer);
            renderObject .getLights ()       .push (lightContainer);

            renderObject .pushLocalShadows (!! this .getShadowIntensity ());

            ++ renderObject .getLocalObjectsCount () [1];
         }
      }
      else
      {
         const lightContainer = renderObject .getLightContainer ();

         if (this ._global .getValue ())
         {
            lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

            renderObject .getGlobalObjects () .push (lightContainer);
            renderObject .getLights ()        .push (lightContainer);

            renderObject .pushGlobalShadows (!! this .getShadowIntensity ());
         }
         else
         {
            lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

            renderObject .getLocalObjects () .push (lightContainer);
            renderObject .getLights ()       .push (lightContainer);

            renderObject .pushLocalShadows (!! this .getShadowIntensity ());

            ++ renderObject .getLocalObjectsCount () [1];
         }
      }
   },
   pop: function (renderObject)
   {
      if (this ._global .getValue ())
         return;

      if (renderObject .isIndependent ())
         this .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());
      else
         renderObject .getLocalObjects () .pop ();

      renderObject .popLocalShadows ();

      -- renderObject .getLocalObjectsCount () [1];
   },
});

/* harmony default export */ const Lighting_X3DLightNode = (X3DLightNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Lighting/DirectionalLight.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/



















const DirectionalLights = ObjectCache (DirectionalLightContainer);

function DirectionalLightContainer ()
{
   this .direction                     = new Numbers_Vector3 (0, 0, 0);
   this .shadowBuffer                  = null;
   this .bbox                          = new Geometry_Box3 ();
   this .viewVolume                    = new Geometry_ViewVolume ();
   this .viewport                      = new Numbers_Vector4 (0, 0, 0, 0);
   this .projectionMatrix              = new Numbers_Matrix4 ();
   this .modelViewMatrix               = new Utility_MatrixStack (Numbers_Matrix4);
   this .modelMatrix                   = new Numbers_Matrix4 ();
   this .invLightSpaceMatrix           = new Numbers_Matrix4 ();
   this .invLightSpaceProjectionMatrix = new Numbers_Matrix4 ();
   this .shadowMatrix                  = new Numbers_Matrix4 ();
   this .shadowMatrixArray             = new Float32Array (16);
   this .rotation                      = new Numbers_Rotation4 ();
   this .textureUnit                   = undefined;
}

DirectionalLightContainer .prototype =
{
   constructor: DirectionalLightContainer,
   getModelViewMatrix: function ()
   {
      return this .modelViewMatrix;
   },
   set: function (lightNode, groupNode, modelViewMatrix)
   {
      const shadowMapSize = lightNode .getShadowMapSize ();

      this .browser   = lightNode .getBrowser ();
      this .lightNode = lightNode;
      this .groupNode = groupNode;

      this .modelViewMatrix .pushMatrix (modelViewMatrix);

      // Get shadow buffer from browser.

      if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
      {
         this .shadowBuffer = this .browser .popShadowBuffer (shadowMapSize);

         if (! this .shadowBuffer)
            console .warn ("Couldn't create shadow buffer.");
      }
   },
   renderShadowMap: function (renderObject)
   {
      if (! this .shadowBuffer)
         return;

      const
         lightNode            = this .lightNode,
         cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
         modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
         invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Numbers_Matrix4.Identity);

      invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Numbers_Vector3.zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
      invLightSpaceMatrix .inverse ();

      const
         groupBBox        = this .groupNode .getSubBBox (this .bbox, true), // Group bbox.
         lightBBox        = groupBBox .multRight (invLightSpaceMatrix),     // Group bbox from the perspective of the light.
         shadowMapSize    = lightNode .getShadowMapSize (),
         viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
         projectionMatrix = Camera.orthoBox (lightBBox, this .projectionMatrix);

      this .shadowBuffer .bind ();

      renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
      renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
      renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

      renderObject .render (Rendering_TraverseType.SHADOW, Grouping_X3DGroupingNode.prototype.traverse, this .groupNode);

      renderObject .getModelViewMatrix  () .pop ();
      renderObject .getProjectionMatrix () .pop ();
      renderObject .getViewVolumes      () .pop ();

      this .shadowBuffer .unbind ();

      if (! lightNode .getGlobal ())
         invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

      this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
   },
   setGlobalVariables: function (renderObject)
   {
      this .modelViewMatrix .get () .multDirMatrix (this .direction .assign (this .lightNode .getDirection ())) .normalize ();

      if (! this .shadowBuffer)
         return;

      this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
      this .shadowMatrixArray .set (this .shadowMatrix);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const i = shaderObject .numLights ++;

      if (this .shadowBuffer)
      {
         const textureUnit = this .lightNode .getGlobal ()
            ? (this .textureUnit = this .textureUnit !== undefined
               ? this .textureUnit
               : this .browser .popTexture2DUnit ())
            : this .browser .getTexture2DUnit ();

         if (textureUnit !== undefined)
         {
            gl .activeTexture (gl .TEXTURE0 + textureUnit);

            if (gl .HAS_FEATURE_DEPTH_TEXTURE)
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
            else
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

            gl .uniform1i (shaderObject .x3d_ShadowMap [i], textureUnit);
         }
         else
         {
            console .warn ("Not enough combined texture units for shadow map available.");
         }
      }

      if (shaderObject .hasLight (i, this))
         return;

      const
         lightNode = this .lightNode,
         color     = lightNode .getColor (),
         direction = this .direction;

      gl .uniform1i (shaderObject .x3d_LightType [i],             1);
      gl .uniform3f (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
      gl .uniform1f (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
      gl .uniform1f (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
      gl .uniform3f (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);

      if (this .shadowBuffer)
      {
         const shadowColor = lightNode .getShadowColor ();

         gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
         gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
         gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
         gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
         gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
      }
   },
   dispose: function ()
   {
      this .browser .pushShadowBuffer (this .shadowBuffer);
      this .browser .pushTexture2DUnit (this .textureUnit);

      this .modelViewMatrix .clear ();

      this .shadowBuffer = null;
      this .textureUnit  = undefined;

      // Return container

      DirectionalLights .push (this);
   },
};

function DirectionalLight (executionContext)
{
   Lighting_X3DLightNode.call (this, executionContext);

   this .addType (Base_X3DConstants.DirectionalLight);

   if (executionContext .getSpecificationVersion () === "2.0")
      this ._global = true;
}

DirectionalLight .prototype = Object .assign (Object .create (Lighting_X3DLightNode.prototype),
{
   constructor: DirectionalLight,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "global",           new x_ite_Fields.SFBool (false)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "on",               new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",            new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "intensity",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "ambientIntensity", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "direction",        new x_ite_Fields.SFVec3f (0, 0, -1)),

      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadows",         new  x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowColor",     new  x_ite_Fields.SFColor ()),        // Color of shadows.
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowIntensity", new  x_ite_Fields.SFFloat (1)),       // Intensity of shadow color in the range (0, 1).
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowBias",      new  x_ite_Fields.SFFloat (0.005)),   // Bias of the shadow.
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "shadowMapSize",   new  x_ite_Fields.SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
   ]),
   getTypeName: function ()
   {
      return "DirectionalLight";
   },
   getComponentName: function ()
   {
      return "Lighting";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getLights: function ()
   {
      return DirectionalLights;
   },
});

/* harmony default export */ const Lighting_DirectionalLight = (DirectionalLight);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Navigation/X3DNavigationContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const
   _activeCollisions   = Symbol (),
   _viewerNode         = Symbol (),
   _headlightContainer = Symbol ();

function getHeadlight (browser)
{
   const headlight = new Lighting_DirectionalLight (browser .getPrivateScene ());

   headlight .setup ();

   const headlightContainer = headlight .getLights () .pop ();

   headlightContainer .set (headlight, null, Numbers_Matrix4.Identity);
   headlightContainer .dispose = Function .prototype;

   return headlightContainer;
};

function X3DNavigationContext ()
{
   this .addChildObjects ("activeLayer",          new x_ite_Fields.SFNode (),
                          "activeNavigationInfo", new x_ite_Fields.SFNode (),
                          "activeViewpoint",      new x_ite_Fields.SFNode (),
                          "availableViewers",     new x_ite_Fields.MFString (),
                          "viewer",               new x_ite_Fields.SFString ("EXAMINE"));

   this [_activeCollisions] = new Set ();
   this [_viewerNode]       = new Navigation_NoneViewer (this);
}

X3DNavigationContext .prototype =
{
   initialize: function ()
   {
      this ._viewer .addInterest ("set_viewer__", this);

      this .initialized () .addInterest ("set_world__",    this);
      this .shutdown ()    .addInterest ("remove_world__", this);

      this [_headlightContainer] = getHeadlight (this);
      this [_viewerNode] .setup ();
   },
   getHeadlight: function ()
   {
      return this [_headlightContainer];
   },
   getActiveLayer: function ()
   {
      return this ._activeLayer .getValue ();
   },
   getActiveNavigationInfo: function ()
   {
      return this ._activeNavigationInfo .getValue ();
   },
   getActiveViewpoint: function ()
   {
      return this ._activeViewpoint .getValue ();
   },
   getCurrentViewer: function ()
   {
      return this ._viewer .getValue ();
   },
   getViewer: function ()
   {
      return this [_viewerNode];
   },
   addCollision: function (object)
   {
      this [_activeCollisions] .add (object);
   },
   removeCollision: function (object)
   {
      this [_activeCollisions] .delete (object);
   },
   getCollisionCount: function ()
   {
      return this [_activeCollisions] .size;
   },
   remove_world__: function ()
   {
      this .getWorld () ._activeLayer .removeInterest ("set_activeLayer__", this);
   },
   set_world__: function ()
   {
      this .getWorld () ._activeLayer .addInterest ("set_activeLayer__", this);

      this .set_activeLayer__ ();
   },
   set_activeLayer__: function ()
   {
      if (this ._activeLayer .getValue ())
      {
         this ._activeLayer .getValue () .getNavigationInfoStack () .removeInterest ("set_activeNavigationInfo__", this);
         this ._activeLayer .getValue () .getViewpointStack ()      .removeInterest ("set_activeViewpoint__",      this);
      }

      this ._activeLayer = this .getWorld () .getActiveLayer ();

      if (this ._activeLayer .getValue ())
      {
         this ._activeLayer .getValue () .getNavigationInfoStack () .addInterest ("set_activeNavigationInfo__", this);
         this ._activeLayer .getValue () .getViewpointStack ()      .addInterest ("set_activeViewpoint__",      this);
      }

      this .set_activeNavigationInfo__ ();
      this .set_activeViewpoint__ ();
   },
   set_activeNavigationInfo__: function ()
   {
      if (this ._activeNavigationInfo .getValue ())
         this ._activeNavigationInfo .getValue () ._viewer .removeFieldInterest (this ._viewer);

      if (this ._activeLayer .getValue ())
      {
         this ._activeNavigationInfo = this ._activeLayer .getValue () .getNavigationInfo ();

         this ._activeNavigationInfo .getValue () ._viewer .addFieldInterest (this ._viewer);

         this ._viewer = this ._activeNavigationInfo .getValue () ._viewer;
      }
      else
      {
         this ._activeNavigationInfo = null;
         this ._viewer               = "NONE";
      }
   },
   set_activeViewpoint__: function ()
   {
      if (this ._activeLayer .getValue ())
         this ._activeViewpoint = this ._activeLayer .getValue () .getViewpoint ();
      else
         this ._activeViewpoint = null;
   },
   set_viewer__: function (viewer)
   {
      if (this ._activeNavigationInfo .getValue ())
         this ._availableViewers = this ._activeNavigationInfo .getValue () ._availableViewers;
      else
         this ._availableViewers .length = 0;

      // Create viewer node.

      if (this [_viewerNode])
         this [_viewerNode] .dispose ();

      switch (viewer .getValue ())
      {
         case "EXAMINE":
            this [_viewerNode] = new Navigation_ExamineViewer (this);
            break;
         case "WALK":
            this [_viewerNode] = new Navigation_WalkViewer (this);
            break;
         case "FLY":
            this [_viewerNode] = new Navigation_FlyViewer (this);
            break;
         case "PLANE":
         case "PLANE_create3000.de":
            this [_viewerNode] = new Navigation_PlaneViewer (this);
            break;
         case "NONE":
            this [_viewerNode] = new Navigation_NoneViewer (this);
            break;
         case "LOOKAT":
            this [_viewerNode] = new Navigation_LookAtViewer (this);
            break;
         default:
            this [_viewerNode] = new Navigation_ExamineViewer (this);
            break;
      }

      this [_viewerNode] .setup ();
   },
};

/* harmony default export */ const Navigation_X3DNavigationContext = (X3DNavigationContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Networking/URLs.js
var URLs_filename = "/index.js";
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

function URLs () { }

URLs .prototype =
{
   getScriptUrl: (function ()
   {
      if (document .currentScript)
         var src = document .currentScript .src;
      else if (typeof __global_require__ === "function" && typeof URLs_filename === "string")
         var src = __global_require__ ("url") .pathToFileURL (URLs_filename) .href;
      else
         var src = document .location .href;

      return function ()
      {
         return src;
      };
   })(),
   getProviderUrl: function (file)
   {
      if (file)
      {
         if (this .getScriptUrl () .match (/\.min\.js$/))
            file += ".min";

         return new URL ("assets/components/" + file + ".js", this .getScriptUrl ()) .href;
      }

      return "https://create3000.github.io/x_ite/";
   },
   // getComponentUrl: function  (name)
   // {
   //    const url = urls .getProviderUrl (name);

   //    if (typeof __global_require__ === "function" && typeof __filename === "string")
   //       __global_require__ (__global_require__ ("url") .fileURLToPath (url));

   //    return url;
   // },
   getFontsUrl: function (file)
   {
      return new URL ("assets/fonts/" + file, this .getScriptUrl ()) .href;
   },
   getLinetypeUrl: function ()
   {
      return new URL ("assets/linetype/linetypes.png", this .getScriptUrl ()) .href;
   },
   getHatchingUrl: function (index)
   {
      return new URL ("assets/hatching/" + index + ".png", this .getScriptUrl ()) .href;
   },
};

/* harmony default export */ const Networking_URLs = (new URLs ());

;// CONCATENATED MODULE: ./src/x_ite/Browser/Networking/X3DNetworkingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const
   _loadingTotal   = Symbol (),
   X3DNetworkingContext_loadingObjects = Symbol (),
   _loading        = Symbol (),
   _location       = Symbol (),
   _defaultScene   = Symbol ();

function getBaseURI (element)
{
   let baseURI = element .baseURI;

   // Fix for Edge.
   if (baseURI .startsWith ("about:"))
      baseURI = document .baseURI;

   return baseURI;
}

function X3DNetworkingContext ()
{
   this .addChildObjects ("loadCount", new x_ite_Fields.SFInt32 ());

   this [_loadingTotal]   = 0;
   this [X3DNetworkingContext_loadingObjects] = new Set ();
   this [_loading]        = false;
   this [_location]       = getBaseURI (this .getElement () [0]);

   this .getCanvas () .hide ();

   if (this .getBrowserOptions () .getSplashScreen ())
   {
      this .getContextMenu () .hide ();
      this .getSplashScreen () .show ();
   }
}

X3DNetworkingContext .prototype =
{
   initialize: function ()
   { },
   getProviderUrl: function ()
   {
      return Networking_URLs.getProviderUrl ();
   },
   getLocation: function ()
   {
      return this [_location];
   },
   getDefaultScene: function ()
   {
      // Inline node's empty scene.

      this [_defaultScene] = this .createScene ();

      this [_defaultScene] .setPrivate (true);
      this [_defaultScene] .setLive (true);
      this [_defaultScene] .setup ();

      this .getDefaultScene = function () { return this [_defaultScene]; };

      Object .defineProperty (this, "getDefaultScene", { enumerable: false });

      return this [_defaultScene];
   },
   setBrowserLoading: function (value)
   {
      this [_loading] = value;

      this .setLoadCount (0);

      if (value)
      {
         this .resetLoadCount ();

         this .getShadow () .find (".x_ite-private-world-info") .remove ();

         if (this .getBrowserOptions () .getSplashScreen ())
         {
            this .getContextMenu ()  .hide ();
            this .getCanvas ()       .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeOut (0);
            this .getSplashScreen () .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeIn (0);
         }
         else
         {
            this .getCanvas () .hide ();
         }
      }
      else
      {
         if (this .getBrowserOptions () .getSplashScreen ())
         {
            this .getSplashScreen () .stop (true, true) .show () .fadeOut (2000);
            this .getCanvas ()       .stop (true, true) .hide () .fadeIn  (2000);
         }
         else
         {
            this .getCanvas () .show ();
         }
      }
   },
   getLoading: function ()
   {
      return this [_loading];
   },
   addLoadCount: function (object)
   {
      if (this [X3DNetworkingContext_loadingObjects] .has (object))
         return;

      ++ this [_loadingTotal];

      this [X3DNetworkingContext_loadingObjects] .add (object);

      this .setLoadCount (this [X3DNetworkingContext_loadingObjects] .size);
      this .setCursor ("DEFAULT");
   },
   removeLoadCount: function (object)
   {
      if (! this [X3DNetworkingContext_loadingObjects] .has (object))
         return;

      this [X3DNetworkingContext_loadingObjects] .delete (object);

      this .setLoadCount (this [X3DNetworkingContext_loadingObjects] .size);
   },
   setLoadCount: function (value)
   {
      this ._loadCount = value;

      const displayValue = [... this [X3DNetworkingContext_loadingObjects]] .reduce ((v, o) => v + ! o .isPrivate (), 0);

      if (value || this [_loading])
      {
         var string = (displayValue == 1 ? locale_gettext ("Loading %1 file") : locale_gettext ("Loading %1 files")) .replace ("%1", displayValue || 1);
      }
      else
      {
         var string = locale_gettext("Loading done");
         this .setCursor ("DEFAULT");
      }

      if (! this [_loading])
         this .getNotification () ._string = string;

      this .getSplashScreen () .find (".x_ite-private-spinner-text") .text (string);
      this .getSplashScreen () .find (".x_ite-private-progressbar div")
         .css ("width", (100 - 100 * value / this [_loadingTotal]) + "%");
   },
   resetLoadCount: function ()
   {
      this ._loadCount     = 0;
      this [_loadingTotal] = 0;

      this [X3DNetworkingContext_loadingObjects] .clear ();
   },
};

/* harmony default export */ const Networking_X3DNetworkingContext = (X3DNetworkingContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Picking/X3DPickingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _transformSensorNodes = Symbol (),
   _pickSensorNodes      = Symbol (),
   _pickingHierarchy     = Symbol (),
   _pickable             = Symbol (),
   _pickingTime          = Symbol ();

function X3DPickingContext ()
{
   this [_transformSensorNodes] = new Set ();
   this [_pickSensorNodes]      = [ new Set () ];
   this [_pickingHierarchy]     = [ ];
   this [_pickable]             = [ false ];
   this [_pickingTime]          = 0;
}

X3DPickingContext .prototype =
{
   initialize: function ()
   { },
   addTransformSensor: function (transformSensorNode)
   {
      this [_transformSensorNodes] .add (transformSensorNode);
      this .enablePicking ();
   },
   removeTransformSensor: function (transformSensorNode)
   {
      this [_transformSensorNodes] .delete (transformSensorNode);
      this .enablePicking ();
   },
   addPickSensor: function (pickSensorNode)
   {
      this [_pickSensorNodes] [0] .add (pickSensorNode);
      this .enablePicking ();
   },
   removePickSensor: function (pickSensorNode)
   {
      this [_pickSensorNodes] [0] .delete (pickSensorNode);
      this .enablePicking ();
   },
   getPickSensors: function ()
   {
      return this [_pickSensorNodes];
   },
   getPickingHierarchy: function ()
   {
      return this [_pickingHierarchy];
   },
   getPickable: function ()
   {
      return this [_pickable];
   },
   enablePicking: function ()
   {
      if (this [_transformSensorNodes] .size || this [_pickSensorNodes] [0] .size)
         this ._sensorEvents .addInterest ("picking", this);
      else
         this ._sensorEvents .removeInterest ("picking", this);
   },
   picking: function ()
   {
      const t0 = performance .now ();

      this .getWorld () .traverse (Rendering_TraverseType.PICKING, null);

      for (const transformSensorNode of this [_transformSensorNodes])
      {
         transformSensorNode .process ();
      }

      for (const pickSensorNode of this [_pickSensorNodes] [0])
      {
         pickSensorNode .process ();
      }

      this [_pickingTime] = performance .now () - t0;
   },
   getPickingTime: function ()
   {
      return this [_pickingTime];
   },
};

/* harmony default export */ const Picking_X3DPickingContext = (X3DPickingContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/PointingDeviceSensor/PointingDevice.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const CONTEXT_MENU_TIME = 1200;

function PointingDevice (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .cursor     = "DEFAULT";
   this .isOver     = false;
   this .motionTime = 0;
}

PointingDevice .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: PointingDevice,
   getTypeName: function ()
   {
      return "PointingDevice";
   },
   initialize: function ()
   {
      const element = this .getBrowser () .getSurface ();

      //element .on ("mousewheel.PointingDevice", this .mousewheel .bind (this));
      element .on ("mousedown.PointingDevice" + this .getId (), this .mousedown  .bind (this));
      element .on ("mouseup.PointingDevice"   + this .getId (), this .mouseup    .bind (this));
      element .on ("dblclick.PointingDevice"  + this .getId (), this .dblclick   .bind (this));
      element .on ("mousemove.PointingDevice" + this .getId (), this .mousemove  .bind (this));
      element .on ("mouseout.PointingDevice"  + this .getId (), this .onmouseout .bind (this));

      element .on ("touchstart.PointingDevice" + this .getId (), this .touchstart .bind (this));
      element .on ("touchend.PointingDevice"   + this .getId (), this .touchend   .bind (this));
   },
   mousewheel: function (event)
   {
      // event .preventDefault () must be done in the several viewers.
   },
   mousedown: function (event)
   {
      const browser = this .getBrowser ();

      browser .getElement () .focus ();

      if (browser .getShiftKey () && browser .getControlKey ())
         return;

      if (event .button === 0)
      {
         const
            element = browser .getSurface (),
            offset  = element .offset (),
            x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
            y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

         element .off ("mousemove.PointingDevice" + this .getId ());

         $(document) .on ("mouseup.PointingDevice"   + this .getId (), this .mouseup   .bind (this));
         $(document) .on ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));
         $(document) .on ("touchend.PointingDevice"  + this .getId (), this .touchend  .bind (this));
         $(document) .on ("touchmove.PointingDevice" + this .getId (), this .touchmove .bind (this));

         if (browser .buttonPressEvent (x, y))
         {
            event .preventDefault ();
            event .stopImmediatePropagation (); // Keeps the rest of the handlers from being executed

            browser .setCursor ("HAND");
            browser .finished () .addInterest ("onverifymotion", this, x, y);
         }
      }
   },
   mouseup: function (event)
   {
      event .preventDefault ();

      if (event .button === 0)
      {
         const
            browser = this .getBrowser (),
            element = browser .getSurface (),
            offset  = element .offset (),
            x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
            y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

         $(document) .off (".PointingDevice" + this .getId ());
         element .on ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));

         browser .buttonReleaseEvent ();
         browser .setCursor (this .isOver ? "HAND" : "DEFAULT");
         browser .finished () .addInterest ("onverifymotion", this, x, y);
         browser .addBrowserEvent ();

         this .cursor = "DEFAULT";
      }
   },
   dblclick: function (event)
   {
      if (this .isOver)
         event .stopImmediatePropagation ();
   },
   mousemove: function (event)
   {
      event .preventDefault ();

      const browser = this .getBrowser ();

      if (this .motionTime === browser .getCurrentTime ())
         return;

      this .motionTime = browser .getCurrentTime ();

      const
         element = browser .getSurface (),
         offset  = element .offset (),
         x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
         y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

      this .onmotion (x, y);
   },
   touchstart: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // button 0.

            event .button = 0;
            event .pageX  = touches [0] .pageX;
            event .pageY  = touches [0] .pageY;

            this .mousedown (event);

            // Show context menu on long tab.

            const nearestHit = this .getBrowser () .getNearestHit ();

            if (! nearestHit || nearestHit .sensors .size === 0)
            {
               this .touchX       = event .pageX;
               this .touchY       = event .pageY;
               this .touchTimeout = setTimeout (this .showContextMenu .bind (this, event), CONTEXT_MENU_TIME);
            }

            break;
         }
         case 2:
         {
            this .touchend (event);
            break;
         }
      }
   },
   touchend: function (event)
   {
      event .button = 0;

      this .mouseup (event);

      clearTimeout (this .touchTimeout);
   },
   touchmove: function (event)
   {
      const touches = event .originalEvent .touches;

      switch (touches .length)
      {
         case 1:
         {
            // button 0.

            event .button = 0;
            event .pageX  = touches [0] .pageX;
            event .pageY  = touches [0] .pageY;

            this .mousemove (event);

            if (Math .hypot (this .touchX - event .pageX, this .touchY - event .pageY) > 7)
               clearTimeout (this .touchTimeout);

            break;
         }
      }
   },
   onmotion: function (x, y)
   {
      const browser = this .getBrowser ();

      if (browser .motionNotifyEvent (x, y))
      {
         if (!this .isOver)
         {
            this .isOver = true;
            this .cursor = browser .getCursor ();

            browser .setCursor ("HAND");
         }
      }
      else
      {
         if (this .isOver)
         {
            this .isOver = false;

            browser .setCursor (this .cursor);
         }
      }
   },
   onmouseout: function (event)
   {
      this .getBrowser () .leaveNotifyEvent ();
   },
   onverifymotion: function (x, y)
   {
      // Verify isOver state. This is necessary if an Switch changes on buttonReleaseEvent
      // and the new child has a sensor node inside. This sensor node must be update to
      // reflect the correct isOver state.

      this .getBrowser () .finished () .removeInterest ("onverifymotion", this);

      this .onmotion (x, y);
   },
   showContextMenu: function (event)
   {
      this .getBrowser () .getContextMenu () .show (event);
   },
});

/* harmony default export */ const PointingDeviceSensor_PointingDevice = (PointingDevice);

;// CONCATENATED MODULE: ./src/x_ite/Browser/PointingDeviceSensor/X3DPointingDeviceSensorContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const
   _pointingDevice  = Symbol (),
   _cursorType      = Symbol (),
   _pointer         = Symbol (),
   _hitRay          = Symbol (),
   _hits            = Symbol (),
   _enabledSensors  = Symbol (),
   _pickOnlySensors = Symbol (),
   _selectedLayer   = Symbol (),
   _overSensors     = Symbol (),
   _activeSensors   = Symbol (),
   _hitPointSorter  = Symbol (),
   _layerNumber     = Symbol (),
   _layerSorter     = Symbol (),
   _pointerTime     = Symbol ();

const line = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero);

function X3DPointingDeviceSensorContext ()
{
   this [_pointingDevice] = new PointingDeviceSensor_PointingDevice (this);
   this [_pointer]        = new Numbers_Vector2 (0, 0);
   this [_hitRay]         = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero);
   this [_hits]           = [ ];
   this [_enabledSensors] = [new Map ()];
   this [_selectedLayer]  = null;
   this [_overSensors]    = new Set ();
   this [_activeSensors]  = new Set ();
   this [_hitPointSorter] = new Algorithms_MergeSort (this [_hits], function (lhs, rhs) { return lhs .intersection .point .z < rhs .intersection .point .z; });
   this [_layerSorter]    = new Algorithms_MergeSort (this [_hits], function (lhs, rhs) { return lhs .layerNumber < rhs .layerNumber; });
   this [_pointerTime]    = 0;
}

X3DPointingDeviceSensorContext .prototype =
{
   initialize: function ()
   {
      this .setCursor ("DEFAULT");

      this [_pointingDevice] .setup ();
   },
   setCursor: function (value)
   {
      const div = this .getSurface ();

      this [_cursorType] = value;

      switch (value)
      {
         case "HAND": // Hand with finger
            div .css ("cursor", "pointer");
            break;
         case "MOVE": // Hand grabed something
            div .css ("cursor", "move");
            break;
         case "CROSSHAIR":
            div .css ("cursor", "crosshair");
            break;
         default:
         {
            if (this ._loadCount .getValue ())
               div .css ("cursor", "wait");
            else if (this [_pointingDevice] && this [_pointingDevice] .isOver)
               div .css ("cursor", "pointer");
            else
               div .css ("cursor", "default");
            break;
         }
      }
   },
   getCursor: function ()
   {
      return this [_cursorType];
   },
   getPointer: function ()
   {
      return this [_pointer];
   },
   isPointerInRectangle: function (rectangle)
   {
      return this [_pointer] .x > rectangle .x &&
             this [_pointer] .x < rectangle .x + rectangle .z &&
             this [_pointer] .y > rectangle .y &&
             this [_pointer] .y < rectangle .y + rectangle .w;
   },
   setLayerNumber: function (value)
   {
      this [_layerNumber] = value;
   },
   getSelectedLayer: function ()
   {
      return this [_selectedLayer];
   },
   setHitRay: function (projectionMatrix, viewport)
   {
      Geometry_ViewVolume.unProjectRay (this [_pointer] .x, this [_pointer] .y, Numbers_Matrix4.Identity, projectionMatrix, viewport, this [_hitRay]);
   },
   getHitRay: function ()
   {
      return this [_hitRay];
   },
   getSensors: function ()
   {
      return this [_enabledSensors];
   },
   getPickOnlySensors: function ()
   {
      return this [_pickOnlySensors];
   },
   addHit: function (intersection, layer, shape, modelViewMatrix)
   {
      const sensors = this [_enabledSensors] .at (-1);

      this [_hits] .push ({
         pointer:         this [_pointer],
         hitRay:          this [_hitRay] .copy (),
         intersection:    intersection,
         sensors:         new Set (sensors .values ()),
         layer:           layer,
         layerNumber:     this [_layerNumber],
         shape:           shape,
         modelViewMatrix: modelViewMatrix .copy (),
      });
   },
   getHits: function ()
   {
      return this [_hits];
   },
   getNearestHit: function ()
   {
      return this [_hits] .at (-1);
   },
   buttonPressEvent: function (x, y)
   {
      this .touch (x, y, true);

      if (this [_hits] .length === 0)
         return false;

      const nearestHit = this .getNearestHit ();

      this [_selectedLayer] = nearestHit .layer;
      this [_activeSensors] = nearestHit .sensors;

      for (const sensor of this [_activeSensors])
         sensor .set_active__ (true, nearestHit);

      return !! nearestHit .sensors .size;
   },
   buttonReleaseEvent: function ()
   {
      this [_selectedLayer] = null;

      for (const sensor of this [_activeSensors])
         sensor .set_active__ (false, null);

      this [_activeSensors] = new Set ();

      // Selection

      return true;
   },
   motionNotifyEvent: function (x, y)
   {
      this .touch (x, y, true);
      this .motion ();

      return !! (this [_hits] .length && this [_hits] .at (-1) .sensors .size);
   },
   leaveNotifyEvent: function ()
   { },
   touch: function (x, y, pickOnlySensors)
   {
      if (this .getViewer () ._isActive .getValue ())
      {
         this [_pointerTime] = 0;
         return;
      }

      const t0 = performance .now ();

      this [_pickOnlySensors] = pickOnlySensors;

      this [_pointer] .set (x, y);

      // Clear hits.

      this [_hits] .length = 0;

      // Pick.

      this .getWorld () .traverse (Rendering_TraverseType.POINTER, null);

      // Picking end.

      this [_hitPointSorter] .sort (0, this [_hits] .length);
      this [_layerSorter]    .sort (0, this [_hits] .length);

      this .addBrowserEvent ();
      this [_pointerTime] = performance .now () - t0;
   },
   motion: function ()
   {
      if (this [_hits] .length)
      {
         var nearestHit = this [_hits] .at (-1);
      }
      else
      {
         var nearestHit = {
            pointer:         this [_pointer],
            modelViewMatrix: new Numbers_Matrix4 (),
            hitRay:          this [_selectedLayer] ? this [_hitRay] : line,
            intersection:    null,
            sensors:         new Set (),
            shape:           null,
            layer:           null,
            layerNumber:     0,
         };
      }

      // Set isOver to FALSE for appropriate nodes

      if (this [_hits] .length)
      {
         var difference = Math_Algorithm.set_difference (this [_overSensors], nearestHit .sensors, new Set ());
      }
      else
      {
         var difference = new Set (this [_overSensors]);
      }

      for (const sensor of difference)
         sensor .set_over__ (false, nearestHit);

      // Set isOver to TRUE for appropriate nodes

      if (this [_hits] .length)
      {
         this [_overSensors] = nearestHit .sensors;

         for (const sensor of this [_overSensors])
            sensor .set_over__ (true, nearestHit);
      }
      else
      {
         this [_overSensors] = new Set ();
      }

      // Forward motion event to active drag sensor nodes

      for (const sensor of this [_activeSensors])
         sensor .set_motion__ (nearestHit);
   },
   getPointerTime: function ()
   {
      return this [_pointerTime];
   },
};

/* harmony default export */ const PointingDeviceSensor_X3DPointingDeviceSensorContext = (X3DPointingDeviceSensorContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Rendering/X3DRenderingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


const
   _viewport     = Symbol (),
   _localObjects = Symbol (),
   _depthShaders = Symbol (),
   _resizer      = Symbol ();

function X3DRenderingContext ()
{
   this [_viewport]     = [0, 0, 300, 150];
   this [_localObjects] = [ ]; // shader objects dumpster
   this [_depthShaders] = new Map ();
}

X3DRenderingContext .prototype =
{
   initialize: function ()
   {
      // Configure context.

      const gl = this .getContext ();

      gl .enable (gl .SCISSOR_TEST);
      gl .depthFunc (gl .LEQUAL);
      gl .clearDepth (1);

      gl .blendFuncSeparate (gl .SRC_ALPHA, gl .ONE_MINUS_SRC_ALPHA, gl .ONE, gl .ONE_MINUS_SRC_ALPHA);
      gl .blendEquationSeparate (gl .FUNC_ADD, gl .FUNC_ADD);

      // Configure viewport.

      $(document) .on ('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', this .onfullscreen .bind (this));

      //https://github.com/sdecima/javascript-detect-element-resize
      this [_resizer] = new ResizeSensor (this .getSurface (), this .reshape .bind (this));

			this .getSurface () .css ("position", ""); // Reset position, set from ResizeSensor.

      this .reshape ();
   },
   getRenderer: function ()
   {
      const gl = this .getContext ();

      if (! navigator .userAgent .match (/Firefox/))
      {
         const dbgRenderInfo = gl .getExtension ("WEBGL_debug_renderer_info");

         if (dbgRenderInfo)
            return gl .getParameter (dbgRenderInfo .UNMASKED_RENDERER_WEBGL);
      }

      return gl .getParameter (gl .RENDERER);
   },
   getVendor: function ()
   {
      const gl = this .getContext ();

      if (! navigator .userAgent .match (/Firefox/))
      {
         const dbgRenderInfo = gl .getExtension ("WEBGL_debug_renderer_info");

         if (dbgRenderInfo)
            return gl .getParameter (dbgRenderInfo .UNMASKED_VENDOR_WEBGL);
      }

      return gl .getParameter (gl .VENDOR);
   },
   getWebGLVersion: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .VERSION);
   },
   getAntialiased: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .SAMPLES) > 0;
   },
   getMaxClipPlanes: function ()
   {
      return 6;
   },
   getDepthSize: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .DEPTH_BITS);
   },
   getColorDepth: function ()
   {
      const gl = this .getContext ();

      return (gl .getParameter (gl .RED_BITS) +
              gl .getParameter (gl .BLUE_BITS) +
              gl .getParameter (gl .GREEN_BITS) +
              gl .getParameter (gl .ALPHA_BITS));
   },
   getViewport: function ()
   {
      return this [_viewport];
   },
   getLocalObjects: function ()
   {
      return this [_localObjects];
   },
   getDepthShader: function (numClipPlanes, particles)
   {
      let key = "";

      key += numClipPlanes;
      key += particles ? "1" : "0";

      return this [_depthShaders] .get (key) || this .createDepthShader (key, numClipPlanes, particles);
   },
   createDepthShader: function (key, numClipPlanes, particles)
   {
      const options = [ ];

      if (numClipPlanes)
      {
         options .push ("X3D_CLIP_PLANES");
         options .push ("X3D_NUM_CLIP_PLANES " + numClipPlanes);
      }

      if (particles)
         options .push ("X3D_PARTICLE_SYSTEM");

      const shaderNode = this .createShader ("DepthShader", "Depth", "Depth", options);

      this [_depthShaders] .set (key, shaderNode);

      return shaderNode;
   },
   reshape: function ()
   {
      const
         gl      = this .getContext (),
         jCanvas = this .getCanvas (),
         width   = jCanvas .width (),
         height  = jCanvas .height (),
         canvas  = jCanvas [0];

      canvas .width  = width;
      canvas .height = height;

      this [_viewport] [2] = width;
      this [_viewport] [3] = height;

      gl .viewport (0, 0, width, height);
      gl .scissor  (0, 0, width, height);

      this .addBrowserEvent ();
   },
   onfullscreen: function ()
   {
      const element = this .getElement ();

      if (element .fullScreen ())
         element .addClass ("x_ite-fullscreen");
      else
         element .removeClass ("x_ite-fullscreen");
   },
};

/* harmony default export */ const Rendering_X3DRenderingContext = (X3DRenderingContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Scripting/X3DScriptingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const _scripts = Symbol ();

function X3DScriptingContext ()
{
   this [_scripts] = [this];
}

X3DScriptingContext .prototype =
{
   initialize: function ()
   { },
   isExternal: function ()
   {
      return this [_scripts] .length === 1;
   },
   getScriptStack: function ()
   {
      return this [_scripts];
   }
};

/* harmony default export */ const Scripting_X3DScriptingContext = (X3DScriptingContext);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/ClipPlanes.glsl.js
/* harmony default export */ const ClipPlanes_glsl = (/* glsl */`
#if defined (X3D_CLIP_PLANES)

uniform vec4 x3d_ClipPlane [X3D_NUM_CLIP_PLANES];

void
clip ()
{
   for (int i = 0; i < X3D_NUM_CLIP_PLANES; ++ i)
   {
      if (dot (vertex, x3d_ClipPlane [i] .xyz) - x3d_ClipPlane [i] .w < 0.0)
         discard;
   }
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Colors.glsl.js
/* harmony default export */ const Colors_glsl = (/* glsl */`
#define MANUAL_SRGB

vec4
SRGBtoLINEAR (const in vec4 srgbIn)
{
   #if defined (MANUAL_SRGB)
      #if defined (SRGB_FAST_APPROXIMATION)
         vec3 linOut = pow (srgbIn .xyz, vec3 (2.2));
      #else //SRGB_FAST_APPROXIMATION
         vec3 bLess  = step (vec3 (0.04045), srgbIn .xyz);
         vec3 linOut = mix (srgbIn .xyz / vec3 (12.92), pow ((srgbIn .xyz + vec3 (0.055)) / vec3 (1.055), vec3 (2.4)), bLess);
      #endif //SRGB_FAST_APPROXIMATION
      return vec4 (linOut, srgbIn .w);
   #else //MANUAL_SRGB
      return srgbIn;
   #endif //MANUAL_SRGB
}

vec4
Gamma (const in vec4 color)
{
   #if defined (MANUAL_SRGB)
      return vec4 (pow (color .rgb, vec3 (1.0 / 2.2)), color .a);
   #else
      return color;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Fog.glsl.js
/* harmony default export */ const Fog_glsl = (/* glsl */`
#if defined (X3D_FOG)

uniform x3d_FogParameters x3d_Fog;

float
getFogInterpolant ()
{
   // Returns 0.0 for fog color and 1.0 for material color.

   #if defined (X3D_FOG_COORDS)
      return clamp (1.0 - fogDepth, 0.0, 1.0);
   #else
      float visibilityRange = x3d_Fog .visibilityRange;
      float dV              = length (x3d_Fog .matrix * vertex);

      #if defined (X3D_FOG_LINEAR)
         return max (0.0, visibilityRange - dV) / visibilityRange;
      #elif defined (X3D_FOG_EXPONENTIAL)
         return exp (-dV / max (0.001, visibilityRange - dV));
      #endif
   #endif
}

vec3
getFogColor (const in vec3 color)
{
   return mix (x3d_Fog .color, color, getFogInterpolant ());
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Fragment.glsl.js
/* harmony default export */ const Fragment_glsl = (/* glsl */`
#if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
   #extension GL_EXT_frag_depth : enable
#endif

uniform float x3d_AlphaCutoff;

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   varying float fogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   varying vec4 color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         varying vec4 texCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         varying vec4 texCoord1;
      #endif
   #endif
#else
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         vec4 texCoord0 = vec4 (0.0);
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         vec4 texCoord1 = vec4 (0.0);
      #endif
   #endif
#endif

#if defined (X3D_NORMALS)
   varying vec3 normal;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      varying vec3 localNormal;
   #endif
#else
   const vec3 normal = vec3 (0.0, 0.0, 1.0);

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      const vec3 localNormal = vec3 (0.0, 0.0, 1.0);
   #endif
#endif

varying vec3 vertex;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
   varying vec3 localVertex;
#endif

#if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
   uniform float x3d_LogarithmicFarFactor1_2;
   varying float depth;
#endif

#pragma X3D include "Point.glsl"
#pragma X3D include "Hatch.glsl"
#pragma X3D include "Fog.glsl"
#pragma X3D include "ClipPlanes.glsl"
#pragma X3D include "Texture.glsl"

vec4
getMaterialColor ();

vec4
getFinalColor ()
{
   #if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)
      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         setTexCoords ();

         return getMaterialColor ();
       #else
         return getPointColor (getMaterialColor ());
      #endif
   #else
      return getMaterialColor ();
   #endif
}
void
fragment_main ()
{
   #if defined (X3D_CLIP_PLANES)
      clip ();
   #endif

   vec4 finalColor = getFinalColor ();

   #if (defined (X3D_GEOMETRY_2D) || defined (X3D_GEOMETRY_3D)) && defined (X3D_STYLE_PROPERTIES)
      finalColor = getHatchColor (finalColor);
   #endif

   #if defined (X3D_FOG)
      finalColor .rgb = getFogColor (finalColor .rgb);
   #endif

   if (finalColor .a < x3d_AlphaCutoff)
      discard;

   gl_FragColor = finalColor;

   #if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
      //http://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html
      gl_FragDepthEXT = log2 (depth) * x3d_LogarithmicFarFactor1_2;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Hatch.glsl.js
/* harmony default export */ const Hatch_glsl = (/* glsl */`
#if (defined (X3D_GEOMETRY_2D) || defined (X3D_GEOMETRY_3D)) && defined (X3D_STYLE_PROPERTIES)

uniform x3d_FillPropertiesParameters x3d_FillProperties;

vec4
getHatchColor (vec4 color)
{
   vec4 finalColor = x3d_FillProperties .filled ? color : vec4 (0.0);

   if (x3d_FillProperties .hatched)
   {
      vec4 hatch = texture2D (x3d_FillProperties .texture, gl_FragCoord .xy / 32.0);

      hatch .rgb *= x3d_FillProperties .hatchColor;
      finalColor  = mix (finalColor, hatch, hatch .a);
   }

   return finalColor;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Material.glsl.js
/* harmony default export */ const Material_glsl = (/* glsl */`
uniform x3d_MaterialParameters x3d_Material;

#if defined (X3D_LIGHTING)

#pragma X3D include "SpotFactor.glsl"
#pragma X3D include "Shadow.glsl"

uniform x3d_LightSourceParameters x3d_LightSource [X3D_NUM_LIGHTS];

vec3
getMaterialColor (const in vec3 vertex, const in vec3 N, const in vec3 ambientColor, const in vec3 diffuseColor, const in vec3 specularColor, const in float shininess)
{
   // Apply light sources

   vec3 V = normalize (-vertex);

   vec3 finalColor = vec3 (0.0);

   for (int i = 0; i < X3D_NUM_LIGHTS; ++ i)
   {
      x3d_LightSourceParameters light = x3d_LightSource [i];

      vec3  vL = light .location - vertex;
      float dL = length (light .matrix * vL);
      bool  di = light .type == x3d_DirectionalLight;

      if (di || dL <= light .radius)
      {
         vec3 d = light .direction;
         vec3 c = light .attenuation;
         vec3 L = di ? -d : normalize (vL);      // Normalized vector from point on geometry to light source i position.
         vec3 H = normalize (L + V);             // Specular term

         float lightAngle     = max (dot (N, L), 0.0);      // Angle between normal and light ray.
         vec3  diffuseTerm    = diffuseColor * lightAngle;
         float specularFactor = shininess > 0.0 ? pow (max (dot (N, H), 0.0), shininess * 128.0) : 1.0;
         vec3  specularTerm   = specularColor * specularFactor;

         float attenuationFactor     = di ? 1.0 : 1.0 / max (dot (c, vec3 (1.0, dL, dL * dL)), 1.0);
         float spotFactor            = light .type == x3d_SpotLight ? getSpotFactor (light .cutOffAngle, light .beamWidth, L, d) : 1.0;
         float attenuationSpotFactor = attenuationFactor * spotFactor;
         vec3  ambientTerm           = light .ambientIntensity * ambientColor;
         vec3  diffuseSpecularTerm   = light .intensity * (diffuseTerm + specularTerm);

         #if defined (X3D_FRAGMENT_SHADER) && defined (X3D_SHADOWS)
            if (lightAngle > 0.0)
               diffuseSpecularTerm = mix (diffuseSpecularTerm, light .shadowColor, getShadowIntensity (i, light));
         #endif

         finalColor += attenuationSpotFactor * light .color * (ambientTerm + diffuseSpecularTerm);
      }
   }

   return finalColor;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Normal.glsl.js
/* harmony default export */ const Normal_glsl = (/* glsl */`
#if defined (X3D_NORMAL_TEXTURE)
// Tangent-Bitangent-Normal-Matrix
mat3
getTBNMatrix (const in vec2 texCoord)
{
   vec3 pos_dx = dFdx (vertex);
   vec3 pos_dy = dFdy (vertex);
   vec3 tex_dx = dFdx (vec3 (texCoord, 0.0));
   vec3 tex_dy = dFdy (vec3 (texCoord, 0.0));
   vec3 t      = (tex_dy .t * pos_dx - tex_dx .t * pos_dy) / (tex_dx .s * tex_dy.t - tex_dy .s * tex_dx .t);
   vec3 N      = normalize (normal); // OR generated face normal: n = normalize (cross (pos_dx, pos_dy));
   vec3 T      = normalize (t - N * dot (N, t));
   vec3 B      = normalize (cross (N, T));
   mat3 tbn    = mat3 (T, B, N);

   return tbn;
}
#endif

#if defined (X3D_NORMAL_TEXTURE)
uniform x3d_NormalTextureParameters x3d_NormalTexture;
#endif

vec3
getNormalVector (const in float normalScale)
{
   float facing = gl_FrontFacing ? 1.0 : -1.0;

   // Get normal vector.

   #if defined (X3D_NORMAL_TEXTURE) && ! defined (X3D_NORMAL_TEXTURE_3D)
      vec3 texCoord = getTexCoord (x3d_NormalTexture .textureTransformMapping, x3d_NormalTexture .textureCoordinateMapping);
      vec3 scale    = vec3 (vec2 (normalScale), 1.0);
      mat3 tbn      = getTBNMatrix (texCoord .st);

      #if defined (X3D_NORMAL_TEXTURE_2D)
         vec3 n = texture2D (x3d_NormalTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_NORMAL_TEXTURE_CUBE)
         vec3 n = textureCube (x3d_NormalTexture .textureCube, texCoord) .rgb;
      #endif

      return normalize (tbn * ((n * 2.0 - 1.0) * scale)) * facing;
   #else
      return normalize (normal) * facing;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Pack.glsl.js
/* harmony default export */ const Pack_glsl = (/* glsl */`
vec4
pack (const in float value)
{
   const vec3 bitShifts = vec3 (255.0,
                                255.0 * 255.0,
                                255.0 * 255.0 * 255.0);

   return vec4 (value, fract (value * bitShifts));
}

#if defined (X3D_DEPTH_TEXTURE)

float
unpack (const in vec4 color)
{
   return color .r;
}

#else

float
unpack (const vec4 color)
{
   const vec3 bitShifts = vec3 (1.0 / 255.0,
                                1.0 / (255.0 * 255.0),
                                1.0 / (255.0 * 255.0 * 255.0));

   return color .x + dot (color .gba, bitShifts);
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Perlin.glsl.js
/* harmony default export */ const Perlin_glsl = (/* glsl */`
//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83

float rand (vec2 co) { return fract (sin (dot (co.xy, vec2 (12.9898,78.233))) * 43758.5453); }
float rand (vec2 co, float l) { return rand (vec2 (rand (co), l)); }
float rand (vec2 co, float l, float t) { return rand (vec2 (rand (co, l), t)); }

float
perlin (vec2 p, float dim, float time)
{
   const float M_PI = 3.14159265358979323846;

   vec2 pos   = floor (p * dim);
   vec2 posx  = pos + vec2 (1.0, 0.0);
   vec2 posy  = pos + vec2 (0.0, 1.0);
   vec2 posxy = pos + vec2 (1.0);

   float c   = rand (pos,   dim, time);
   float cx  = rand (posx,  dim, time);
   float cy  = rand (posy,  dim, time);
   float cxy = rand (posxy, dim, time);

   vec2 d = fract (p * dim);

   d = -0.5 * cos (d * M_PI) + 0.5;

   float ccx    = mix (c,   cx,    d.x);
   float cycxy  = mix (cy,  cxy,   d.x);
   float center = mix (ccx, cycxy, d.y);

   return center * 2.0 - 1.0;
}

vec3
perlin (vec3 p)
{
   return vec3 (perlin (p.xy, 1.0, 0.0),
                perlin (p.yz, 1.0, 0.0),
                perlin (p.zx, 1.0, 0.0));
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Point.glsl.js
/* harmony default export */ const Point_glsl = (/* glsl */`
#if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)

varying float pointSize;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
void
setTexCoords ()
{
   vec4 texCoord = vec4 (gl_PointCoord .x, 1.0 - gl_PointCoord .y, 0.0, 1.0);

   #if X3D_NUM_TEXTURE_COORDINATES > 0
      texCoord0 = texCoord;
   #endif

   #if X3D_NUM_TEXTURE_COORDINATES > 1
      texCoord1 = texCoord;
   #endif
}
#endif

vec4
getPointColor (in vec4 color)
{
   if (pointSize > 1.0)
      color .a *= clamp (pointSize * (0.5 - distance (vec2 (0.5), gl_PointCoord)), 0.0, 1.0);

   else
      color .a *= pointSize;

   return color;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/PointSize.glsl.js
/* harmony default export */ const PointSize_glsl = (/* glsl */`
#if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)

uniform x3d_PointPropertiesParameters x3d_PointProperties;

varying float pointSize;

float
getPointSize (const in vec3 vertex)
{
   // Determine point size.

   float pointSizeMinValue    = x3d_PointProperties .pointSizeMinValue;
   float pointSizeMaxValue    = x3d_PointProperties .pointSizeMaxValue;
   vec3  pointSizeAttenuation = x3d_PointProperties .pointSizeAttenuation;
   float dL                   = length (vertex);
   float pointSize            = 0.0;

   pointSize  = x3d_PointProperties .pointSizeScaleFactor;
   pointSize /= dot (pointSizeAttenuation, vec3 (1.0, dL, dL * dL));
   pointSize  = clamp (pointSize, pointSizeMinValue, pointSizeMaxValue);

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURE)
      return pointSize;
   #else
      return pointSize + 1.0 - step (pointSize, 1.0);
   #endif
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Shadow.glsl.js
/* harmony default export */ const Shadow_glsl = (/* glsl */`
#if defined (X3D_FRAGMENT_SHADER) && defined (X3D_SHADOWS)

#pragma X3D include "Pack.glsl"

uniform sampler2D x3d_ShadowMap [X3D_NUM_LIGHTS];

float
getShadowDepth (const in int index, const in vec2 shadowCoord)
{
   #if X3D_NUM_LIGHTS > 0
   if (index == 0)
      return unpack (texture2D (x3d_ShadowMap [0], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 1
   if (index == 1)
      return unpack (texture2D (x3d_ShadowMap [1], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 2
   if (index == 2)
      return unpack (texture2D (x3d_ShadowMap [2], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 3
   if (index == 3)
      return unpack (texture2D (x3d_ShadowMap [3], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 4
   if (index == 4)
      return unpack (texture2D (x3d_ShadowMap [4], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 5
   if (index == 5)
      return unpack (texture2D (x3d_ShadowMap [5], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 6
   if (index == 6)
      return unpack (texture2D (x3d_ShadowMap [6], shadowCoord));
   #endif

   #if X3D_NUM_LIGHTS > 7
   if (index == 7)
      return unpack (texture2D (x3d_ShadowMap [7], shadowCoord));
   #endif

   return 0.0;
}

float
texture2DCompare (const in int index, const in vec2 texCoord, const in float compare)
{
   float shadowDepth = getShadowDepth (index, texCoord);

   return (1.0 - step (1.0, shadowDepth)) * step (shadowDepth, compare);
}

float
texture2DShadowLerp (const in int index, const in vec2 texelSize, const in float shadowMapSize, const in vec2 texCoord, const in float compare)
{
   const vec2 offset = vec2 (0.0, 1.0);

   vec2 centroidTexCoord = floor (texCoord * shadowMapSize + 0.5) / shadowMapSize;

   float lb = texture2DCompare (index, centroidTexCoord + texelSize * offset .xx, compare);
   float lt = texture2DCompare (index, centroidTexCoord + texelSize * offset .xy, compare);
   float rb = texture2DCompare (index, centroidTexCoord + texelSize * offset .yx, compare);
   float rt = texture2DCompare (index, centroidTexCoord + texelSize * offset .yy, compare);

   vec2 f = fract (texCoord * shadowMapSize + 0.5);

   float a = mix (lb, lt, f.y);
   float b = mix (rb, rt, f.y);
   float c = mix (a, b, f.x);

   return c;
}

//https://gist.github.com/tschw/da10c43c467ce8afd0c4
vec2
cubeToUVCompact (in vec3 v, const float texelSizeY)
{
   // Compact layout:
   //
   // xzXZ		Char: Axis
   // yyYY		Case: Sign

   // Number of texels to avoid at the edge of each square

   vec3 absV = abs (v);

   // Intersect unit cube

   float scaleToCube = 1.0 / max (absV .x, max (absV .y, absV .z));

   absV *= scaleToCube;

   // Apply scale to avoid seams

   // one texel less per square (half a texel on each side)
   v *= scaleToCube * (1.0 - 2.0 * texelSizeY);

   // Unwrap

   // space: -1 ... 1 range for each square
   //
   // #X##		dim    := ( 4 , 2 )
   //  # #		center := ( 1 , 1 )

   vec2 planar = v .xy;

   float almostATexel = 1.5 * texelSizeY;
   float almostOne    = 1.0 - almostATexel;

   if (absV .z >= almostOne)
   {
      // zZ

      if (v .z > 0.0)
         planar .x = 4.0 - v .x;
   }
   else if (absV .x >= almostOne)
   {
      // xX

      float signX = sign (v .x);

      planar .x = v .z * signX + 2.0 * signX;
   }
   else if (absV .y >= almostOne)
   {
      // yY

      float signY = sign (v .y);

      planar .x = (v .x + 0.5 + signY) * 2.0;
      planar .y = v .z * signY - 2.0;
   }

   // Transform to UV space

   // scale := 0.5 / dim
   // translate := ( center + 0.5 ) / dim
   return vec2 (0.125, 0.25) * planar + vec2 (0.375, 0.75);
}

mat4
getPointLightRotations (const in vec3 vector)
{
   mat4 rotations [6];
   rotations [0] = mat4 ( 0, 0 , 1, 0,   0, 1,  0, 0,  -1,  0,  0, 0,   0, 0, 0, 1);  // left
   rotations [1] = mat4 ( 0, 0, -1, 0,   0, 1,  0, 0,   1,  0,  0, 0,   0, 0, 0, 1);  // right
   rotations [2] = mat4 (-1, 0,  0, 0,   0, 1,  0, 0,   0,  0, -1, 0,   0, 0, 0, 1);  // front
   rotations [3] = mat4 ( 1, 0,  0, 0,   0, 1,  0, 0,   0,  0,  1, 0,   0, 0, 0, 1);  // back
   rotations [4] = mat4 ( 1, 0,  0, 0,   0, 0,  1, 0,   0, -1,  0, 0,   0, 0, 0, 1);  // bottom
   rotations [5] = mat4 ( 1, 0,  0, 0,   0, 0, -1, 0,   0,  1,  0, 0,   0, 0, 0, 1);  // top

   vec3 a = abs (vector .xyz);

   if (a .x > a .y)
   {
      if (a .x > a .z)
         return vector .x > 0.0 ? rotations [1] : rotations [0];
      else
         return vector .z > 0.0 ? rotations [2] : rotations [3];
   }
   else
   {
      if (a .y > a .z)
         return vector .y > 0.0 ? rotations [5] : rotations [4];
      else
         return vector .z > 0.0 ? rotations [2] : rotations [3];
   }

   return rotations [3];
}

// DEBUG
//vec4 tex;

float
getShadowIntensity (const in int index, const in x3d_LightSourceParameters light)
{
   if (light .type == x3d_PointLight)
   {
      const mat4 biasMatrix = mat4 (0.5, 0.0, 0.0, 0.0,
                                    0.0, 0.5, 0.0, 0.0,
                                    0.0, 0.0, 0.5, 0.0,
                                    0.5, 0.5, 0.5, 1.0);

      const mat4 projectionMatrix = mat4 (1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.000025000312504, -1.0, 0, 0.0, -0.25000312503906297, 0.0);

      vec2 texelSize = vec2 (1.0) / (float (light .shadowMapSize) * vec2 (4.0, 2.0));

      // for point lights, the uniform @vShadowCoord is re-purposed to hold
      // the vector from the light to the world-space position of the fragment.
      vec4 shadowCoord     = light .shadowMatrix * vec4 (vertex, 1.0);
      vec3 lightToPosition = shadowCoord .xyz;

      shadowCoord       = biasMatrix * (projectionMatrix * (getPointLightRotations (lightToPosition) * shadowCoord));
      shadowCoord .z   -= light .shadowBias;
      shadowCoord .xyz /= shadowCoord .w;

      // DEBUG
      //tex = texture2D (x3d_ShadowMap [0], cubeToUVCompact (lightToPosition, texelSize .y));

      #if defined (X3D_PCF_FILTERING) || defined (X3D_PCF_SOFT_FILTERING)

         vec2 offset = vec2 (-1, 1) * (texelSize .y * 42.0);

         float value = (
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xyy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yyy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xyx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yyx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xxy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yxy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xxx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yxx, texelSize .y), shadowCoord .z)
         ) * (1.0 / 9.0);

         return light .shadowIntensity * value;

      #else // no percentage-closer filtering

         float value = texture2DCompare (index, cubeToUVCompact (lightToPosition, texelSize .y), shadowCoord .z);

         return light .shadowIntensity * value;

      #endif
   }
   else
   {
      #if defined (X3D_PCF_FILTERING)

         vec2 texelSize   = vec2 (1.0) / vec2 (light .shadowMapSize);
         vec4 shadowCoord = light .shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= light .shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float dx0 = - texelSize .x;
         float dy0 = - texelSize .y;
         float dx1 = + texelSize .x;
         float dy1 = + texelSize .y;

         float value = (
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (0.0, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, 0.0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy, shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, 0.0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, dy1), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (0.0, dy1), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, dy1), shadowCoord .z)
         ) * (1.0 / 9.0);

         return light .shadowIntensity * value;

      #elif defined (X3D_PCF_SOFT_FILTERING)

         vec2 texelSize   = vec2 (1.0) / vec2 (light .shadowMapSize);
         vec4 shadowCoord = light .shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= light .shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float dx0 = - texelSize.x;
         float dy0 = - texelSize.y;
         float dx1 = + texelSize.x;
         float dy1 = + texelSize.y;

         float value = (
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (0.0, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, 0.0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy, shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, 0.0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, dy1), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (0.0, dy1), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, dy1), shadowCoord .z)
         ) * ( 1.0 / 9.0 );

         return light .shadowIntensity * value;

      #else // no percentage-closer filtering

         vec4 shadowCoord = shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float value = texture2DCompare (index, shadowCoord .xy, shadowCoord .z);

         return light .shadowIntensity * value;

      #endif
   }

   return 0.0;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/SpotFactor.glsl.js
/* harmony default export */ const SpotFactor_glsl = (/* glsl */`
float
getSpotFactor (const in float cutOffAngle, const in float beamWidth, const in vec3 L, const in vec3 d)
{
   float spotAngle = acos (clamp (dot (-L, d), -1.0, 1.0));

   if (spotAngle >= cutOffAngle)
      return 0.0;
   else if (spotAngle <= beamWidth)
      return 1.0;

   return (spotAngle - cutOffAngle) / (beamWidth - cutOffAngle);
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Texture.glsl.js
/* harmony default export */ const Texture_glsl = (/* glsl */`
#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)

#pragma X3D include "Perlin.glsl"

uniform mat4 x3d_TextureMatrix [X3D_NUM_TEXTURE_TRANSFORMS];

mat4
getTextureMatrix (const in int i)
{
   #if defined (X3D_MULTI_TEXTURING)
      mat4 textureMatrix = mat4 (0.0);

      #if X3D_NUM_TEXTURE_TRANSFORMS > 0
      if (i == 0)
         textureMatrix = x3d_TextureMatrix [0];
      #endif

      #if X3D_NUM_TEXTURE_TRANSFORMS > 1
      else if (i == 1)
         textureMatrix = x3d_TextureMatrix [1];
      #endif

      return textureMatrix;
   #else
      return x3d_TextureMatrix [0];
   #endif
}

vec4
getTexCoord (const in int i)
{
   #if defined (X3D_MULTI_TEXTURING)
      vec4 texCoord = vec4 (0.0);

      #if X3D_NUM_TEXTURE_COORDINATES > 0
      if (i == 0)
         texCoord = texCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
      else if (i == 1)
         texCoord = texCoord1;
      #endif

      return texCoord;
   #else
      return texCoord0;
   #endif
}

vec4
getTexCoord (const in x3d_TextureCoordinateGeneratorParameters textureCoordinateGenerator, const in int textureTransformMapping, const in int textureCoordinateMapping)
{
   int mode = textureCoordinateGenerator .mode;

   if (mode == x3d_None)
   {
      return getTextureMatrix (textureTransformMapping) * getTexCoord (textureCoordinateMapping);
   }
   else if (mode == x3d_Sphere)
   {
      vec2 N = normalize (gl_FrontFacing ? normal : -normal) .xy;

      return vec4 (N * 0.5 + 0.5, 0.0, 1.0);
   }
   else if (mode == x3d_CameraSpaceNormal)
   {
      vec3 N = normalize (gl_FrontFacing ? normal : -normal);

      return vec4 (N, 1.0);
   }
   else if (mode == x3d_CameraSpacePosition)
   {
      return vec4 (vertex, 1.0);
   }
   else if (mode == x3d_CameraSpaceReflectionVector)
   {
      vec3 N = normalize (gl_FrontFacing ? normal : -normal);

      return vec4 (reflect (normalize (vertex), -N), 1.0);
   }
   else if (mode == x3d_SphereLocal)
   {
      vec2 N = normalize (gl_FrontFacing ? localNormal : -localNormal) .xy;

      return vec4 (N * 0.5 + 0.5, 0.0, 1.0);
   }
   else if (mode == x3d_Coord)
   {
      return vec4 (localVertex, 1.0);
   }
   else if (mode == x3d_CoordEye)
   {
      return vec4 (vertex, 1.0);
   }
   else if (mode == x3d_Noise)
   {
      vec3 scale       = vec3 (textureCoordinateGenerator .parameter [0], textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2]);
      vec3 translation = vec3 (textureCoordinateGenerator .parameter [3], textureCoordinateGenerator .parameter [4], textureCoordinateGenerator .parameter [5]);

      return vec4 (perlin (localVertex * scale + translation), 1.0);
   }
   else if (mode == x3d_NoiseEye)
   {
      vec3 scale       = vec3 (textureCoordinateGenerator .parameter [0], textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2]);
      vec3 translation = vec3 (textureCoordinateGenerator .parameter [3], textureCoordinateGenerator .parameter [4], textureCoordinateGenerator .parameter [5]);

      return vec4 (perlin (vertex * scale + translation), 1.0);
   }
   else if (mode == x3d_SphereReflect)
   {
      vec3  N   = normalize (gl_FrontFacing ? normal : -normal);
      float eta = textureCoordinateGenerator .parameter [0];

      return vec4 (refract (normalize (vertex), -N, eta), 1.0);
   }
   else if (mode == x3d_SphereReflectLocal)
   {
      vec3  N   = normalize (gl_FrontFacing ? localNormal : -localNormal);
      float eta = textureCoordinateGenerator .parameter [0];
      vec3  eye = vec3 (textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2], textureCoordinateGenerator .parameter [3]);

      return vec4 (refract (normalize (localVertex - eye), -N, eta), 1.0);
   }

   return getTextureMatrix (textureTransformMapping) * getTexCoord (textureCoordinateMapping);
}

uniform x3d_TextureCoordinateGeneratorParameters x3d_TextureCoordinateGenerator [X3D_NUM_TEXTURE_COORDINATES];

vec3
getTexCoord (const in int textureTransformMapping, const in int textureCoordinateMapping)
{
   vec4 texCoord;

   #if X3D_NUM_TEXTURE_COORDINATES > 0
   if (textureCoordinateMapping == 0)
      texCoord = getTexCoord (x3d_TextureCoordinateGenerator [0], textureTransformMapping, textureCoordinateMapping);
   #endif

   #if X3D_NUM_TEXTURE_COORDINATES > 1
   else if (textureCoordinateMapping == 1)
      texCoord = getTexCoord (x3d_TextureCoordinateGenerator [1], textureTransformMapping, textureCoordinateMapping);
   #endif

   texCoord .stp /= texCoord .q;

   #if defined (X3D_GEOMETRY_2D)
      if (gl_FrontFacing == false)
         texCoord .s = 1.0 - texCoord .s;
   #endif

   return texCoord .stp;
}

#endif // X3D_TEXTURE || X3D_MATERIAL_TEXTURES

#if defined (X3D_TEXTURE)

uniform sampler2D   x3d_Texture2D [X3D_NUM_TEXTURES];
uniform samplerCube x3d_TextureCube [X3D_NUM_TEXTURES];

#if defined (X3D_MULTI_TEXTURING)
vec4
getTexture (const in int i, const in vec3 texCoord)
{
   vec4 textureColor = vec4 (0.0);

   #if X3D_NUM_TEXTURES > 0
   if (i == 0)
   {
      #if defined (X3D_TEXTURE0_2D)
         textureColor = texture2D (x3d_Texture2D [0], texCoord .st);
      #elif defined (X3D_TEXTURE0_CUBE)
         textureColor = textureCube (x3d_TextureCube [0], texCoord .stp);
      #endif
   }
   #endif

   #if X3D_NUM_TEXTURES > 1
   else if (i == 1)
   {
      #if defined (X3D_TEXTURE0_2D)
         textureColor = texture2D (x3d_Texture2D [1], texCoord .st);
      #elif defined (X3D_TEXTURE0_CUBE)
         textureColor = textureCube (x3d_TextureCube [1], texCoord .stp);
      #endif
   }
   #endif

   return textureColor;
}
#endif

#if defined (X3D_MULTI_TEXTURING)
   uniform vec4 x3d_MultiTextureColor;
   uniform x3d_MultiTextureParameters x3d_MultiTexture [X3D_NUM_TEXTURES];
#endif

vec4
getTextureColor (const in vec4 diffuseColor, const in vec4 specularColor)
{
   #if defined (X3D_MULTI_TEXTURING)
      vec4 currentColor = diffuseColor;

      for (int i = 0; i < X3D_NUM_TEXTURES; ++ i)
      {
         // Get texture color.

         vec3 texCoord     = getTexCoord (i, i);
         vec4 textureColor = getTexture (i, texCoord);

         // Multi texturing

         x3d_MultiTextureParameters multiTexture = x3d_MultiTexture [i];

         vec4 arg1 = textureColor;
         vec4 arg2 = currentColor;

         // Source

         int source = multiTexture .source;

         if (source == x3d_Diffuse)
         {
            arg1 = diffuseColor;
         }
         else if (source == x3d_Specular)
         {
            arg1 = specularColor;
         }
         else if (source == x3d_Factor)
         {
            arg1 = x3d_MultiTextureColor;
         }

         // Function

         int function = multiTexture .function;

         if (function == x3d_Complement)
         {
            arg1 = 1.0 - arg1;
         }
         else if (function == x3d_AlphaReplicate)
         {
            arg1 .a = arg2 .a;
         }

         // Mode

         int mode      = multiTexture .mode;
         int alphaMode = multiTexture .alphaMode;

         // RGB

         if (mode == x3d_Replace)
         {
            currentColor .rgb = arg1 .rgb;
         }
         else if (mode == x3d_Modulate)
         {
            currentColor .rgb = arg1 .rgb * arg2 .rgb;
         }
         else if (mode == x3d_Modulate2X)
         {
            currentColor .rgb = (arg1 .rgb * arg2 .rgb) * 2.0;
         }
         else if (mode == x3d_Modulate4X)
         {
            currentColor .rgb = (arg1 .rgb * arg2 .rgb) * 4.0;
         }
         else if (mode == x3d_Add)
         {
            currentColor .rgb = arg1 .rgb + arg2 .rgb;
         }
         else if (mode == x3d_AddSigned)
         {
            currentColor .rgb = arg1 .rgb + arg2 .rgb - 0.5;
         }
         else if (mode == x3d_AddSigned2X)
         {
            currentColor .rgb = (arg1 .rgb + arg2 .rgb - 0.5) * 2.0;
         }
         else if (mode == x3d_AddSmooth)
         {
            currentColor .rgb = arg1 .rgb + (1.0 - arg1 .rgb) * arg2 .rgb;
         }
         else if (mode == x3d_Subtract)
         {
            currentColor .rgb = arg1 .rgb - arg2 .rgb;
         }
         else if (mode == x3d_BlendDiffuseAlpha)
         {
            currentColor .rgb = arg1 .rgb * diffuseColor .a + arg2 .rgb * (1.0 - diffuseColor .a);
         }
         else if (mode == x3d_BlendTextureAlpha)
         {
            currentColor .rgb = arg1 .rgb * arg1 .a + arg2 .rgb * (1.0 - arg1 .a);
         }
         else if (mode == x3d_BlendFactorAlpha)
         {
            currentColor .rgb = arg1 .rgb * x3d_MultiTextureColor .a + arg2 .rgb * (1.0 - x3d_MultiTextureColor .a);
         }
         else if (mode == x3d_BlendCurrentAlpha)
         {
            currentColor .rgb = arg1 .rgb * arg2 .a + arg2 .rgb * (1.0 - arg2 .a);
         }
         else if (mode == x3d_ModulateAlphaAddColor)
         {
            currentColor .rgb = arg1 .rgb + arg1 .a * arg2 .rgb;
         }
         else if (mode == x3d_ModulateInvAlphaAddColor)
         {
            currentColor .rgb = (1.0 - arg1 .a) * arg2 .rgb + arg1 .rgb;
         }
         else if (mode == x3d_ModulateInvColorAddAlpha)
         {
            currentColor .rgb = (1.0 - arg1 .rgb) * arg2 .rgb + arg1 .a;
         }
         else if (mode == x3d_DotProduct3)
         {
            currentColor .rgb = vec3 (dot (arg1 .rgb * 2.0 - 1.0, arg2 .rgb * 2.0 - 1.0));
         }
         else if (mode == x3d_SelectArg1)
         {
            currentColor .rgb = arg1 .rgb;
         }
         else if (mode == x3d_SelectArg2)
         {
            currentColor .rgb = arg2 .rgb;
         }
         else if (mode == x3d_Off)
            ;

         // Alpha

         if (alphaMode == x3d_Replace)
         {
            currentColor .a = arg1 .a;
         }
         else if (alphaMode == x3d_Modulate)
         {
            currentColor .a = arg1 .a * arg2 .a;
         }
         else if (alphaMode == x3d_Modulate2X)
         {
            currentColor .a = (arg1 .a * arg2 .a) * 2.0;
         }
         else if (alphaMode == x3d_Modulate4X)
         {
            currentColor .a = (arg1 .a * arg2 .a) * 4.0;
         }
         else if (alphaMode == x3d_Add)
         {
            currentColor .a = arg1 .a + arg2 .a;
         }
         else if (alphaMode == x3d_AddSigned)
         {
            currentColor .a = arg1 .a + arg2 .a - 0.5;
         }
         else if (alphaMode == x3d_AddSigned2X)
         {
            currentColor .a = (arg1 .a + arg2 .a - 0.5) * 2.0;
         }
         else if (alphaMode == x3d_AddSmooth)
         {
            currentColor .a = arg1 .a + (1.0 - arg1 .a) * arg2 .a;
         }
         else if (alphaMode == x3d_Subtract)
         {
            currentColor .a = arg1 .a - arg2 .a;
         }
         else if (alphaMode == x3d_BlendDiffuseAlpha)
         {
            currentColor .a = arg1 .a * diffuseColor .a + arg2 .a * (1.0 - diffuseColor .a);
         }
         else if (alphaMode == x3d_BlendTextureAlpha)
         {
            currentColor .a = arg1 .a * arg1 .a + arg2 .a * (1.0 - arg1 .a);
         }
         else if (alphaMode == x3d_BlendFactorAlpha)
         {
            currentColor .a = arg1 .a * x3d_MultiTextureColor .a + arg2 .a * (1.0 - x3d_MultiTextureColor .a);
         }
         else if (alphaMode == x3d_BlendCurrentAlpha)
         {
            currentColor .a = arg1 .a * arg2 .a + arg2 .a * (1.0 - arg2 .a);
         }
         else if (alphaMode == x3d_ModulateAlphaAddColor)
         {
            currentColor .a = arg1 .a + arg1 .a * arg2 .a;
         }
         else if (alphaMode == x3d_ModulateInvAlphaAddColor)
         {
            currentColor .a = (1.0 - arg1 .a) * arg2 .a + arg1 .a;
         }
         else if (alphaMode == x3d_ModulateInvColorAddAlpha)
         {
            currentColor .a = (1.0 - arg1 .a) * arg2 .a + arg1 .a;
         }
         else if (alphaMode == x3d_DotProduct3)
         {
            currentColor .a = dot (arg1 .rgb * 2.0 - 1.0, arg2 .rgb * 2.0 - 1.0);
         }
         else if (alphaMode == x3d_SelectArg1)
         {
            currentColor .a = arg1 .a;
         }
         else if (alphaMode == x3d_SelectArg2)
         {
            currentColor .a = arg2 .a;
         }
         else if (alphaMode == x3d_Off)
            ;
      }

      return currentColor;
   #else
      // Get texture color.

      vec3 texCoord = getTexCoord (0, 0);

      #if defined (X3D_TEXTURE0_2D)
         vec4 textureColor = texture2D (x3d_Texture2D [0], texCoord .st);
      #elif defined (X3D_TEXTURE0_CUBE)
         vec4 textureColor = textureCube (x3d_TextureCube [0], texCoord .stp);
      #endif

      return diffuseColor * textureColor;
   #endif
}

#endif

#if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)

uniform sampler2D x3d_ProjectiveTexture [X3D_NUM_TEXTURE_PROJECTORS];
uniform mat4      x3d_ProjectiveTextureMatrix [X3D_NUM_TEXTURE_PROJECTORS];
uniform vec3      x3d_ProjectiveTextureLocation [X3D_NUM_TEXTURE_PROJECTORS];

vec4
getProjectiveTexture (const in int i, const in vec2 texCoord)
{
   vec4 color = vec4 (0.0);

   #if X3D_NUM_TEXTURE_PROJECTORS > 0
   if (i == 0)
      color = texture2D (x3d_ProjectiveTexture [0], texCoord);
   #endif

   #if X3D_NUM_TEXTURE_PROJECTORS > 1
   else if (i == 1)
      color = texture2D (x3d_ProjectiveTexture [1], texCoord);
   #endif

   return color;
}

vec4
getProjectiveTextureColor (in vec4 currentColor)
{
   vec3 N = gl_FrontFacing ? normal : -normal;

   for (int i = 0; i < X3D_NUM_TEXTURE_PROJECTORS; ++ i)
   {
      vec4 texCoord = x3d_ProjectiveTextureMatrix [i] * vec4 (vertex, 1.0);

      texCoord .stp /= texCoord .q;

      if (texCoord .s < 0.0 || texCoord .s > 1.0)
         continue;

      if (texCoord .t < 0.0 || texCoord .t > 1.0)
         continue;

      if (texCoord .p < 0.0 || texCoord .p > 1.0)
         continue;

      // We do not need to normalze p, as we only need the sign of the dot product.
      vec3 p = x3d_ProjectiveTextureLocation [i] - vertex;

      if (dot (N, p) < 0.0)
         continue;

      currentColor *= getProjectiveTexture (i, texCoord .st);
   }

   return currentColor;
}

#endif // X3D_PROJECTIVE_TEXTURE_MAPPING
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/include/Vertex.glsl.js
/* harmony default export */ const Vertex_glsl = (/* glsl */`
// Uniforms

uniform mat4 x3d_ProjectionMatrix;
uniform mat4 x3d_ModelViewMatrix;

// Attributes

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   attribute float x3d_FogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   attribute vec4 x3d_Color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         attribute vec4 x3d_TexCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         attribute vec4 x3d_TexCoord1;
      #endif
   #endif
#endif

attribute vec4 x3d_Vertex;

// Varyings

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   varying float fogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   varying vec4 color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         varying vec4 texCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         varying vec4 texCoord1;
      #endif
   #endif
#endif

#if defined (X3D_NORMALS)
   uniform mat3 x3d_NormalMatrix;
   attribute vec3 x3d_Normal;
   varying vec3 normal;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      varying vec3 localNormal;
   #endif
#endif

varying vec3 vertex;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
   varying vec3 localVertex;
#endif

#if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
   varying float depth;
#endif

// Main

#pragma X3D include "PointSize.glsl"

void
vertex_main ()
{
   #if defined (X3D_GEOMETRY_0D)
      #if defined (X3D_STYLE_PROPERTIES)
         gl_PointSize = pointSize = getPointSize (vertex);
      #else
         gl_PointSize = 1.0;
      #endif
   #endif

   #if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
      fogDepth = x3d_FogDepth;
   #endif

   #if defined (X3D_COLOR_MATERIAL)
      color = x3d_Color;
   #endif

   #if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         #if X3D_NUM_TEXTURE_COORDINATES > 0
            texCoord0 = x3d_TexCoord0;
         #endif

         #if X3D_NUM_TEXTURE_COORDINATES > 1
            texCoord1 = x3d_TexCoord1;
         #endif
      #endif
   #endif

   #if defined (X3D_NORMALS)
      normal      = x3d_NormalMatrix * x3d_Normal;

      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         localNormal = x3d_Normal;
      #endif
   #endif

   vec4 position = x3d_ModelViewMatrix * x3d_Vertex;

   vertex = position .xyz;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      localVertex = x3d_Vertex .xyz;
   #endif

   gl_Position = x3d_ProjectionMatrix * position;

   #if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
      depth = 1.0 + gl_Position .w;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/ClipPlanes.glsl.js
/* harmony default export */ const include_ClipPlanes_glsl = (/* glsl */`
#if defined (X3D_CLIP_PLANES)

uniform vec4 x3d_ClipPlane [X3D_NUM_CLIP_PLANES];

void
clip ()
{
   for (int i = 0; i < X3D_NUM_CLIP_PLANES; ++ i)
   {
      if (dot (vertex, x3d_ClipPlane [i] .xyz) - x3d_ClipPlane [i] .w < 0.0)
         discard;
   }
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Colors.glsl.js
/* harmony default export */ const include_Colors_glsl = (/* glsl */`
#define MANUAL_SRGB

vec4
SRGBtoLINEAR (const in vec4 srgbIn)
{
   #if defined (MANUAL_SRGB)
      #if defined (SRGB_FAST_APPROXIMATION)
         vec3 linOut = pow (srgbIn .xyz, vec3 (2.2));
      #else //SRGB_FAST_APPROXIMATION
         vec3 bLess  = step (vec3 (0.04045), srgbIn .xyz);
         vec3 linOut = mix (srgbIn .xyz / vec3 (12.92), pow ((srgbIn .xyz + vec3 (0.055)) / vec3 (1.055), vec3 (2.4)), bLess);
      #endif //SRGB_FAST_APPROXIMATION
      return vec4 (linOut, srgbIn .w);
   #else //MANUAL_SRGB
      return srgbIn;
   #endif //MANUAL_SRGB
}

vec4
Gamma (const in vec4 color)
{
   #if defined (MANUAL_SRGB)
      return vec4 (pow (color .rgb, vec3 (1.0 / 2.2)), color .a);
   #else
      return color;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Fog.glsl.js
/* harmony default export */ const include_Fog_glsl = (/* glsl */`
#if defined (X3D_FOG)

uniform x3d_FogParameters x3d_Fog;

float
getFogInterpolant ()
{
   // Returns 0.0 for fog color and 1.0 for material color.

   #if defined (X3D_FOG_COORDS)
      return clamp (1.0 - fogDepth, 0.0, 1.0);
   #else
      float visibilityRange = x3d_Fog .visibilityRange;
      float dV              = length (x3d_Fog .matrix * vertex);

      #if defined (X3D_FOG_LINEAR)
         return max (0.0, visibilityRange - dV) / visibilityRange;
      #elif defined (X3D_FOG_EXPONENTIAL)
         return exp (-dV / max (0.001, visibilityRange - dV));
      #endif
   #endif
}

vec3
getFogColor (const in vec3 color)
{
   return mix (x3d_Fog .color, color, getFogInterpolant ());
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Fragment.glsl.js
/* harmony default export */ const include_Fragment_glsl = (/* glsl */`
uniform float x3d_AlphaCutoff;

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   in float fogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   in vec4 color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         in vec4 texCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         in vec4 texCoord1;
      #endif
   #endif
#else
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         vec4 texCoord0 = vec4 (0.0);
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         vec4 texCoord1 = vec4 (0.0);
      #endif
   #endif
#endif

#if defined (X3D_NORMALS)
   in vec3 normal;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      in vec3 localNormal;
   #endif
#else
   const vec3 normal = vec3 (0.0, 0.0, 1.0);

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      const vec3 localNormal = vec3 (0.0, 0.0, 1.0);
   #endif
#endif

in vec3 vertex;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
   in vec3 localVertex;
#endif

#if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
   uniform float x3d_LogarithmicFarFactor1_2;
   in float depth;
#endif

out vec4 x3d_FragColor;

#pragma X3D include "Point.glsl"
#pragma X3D include "Stipple.glsl"
#pragma X3D include "Hatch.glsl"
#pragma X3D include "Fog.glsl"
#pragma X3D include "ClipPlanes.glsl"
#pragma X3D include "Texture.glsl"

vec4
getMaterialColor ();

vec4
getFinalColor ()
{
   #if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)
      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         setTexCoords ();

         return getMaterialColor ();
       #else
         return getPointColor (getMaterialColor ());
      #endif
   #else
      return getMaterialColor ();
   #endif
}

void
fragment_main ()
{
   #if defined (X3D_CLIP_PLANES)
      clip ();
   #endif

   #if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)
      stipple ();
   #endif

   vec4 finalColor = getFinalColor ();

   #if (defined (X3D_GEOMETRY_2D) || defined (X3D_GEOMETRY_3D)) && defined (X3D_STYLE_PROPERTIES)
      finalColor = getHatchColor (finalColor);
   #endif

   #if defined (X3D_FOG)
      finalColor .rgb = getFogColor (finalColor .rgb);
   #endif

   if (finalColor .a < x3d_AlphaCutoff)
      discard;

   x3d_FragColor = finalColor;

   #if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
      //http://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html
      gl_FragDepth = log2 (depth) * x3d_LogarithmicFarFactor1_2;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Hatch.glsl.js
/* harmony default export */ const include_Hatch_glsl = (/* glsl */`
#if (defined (X3D_GEOMETRY_2D) || defined (X3D_GEOMETRY_3D)) && defined (X3D_STYLE_PROPERTIES)

uniform x3d_FillPropertiesParameters x3d_FillProperties;

vec4
getHatchColor (vec4 color)
{
   vec4 finalColor = x3d_FillProperties .filled ? color : vec4 (0.0);

   if (x3d_FillProperties .hatched)
   {
      vec4 hatch = texture (x3d_FillProperties .texture, gl_FragCoord .xy / 32.0);

      hatch .rgb *= x3d_FillProperties .hatchColor;
      finalColor  = mix (finalColor, hatch, hatch .a);
   }

   return finalColor;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Line2.glsl.js
/* harmony default export */ const Line2_glsl = (/* glsl */`
struct Line2
{
   vec2 point;
   vec2 direction;
};

Line2
line2 (const in vec2 point1, const in vec2 point2)
{
   return Line2 (point1, normalize (point2 - point1));
}

vec2
closest_point (const in Line2 line, const in vec2 point)
{
   vec2  r = point - line .point;
   float d = dot (r, line .direction);

   return line .direction * d + line .point;
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Material.glsl.js
/* harmony default export */ const include_Material_glsl = (/* glsl */`
uniform x3d_MaterialParameters x3d_Material;

#if defined (X3D_LIGHTING)

#pragma X3D include "SpotFactor.glsl"
#pragma X3D include "Shadow.glsl"

uniform x3d_LightSourceParameters x3d_LightSource [X3D_NUM_LIGHTS];

vec3
getMaterialColor (const in vec3 vertex, const in vec3 N, const in vec3 ambientColor, const in vec3 diffuseColor, const in vec3 specularColor, const in float shininess)
{
   // Apply light sources

   vec3 V = normalize (-vertex);

   vec3 finalColor = vec3 (0.0);

   for (int i = 0; i < X3D_NUM_LIGHTS; ++ i)
   {
      x3d_LightSourceParameters light = x3d_LightSource [i];

      vec3  vL = light .location - vertex;
      float dL = length (light .matrix * vL);
      bool  di = light .type == x3d_DirectionalLight;

      if (di || dL <= light .radius)
      {
         vec3 d = light .direction;
         vec3 c = light .attenuation;
         vec3 L = di ? -d : normalize (vL);      // Normalized vector from point on geometry to light source i position.
         vec3 H = normalize (L + V);             // Specular term

         float lightAngle     = max (dot (N, L), 0.0);      // Angle between normal and light ray.
         vec3  diffuseTerm    = diffuseColor * lightAngle;
         float specularFactor = shininess > 0.0 ? pow (max (dot (N, H), 0.0), shininess * 128.0) : 1.0;
         vec3  specularTerm   = specularColor * specularFactor;

         float attenuationFactor     = di ? 1.0 : 1.0 / max (dot (c, vec3 (1.0, dL, dL * dL)), 1.0);
         float spotFactor            = light .type == x3d_SpotLight ? getSpotFactor (light .cutOffAngle, light .beamWidth, L, d) : 1.0;
         float attenuationSpotFactor = attenuationFactor * spotFactor;
         vec3  ambientTerm           = light .ambientIntensity * ambientColor;
         vec3  diffuseSpecularTerm   = light .intensity * (diffuseTerm + specularTerm);

         #if defined (X3D_FRAGMENT_SHADER) && defined (X3D_SHADOWS)
            if (lightAngle > 0.0)
               diffuseSpecularTerm = mix (diffuseSpecularTerm, light .shadowColor, getShadowIntensity (i, light));
         #endif

         finalColor += attenuationSpotFactor * light .color * (ambientTerm + diffuseSpecularTerm);
      }
   }

   return finalColor;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Normal.glsl.js
/* harmony default export */ const include_Normal_glsl = (/* glsl */`
#if defined (X3D_NORMAL_TEXTURE)
// Tangent-Bitangent-Normal-Matrix
mat3
getTBNMatrix (const in vec2 texCoord)
{
   vec3 pos_dx = dFdx (vertex);
   vec3 pos_dy = dFdy (vertex);
   vec3 tex_dx = dFdx (vec3 (texCoord, 0.0));
   vec3 tex_dy = dFdy (vec3 (texCoord, 0.0));
   vec3 t      = (tex_dy .t * pos_dx - tex_dx .t * pos_dy) / (tex_dx .s * tex_dy.t - tex_dy .s * tex_dx .t);
   vec3 N      = normalize (normal); // OR generated face normal: n = normalize (cross (pos_dx, pos_dy));
   vec3 T      = normalize (t - N * dot (N, t));
   vec3 B      = normalize (cross (N, T));
   mat3 tbn    = mat3 (T, B, N);

   return tbn;
}
#endif

#if defined (X3D_NORMAL_TEXTURE)
uniform x3d_NormalTextureParameters x3d_NormalTexture;
#endif

vec3
getNormalVector (const in float normalScale)
{
   float facing = gl_FrontFacing ? 1.0 : -1.0;

   // Get normal vector.

   #if defined (X3D_NORMAL_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_NormalTexture .textureTransformMapping, x3d_NormalTexture .textureCoordinateMapping);
      vec3 scale    = vec3 (vec2 (normalScale), 1.0);
      mat3 tbn      = getTBNMatrix (texCoord .st);

      #if defined (X3D_NORMAL_TEXTURE_2D)
         vec3 n = texture (x3d_NormalTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_NORMAL_TEXTURE_3D)
         vec3 n = texture (x3d_NormalTexture .texture3D, texCoord) .rgb;
      #elif defined (X3D_NORMAL_TEXTURE_CUBE)
         vec3 n = texture (x3d_NormalTexture .textureCube, texCoord) .rgb;
      #endif

      return normalize (tbn * ((n * 2.0 - 1.0) * scale)) * facing;
   #else
      return normalize (normal) * facing;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Pack.glsl.js
/* harmony default export */ const include_Pack_glsl = (/* glsl */`
vec4
pack (const in float value)
{
   const vec3 bitShifts = vec3 (255.0,
                                255.0 * 255.0,
                                255.0 * 255.0 * 255.0);

   return vec4 (value, fract (value * bitShifts));
}

#if defined (X3D_DEPTH_TEXTURE)

float
unpack (const in vec4 color)
{
   return color .r;
}

#else

float
unpack (const vec4 color)
{
   const vec3 bitShifts = vec3 (1.0 / 255.0,
                                1.0 / (255.0 * 255.0),
                                1.0 / (255.0 * 255.0 * 255.0));

   return color .x + dot (color .gba, bitShifts);
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Particle.glsl.js
/* harmony default export */ const Particle_glsl = (/* glsl */`
#if defined (X3D_PARTICLE_SYSTEM)

in vec4 x3d_Particle;
in mat4 x3d_ParticleMatrix;

uniform sampler2D x3d_TexCoordRamp;

vec4
texelFetch (const in sampler2D sampler, const in int index, const in int lod)
{
   int   x = textureSize (sampler, lod) .x;
   ivec2 p = ivec2 (index % x, index / x);
   vec4  t = texelFetch (sampler, p, lod);

   return t;
}

#if defined (X3D_TEX_COORD_RAMP)
vec4
getTexCoord (const in vec4 texCoord)
{
   const int map [6] = int [6] (0, 1, 2, 0, 2, 3);

   int index0 = int (x3d_Particle [3]);

   return texelFetch (x3d_TexCoordRamp, index0 + map [gl_VertexID % 6], 0);
}
#else
   #define getTexCoord(texCoord) texCoord
#endif

vec4
getVertex (const in vec4 vertex)
{
   return x3d_ParticleMatrix * vertex;
}

#else

#define getVertex(vertex) vertex
#define getTexCoord(texCoord) texCoord

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Perlin.glsl.js
/* harmony default export */ const include_Perlin_glsl = (/* glsl */`
//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83

float rand (vec2 co) { return fract (sin (dot (co.xy, vec2 (12.9898,78.233))) * 43758.5453); }
float rand (vec2 co, float l) { return rand (vec2 (rand (co), l)); }
float rand (vec2 co, float l, float t) { return rand (vec2 (rand (co, l), t)); }

float
perlin (vec2 p, float dim, float time)
{
   const float M_PI = 3.14159265358979323846;

   vec2 pos   = floor (p * dim);
   vec2 posx  = pos + vec2 (1.0, 0.0);
   vec2 posy  = pos + vec2 (0.0, 1.0);
   vec2 posxy = pos + vec2 (1.0);

   float c   = rand (pos,   dim, time);
   float cx  = rand (posx,  dim, time);
   float cy  = rand (posy,  dim, time);
   float cxy = rand (posxy, dim, time);

   vec2 d = fract (p * dim);

   d = -0.5 * cos (d * M_PI) + 0.5;

   float ccx    = mix (c,   cx,    d.x);
   float cycxy  = mix (cy,  cxy,   d.x);
   float center = mix (ccx, cycxy, d.y);

   return center * 2.0 - 1.0;
}

vec3
perlin (vec3 p)
{
   return vec3 (perlin (p.xy, 1.0, 0.0),
                perlin (p.yz, 1.0, 0.0),
                perlin (p.zx, 1.0, 0.0));
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Point.glsl.js
/* harmony default export */ const include_Point_glsl = (/* glsl */`
#if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)

in float pointSize;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
void
setTexCoords ()
{
   vec4 texCoord = vec4 (gl_PointCoord .x, 1.0 - gl_PointCoord .y, 0.0, 1.0);

   #if X3D_NUM_TEXTURE_COORDINATES > 0
      texCoord0 = texCoord;
   #endif

   #if X3D_NUM_TEXTURE_COORDINATES > 1
      texCoord1 = texCoord;
   #endif
}
#endif

vec4
getPointColor (in vec4 color)
{
   if (pointSize > 1.0)
      color .a *= clamp (pointSize * (0.5 - distance (vec2 (0.5), gl_PointCoord)), 0.0, 1.0);

   else
      color .a *= pointSize;

   return color;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/PointSize.glsl.js
/* harmony default export */ const include_PointSize_glsl = (/* glsl */`
#if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)

uniform x3d_PointPropertiesParameters x3d_PointProperties;

out float pointSize;

float
getPointSize (const in vec3 vertex)
{
   // Determine point size.

   float pointSizeMinValue    = x3d_PointProperties .pointSizeMinValue;
   float pointSizeMaxValue    = x3d_PointProperties .pointSizeMaxValue;
   vec3  pointSizeAttenuation = x3d_PointProperties .pointSizeAttenuation;
   float dL                   = length (vertex);
   float pointSize            = 0.0;

   pointSize  = x3d_PointProperties .pointSizeScaleFactor;
   pointSize /= dot (pointSizeAttenuation, vec3 (1.0, dL, dL * dL));
   pointSize  = clamp (pointSize, pointSizeMinValue, pointSizeMaxValue);

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURE)
      return pointSize;
   #else
      return pointSize + 1.0 - step (pointSize, 1.0);
   #endif
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Shadow.glsl.js
/* harmony default export */ const include_Shadow_glsl = (/* glsl */`
#if defined (X3D_FRAGMENT_SHADER) && defined (X3D_SHADOWS)

#pragma X3D include "Pack.glsl"

uniform sampler2D x3d_ShadowMap [X3D_NUM_LIGHTS];

float
getShadowDepth (const in int index, const in vec2 shadowCoord)
{
   switch (index)
   {
      #if X3D_NUM_LIGHTS > 0
      case 0:
      {
         return unpack (texture (x3d_ShadowMap [0], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 1
      case 1:
      {
         return unpack (texture (x3d_ShadowMap [1], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 2
      case 2:
      {
         return unpack (texture (x3d_ShadowMap [2], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 3
      case 3:
      {
         return unpack (texture (x3d_ShadowMap [3], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 4
      case 4:
      {
         return unpack (texture (x3d_ShadowMap [4], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 5
      case 5:
      {
         return unpack (texture (x3d_ShadowMap [5], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 6
      case 6:
      {
         return unpack (texture (x3d_ShadowMap [6], shadowCoord));
      }
      #endif
      #if X3D_NUM_LIGHTS > 7
      case 7:
      {
         return unpack (texture (x3d_ShadowMap [7], shadowCoord));
      }
      #endif
      default:
      {
         return 0.0;
      }
   }
}

float
texture2DCompare (const in int index, const in vec2 texCoord, const in float compare)
{
   float shadowDepth = getShadowDepth (index, texCoord);

   return (1.0 - step (1.0, shadowDepth)) * step (shadowDepth, compare);
}

float
texture2DShadowLerp (const in int index, const in vec2 texelSize, const in float shadowMapSize, const in vec2 texCoord, const in float compare)
{
   const vec2 offset = vec2 (0.0, 1.0);

   vec2 centroidTexCoord = floor (texCoord * shadowMapSize + 0.5) / shadowMapSize;

   float lb = texture2DCompare (index, centroidTexCoord + texelSize * offset .xx, compare);
   float lt = texture2DCompare (index, centroidTexCoord + texelSize * offset .xy, compare);
   float rb = texture2DCompare (index, centroidTexCoord + texelSize * offset .yx, compare);
   float rt = texture2DCompare (index, centroidTexCoord + texelSize * offset .yy, compare);

   vec2 f = fract (texCoord * shadowMapSize + 0.5);

   float a = mix (lb, lt, f.y);
   float b = mix (rb, rt, f.y);
   float c = mix (a, b, f.x);

   return c;
}

//https://gist.github.com/tschw/da10c43c467ce8afd0c4
vec2
cubeToUVCompact (in vec3 v, const float texelSizeY)
{
   // Compact layout:
   //
   // xzXZ		Char: Axis
   // yyYY		Case: Sign

   // Number of texels to avoid at the edge of each square

   vec3 absV = abs (v);

   // Intersect unit cube

   float scaleToCube = 1.0 / max (absV .x, max (absV .y, absV .z));

   absV *= scaleToCube;

   // Apply scale to avoid seams

   // one texel less per square (half a texel on each side)
   v *= scaleToCube * (1.0 - 2.0 * texelSizeY);

   // Unwrap

   // space: -1 ... 1 range for each square
   //
   // #X##		dim    := ( 4 , 2 )
   //  # #		center := ( 1 , 1 )

   vec2 planar = v .xy;

   float almostATexel = 1.5 * texelSizeY;
   float almostOne    = 1.0 - almostATexel;

   if (absV .z >= almostOne)
   {
      // zZ

      if (v .z > 0.0)
         planar .x = 4.0 - v .x;
   }
   else if (absV .x >= almostOne)
   {
      // xX

      float signX = sign (v .x);

      planar .x = v .z * signX + 2.0 * signX;
   }
   else if (absV .y >= almostOne)
   {
      // yY

      float signY = sign (v .y);

      planar .x = (v .x + 0.5 + signY) * 2.0;
      planar .y = v .z * signY - 2.0;
   }

   // Transform to UV space

   // scale := 0.5 / dim
   // translate := ( center + 0.5 ) / dim
   return vec2 (0.125, 0.25) * planar + vec2 (0.375, 0.75);
}

mat4
getPointLightRotations (const in vec3 vector)
{
   mat4 rotations [6];
   rotations [0] = mat4 ( 0, 0 , 1, 0,   0, 1,  0, 0,  -1,  0,  0, 0,   0, 0, 0, 1);  // left
   rotations [1] = mat4 ( 0, 0, -1, 0,   0, 1,  0, 0,   1,  0,  0, 0,   0, 0, 0, 1);  // right
   rotations [2] = mat4 (-1, 0,  0, 0,   0, 1,  0, 0,   0,  0, -1, 0,   0, 0, 0, 1);  // front
   rotations [3] = mat4 ( 1, 0,  0, 0,   0, 1,  0, 0,   0,  0,  1, 0,   0, 0, 0, 1);  // back
   rotations [4] = mat4 ( 1, 0,  0, 0,   0, 0,  1, 0,   0, -1,  0, 0,   0, 0, 0, 1);  // bottom
   rotations [5] = mat4 ( 1, 0,  0, 0,   0, 0, -1, 0,   0,  1,  0, 0,   0, 0, 0, 1);  // top

   vec3 a = abs (vector .xyz);

   if (a .x > a .y)
   {
      if (a .x > a .z)
         return vector .x > 0.0 ? rotations [1] : rotations [0];
      else
         return vector .z > 0.0 ? rotations [2] : rotations [3];
   }
   else
   {
      if (a .y > a .z)
         return vector .y > 0.0 ? rotations [5] : rotations [4];
      else
         return vector .z > 0.0 ? rotations [2] : rotations [3];
   }

   return rotations [3];
}

// DEBUG
//vec4 tex;

float
getShadowIntensity (const in int index, const in x3d_LightSourceParameters light)
{
   if (light .type == x3d_PointLight)
   {
      const mat4 biasMatrix = mat4 (0.5, 0.0, 0.0, 0.0,
                                    0.0, 0.5, 0.0, 0.0,
                                    0.0, 0.0, 0.5, 0.0,
                                    0.5, 0.5, 0.5, 1.0);

      const mat4 projectionMatrix = mat4 (1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.000025000312504, -1.0, 0, 0.0, -0.25000312503906297, 0.0);

      vec2 texelSize = vec2 (1.0) / (float (light .shadowMapSize) * vec2 (4.0, 2.0));

      // for point lights, the uniform @vShadowCoord is re-purposed to hold
      // the vector from the light to the world-space position of the fragment.
      vec4 shadowCoord     = light .shadowMatrix * vec4 (vertex, 1.0);
      vec3 lightToPosition = shadowCoord .xyz;

      shadowCoord       = biasMatrix * (projectionMatrix * (getPointLightRotations (lightToPosition) * shadowCoord));
      shadowCoord .z   -= light .shadowBias;
      shadowCoord .xyz /= shadowCoord .w;

      // DEBUG
      //tex = texture2D (x3d_ShadowMap [0], cubeToUVCompact (lightToPosition, texelSize .y));

      #if defined (X3D_PCF_FILTERING) || defined (X3D_PCF_SOFT_FILTERING)

         vec2 offset = vec2 (-1, 1) * (texelSize .y * 42.0);

         float value = (
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xyy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yyy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xyx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yyx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xxy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yxy, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .xxx, texelSize .y), shadowCoord .z) +
            texture2DCompare (index, cubeToUVCompact (lightToPosition + offset .yxx, texelSize .y), shadowCoord .z)
         ) * (1.0 / 9.0);

         return light .shadowIntensity * value;

      #else // no percentage-closer filtering

         float value = texture2DCompare (index, cubeToUVCompact (lightToPosition, texelSize .y), shadowCoord .z);

         return light .shadowIntensity * value;

      #endif
   }
   else
   {
      #if defined (X3D_PCF_FILTERING)

         vec2 texelSize   = vec2 (1.0) / vec2 (light .shadowMapSize);
         vec4 shadowCoord = light .shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= light .shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float dx0 = - texelSize .x;
         float dy0 = - texelSize .y;
         float dx1 = + texelSize .x;
         float dy1 = + texelSize .y;

         float value = (
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (0.0, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, dy0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, 0.0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy, shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, 0.0), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx0, dy1), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (0.0, dy1), shadowCoord .z) +
            texture2DCompare (index, shadowCoord .xy + vec2 (dx1, dy1), shadowCoord .z)
         ) * (1.0 / 9.0);

         return light .shadowIntensity * value;

      #elif defined (X3D_PCF_SOFT_FILTERING)

         vec2 texelSize   = vec2 (1.0) / vec2 (light .shadowMapSize);
         vec4 shadowCoord = light .shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= light .shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float dx0 = - texelSize.x;
         float dy0 = - texelSize.y;
         float dx1 = + texelSize.x;
         float dy1 = + texelSize.y;

         float value = (
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (0.0, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, dy0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, 0.0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy, shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, 0.0), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx0, dy1), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (0.0, dy1), shadowCoord .z) +
            texture2DShadowLerp (index, texelSize, float (shadowMapSize), shadowCoord .xy + vec2 (dx1, dy1), shadowCoord .z)
         ) * ( 1.0 / 9.0 );

         return light .shadowIntensity * value;

      #else // no percentage-closer filtering

         vec4 shadowCoord = shadowMatrix * vec4 (vertex, 1.0);

         shadowCoord .z   -= shadowBias;
         shadowCoord .xyz /= shadowCoord .w;

         float value = texture2DCompare (index, shadowCoord .xy, shadowCoord .z);

         return light .shadowIntensity * value;

      #endif
   }

   return 0.0;
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Stipple.glsl.js
/* harmony default export */ const Stipple_glsl = (/* glsl */`
#if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)

#pragma X3D include "Line2.glsl"

uniform x3d_LinePropertiesParameters x3d_LineProperties;

flat in float lengthSoFar; // in px
flat in vec2  startPoint;  // in px
in vec2       midPoint;    // in px

void
stipple ()
{
   vec2  point = closest_point (line2 (startPoint, midPoint), gl_FragCoord .xy);
   float s     = (lengthSoFar + length (point - startPoint)) * x3d_LineProperties .lineStippleScale;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         texCoord0 = vec4 (s, 0.0, 0.0, 1.0);
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         texCoord1 = vec4 (s, 0.0, 0.0, 1.0);
      #endif
   #endif

   if (x3d_LineProperties .linetype != 16)
   {
      int   linetype = x3d_LineProperties .linetype;
      int   height   = textureSize (x3d_LineProperties .texture, 0) .y;
      float t        = 1.0 - float (linetype * 2 + 1) / float (height * 2);
      float alpha    = texture (x3d_LineProperties .texture, vec2 (s, t)) .a;

      if (alpha != 1.0)
         discard;
   }
}

#endif
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/SpotFactor.glsl.js
/* harmony default export */ const include_SpotFactor_glsl = (/* glsl */`
float
getSpotFactor (const in float cutOffAngle, const in float beamWidth, const in vec3 L, const in vec3 d)
{
   float spotAngle = acos (clamp (dot (-L, d), -1.0, 1.0));

   if (spotAngle >= cutOffAngle)
      return 0.0;
   else if (spotAngle <= beamWidth)
      return 1.0;

   return (spotAngle - cutOffAngle) / (beamWidth - cutOffAngle);
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Texture.glsl.js
/* harmony default export */ const include_Texture_glsl = (/* glsl */`
#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)

#pragma X3D include "Perlin.glsl"

vec4
getTexCoord (const in int i)
{
   #if defined (X3D_MULTI_TEXTURING)
      switch (i)
      {
         #if X3D_NUM_TEXTURE_COORDINATES > 0
         case 0:
            return texCoord0;
         #endif
         #if X3D_NUM_TEXTURE_COORDINATES > 1
         case 1:
            return texCoord1;
         #endif
      }

      return vec4 (0.0);
   #else
      return texCoord0;
   #endif
}

uniform mat4 x3d_TextureMatrix [X3D_NUM_TEXTURE_TRANSFORMS];

vec4
getTexCoord (const in x3d_TextureCoordinateGeneratorParameters textureCoordinateGenerator, const in int textureTransformMapping, const in int textureCoordinateMapping)
{
   int mode = textureCoordinateGenerator .mode;

   switch (mode)
   {
      case x3d_None:
      {
         return x3d_TextureMatrix [textureTransformMapping] * getTexCoord (textureCoordinateMapping);
      }
      case x3d_Sphere:
      {
         vec2 N = normalize (gl_FrontFacing ? normal : -normal) .xy;

         return vec4 (N * 0.5 + 0.5, 0.0, 1.0);
      }
      case x3d_CameraSpaceNormal:
      {
         vec3 N = normalize (gl_FrontFacing ? normal : -normal);

         return vec4 (N, 1.0);
      }
      case x3d_CameraSpacePosition:
      {
         return vec4 (vertex, 1.0);
      }
      case x3d_CameraSpaceReflectionVector:
      {
         vec3 N = normalize (gl_FrontFacing ? normal : -normal);

         return vec4 (reflect (normalize (vertex), -N), 1.0);
      }
      case x3d_SphereLocal:
      {
         vec2 N = normalize (gl_FrontFacing ? localNormal : -localNormal) .xy;

         return vec4 (N * 0.5 + 0.5, 0.0, 1.0);
      }
      case x3d_Coord:
      {
         return vec4 (localVertex, 1.0);
      }
      case x3d_CoordEye:
      {
         return vec4 (vertex, 1.0);
      }
      case x3d_Noise:
      {
         vec3 scale       = vec3 (textureCoordinateGenerator .parameter [0], textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2]);
         vec3 translation = vec3 (textureCoordinateGenerator .parameter [3], textureCoordinateGenerator .parameter [4], textureCoordinateGenerator .parameter [5]);

         return vec4 (perlin (localVertex * scale + translation), 1.0);
      }
      case x3d_NoiseEye:
      {
         vec3 scale       = vec3 (textureCoordinateGenerator .parameter [0], textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2]);
         vec3 translation = vec3 (textureCoordinateGenerator .parameter [3], textureCoordinateGenerator .parameter [4], textureCoordinateGenerator .parameter [5]);

         return vec4 (perlin (vertex * scale + translation), 1.0);
      }
      case x3d_SphereReflect:
      {
         vec3  N   = normalize (gl_FrontFacing ? normal : -normal);
         float eta = textureCoordinateGenerator .parameter [0];

         return vec4 (refract (normalize (vertex), -N, eta), 1.0);
      }
      case x3d_SphereReflectLocal:
      {
         vec3  N   = normalize (gl_FrontFacing ? localNormal : -localNormal);
         float eta = textureCoordinateGenerator .parameter [0];
         vec3  eye = vec3 (textureCoordinateGenerator .parameter [1], textureCoordinateGenerator .parameter [2], textureCoordinateGenerator .parameter [3]);

         return vec4 (refract (normalize (localVertex - eye), -N, eta), 1.0);
      }
      default:
      {
         return x3d_TextureMatrix [textureTransformMapping] * getTexCoord (textureCoordinateMapping);
      }
   }
}

uniform x3d_TextureCoordinateGeneratorParameters x3d_TextureCoordinateGenerator [X3D_NUM_TEXTURE_COORDINATES];

vec3
getTexCoord (const in int textureTransformMapping, const in int textureCoordinateMapping)
{
   vec4 texCoord = getTexCoord (x3d_TextureCoordinateGenerator [textureCoordinateMapping], textureTransformMapping, textureCoordinateMapping);

   texCoord .stp /= texCoord .q;

   #if defined (X3D_GEOMETRY_2D)
      if (gl_FrontFacing == false)
         texCoord .s = 1.0 - texCoord .s;
   #endif

   return texCoord .stp;
}

#endif // X3D_TEXTURE || X3D_MATERIAL_TEXTURES

#if defined (X3D_TEXTURE)

uniform int         x3d_TextureType [X3D_NUM_TEXTURES];
uniform sampler2D   x3d_Texture2D [X3D_NUM_TEXTURES];
uniform sampler3D   x3d_Texture3D [X3D_NUM_TEXTURES];
uniform samplerCube x3d_TextureCube [X3D_NUM_TEXTURES];

#if defined (X3D_MULTI_TEXTURING)
vec4
getTexture (const in int i, const in vec3 texCoord)
{
   switch (i)
   {
      #if X3D_NUM_TEXTURES > 0
      case 0:
         #if defined (X3D_TEXTURE0_2D)
            return texture (x3d_Texture2D [0], texCoord .st);
         #elif defined (X3D_TEXTURE0_3D)
            return texture (x3d_Texture3D [0], texCoord .stp);
         #elif defined (X3D_TEXTURE0_CUBE)
            return texture (x3d_TextureCube [0], texCoord .stp);
         #endif
      #endif
      #if X3D_NUM_TEXTURES > 1
      case 1:
         #if defined (X3D_TEXTURE0_2D)
            return texture (x3d_Texture2D [1], texCoord .st);
         #elif defined (X3D_TEXTURE0_3D)
            return texture (x3d_Texture3D [1], texCoord .stp);
         #elif defined (X3D_TEXTURE0_CUBE)
            return texture (x3d_TextureCube [1], texCoord .stp);
         #endif
      #endif
   }

   return vec4 (0.0);
}
#endif

#if defined (X3D_MULTI_TEXTURING)
   uniform vec4 x3d_MultiTextureColor;
   uniform x3d_MultiTextureParameters x3d_MultiTexture [X3D_NUM_TEXTURES];
#endif

vec4
getTextureColor (const in vec4 diffuseColor, const in vec4 specularColor)
{
   #if defined (X3D_MULTI_TEXTURING)
      vec4 currentColor = diffuseColor;

      for (int i = 0; i < X3D_NUM_TEXTURES; ++ i)
      {
         // Get texture color.

         vec3 texCoord     = getTexCoord (i, i);
         vec4 textureColor = getTexture (i, texCoord);

         // Multi texturing

         x3d_MultiTextureParameters multiTexture = x3d_MultiTexture [i];

         vec4 arg1 = textureColor;
         vec4 arg2 = currentColor;

         // Source

         int source = multiTexture .source;

         switch (source)
         {
            case x3d_Diffuse:
            {
               arg1 = diffuseColor;
               break;
            }
            case x3d_Specular:
            {
               arg1 = specularColor;
               break;
            }
            case x3d_Factor:
            {
               arg1 = x3d_MultiTextureColor;
               break;
            }
         }

         // Function

         int function = multiTexture .function;

         switch (function)
         {
            case x3d_Complement:
            {
               arg1 = 1.0 - arg1;
               break;
            }
            case x3d_AlphaReplicate:
            {
               arg1 .a = arg2 .a;
               break;
            }
         }

         // Mode

         int mode      = multiTexture .mode;
         int alphaMode = multiTexture .alphaMode;

         // RGB

         switch (mode)
         {
            case x3d_Replace:
            {
               currentColor .rgb = arg1 .rgb;
               break;
            }
            case x3d_Modulate:
            {
               currentColor .rgb = arg1 .rgb * arg2 .rgb;
               break;
            }
            case x3d_Modulate2X:
            {
               currentColor .rgb = (arg1 .rgb * arg2 .rgb) * 2.0;
               break;
            }
            case x3d_Modulate4X:
            {
               currentColor .rgb = (arg1 .rgb * arg2 .rgb) * 4.0;
               break;
            }
            case x3d_Add:
            {
               currentColor .rgb = arg1 .rgb + arg2 .rgb;
               break;
            }
            case x3d_AddSigned:
            {
               currentColor .rgb = arg1 .rgb + arg2 .rgb - 0.5;
               break;
            }
            case x3d_AddSigned2X:
            {
               currentColor .rgb = (arg1 .rgb + arg2 .rgb - 0.5) * 2.0;
               break;
            }
            case x3d_AddSmooth:
            {
               currentColor .rgb = arg1 .rgb + (1.0 - arg1 .rgb) * arg2 .rgb;
               break;
            }
            case x3d_Subtract:
            {
               currentColor .rgb = arg1 .rgb - arg2 .rgb;
               break;
            }
            case x3d_BlendDiffuseAlpha:
            {
               currentColor .rgb = arg1 .rgb * diffuseColor .a + arg2 .rgb * (1.0 - diffuseColor .a);
               break;
            }
            case x3d_BlendTextureAlpha:
            {
               currentColor .rgb = arg1 .rgb * arg1 .a + arg2 .rgb * (1.0 - arg1 .a);
               break;
            }
            case x3d_BlendFactorAlpha:
            {
               currentColor .rgb = arg1 .rgb * x3d_MultiTextureColor .a + arg2 .rgb * (1.0 - x3d_MultiTextureColor .a);
               break;
            }
            case x3d_BlendCurrentAlpha:
            {
               currentColor .rgb = arg1 .rgb * arg2 .a + arg2 .rgb * (1.0 - arg2 .a);
               break;
            }
            case x3d_ModulateAlphaAddColor:
            {
               currentColor .rgb = arg1 .rgb + arg1 .a * arg2 .rgb;
               break;
            }
            case x3d_ModulateInvAlphaAddColor:
            {
               currentColor .rgb = (1.0 - arg1 .a) * arg2 .rgb + arg1 .rgb;
               break;
            }
            case x3d_ModulateInvColorAddAlpha:
            {
               currentColor .rgb = (1.0 - arg1 .rgb) * arg2 .rgb + arg1 .a;
               break;
            }
            case x3d_DotProduct3:
            {
               currentColor .rgb = vec3 (dot (arg1 .rgb * 2.0 - 1.0, arg2 .rgb * 2.0 - 1.0));
               break;
            }
            case x3d_SelectArg1:
            {
               currentColor .rgb = arg1 .rgb;
               break;
            }
            case x3d_SelectArg2:
            {
               currentColor .rgb = arg2 .rgb;
               break;
            }
            case x3d_Off:
            {
               break;
            }
         }

         // Alpha

         switch (alphaMode)
         {
            case x3d_Replace:
            {
               currentColor .a = arg1 .a;
               break;
            }
            case x3d_Modulate:
            {
               currentColor .a = arg1 .a * arg2 .a;
               break;
            }
            case x3d_Modulate2X:
            {
               currentColor .a = (arg1 .a * arg2 .a) * 2.0;
               break;
            }
            case x3d_Modulate4X:
            {
               currentColor .a = (arg1 .a * arg2 .a) * 4.0;
               break;
            }
            case x3d_Add:
            {
               currentColor .a = arg1 .a + arg2 .a;
               break;
            }
            case x3d_AddSigned:
            {
               currentColor .a = arg1 .a + arg2 .a - 0.5;
               break;
            }
            case x3d_AddSigned2X:
            {
               currentColor .a = (arg1 .a + arg2 .a - 0.5) * 2.0;
               break;
            }
            case x3d_AddSmooth:
            {
               currentColor .a = arg1 .a + (1.0 - arg1 .a) * arg2 .a;
               break;
            }
            case x3d_Subtract:
            {
               currentColor .a = arg1 .a - arg2 .a;
               break;
            }
            case x3d_BlendDiffuseAlpha:
            {
               currentColor .a = arg1 .a * diffuseColor .a + arg2 .a * (1.0 - diffuseColor .a);
               break;
            }
            case x3d_BlendTextureAlpha:
            {
               currentColor .a = arg1 .a * arg1 .a + arg2 .a * (1.0 - arg1 .a);
               break;
            }
            case x3d_BlendFactorAlpha:
            {
               currentColor .a = arg1 .a * x3d_MultiTextureColor .a + arg2 .a * (1.0 - x3d_MultiTextureColor .a);
               break;
            }
            case x3d_BlendCurrentAlpha:
            {
               currentColor .a = arg1 .a * arg2 .a + arg2 .a * (1.0 - arg2 .a);
               break;
            }
            case x3d_ModulateAlphaAddColor:
            {
               currentColor .a = arg1 .a + arg1 .a * arg2 .a;
               break;
            }
            case x3d_ModulateInvAlphaAddColor:
            {
               currentColor .a = (1.0 - arg1 .a) * arg2 .a + arg1 .a;
               break;
            }
            case x3d_ModulateInvColorAddAlpha:
            {
               currentColor .a = (1.0 - arg1 .a) * arg2 .a + arg1 .a;
               break;
            }
            case x3d_DotProduct3:
            {
               currentColor .a = dot (arg1 .rgb * 2.0 - 1.0, arg2 .rgb * 2.0 - 1.0);
               break;
            }
            case x3d_SelectArg1:
            {
               currentColor .a = arg1 .a;
               break;
            }
            case x3d_SelectArg2:
            {
               currentColor .a = arg2 .a;
               break;
            }
            case x3d_Off:
            {
               break;
            }
         }
      }

      return currentColor;
   #else
      // Get texture color.

      vec3 texCoord = getTexCoord (0, 0);

      #if defined (X3D_TEXTURE0_2D)
         vec4 textureColor = texture (x3d_Texture2D [0], texCoord .st);
      #elif defined (X3D_TEXTURE0_3D)
         vec4 textureColor = texture (x3d_Texture3D [0], texCoord .stp);
      #elif defined (X3D_TEXTURE0_CUBE)
         vec4 textureColor = texture (x3d_TextureCube [0], texCoord .stp);
      #endif

      return diffuseColor * textureColor;
   #endif
}

#endif // X3D_TEXTURE

#if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)

uniform sampler2D x3d_ProjectiveTexture [X3D_NUM_TEXTURE_PROJECTORS];
uniform mat4      x3d_ProjectiveTextureMatrix [X3D_NUM_TEXTURE_PROJECTORS];
uniform vec3      x3d_ProjectiveTextureLocation [X3D_NUM_TEXTURE_PROJECTORS];

vec4
getProjectiveTexture (const in int i, const in vec2 texCoord)
{
   switch (i)
   {
      #if X3D_NUM_TEXTURE_PROJECTORS > 0
      case 0:
         return texture (x3d_ProjectiveTexture [0], texCoord);
      #endif
      #if X3D_NUM_TEXTURE_PROJECTORS > 1
      case 1:
         return texture (x3d_ProjectiveTexture [1], texCoord);
      #endif
   }

   return vec4 (0.0);
}

vec4
getProjectiveTextureColor (in vec4 currentColor)
{
   vec3 N = gl_FrontFacing ? normal : -normal;

   for (int i = 0; i < X3D_NUM_TEXTURE_PROJECTORS; ++ i)
   {
      vec4 texCoord = x3d_ProjectiveTextureMatrix [i] * vec4 (vertex, 1.0);

      texCoord .stp /= texCoord .q;

      if (texCoord .s < 0.0 || texCoord .s > 1.0)
         continue;

      if (texCoord .t < 0.0 || texCoord .t > 1.0)
         continue;

      if (texCoord .p < 0.0 || texCoord .p > 1.0)
         continue;

      // We do not need to normalze p, as we only need the sign of the dot product.
      vec3 p = x3d_ProjectiveTextureLocation [i] - vertex;

      if (dot (N, p) < 0.0)
         continue;

      currentColor *= getProjectiveTexture (i, texCoord .st);
   }

   return currentColor;
}

#endif // X3D_PROJECTIVE_TEXTURE_MAPPING
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/include/Vertex.glsl.js
/* harmony default export */ const include_Vertex_glsl = (/* glsl */`
// Uniforms

uniform mat4 x3d_ProjectionMatrix;
uniform mat4 x3d_ModelViewMatrix;

// Attributes

#if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)
   in vec3 x3d_LineStipple;
#endif

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   in float x3d_FogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   in vec4  x3d_Color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         in vec4 x3d_TexCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         in vec4 x3d_TexCoord1;
      #endif
   #endif
#endif

in vec4 x3d_Vertex;

// Varyings

#if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
   out float fogDepth;
#endif

#if defined (X3D_COLOR_MATERIAL)
   out vec4 color;
#endif

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      #if X3D_NUM_TEXTURE_COORDINATES > 0
         out vec4 texCoord0;
      #endif

      #if X3D_NUM_TEXTURE_COORDINATES > 1
         out vec4 texCoord1;
      #endif
   #endif
#endif

#if defined (X3D_NORMALS)
   uniform mat3 x3d_NormalMatrix;
   in  vec3 x3d_Normal;
   out vec3 normal;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      out vec3 localNormal;
   #endif
#endif

#if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)
   flat out float lengthSoFar;
   flat out vec2  startPoint;
   out vec2       midPoint;
#endif

out vec3 vertex;

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
   out vec3 localVertex;
#endif

#if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
   out float depth;
#endif

// Main

#pragma X3D include "Particle.glsl"
#pragma X3D include "PointSize.glsl"

void
vertex_main ()
{
   #if defined (X3D_GEOMETRY_0D)
      #if defined (X3D_STYLE_PROPERTIES)
         gl_PointSize = pointSize = getPointSize (vertex);
      #else
         gl_PointSize = 1.0;
      #endif
   #endif

   #if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)
      lengthSoFar = x3d_LineStipple .z;
      startPoint  = x3d_LineStipple .xy;
      midPoint    = x3d_LineStipple .xy;
   #endif

   #if defined (X3D_FOG) && defined (X3D_FOG_COORDS)
      fogDepth = x3d_FogDepth;
   #endif

   #if defined (X3D_COLOR_MATERIAL)
      color = x3d_Color;
   #endif

   #if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         #if X3D_NUM_TEXTURE_COORDINATES > 0
            texCoord0 = getTexCoord (x3d_TexCoord0);
         #endif

         #if X3D_NUM_TEXTURE_COORDINATES > 1
            texCoord1 = getTexCoord (x3d_TexCoord1);
         #endif
      #endif
   #endif

   #if defined (X3D_NORMALS)
      normal = x3d_NormalMatrix * x3d_Normal;

      #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
         localNormal = x3d_Normal;
      #endif
   #endif

   vec4 position = x3d_ModelViewMatrix * getVertex (x3d_Vertex);

   vertex = position .xyz;

   #if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
      localVertex = x3d_Vertex .xyz;
   #endif

   gl_Position = x3d_ProjectionMatrix * position;

   #if defined (X3D_LOGARITHMIC_DEPTH_BUFFER)
      depth = 1.0 + gl_Position .w;
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Default.vs.js
/* harmony default export */ const Default_vs = (/* glsl */`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Vertex.glsl"

void
main ()
{
   vertex_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Depth.vs.js
/* harmony default export */ const Depth_vs = (/* glsl */`
precision highp float;
precision highp int;

uniform mat4 x3d_ProjectionMatrix;
uniform mat4 x3d_ModelViewMatrix;

attribute vec4 x3d_Vertex;

varying vec3 vertex;

void
main ()
{
   vec4 position = x3d_ModelViewMatrix * x3d_Vertex;

   vertex = position .xyz;

   gl_Position = x3d_ProjectionMatrix * position;
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Gouraud.vs.js
/* harmony default export */ const Gouraud_vs = (/* glsl */`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Vertex.glsl"
#pragma X3D include "include/Material.glsl"

varying vec4 frontColor;

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   varying vec4 backColor;
#endif

vec4
getMaterialColor (const in vec3 N,
                  const in vec3 vertex,
                  const in x3d_MaterialParameters material)
{
   // Get diffuse parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 diffuseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 diffuseParameter = vec4 (x3d_Material .diffuseColor, alpha);
   #endif

   // Get material color.

   vec3 ambientColor = diffuseParameter .rgb * material .ambientIntensity;

   #if defined (X3D_LIGHTING)
      vec3 finalColor = getMaterialColor (vertex, N, ambientColor, diffuseParameter .rgb, material .specularColor, material .shininess);
   #else
      vec3 finalColor = vec3 (0.0);
   #endif

   finalColor += material .emissiveColor;

   return vec4 (finalColor, diffuseParameter .a);
}

void
main ()
{
   vertex_main ();

   normal     = normalize (normal);
   frontColor = getMaterialColor (normal, vertex, x3d_Material);

   #if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
      backColor = getMaterialColor (-normal, vertex, x3d_Material);
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Depth.fs.js
/* harmony default export */ const Depth_fs = (/* glsl */`
precision highp float;
precision highp int;

varying vec3 vertex;

#pragma X3D include "include/ClipPlanes.glsl"
#pragma X3D include "include/Pack.glsl"

void
main ()
{
   #if defined (X3D_CLIP_PLANES)
      clip ();
   #endif

   gl_FragColor = pack (gl_FragCoord .z);
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Gouraud.fs.js
/* harmony default export */ const Gouraud_fs = (/* glsl */`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"

varying vec4 frontColor;

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   varying vec4 backColor;
#endif

vec4
getMaterialColor ()
{
   #if defined (X3D_GEOMETRY_0D) || defined (X3D_GEOMETRY_1D)
      vec4 finalColor = frontColor;
   #else
      vec4 finalColor = gl_FrontFacing ? frontColor : backColor;
   #endif

   #if defined (X3D_TEXTURE)
      finalColor = getTextureColor (finalColor, vec4 (1.0));
   #endif

   #if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)
      finalColor = getProjectiveTextureColor (finalColor);
   #endif

   return finalColor;
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/PBR.fs.js
/* harmony default export */ const PBR_fs = (/* glsl */`
// https://github.com/cx20/gltf-test/blob/master/examples/khronos-gltf-loader/shaders/pbr-frag.glsl

#extension GL_EXT_shader_texture_lod: enable
#extension GL_OES_standard_derivatives : enable

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"
#pragma X3D include "include/Colors.glsl"
#pragma X3D include "include/Normal.glsl"
#pragma X3D include "include/SpotFactor.glsl"
#pragma X3D include "include/Shadow.glsl"

#if defined (X3D_LIGHTING)
   uniform x3d_LightSourceParameters x3d_LightSource [X3D_NUM_LIGHTS];
#endif

uniform x3d_PhysicalMaterialParameters x3d_Material;

#if defined (USE_IBL)
   uniform samplerCube diffuseEnvironmentTexture;
   uniform samplerCube specularEnvironmentTexture;
   uniform sampler2D brdfLUT;
#endif

#if defined (X3D_BASE_TEXTURE)
uniform x3d_BaseTextureParameters x3d_BaseTexture;
#endif

vec4
getBaseColor ()
{
   // Get base parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 baseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 baseParameter = vec4 (x3d_Material .baseColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_BASE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_BaseTexture .textureTransformMapping, x3d_BaseTexture .textureCoordinateMapping);
      #if defined (X3D_BASE_TEXTURE_2D)
         return baseParameter * SRGBtoLINEAR (texture2D (x3d_BaseTexture .texture2D, texCoord .st));
      #elif defined (X3D_BASE_TEXTURE_CUBE)
         return baseParameter * SRGBtoLINEAR (textureCube (x3d_BaseTexture .textureCube, texCoord));
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (baseParameter, vec4 (vec3 (1.0), alpha));
   #else
      return baseParameter;
   #endif
}

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec3
getEmissiveColor ()
{
   // Get emissive parameter.

   vec3 emissiveParameter = x3d_Material .emissiveColor;

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * SRGBtoLINEAR (texture2D (x3d_EmissiveTexture .texture2D, texCoord .st)) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * SRGBtoLINEAR (textureCube (x3d_EmissiveTexture .textureCube, texCoord)) .rgb;
      #endif
   #else
      return emissiveParameter .rgb;
   #endif
}

#if defined (X3D_METALLIC_ROUGHNESS_TEXTURE)
uniform x3d_MetallicRoughnessTextureParameters x3d_MetallicRoughnessTexture;
#endif

vec2
getMetallicRoughness ()
{
   // Metallic and Roughness material properties are packed together
   // In glTF, these factors can be specified by fixed scalar values
   // or from a metallic-roughness map
   float metallic            = x3d_Material .metallic;
   float perceptualRoughness = x3d_Material .roughness;

   // Get texture color.

   #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_MetallicRoughnessTexture .textureTransformMapping, x3d_MetallicRoughnessTexture .textureCoordinateMapping);
      // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
      // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
      #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE_2D)
         vec4 mrSample = texture2D (x3d_MetallicRoughnessTexture .texture2D, texCoord .st);
      #elif defined (X3D_METALLIC_ROUGHNESS_TEXTURE_CUBE)
         vec4 mrSample = textureCube (x3d_MetallicRoughnessTexture .textureCube, texCoord);
      #endif
      metallic            *= mrSample .b;
      perceptualRoughness *= mrSample .g;

      return vec2 (metallic, perceptualRoughness);
   #else
      return vec2 (metallic, perceptualRoughness);
   #endif
}

#if defined (X3D_OCCLUSION_TEXTURE)
uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;
#endif

float
getOcclusionFactor ()
{
   // Get texture color.

   #if defined (X3D_OCCLUSION_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_OcclusionTexture .textureTransformMapping, x3d_OcclusionTexture .textureCoordinateMapping);

      #if defined (X3D_OCCLUSION_TEXTURE_2D)
         return texture2D (x3d_OcclusionTexture .texture2D, texCoord .st) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_CUBE)
         return textureCube (x3d_OcclusionTexture .textureCube, texCoord) .r;
      #endif
   #else
      return 1.0;
   #endif
}

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
   float NdotL;                  // cos angle between normal and light direction
   float NdotV;                  // cos angle between normal and view direction
   float NdotH;                  // cos angle between normal and half vector
   float LdotH;                  // cos angle between light direction and half vector
   float VdotH;                  // cos angle between view direction and half vector
   float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
   float metalness;              // metallic value at the surface
   vec3 reflectance0;            // full reflectance color (normal incidence angle)
   vec3 reflectance90;           // reflectance color at grazing angle
   float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
   vec3 diffuseColor;            // color contribution from diffuse lighting
   vec3 specularColor;           // color contribution from specular lighting
};

const float M_PI           = 3.141592653589793;
const float c_MinRoughness = 0.04;

#if defined (USE_IBL)
// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
vec3
getIBLContribution (const in PBRInfo pbrInputs, vec3 n, const in vec3 reflection)
{
   float mipCount = 9.0; // resolution of 512x512
   float lod      = pbrInputs .perceptualRoughness * mipCount;

   // retrieve a scale and bias to F0. See [1], Figure 3
   vec3 brdf         = SRGBtoLINEAR (texture2D (brdfLUT, vec2 (pbrInputs .NdotV, 1.0 - pbrInputs .perceptualRoughness))) .rgb;
   vec3 diffuseLight = SRGBtoLINEAR (textureCube (diffuseEnvironmentTexture, n)) .rgb;

   #if defined (USE_TEX_LOD)
      vec3 specularLight = SRGBtoLINEAR (textureCubeLodEXT (specularEnvironmentTexture, reflection, lod)) .rgb;
   #else
      vec3 specularLight = SRGBtoLINEAR (textureCube (specularEnvironmentTexture, reflection)) .rgb;
   #endif

   vec3 diffuse  = diffuseLight * pbrInputs .diffuseColor;
   vec3 specular = specularLight * (pbrInputs .specularColor * brdf .x + brdf .y);

   return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3
diffuse (const in PBRInfo pbrInputs)
{
   return pbrInputs .diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3
specularReflection (const in PBRInfo pbrInputs)
{
   return pbrInputs .reflectance0 + (pbrInputs .reflectance90 - pbrInputs .reflectance0) * pow (clamp (1.0 - pbrInputs .VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float
geometricOcclusion (const in PBRInfo pbrInputs)
{
   float NdotL = pbrInputs .NdotL;
   float NdotV = pbrInputs .NdotV;
   float r     = pbrInputs .alphaRoughness;

   float attenuationL = 2.0 * NdotL / (NdotL + sqrt (r * r + (1.0 - r * r) * (NdotL * NdotL)));
   float attenuationV = 2.0 * NdotV / (NdotV + sqrt (r * r + (1.0 - r * r) * (NdotV * NdotV)));

   return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float
microfacetDistribution (const in PBRInfo pbrInputs)
{
   float roughnessSq = pbrInputs .alphaRoughness * pbrInputs .alphaRoughness;
   float f           = (pbrInputs .NdotH * roughnessSq - pbrInputs .NdotH) * pbrInputs .NdotH + 1.0;

   return roughnessSq / (M_PI * f * f);
}

vec4
getMaterialColor ()
{
   // Metallic and Roughness material properties are packed together
   // In glTF, these factors can be specified by fixed scalar values
   // or from a metallic-roughness map.

   vec2  metallicRoughness   = getMetallicRoughness ();
   float perceptualRoughness = clamp (metallicRoughness [1], c_MinRoughness, 1.0);
   float metallic            = clamp (metallicRoughness [0], 0.0, 1.0);

   // Roughness is authored as perceptual roughness; as is convention,
   // convert to material roughness by squaring the perceptual roughness [2].
   float alphaRoughness = perceptualRoughness * perceptualRoughness;

   // The albedo may be defined from a base texture or a flat color.
   vec4  baseColor    = getBaseColor ();
   float alpha        = baseColor .a;
   vec3  f0           = vec3 (0.04);
   vec3  diffuseColor = baseColor .rgb * (vec3 (1.0) - f0);
   diffuseColor *= 1.0 - metallic;

   vec3 specularColor = mix (f0, baseColor .rgb, metallic);

   // Compute reflectance.
   float reflectance = max (max (specularColor .r, specularColor .g), specularColor .b);

   // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
   // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
   float reflectance90          = clamp (reflectance * 25.0, 0.0, 1.0);
   vec3  specularEnvironmentR0  = specularColor .rgb;
   vec3  specularEnvironmentR90 = vec3 (1.0, 1.0, 1.0) * reflectance90;

   // Apply light sources

   vec3 n = getNormalVector (x3d_Material .normalScale);  // normal at surface point
   vec3 v = normalize (-vertex); // Vector from surface point to camera

   vec3 finalColor = vec3 (0.0);

   #if defined (X3D_LIGHTING)
   for (int i = 0; i < X3D_NUM_LIGHTS; i ++)
   {
      x3d_LightSourceParameters light = x3d_LightSource [i];

      vec3  vL = light .location - vertex; // Light to fragment
      float dL = length (light .matrix * vL);
      bool  di = light .type == x3d_DirectionalLight;

      if (di || dL <= light .radius)
      {
         vec3 d = light .direction;
         vec3 c = light .attenuation;
         vec3 L = di ? -d : normalize (vL); // Normalized vector from point on geometry to light source i position.

         vec3 l = normalize (L);       // Vector from surface point to light
         vec3 h = normalize (l + v);   // Half vector between both l and v

         float NdotL = clamp (dot (n, l), 0.001, 1.0);
         float NdotV = abs (dot (n, v)) + 0.001;
         float NdotH = clamp (dot (n, h), 0.0, 1.0);
         float LdotH = clamp (dot (l, h), 0.0, 1.0);
         float VdotH = clamp (dot (v, h), 0.0, 1.0);

         PBRInfo pbrInputs = PBRInfo (
            NdotL,
            NdotV,
            NdotH,
            LdotH,
            VdotH,
            perceptualRoughness,
            metallic,
            specularEnvironmentR0,
            specularEnvironmentR90,
            alphaRoughness,
            diffuseColor,
            specularColor
         );

         // Calculate the shading terms for the microfacet specular shading model.
         vec3  F = specularReflection (pbrInputs);
         float G = geometricOcclusion (pbrInputs);
         float D = microfacetDistribution (pbrInputs);

         float attenuationFactor     = di ? 1.0 : 1.0 / max (dot (c, vec3 (1.0, dL, dL * dL)), 1.0);
         float spotFactor            = light .type == x3d_SpotLight ? getSpotFactor (light .cutOffAngle, light .beamWidth, L, d) : 1.0;
         float attenuationSpotFactor = attenuationFactor * spotFactor;

         // Calculation of analytical lighting contribution
         vec3 diffuseContrib     = (1.0 - F) * diffuse (pbrInputs);
         vec3 specContrib        = F * G * D / (4.0 * NdotL * NdotV);
         vec3 diffuseSpecContrib = light .intensity * (diffuseContrib + specContrib);

         #if defined (X3D_SHADOWS)
            if (NdotL > 0.001)
               diffuseSpecContrib = mix (diffuseSpecContrib, light .shadowColor, getShadowIntensity (i, light));
         #endif

         vec3 color = NdotL * attenuationSpotFactor * light .color * diffuseSpecContrib;

         finalColor += color;
      }
   }
   #endif

   // Calculate lighting contribution from image based lighting source (IBL).
   #if defined (USE_IBL)
   vec3 reflection = -normalize (reflect (v, n));
   finalColor += getIBLContribution (pbrInputs, n, reflection);
   #endif

   // Apply optional PBR terms for additional (optional) shading.
   #if defined (X3D_OCCLUSION_TEXTURE)
   finalColor = mix (finalColor, finalColor * getOcclusionFactor (), x3d_Material .occlusionStrength);
   #endif

   finalColor += getEmissiveColor ();

   // Combine with alpha and do gamma correction.
   return Gamma (vec4 (finalColor, alpha));
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Phong.fs.js
/* harmony default export */ const Phong_fs = (/* glsl */`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"
#pragma X3D include "include/Material.glsl"
#pragma X3D include "include/Normal.glsl"

#if defined (X3D_AMBIENT_TEXTURE)
uniform x3d_AmbientTextureParameters x3d_AmbientTexture;
#endif

vec3
getAmbientColor (const in vec3 diffuseColor)
{
   // Get ambient parameter.

   vec3 ambientParameter = x3d_Material .ambientIntensity * diffuseColor;

   // Get texture color.

   #if defined (X3D_AMBIENT_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_AmbientTexture .textureTransformMapping, x3d_AmbientTexture .textureCoordinateMapping);

      #if defined (X3D_AMBIENT_TEXTURE_2D)
         return ambientParameter * texture2D (x3d_AmbientTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_AMBIENT_TEXTURE_CUBE)
         return ambientParameter * textureCube (x3d_AmbientTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return ambientParameter;
   #endif
}

#if defined (X3D_DIFFUSE_TEXTURE)
uniform x3d_DiffuseTextureParameters x3d_DiffuseTexture;
#endif

vec4
getDiffuseColor ()
{
   // Get diffuse parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 diffuseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 diffuseParameter = vec4 (x3d_Material .diffuseColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_DIFFUSE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_DiffuseTexture .textureTransformMapping, x3d_DiffuseTexture .textureCoordinateMapping);

      #if defined (X3D_DIFFUSE_TEXTURE_2D)
         return diffuseParameter * texture2D (x3d_DiffuseTexture .texture2D, texCoord .st);
      #elif defined (X3D_DIFFUSE_TEXTURE_CUBE)
         return diffuseParameter * textureCube (x3d_DiffuseTexture .textureCube, texCoord);
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (diffuseParameter, vec4 (x3d_Material .specularColor, alpha));
   #else
      return diffuseParameter;
   #endif
}

#if defined (X3D_SPECULAR_TEXTURE)
uniform x3d_SpecularTextureParameters x3d_SpecularTexture;
#endif

vec3
getSpecularColor ()
{
   // Get specular parameter.

   vec3 specularParameter = x3d_Material .specularColor;

   // Get texture color.

   #if defined (X3D_SPECULAR_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_SpecularTexture .textureTransformMapping, x3d_SpecularTexture .textureCoordinateMapping);

      #if defined (X3D_SPECULAR_TEXTURE_2D)
         return specularParameter * texture2D (x3d_SpecularTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_SPECULAR_TEXTURE_CUBE)
         return specularParameter * textureCube (x3d_SpecularTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return specularParameter;
   #endif
}

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec3
getEmissiveColor ()
{
   // Get emissive parameter.

   vec3 emissiveParameter = x3d_Material .emissiveColor;

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * texture2D (x3d_EmissiveTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * textureCube (x3d_EmissiveTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return emissiveParameter;
   #endif
}

#if defined (X3D_SHININESS_TEXTURE)
uniform x3d_ShininessTextureParameters x3d_ShininessTexture;
#endif

float
getShininessFactor ()
{
   // Get shininess parameter.

   float shininess = x3d_Material .shininess;

   // Get texture color.

   #if defined (X3D_SHININESS_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_ShininessTexture .textureTransformMapping, x3d_ShininessTexture .textureCoordinateMapping);

      #if defined (X3D_SHININESS_TEXTURE_2D)
         return shininess * texture2D (x3d_ShininessTexture .texture2D, texCoord .st) .a;
      #elif defined (X3D_SHININESS_TEXTURE_CUBE)
         return shininess * textureCube (x3d_ShininessTexture .textureCube, texCoord) .a;
      #endif
   #else
      return shininess;
   #endif
}

#if defined (X3D_OCCLUSION_TEXTURE)
uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;
#endif

float
getOcclusionFactor ()
{
   // Get texture color.

   #if defined (X3D_OCCLUSION_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_OcclusionTexture .textureTransformMapping, x3d_OcclusionTexture .textureCoordinateMapping);

      #if defined (X3D_OCCLUSION_TEXTURE_2D)
         return texture2D (x3d_OcclusionTexture .texture2D, texCoord .st) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_CUBE)
         return textureCube (x3d_OcclusionTexture .textureCube, texCoord) .r;
      #endif
   #else
      return 1.0;
   #endif
}

vec4
getMaterialColor ()
{
   // Calculate diffuseColor & alpha

   vec4  diffuseColorAlpha = getDiffuseColor ();
   float alpha             = diffuseColorAlpha .a;
   vec3  diffuseColor      = diffuseColorAlpha .rgb;
   vec3  ambientColor      = getAmbientColor (diffuseColor);
   vec3  specularColor     = getSpecularColor ();
   float shininess         = getShininessFactor ();
   float normalScale       = x3d_Material .normalScale;

   #if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)
      vec4 P = getProjectiveTextureColor (vec4 (1.0));

      diffuseColor *= P .rgb;
      alpha        *= P .a;
   #endif

   #if defined (X3D_LIGHTING)
      vec3 finalColor = getMaterialColor (vertex, getNormalVector (normalScale), ambientColor, diffuseColor, specularColor, shininess);
   #else
      vec3 finalColor = vec3 (0.0);
   #endif

   #if defined (X3D_OCCLUSION_TEXTURE)
   finalColor = mix (finalColor, finalColor * getOcclusionFactor (), x3d_Material .occlusionStrength);
   #endif

   finalColor += getEmissiveColor ();

   return vec4 (finalColor, alpha);
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl1/Unlit.fs.js
/* harmony default export */ const Unlit_fs = (/* glsl */`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"
uniform x3d_UnlitMaterialParameters x3d_Material;

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec4
getEmissiveColor ()
{
   // Get emissive parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 emissiveParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 emissiveParameter = vec4 (x3d_Material .emissiveColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * texture2D (x3d_EmissiveTexture .texture2D, texCoord .st);
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * textureCube (x3d_EmissiveTexture .textureCube, texCoord);
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (emissiveParameter, vec4 (vec3 (1.0), alpha));
   #else
      return emissiveParameter;
   #endif
}

vec4
getMaterialColor ()
{
   return getEmissiveColor ();
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Default.vs.js
/* harmony default export */ const webgl2_Default_vs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Vertex.glsl"

void
main ()
{
   vertex_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Depth.vs.js
/* harmony default export */ const webgl2_Depth_vs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;

uniform mat4 x3d_ProjectionMatrix;
uniform mat4 x3d_ModelViewMatrix;

in vec4 x3d_Vertex;

out vec3 vertex;

#pragma X3D include "include/Particle.glsl"

void
main ()
{
   vec4 position = x3d_ModelViewMatrix * getVertex (x3d_Vertex);

   vertex = position .xyz;

   gl_Position = x3d_ProjectionMatrix * position;
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Gouraud.vs.js
/* harmony default export */ const webgl2_Gouraud_vs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Vertex.glsl"
#pragma X3D include "include/Material.glsl"

out vec4 frontColor;

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   out vec4 backColor;
#endif

vec4
getMaterialColor (const in vec3 N,
                  const in vec3 vertex,
                  const in x3d_MaterialParameters material)
{
   // Get diffuse parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 diffuseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 diffuseParameter = vec4 (x3d_Material .diffuseColor, alpha);
   #endif

   // Get material color.

   vec3 ambientColor = diffuseParameter .rgb * material .ambientIntensity;

   #if defined (X3D_LIGHTING)
      vec3 finalColor = getMaterialColor (vertex, N, ambientColor, diffuseParameter .rgb, material .specularColor, material .shininess);
   #else
      vec3 finalColor = vec3 (0.0);
   #endif

   finalColor += material .emissiveColor;

   return vec4 (finalColor, diffuseParameter .a);
}

void
main ()
{
   vertex_main ();

   normal     = normalize (normal);
   frontColor = getMaterialColor (normal, vertex, x3d_Material);

   #if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
      backColor = getMaterialColor (-normal, vertex, x3d_Material);
   #endif
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/LineTransform.vs.js
/* harmony default export */ const LineTransform_vs = (/* glsl */`#version 300 es

precision highp float;

uniform vec4  viewport;
uniform mat4  modelViewProjectionMatrix;
uniform mat4  invModelViewProjectionMatrix;
uniform float scale;

in vec3 x3d_LineStipple0; in float x3d_FogDepth0; in vec4 x3d_Color0; in vec4 x3d_Vertex0;
in vec3 x3d_LineStipple1; in float x3d_FogDepth1; in vec4 x3d_Color1; in vec4 x3d_Vertex1;

out vec3 lineStipple0; out float fogDepth0; out vec4 color0; out vec4 vertex0;
out vec3 lineStipple1; out float fogDepth1; out vec4 color1; out vec4 vertex1;
out vec3 lineStipple2; out float fogDepth2; out vec4 color2; out vec4 vertex2;

vec3
projectPoint (const in vec4 point, const in mat4 modelViewProjectionMatrix, const in vec4 viewport)
{
   vec4 vin = modelViewProjectionMatrix * point;

   vin .xyz = vin .xyz / (2.0 * vin .w) + 0.5;

   return vec3 (vin .xy * viewport .zw + viewport .xy, vin .z);
}

vec4
unProjectPoint (const in vec3 win, const in mat4 invModelViewProjection, const in vec4 viewport)
{
   vec4 vin = vec4 ((win .xy - viewport .xy) / viewport .zw * 2.0 - 1.0, 2.0 * win .z - 1.0, 1.0);

   vin = invModelViewProjection * vin;

   return vec4 (vin .xyz / vin .w, 1.0);
}

void
main ()
{
   vec3 projected0 = projectPoint (x3d_Vertex0, modelViewProjectionMatrix, viewport);
   vec3 projected1 = projectPoint (x3d_Vertex1, modelViewProjectionMatrix, viewport);
   vec2 direction  = normalize (projected1 .xy - projected0 .xy);
   vec2 offset     = vec2 (-direction .y, direction .x) * scale;

   // 0 - 3
   // | \ |
   // 1 - 2

   if (gl_InstanceID == 0)
   {
      vec2 pq0 = projected0 .xy + offset;
      vec2 pq1 = projected0 .xy - offset;
      vec2 pq2 = projected1 .xy - offset;

      vec4 p0 = unProjectPoint (vec3 (pq0 .xy, projected0 .z), invModelViewProjectionMatrix, viewport);
      vec4 p1 = unProjectPoint (vec3 (pq1 .xy, projected0 .z), invModelViewProjectionMatrix, viewport);
      vec4 p2 = unProjectPoint (vec3 (pq2 .xy, projected1 .z), invModelViewProjectionMatrix, viewport);

      lineStipple0 = x3d_LineStipple0; fogDepth0 = x3d_FogDepth0; color0 = x3d_Color0; vertex0 = p0;
      lineStipple1 = x3d_LineStipple0; fogDepth1 = x3d_FogDepth0; color1 = x3d_Color0; vertex1 = p1;
      lineStipple2 = x3d_LineStipple1; fogDepth2 = x3d_FogDepth1; color2 = x3d_Color1; vertex2 = p2;
   }
   else
   {
      vec2 pq0 = projected0 .xy + offset;
      vec2 pq2 = projected1 .xy - offset;
      vec2 pq3 = projected1 .xy + offset;

      vec4 p0 = unProjectPoint (vec3 (pq0 .xy, projected0 .z), invModelViewProjectionMatrix, viewport);
      vec4 p2 = unProjectPoint (vec3 (pq2 .xy, projected1 .z), invModelViewProjectionMatrix, viewport);
      vec4 p3 = unProjectPoint (vec3 (pq3 .xy, projected1 .z), invModelViewProjectionMatrix, viewport);

      lineStipple0 = x3d_LineStipple0; fogDepth0 = x3d_FogDepth0; color0 = x3d_Color0; vertex0 = p0;
      lineStipple1 = x3d_LineStipple1; fogDepth1 = x3d_FogDepth1; color1 = x3d_Color1; vertex1 = p2;
      lineStipple2 = x3d_LineStipple1; fogDepth2 = x3d_FogDepth1; color2 = x3d_Color1; vertex2 = p3;
   }
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Depth.fs.js
/* harmony default export */ const webgl2_Depth_fs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;

in vec3 vertex;

out vec4 x3d_FragColor;

#pragma X3D include "include/ClipPlanes.glsl"
#pragma X3D include "include/Pack.glsl"

void
main ()
{
   #if defined (X3D_CLIP_PLANES)
      clip ();
   #endif

   x3d_FragColor = pack (gl_FragCoord .z);
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Gouraud.fs.js
/* harmony default export */ const webgl2_Gouraud_fs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"

in vec4 frontColor;

#if ! defined (X3D_GEOMETRY_0D) && ! defined (X3D_GEOMETRY_1D)
   in vec4 backColor;
#endif

vec4
getMaterialColor ()
{
   #if defined (X3D_GEOMETRY_0D) || defined (X3D_GEOMETRY_1D)
      vec4 finalColor = frontColor;
   #else
      vec4 finalColor = gl_FrontFacing ? frontColor : backColor;
   #endif

   #if defined (X3D_TEXTURE)
      finalColor = getTextureColor (finalColor, vec4 (1.0));
   #endif

   #if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)
      finalColor = getProjectiveTextureColor (finalColor);
   #endif

   return finalColor;
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/LineTransform.fs.js
/* harmony default export */ const LineTransform_fs = (/* glsl */`#version 300 es

precision highp float;

void
main () { }
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/PBR.fs.js
/* harmony default export */ const webgl2_PBR_fs = (/* glsl */`#version 300 es

// https://github.com/cx20/gltf-test/blob/master/examples/khronos-gltf-loader/shaders/pbr-frag.glsl

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"
#pragma X3D include "include/Colors.glsl"
#pragma X3D include "include/Normal.glsl"
#pragma X3D include "include/SpotFactor.glsl"
#pragma X3D include "include/Shadow.glsl"

#if defined (X3D_LIGHTING)
   uniform x3d_LightSourceParameters x3d_LightSource [X3D_NUM_LIGHTS];
#endif

uniform x3d_PhysicalMaterialParameters x3d_Material;

#if defined (USE_IBL)
   uniform samplerCube diffuseEnvironmentTexture;
   uniform samplerCube specularEnvironmentTexture;
   uniform sampler2D brdfLUT;
#endif

#if defined (X3D_BASE_TEXTURE)
uniform x3d_BaseTextureParameters x3d_BaseTexture;
#endif

vec4
getBaseColor ()
{
   // Get base parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 baseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 baseParameter = vec4 (x3d_Material .baseColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_BASE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_BaseTexture .textureTransformMapping, x3d_BaseTexture .textureCoordinateMapping);
      #if defined (X3D_BASE_TEXTURE_2D)
         return baseParameter * SRGBtoLINEAR (texture (x3d_BaseTexture .texture2D, texCoord .st));
      #elif defined (X3D_BASE_TEXTURE_3D)
         return baseParameter * SRGBtoLINEAR (texture (x3d_BaseTexture .texture3D, texCoord));
      #elif defined (X3D_BASE_TEXTURE_CUBE)
         return baseParameter * SRGBtoLINEAR (texture (x3d_BaseTexture .textureCube, texCoord));
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (baseParameter, vec4 (vec3 (1.0), alpha));
   #else
      return baseParameter;
   #endif
}

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec3
getEmissiveColor ()
{
   // Get emissive parameter.

   vec3 emissiveParameter = x3d_Material .emissiveColor;

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * SRGBtoLINEAR (texture (x3d_EmissiveTexture .texture2D, texCoord .st)) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_3D)
         return emissiveParameter * SRGBtoLINEAR (texture (x3d_EmissiveTexture .texture3D, texCoord)) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * SRGBtoLINEAR (texture (x3d_EmissiveTexture .textureCube, texCoord)) .rgb;
      #endif
   #else
      return emissiveParameter .rgb;
   #endif
}

#if defined (X3D_METALLIC_ROUGHNESS_TEXTURE)
uniform x3d_MetallicRoughnessTextureParameters x3d_MetallicRoughnessTexture;
#endif

vec2
getMetallicRoughness ()
{
   // Metallic and Roughness material properties are packed together
   // In glTF, these factors can be specified by fixed scalar values
   // or from a metallic-roughness map
   float metallic            = x3d_Material .metallic;
   float perceptualRoughness = x3d_Material .roughness;

   // Get texture color.

   #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_MetallicRoughnessTexture .textureTransformMapping, x3d_MetallicRoughnessTexture .textureCoordinateMapping);
      // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
      // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
      #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE_2D)
         vec4 mrSample = texture (x3d_MetallicRoughnessTexture .texture2D, texCoord .st);
      #elif defined (X3D_METALLIC_ROUGHNESS_TEXTURE_3D)
         vec4 mrSample = texture (x3d_MetallicRoughnessTexture .texture3D, texCoord);
      #elif defined (X3D_METALLIC_ROUGHNESS_TEXTURE_CUBE)
         vec4 mrSample = texture (x3d_MetallicRoughnessTexture .textureCube, texCoord);
      #endif
      metallic            *= mrSample .b;
      perceptualRoughness *= mrSample .g;

      return vec2 (metallic, perceptualRoughness);
   #else
      return vec2 (metallic, perceptualRoughness);
   #endif
}

#if defined (X3D_OCCLUSION_TEXTURE)
uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;
#endif

float
getOcclusionFactor ()
{
   // Get texture color.

   #if defined (X3D_OCCLUSION_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_OcclusionTexture .textureTransformMapping, x3d_OcclusionTexture .textureCoordinateMapping);

      #if defined (X3D_OCCLUSION_TEXTURE_2D)
         return texture (x3d_OcclusionTexture .texture2D, texCoord .st) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_3D)
         return texture (x3d_OcclusionTexture .texture3D, texCoord) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_CUBE)
         return texture (x3d_OcclusionTexture .textureCube, texCoord) .r;
      #endif
   #else
      return 1.0;
   #endif
}

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
   float NdotL;                  // cos angle between normal and light direction
   float NdotV;                  // cos angle between normal and view direction
   float NdotH;                  // cos angle between normal and half vector
   float LdotH;                  // cos angle between light direction and half vector
   float VdotH;                  // cos angle between view direction and half vector
   float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
   float metalness;              // metallic value at the surface
   vec3 reflectance0;            // full reflectance color (normal incidence angle)
   vec3 reflectance90;           // reflectance color at grazing angle
   float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
   vec3 diffuseColor;            // color contribution from diffuse lighting
   vec3 specularColor;           // color contribution from specular lighting
};

const float M_PI           = 3.141592653589793;
const float c_MinRoughness = 0.04;

#if defined (USE_IBL)
// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
vec3
getIBLContribution (const in PBRInfo pbrInputs, vec3 n, const in vec3 reflection)
{
   float mipCount = 9.0; // resolution of 512x512
   float lod      = pbrInputs .perceptualRoughness * mipCount;

   // retrieve a scale and bias to F0. See [1], Figure 3
   vec3 brdf         = SRGBtoLINEAR (texture (brdfLUT, vec2 (pbrInputs .NdotV, 1.0 - pbrInputs .perceptualRoughness))) .rgb;
   vec3 diffuseLight = SRGBtoLINEAR (textureCube (diffuseEnvironmentTexture, n)) .rgb;

   #if defined (USE_TEX_LOD)
      vec3 specularLight = SRGBtoLINEAR (textureCubeLodEXT (specularEnvironmentTexture, reflection, lod)) .rgb;
   #else
      vec3 specularLight = SRGBtoLINEAR (textureCube (specularEnvironmentTexture, reflection)) .rgb;
   #endif

   vec3 diffuse  = diffuseLight * pbrInputs .diffuseColor;
   vec3 specular = specularLight * (pbrInputs .specularColor * brdf .x + brdf .y);

   return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3
diffuse (const in PBRInfo pbrInputs)
{
   return pbrInputs .diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3
specularReflection (const in PBRInfo pbrInputs)
{
   return pbrInputs .reflectance0 + (pbrInputs .reflectance90 - pbrInputs .reflectance0) * pow (clamp (1.0 - pbrInputs .VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float
geometricOcclusion (const in PBRInfo pbrInputs)
{
   float NdotL = pbrInputs .NdotL;
   float NdotV = pbrInputs .NdotV;
   float r     = pbrInputs .alphaRoughness;

   float attenuationL = 2.0 * NdotL / (NdotL + sqrt (r * r + (1.0 - r * r) * (NdotL * NdotL)));
   float attenuationV = 2.0 * NdotV / (NdotV + sqrt (r * r + (1.0 - r * r) * (NdotV * NdotV)));

   return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float
microfacetDistribution (const in PBRInfo pbrInputs)
{
   float roughnessSq = pbrInputs .alphaRoughness * pbrInputs .alphaRoughness;
   float f           = (pbrInputs .NdotH * roughnessSq - pbrInputs .NdotH) * pbrInputs .NdotH + 1.0;

   return roughnessSq / (M_PI * f * f);
}

vec4
getMaterialColor ()
{
   // Metallic and Roughness material properties are packed together
   // In glTF, these factors can be specified by fixed scalar values
   // or from a metallic-roughness map.

   vec2  metallicRoughness   = getMetallicRoughness ();
   float perceptualRoughness = clamp (metallicRoughness [1], c_MinRoughness, 1.0);
   float metallic            = clamp (metallicRoughness [0], 0.0, 1.0);

   // Roughness is authored as perceptual roughness; as is convention,
   // convert to material roughness by squaring the perceptual roughness [2].
   float alphaRoughness = perceptualRoughness * perceptualRoughness;

   // The albedo may be defined from a base texture or a flat color.
   vec4  baseColor    = getBaseColor ();
   float alpha        = baseColor .a;
   vec3  f0           = vec3 (0.04);
   vec3  diffuseColor = baseColor .rgb * (vec3 (1.0) - f0);
   diffuseColor *= 1.0 - metallic;

   vec3 specularColor = mix (f0, baseColor .rgb, metallic);

   // Compute reflectance.
   float reflectance = max (max (specularColor .r, specularColor .g), specularColor .b);

   // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
   // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
   float reflectance90          = clamp (reflectance * 25.0, 0.0, 1.0);
   vec3  specularEnvironmentR0  = specularColor .rgb;
   vec3  specularEnvironmentR90 = vec3 (1.0, 1.0, 1.0) * reflectance90;

   // Apply light sources

   vec3 n = getNormalVector (x3d_Material .normalScale);  // normal at surface point
   vec3 v = normalize (-vertex); // Vector from surface point to camera

   vec3 finalColor = vec3 (0.0);

   #if defined (X3D_LIGHTING)
   for (int i = 0; i < X3D_NUM_LIGHTS; i ++)
   {
      x3d_LightSourceParameters light = x3d_LightSource [i];

      vec3  vL = light .location - vertex; // Light to fragment
      float dL = length (light .matrix * vL);
      bool  di = light .type == x3d_DirectionalLight;

      if (di || dL <= light .radius)
      {
         vec3 d = light .direction;
         vec3 c = light .attenuation;
         vec3 L = di ? -d : normalize (vL); // Normalized vector from point on geometry to light source i position.

         vec3 l = normalize (L);       // Vector from surface point to light
         vec3 h = normalize (l + v);   // Half vector between both l and v

         float NdotL = clamp (dot (n, l), 0.001, 1.0);
         float NdotV = abs (dot (n, v)) + 0.001;
         float NdotH = clamp (dot (n, h), 0.0, 1.0);
         float LdotH = clamp (dot (l, h), 0.0, 1.0);
         float VdotH = clamp (dot (v, h), 0.0, 1.0);

         PBRInfo pbrInputs = PBRInfo (
            NdotL,
            NdotV,
            NdotH,
            LdotH,
            VdotH,
            perceptualRoughness,
            metallic,
            specularEnvironmentR0,
            specularEnvironmentR90,
            alphaRoughness,
            diffuseColor,
            specularColor
         );

         // Calculate the shading terms for the microfacet specular shading model.
         vec3  F = specularReflection (pbrInputs);
         float G = geometricOcclusion (pbrInputs);
         float D = microfacetDistribution (pbrInputs);

         float attenuationFactor     = di ? 1.0 : 1.0 / max (dot (c, vec3 (1.0, dL, dL * dL)), 1.0);
         float spotFactor            = light .type == x3d_SpotLight ? getSpotFactor (light .cutOffAngle, light .beamWidth, L, d) : 1.0;
         float attenuationSpotFactor = attenuationFactor * spotFactor;

         // Calculation of analytical lighting contribution
         vec3 diffuseContrib     = (1.0 - F) * diffuse (pbrInputs);
         vec3 specContrib        = F * G * D / (4.0 * NdotL * NdotV);
         vec3 diffuseSpecContrib = light .intensity * (diffuseContrib + specContrib);

         #if defined (X3D_SHADOWS)
            if (NdotL > 0.001)
               diffuseSpecContrib = mix (diffuseSpecContrib, light .shadowColor, getShadowIntensity (i, light));
         #endif

         vec3 color = NdotL * attenuationSpotFactor * light .color * diffuseSpecContrib;

         finalColor += color;
      }
   }
   #endif

   // Calculate lighting contribution from image based lighting source (IBL).
   #if defined (USE_IBL)
   vec3 reflection = -normalize (reflect (v, n));
   finalColor += getIBLContribution (pbrInputs, n, reflection);
   #endif

   // Apply optional PBR terms for additional (optional) shading.
   #if defined (X3D_OCCLUSION_TEXTURE)
   finalColor = mix (finalColor, finalColor * getOcclusionFactor (), x3d_Material .occlusionStrength);
   #endif

   finalColor += getEmissiveColor ();

   // Combine with alpha and do gamma correction.
   return Gamma (vec4 (finalColor, alpha));
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Phong.fs.js
/* harmony default export */ const webgl2_Phong_fs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"
#pragma X3D include "include/Material.glsl"
#pragma X3D include "include/Normal.glsl"

#if defined (X3D_AMBIENT_TEXTURE)
uniform x3d_AmbientTextureParameters x3d_AmbientTexture;
#endif

vec3
getAmbientColor (const in vec3 diffuseColor)
{
   // Get ambient parameter.

   vec3 ambientParameter = x3d_Material .ambientIntensity * diffuseColor;

   // Get texture color.

   #if defined (X3D_AMBIENT_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_AmbientTexture .textureTransformMapping, x3d_AmbientTexture .textureCoordinateMapping);

      #if defined (X3D_AMBIENT_TEXTURE_2D)
         return ambientParameter * texture (x3d_AmbientTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_AMBIENT_TEXTURE_3D)
         return ambientParameter * texture (x3d_AmbientTexture .texture3D, texCoord) .rgb;
      #elif defined (X3D_AMBIENT_TEXTURE_CUBE)
         return ambientParameter * texture (x3d_AmbientTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return ambientParameter;
   #endif
}

#if defined (X3D_DIFFUSE_TEXTURE)
uniform x3d_DiffuseTextureParameters x3d_DiffuseTexture;
#endif

vec4
getDiffuseColor ()
{
   // Get diffuse parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 diffuseParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 diffuseParameter = vec4 (x3d_Material .diffuseColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_DIFFUSE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_DiffuseTexture .textureTransformMapping, x3d_DiffuseTexture .textureCoordinateMapping);

      #if defined (X3D_DIFFUSE_TEXTURE_2D)
         return diffuseParameter * texture (x3d_DiffuseTexture .texture2D, texCoord .st);
      #elif defined (X3D_DIFFUSE_TEXTURE_3D)
         return diffuseParameter * texture (x3d_DiffuseTexture .texture3D, texCoord);
      #elif defined (X3D_DIFFUSE_TEXTURE_CUBE)
         return diffuseParameter * texture (x3d_DiffuseTexture .textureCube, texCoord);
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (diffuseParameter, vec4 (x3d_Material .specularColor, alpha));
   #else
      return diffuseParameter;
   #endif
}

#if defined (X3D_SPECULAR_TEXTURE)
uniform x3d_SpecularTextureParameters x3d_SpecularTexture;
#endif

vec3
getSpecularColor ()
{
   // Get specular parameter.

   vec3 specularParameter = x3d_Material .specularColor;

   // Get texture color.

   #if defined (X3D_SPECULAR_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_SpecularTexture .textureTransformMapping, x3d_SpecularTexture .textureCoordinateMapping);

      #if defined (X3D_SPECULAR_TEXTURE_2D)
         return specularParameter * texture (x3d_SpecularTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_SPECULAR_TEXTURE_3D)
         return specularParameter * texture (x3d_SpecularTexture .texture3D, texCoord) .rgb;
      #elif defined (X3D_SPECULAR_TEXTURE_CUBE)
         return specularParameter * texture (x3d_SpecularTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return specularParameter;
   #endif
}

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec3
getEmissiveColor ()
{
   // Get emissive parameter.

   vec3 emissiveParameter = x3d_Material .emissiveColor;

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * texture (x3d_EmissiveTexture .texture2D, texCoord .st) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_3D)
         return emissiveParameter * texture (x3d_EmissiveTexture .texture3D, texCoord) .rgb;
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * texture (x3d_EmissiveTexture .textureCube, texCoord) .rgb;
      #endif
   #else
      return emissiveParameter;
   #endif
}

#if defined (X3D_SHININESS_TEXTURE)
uniform x3d_ShininessTextureParameters x3d_ShininessTexture;
#endif

float
getShininessFactor ()
{
   // Get shininess parameter.

   float shininess = x3d_Material .shininess;

   // Get texture color.

   #if defined (X3D_SHININESS_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_ShininessTexture .textureTransformMapping, x3d_ShininessTexture .textureCoordinateMapping);

      #if defined (X3D_SHININESS_TEXTURE_2D)
         return shininess * texture (x3d_ShininessTexture .texture2D, texCoord .st) .a;
      #elif defined (X3D_SHININESS_TEXTURE_3D)
         return shininess * texture (x3d_ShininessTexture .texture3D, texCoord) .a;
      #elif defined (X3D_SHININESS_TEXTURE_CUBE)
         return shininess * texture (x3d_ShininessTexture .textureCube, texCoord) .a;
      #endif
   #else
      return shininess;
   #endif
}

#if defined (X3D_OCCLUSION_TEXTURE)
uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;
#endif

float
getOcclusionFactor ()
{
   // Get texture color.

   #if defined (X3D_OCCLUSION_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_OcclusionTexture .textureTransformMapping, x3d_OcclusionTexture .textureCoordinateMapping);

      #if defined (X3D_OCCLUSION_TEXTURE_2D)
         return texture (x3d_OcclusionTexture .texture2D, texCoord .st) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_3D)
         return texture (x3d_OcclusionTexture .texture3D, texCoord) .r;
      #elif defined (X3D_OCCLUSION_TEXTURE_CUBE)
         return texture (x3d_OcclusionTexture .textureCube, texCoord) .r;
      #endif
   #else
      return 1.0;
   #endif
}

vec4
getMaterialColor ()
{
   // Calculate diffuseColor & alpha

   vec4  diffuseColorAlpha = getDiffuseColor ();
   float alpha             = diffuseColorAlpha .a;
   vec3  diffuseColor      = diffuseColorAlpha .rgb;
   vec3  ambientColor      = getAmbientColor (diffuseColor);
   vec3  specularColor     = getSpecularColor ();
   float shininess         = getShininessFactor ();
   float normalScale       = x3d_Material .normalScale;

   #if defined (X3D_PROJECTIVE_TEXTURE_MAPPING)
      vec4 P = getProjectiveTextureColor (vec4 (1.0));

      diffuseColor *= P .rgb;
      alpha        *= P .a;
   #endif

   #if defined (X3D_LIGHTING)
      vec3 finalColor = getMaterialColor (vertex, getNormalVector (normalScale), ambientColor, diffuseColor, specularColor, shininess);
   #else
      vec3 finalColor = vec3 (0.0);
   #endif

   #if defined (X3D_OCCLUSION_TEXTURE)
   finalColor = mix (finalColor, finalColor * getOcclusionFactor (), x3d_Material .occlusionStrength);
   #endif

   finalColor += getEmissiveColor ();

   return vec4 (finalColor, alpha);
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/assets/shaders/webgl2/Unlit.fs.js
/* harmony default export */ const webgl2_Unlit_fs = (/* glsl */`#version 300 es

precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;

#pragma X3D include "include/Fragment.glsl"

uniform x3d_UnlitMaterialParameters x3d_Material;

#if defined (X3D_EMISSIVE_TEXTURE)
uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;
#endif

vec4
getEmissiveColor ()
{
   // Get emissive parameter.

   float alpha = 1.0 - x3d_Material .transparency;

   #if defined (X3D_COLOR_MATERIAL)
      vec4 emissiveParameter = vec4 (color .rgb, color .a * alpha);
   #else
      vec4 emissiveParameter = vec4 (x3d_Material .emissiveColor, alpha);
   #endif

   // Get texture color.

   #if defined (X3D_EMISSIVE_TEXTURE)
      vec3 texCoord = getTexCoord (x3d_EmissiveTexture .textureTransformMapping, x3d_EmissiveTexture .textureCoordinateMapping);

      #if defined (X3D_EMISSIVE_TEXTURE_2D)
         return emissiveParameter * texture (x3d_EmissiveTexture .texture2D, texCoord .st);
      #elif defined (X3D_EMISSIVE_TEXTURE_3D)
         return emissiveParameter * texture (x3d_EmissiveTexture .texture3D, texCoord);
      #elif defined (X3D_EMISSIVE_TEXTURE_CUBE)
         return emissiveParameter * texture (x3d_EmissiveTexture .textureCube, texCoord);
      #endif
   #elif defined (X3D_TEXTURE)
      return getTextureColor (emissiveParameter, vec4 (vec3 (1.0), alpha));
   #else
      return emissiveParameter;
   #endif
}

vec4
getMaterialColor ()
{
   return getEmissiveColor ();
}

void
main ()
{
   fragment_main ();
}
`);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shaders/Shaders.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


/* WebGL 1 */
















/* WebGL 2 */



















/* WebGL 1 */









/* WebGL 2 */











const Shaders = {
   includes: {
      1: {
         ClipPlanes: ClipPlanes_glsl,
         Colors: Colors_glsl,
         Fog: Fog_glsl,
         Fragment: Fragment_glsl,
         Hatch: Hatch_glsl,
         Material: Material_glsl,
         Normal: Normal_glsl,
         Pack: Pack_glsl,
         Perlin: Perlin_glsl,
         Point: Point_glsl,
         PointSize: PointSize_glsl,
         Shadow: Shadow_glsl,
         SpotFactor: SpotFactor_glsl,
         Texture: Texture_glsl,
         Vertex: Vertex_glsl,
      },
      2: {
         ClipPlanes: include_ClipPlanes_glsl,
         Colors: include_Colors_glsl,
         Fog: include_Fog_glsl,
         Fragment: include_Fragment_glsl,
         Hatch: include_Hatch_glsl,
         Line2: Line2_glsl,
         Material: include_Material_glsl,
         Normal: include_Normal_glsl,
         Pack: include_Pack_glsl,
         Particle: Particle_glsl,
         Perlin: include_Perlin_glsl,
         Point: include_Point_glsl,
         PointSize: include_PointSize_glsl,
         Shadow: include_Shadow_glsl,
         Stipple: Stipple_glsl,
         SpotFactor: include_SpotFactor_glsl,
         Texture: include_Texture_glsl,
         Vertex: include_Vertex_glsl,
      },
   },
   vertex: {
      1: {
         Default: Default_vs,
         Depth: Depth_vs,
         Gouraud: Gouraud_vs,
      },
      2: {
         Default: webgl2_Default_vs,
         Depth: webgl2_Depth_vs,
         Gouraud: webgl2_Gouraud_vs,
         LineTransform: LineTransform_vs,
      },
   },
   fragment: {
      1: {
         Depth: Depth_fs,
         Gouraud: Gouraud_fs,
         PBR: PBR_fs,
         Phong: Phong_fs,
         Unlit: Unlit_fs,
      },
      2: {
         Depth: webgl2_Depth_fs,
         Gouraud: webgl2_Gouraud_fs,
         LineTransform: LineTransform_fs,
         PBR: webgl2_PBR_fs,
         Phong: webgl2_Phong_fs,
         Unlit: webgl2_Unlit_fs,
      },
   },
};

/* harmony default export */ const Shaders_Shaders = (Shaders);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/X3DShaderNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DShaderNode (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DShaderNode);

   this .valid    = false;
   this .selected = 0;
}

X3DShaderNode .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: X3DShaderNode,
   setValid: function (value)
   {
      this ._isValid = this .valid = value;
   },
   isValid: function ()
   {
      return this .valid;
   },
   select: function ()
   {
      ++ this .selected;

      if (! this ._isSelected .getValue ())
         this ._isSelected = true;
   },
   deselect: function ()
   {
      -- this .selected;

      if (this .selected === 0)
      {
         if (this ._isSelected .getValue ())
            this ._isSelected = false;
      }
   },
});

/* harmony default export */ const Shaders_X3DShaderNode = (X3DShaderNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/X3DProgrammableShaderObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const X3DProgrammableShaderObject_uniformLocation = Symbol .for ("X3DField.uniformLocation");

function X3DProgrammableShaderObject (executionContext)
{
   this .addType (Base_X3DConstants.X3DProgrammableShaderObject);

   this .uniformNames = [ ];

   this .x3d_ClipPlane                           = [ ];
   this .x3d_LightType                           = [ ];
   this .x3d_LightOn                             = [ ];
   this .x3d_LightColor                          = [ ];
   this .x3d_LightIntensity                      = [ ];
   this .x3d_LightAmbientIntensity               = [ ];
   this .x3d_LightAttenuation                    = [ ];
   this .x3d_LightLocation                       = [ ];
   this .x3d_LightDirection                      = [ ];
   this .x3d_LightBeamWidth                      = [ ];
   this .x3d_LightCutOffAngle                    = [ ];
   this .x3d_LightRadius                         = [ ];
   this .x3d_LightMatrix                         = [ ];
   this .x3d_ShadowIntensity                     = [ ];
   this .x3d_ShadowColor                         = [ ];
   this .x3d_ShadowBias                          = [ ];
   this .x3d_ShadowMatrix                        = [ ];
   this .x3d_ShadowMapSize                       = [ ];
   this .x3d_ShadowMap                           = [ ];
   this .x3d_Texture                             = [ ];
   this .x3d_MultiTextureMode                    = [ ];
   this .x3d_MultiTextureAlphaMode               = [ ];
   this .x3d_MultiTextureSource                  = [ ];
   this .x3d_MultiTextureFunction                = [ ];
   this .x3d_TextureCoordinateGeneratorMode      = [ ];
   this .x3d_TextureCoordinateGeneratorParameter = [ ];
   this .x3d_ProjectiveTexture                   = [ ];
   this .x3d_ProjectiveTextureMatrix             = [ ];
   this .x3d_ProjectiveTextureLocation           = [ ];
   this .x3d_TexCoord                            = [ ];
   this .x3d_TextureMatrix                       = [ ];

   this .numClipPlanes               = 0;
   this .fogNode                     = null;
   this .numLights                   = 0;
   this .numGlobalLights             = 0;
   this .lightNodes                  = [ ];
   this .numProjectiveTextures       = 0;
   this .numGlobalProjectiveTextures = 0;
   this .projectiveTextureNodes      = [ ];
   this .textures                    = new Set ();
}

X3DProgrammableShaderObject .prototype =
{
   constructor: X3DProgrammableShaderObject,
   initialize: function ()
   {
      const browser = this .getBrowser ();

      browser .getRenderingProperties () ._LogarithmicDepthBuffer .addInterest ("set_logarithmicDepthBuffer__", this);

      // Use by multi texture nodes.
      this .x3d_MaxTextures = browser .getMaxTextures ();

      this .set_logarithmicDepthBuffer__ ();
   },
   set_logarithmicDepthBuffer__: function ()
   {
      this .logarithmicDepthBuffer = this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer");
   },
   canUserDefinedFields: function ()
   {
      return true;
   },
   getUniformNames: function ()
   {
      return this .uniformNames;
   },
   setUniformNames: function (value)
   {
      this .uniformNames = value;
   },
   getDefaultUniformsAndAttributes: function ()
   {
      // Get uniforms and attributes.

      const
         program       = this .getProgram (),
         browser       = this .getBrowser (),
         gl            = browser .getContext (),
         maxClipPlanes = browser .getMaxClipPlanes (),
         maxLights     = browser .getMaxLights (),
         maxTextures   = browser .getMaxTextures ();

      gl .useProgram (program);

      for (const name of this .uniformNames)
         this [name] = gl .getUniformLocation (program, name);

      /*
       * Uniforms.
       */

      this .x3d_LogarithmicFarFactor1_2 = gl .getUniformLocation (program, "x3d_LogarithmicFarFactor1_2");

      for (let i = 0; i < maxClipPlanes; ++ i)
         this .x3d_ClipPlane [i] = gl .getUniformLocation (program, "x3d_ClipPlane[" + i + "]");

      this .x3d_FogColor           = this .getUniformLocation (gl, program, "x3d_Fog.color",           "x3d_FogColor");
      this .x3d_FogVisibilityRange = this .getUniformLocation (gl, program, "x3d_Fog.visibilityRange", "x3d_FogVisibilityRange");
      this .x3d_FogMatrix          = this .getUniformLocation (gl, program, "x3d_Fog.matrix",          "x3d_FogMatrix");

      this .x3d_AlphaCutoff = gl .getUniformLocation (program, "x3d_AlphaCutoff");

      this .x3d_PointPropertiesPointSizeScaleFactor = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeScaleFactor");
      this .x3d_PointPropertiesPointSizeMinValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMinValue");
      this .x3d_PointPropertiesPointSizeMaxValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMaxValue");
      this .x3d_PointPropertiesPointSizeAttenuation = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeAttenuation");

      this .x3d_LinePropertiesApplied  = gl .getUniformLocation (program, "x3d_LineProperties.applied");
      this .x3d_LinePropertiesLinetype = gl .getUniformLocation (program, "x3d_LineProperties.linetype");
      this .x3d_LineStippleScale       = gl .getUniformLocation (program, "x3d_LineProperties.lineStippleScale");
      this .x3d_LinePropertiesTexture  = gl .getUniformLocation (program, "x3d_LineProperties.texture");

      this .x3d_FillPropertiesFilled     = gl .getUniformLocation (program, "x3d_FillProperties.filled");
      this .x3d_FillPropertiesHatched    = gl .getUniformLocation (program, "x3d_FillProperties.hatched");
      this .x3d_FillPropertiesHatchColor = gl .getUniformLocation (program, "x3d_FillProperties.hatchColor");
      this .x3d_FillPropertiesTexture    = gl .getUniformLocation (program, "x3d_FillProperties.texture");

      for (let i = 0; i < maxLights; ++ i)
      {
         this .x3d_LightType [i]             = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].type",             "x3d_LightType[" + i + "]");
         this .x3d_LightColor [i]            = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].color",            "x3d_LightColor[" + i + "]");
         this .x3d_LightAmbientIntensity [i] = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].ambientIntensity", "x3d_LightAmbientIntensity[" + i + "]");
         this .x3d_LightIntensity [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].intensity",        "x3d_LightIntensity[" + i + "]");
         this .x3d_LightAttenuation [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].attenuation",      "x3d_LightAttenuation[" + i + "]");
         this .x3d_LightLocation [i]         = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].location",         "x3d_LightLocation[" + i + "]");
         this .x3d_LightDirection [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].direction",        "x3d_LightDirection[" + i + "]");
         this .x3d_LightBeamWidth [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].beamWidth",        "x3d_LightBeamWidth[" + i + "]");
         this .x3d_LightCutOffAngle [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].cutOffAngle",      "x3d_LightCutOffAngle[" + i + "]");
         this .x3d_LightRadius [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].radius",           "x3d_LightRadius[" + i + "]");
         this .x3d_LightMatrix [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].matrix",           "x3d_LightMatrix[" + i + "]");

         this .x3d_ShadowIntensity [i] = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowIntensity");
         this .x3d_ShadowColor [i]     = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowColor");
         this .x3d_ShadowBias [i]      = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowBias");
         this .x3d_ShadowMatrix [i]    = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMatrix");
         this .x3d_ShadowMapSize [i]   = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMapSize");
         this .x3d_ShadowMap [i]       = gl .getUniformLocation (program, "x3d_ShadowMap[" + i + "]");
      }

      this .x3d_AmbientIntensity  = this .getUniformLocation (gl, program, "x3d_Material.ambientIntensity", "x3d_FrontMaterial.ambientIntensity");
      this .x3d_DiffuseColor      = this .getUniformLocation (gl, program, "x3d_Material.diffuseColor",     "x3d_FrontMaterial.diffuseColor");
      this .x3d_SpecularColor     = this .getUniformLocation (gl, program, "x3d_Material.specularColor",    "x3d_FrontMaterial.specularColor");
      this .x3d_EmissiveColor     = this .getUniformLocation (gl, program, "x3d_Material.emissiveColor",    "x3d_FrontMaterial.emissiveColor");
      this .x3d_Shininess         = this .getUniformLocation (gl, program, "x3d_Material.shininess",        "x3d_FrontMaterial.shininess");
      this .x3d_BaseColor         = gl .getUniformLocation (program, "x3d_Material.baseColor");
      this .x3d_Metallic          = gl .getUniformLocation (program, "x3d_Material.metallic");
      this .x3d_Roughness         = gl .getUniformLocation (program, "x3d_Material.roughness");
      this .x3d_OcclusionStrength = gl .getUniformLocation (program, "x3d_Material.occlusionStrength");
      this .x3d_NormalScale       = gl .getUniformLocation (program, "x3d_Material.normalScale");
      this .x3d_Transparency      = this .getUniformLocation (gl, program, "x3d_Material.transparency",     "x3d_FrontMaterial.transparency");

      const materialTextures = [
         "x3d_AmbientTexture",
         "x3d_DiffuseTexture",
         "x3d_SpecularTexture",
         "x3d_EmissiveTexture",
         "x3d_ShininessTexture",
         "x3d_BaseTexture",
         "x3d_MetallicRoughnessTexture",
         "x3d_OcclusionTexture",
         "x3d_NormalTexture",
      ];

      for (const materialTexture of materialTextures)
      {
         this [materialTexture] = {
            textureTransformMapping:  gl .getUniformLocation (program, materialTexture + ".textureTransformMapping"),
            textureCoordinateMapping: gl .getUniformLocation (program, materialTexture + ".textureCoordinateMapping"),
            texture2D:                gl .getUniformLocation (program, materialTexture + ".texture2D"),
            texture3D:                gl .getUniformLocation (program, materialTexture + ".texture3D"),
            textureCube:              gl .getUniformLocation (program, materialTexture + ".textureCube"),
         };
      }

      this .x3d_MultiTextureColor = gl .getUniformLocation (program, "x3d_MultiTextureColor");

      this .x3d_TexCoord .length = 0;

      for (let i = 0; i < maxTextures; ++ i)
      {
         // Attributes

         const x3d_TexCoord = this .getAttribLocation (gl, program, "x3d_TexCoord" + i, i ? "" : "x3d_TexCoord");

         if (x3d_TexCoord !== -1)
            this .x3d_TexCoord .push ([i, x3d_TexCoord]);

         // Uniforms

         this .x3d_TextureMatrix [i] = gl .getUniformLocation (program, "x3d_TextureMatrix[" + i + "]");

         this .x3d_TextureCoordinateGeneratorMode [i]      = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].mode");
         this .x3d_TextureCoordinateGeneratorParameter [i] = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].parameter");

         this .x3d_Texture [i] = {
            texture2D: gl .getUniformLocation (program, "x3d_Texture2D[" + i + "]"),
            texture3D: gl .getUniformLocation (program, "x3d_Texture3D[" + i + "]"),
            textureCube: this .getUniformLocation (gl, program, "x3d_TextureCube[" + i + "]", "x3d_CubeMapTexture[" + i + "]"),
         }

         this .x3d_MultiTextureMode [i]      = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].mode");
         this .x3d_MultiTextureAlphaMode [i] = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].alphaMode");
         this .x3d_MultiTextureSource [i]    = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].source");
         this .x3d_MultiTextureFunction [i]  = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].function");

         this .x3d_ProjectiveTexture [i]         = gl .getUniformLocation (program, "x3d_ProjectiveTexture[" + i + "]");
         this .x3d_ProjectiveTextureMatrix [i]   = gl .getUniformLocation (program, "x3d_ProjectiveTextureMatrix[" + i + "]");
         this .x3d_ProjectiveTextureLocation [i] = gl .getUniformLocation (program, "x3d_ProjectiveTextureLocation[" + i + "]");
      }

      this .x3d_TexCoordRamp = gl .getUniformLocation (program, "x3d_TexCoordRamp");

      this .x3d_Viewport          = gl .getUniformLocation (program, "x3d_Viewport");
      this .x3d_ProjectionMatrix  = gl .getUniformLocation (program, "x3d_ProjectionMatrix");
      this .x3d_ModelViewMatrix   = gl .getUniformLocation (program, "x3d_ModelViewMatrix");
      this .x3d_NormalMatrix      = gl .getUniformLocation (program, "x3d_NormalMatrix");
      this .x3d_CameraSpaceMatrix = gl .getUniformLocation (program, "x3d_CameraSpaceMatrix");

      /*
       * Attributes.
       */

      const attributes = [
         "LineStipple",
         "FogDepth",
         "Color",
         "Normal",
         "Vertex",
         "Particle",
         "ParticleMatrix",
      ];

      for (const name of attributes)
      {
         const attribute = gl .getAttribLocation (program, `x3d_${name}`);

         this [`x3d_${name}`] = attribute;

         if (attribute < 0)
         {
            this [`enable${name}Attribute`]            = Function .prototype;
            this [`${lcfirst (name)}AttributeDivisor`] = Function .prototype;
         }
         else
         {
            delete this [`enable${name}Attribute`];
            delete this [`${lcfirst (name)}AttributeDivisor`];
         }
      }

      if (this .x3d_TexCoord .length === 0)
      {
         this .enableTexCoordAttribute  = Function .prototype;
         this .texCoordAttributeDivisor = Function .prototype;
      }
      else
      {
         delete this .enableTexCoordAttribute;
         delete this .texCoordAttributeDivisor;
      }

      /*
       * Fill uniforms with defaults.
       */

      gl .uniform1f (this .x3d_LineStippleScale, browser .getLineStippleScale ());

      // Fill special uniforms with default values, textures for units are created in X3DTexturingContext.

      gl .uniform1i  (this .x3d_LinePropertiesTexture, browser .getDefaultTexture2DUnit ());
      gl .uniform1i  (this .x3d_FillPropertiesTexture, browser .getDefaultTexture2DUnit ());

      for (const materialTexture of materialTextures)
      {
         gl .uniform1i (this [materialTexture] .texture2D,   browser .getDefaultTexture2DUnit ());
         gl .uniform1i (this [materialTexture] .texture3D,   browser .getDefaultTexture3DUnit ());
         gl .uniform1i (this [materialTexture] .textureCube, browser .getDefaultTextureCubeUnit ());
      }

      for (const uniforms of this .x3d_Texture)
      {
         gl .uniform1i (uniforms .texture2D, browser .getDefaultTexture2DUnit ());

         if (gl .getVersion () >= 2)
            gl .uniform1i (uniforms .texture3D, browser .getDefaultTexture3DUnit ());

         gl .uniform1i (uniforms .textureCube, browser .getDefaultTextureCubeUnit ());
      }

      for (const uniform of this .x3d_ShadowMap)
         gl .uniform1i (uniform, browser .getDefaultTexture2DUnit ());

      for (const uniform of this .x3d_ProjectiveTexture)
         gl .uniform1i (uniform, browser .getDefaultTexture2DUnit ());

      gl .uniform1i  (this .x3d_TexCoordRamp, browser .getDefaultTexture2DUnit ());
   },
   getUniformLocation: function (gl, program, name, depreciated)
   {
      // Legacy function to get uniform location.

      let location = gl .getUniformLocation (program, name);

      if (location)
         return location;

      // Look for depreciated location.

      if (depreciated)
      {
         location = gl .getUniformLocation (program, depreciated);

         if (location)
         {
            console .warn (this .getTypeName (), this .getName (), "Using uniform location name »" + depreciated + "« is depreciated, use »" + name + "«. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
         }

         return location;
      }

      return 0;
   },
   getAttribLocation: function (gl, program, name, depreciated)
   {
      // Legacy function to get uniform location.

      let location = gl .getAttribLocation (program, name);

      if (location >= 0)
         return location;

      // Look for depreciated location.

      if (depreciated)
      {
         location = gl .getAttribLocation (program, depreciated);

         if (location >= 0)
         {
            console .warn (this .getTypeName (), this .getName (), "Using attribute location name »" + depreciated + "« is depreciated, use »" + name + "«. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
         }

         return location;
      }

      return -1;
   },
   addShaderFields: function ()
   {
      const
         program = this .getProgram (),
         gl      = this .getBrowser () .getContext ();

      gl .useProgram (program);

      this .textures .clear ();

      for (const field of this .getUserDefinedFields ())
      {
         const location = gl .getUniformLocation (program, field .getName ());

         if (location)
         {
            switch (field .getType ())
            {
               case Base_X3DConstants.SFImage:
               {
                  location .array = new Int32Array (3 + field .array .length);
                  break;
               }
               case Base_X3DConstants.SFMatrix3d:
               case Base_X3DConstants.SFMatrix3f:
               case Base_X3DConstants.SFRotation:
               {
                  location .array = new Float32Array (9);
                  break;
               }
               case Base_X3DConstants.SFMatrix4d:
               case Base_X3DConstants.SFMatrix4f:
               {
                  location .array = new Float32Array (16);
                  break;
               }
               case Base_X3DConstants.SFNode:
               {
                  break;
               }
               case Base_X3DConstants.MFBool:
               case Base_X3DConstants.MFInt32:
               {
                  location .array = new Int32Array (this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFFloat:
               case Base_X3DConstants.MFDouble:
               case Base_X3DConstants.MFTime:
               {
                  location .array = new Float32Array (this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFImage:
               {
                  location .array = new Int32Array (this .getImagesLength (field));
                  break;
               }
               case Base_X3DConstants.MFMatrix3d:
               case Base_X3DConstants.MFMatrix3f:
               case Base_X3DConstants.MFRotation:
               {
                  location .array = new Float32Array (9 * this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFMatrix4d:
               case Base_X3DConstants.MFMatrix4f:
               {
                  location .array = new Float32Array (16 * this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFNode:
               {
                  const locations = location .locations = [ ];

                  for (let i = 0;; ++ i)
                  {
                     const l = gl .getUniformLocation (program, field .getName () + "[" + i + "]");

                     if (! l)
                        break;

                     locations .push (l);
                  }

                  break;
               }
               case Base_X3DConstants.MFVec2d:
               case Base_X3DConstants.MFVec2f:
               {
                  location .array = new Float32Array (2 * this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFVec3d:
               case Base_X3DConstants.MFVec3f:
               case Base_X3DConstants.MFColor:
               {
                  location .array = new Float32Array (3 * this .getLocationLength (gl, program, field));
                  break;
               }
               case Base_X3DConstants.MFVec4d:
               case Base_X3DConstants.MFVec4f:
               case Base_X3DConstants.MFColorRGBA:
               {
                  location .array = new Float32Array (4 * this .getLocationLength (gl, program, field));
                  break;
               }
            }

            if (location .array)
               field [X3DProgrammableShaderObject_uniformLocation] = location .array .length ? location : null;
            else
               field [X3DProgrammableShaderObject_uniformLocation] = location;

            field .addInterest ("set_field__", this);

            this .set_field__ (field);
         }
      }
   },
   removeShaderFields: function ()
   {
      for (const field of this .getUserDefinedFields ())
         field .removeInterest ("set_field__", this);
   },
   set_field__: (function ()
   {
      const rotation = new Float32Array (9);

      return function (field)
      {
         const
            program  = this .getProgram (),
            gl       = this .getBrowser () .getContext (),
            location = field [X3DProgrammableShaderObject_uniformLocation];

         gl .useProgram (program);

         if (location)
         {
            switch (field .getType ())
            {
               case Base_X3DConstants.SFBool:
               case Base_X3DConstants.SFInt32:
               {
                  gl .uniform1i (location, field .getValue ());
                  return;
               }
               case Base_X3DConstants.SFColor:
               {
                  const value = field .getValue ();
                  gl .uniform3f (location, value .r, value .g, value .b);
                  return;
               }
               case Base_X3DConstants.SFColorRGBA:
               {
                  const value = field .getValue ();
                  gl .uniform4f (location, value .r, value .g, value .b, value .a);
                  return;
               }
               case Base_X3DConstants.SFDouble:
               case Base_X3DConstants.SFFloat:
               case Base_X3DConstants.SFTime:
               {
                  gl .uniform1f (location, field .getValue ());
                  return;
               }
               case Base_X3DConstants.SFImage:
               {
                  let array = location .array;

                  const
                     pixels = field .array,
                     length = 3 + pixels .length;

                  if (length !== array .length)
                     array = location .array = new Int32Array (length);

                  array [0] = field .width;
                  array [1] = field .height;
                  array [2] = field .comp;

                  for (let a = 3, p = 0, pl = pixels .length; p < pl; ++ p, ++ a)
                     array [a] = pixels [p];

                  gl .uniform1iv (location, array);
                  return;
               }
               case Base_X3DConstants.SFMatrix3d:
               case Base_X3DConstants.SFMatrix3f:
               {
                  location .array .set (field .getValue ());

                  gl .uniformMatrix3fv (location, false, location .array);
                  return;
               }
               case Base_X3DConstants.SFMatrix4d:
               case Base_X3DConstants.SFMatrix4f:
               {
                  location .array .set (field .getValue ());

                  gl .uniformMatrix4fv (location, false, location .array);
                  return;
               }
               case Base_X3DConstants.SFNode:
               {
                  const texture = X3DCast (Base_X3DConstants.X3DTextureNode, field);

                  if (texture)
                  {
                     location .name    = field .getName ();
                     location .texture = texture;

                     this .textures .add (location);
                  }
                  else
                  {
                     this .textures .delete (location);
                  }

                  return;
               }
               case Base_X3DConstants.SFRotation:
               {
                  field .getValue () .getMatrix (location .array);

                  gl .uniformMatrix3fv (location, false, location .array);
                  return;
               }
               case Base_X3DConstants.SFString:
               {
                  return;
               }
               case Base_X3DConstants.SFVec2d:
               case Base_X3DConstants.SFVec2f:
               {
                  const value = field .getValue ();
                  gl .uniform2f (location, value .x, value .y);
                  return;
               }
               case Base_X3DConstants.SFVec3d:
               case Base_X3DConstants.SFVec3f:
               {
                  const value = field .getValue ();
                  gl .uniform3f (location, value .x, value .y, value .z);
                  return;
               }
               case Base_X3DConstants.SFVec4d:
               case Base_X3DConstants.SFVec4f:
               {
                  const value = field .getValue ();
                  gl .uniform4f (location, value .x, value .y, value .z, value .w);
                  return;
               }
               case Base_X3DConstants.MFBool:
               case Base_X3DConstants.MFInt32:
               {
                  const array = location .array;

                  for (var i = 0, length = field .length; i < length; ++ i)
                     array [i] = field [i];

                  for (let length = array .length; i < length; ++ i)
                     array [i] = 0;

                  gl .uniform1iv (location, array);
                  return;
               }
               case Base_X3DConstants.MFColor:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const color = field [i];

                     array [k++] = color .r;
                     array [k++] = color .g;
                     array [k++] = color .b;
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniform3fv (location, array);
                  return;
               }
               case Base_X3DConstants.MFColorRGBA:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const color = field [i];

                     array [k++] = color .r;
                     array [k++] = color .g;
                     array [k++] = color .b;
                     array [k++] = color .a;
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniform4fv (location, array);
                  return;
               }
               case Base_X3DConstants.MFDouble:
               case Base_X3DConstants.MFFloat:
               case Base_X3DConstants.MFTime:
               {
                  const array = location .array;

                  for (var i = 0, length = field .length; i < length; ++ i)
                     array [i] = field [i];

                  for (let length = array .length; i < length; ++ i)
                     array [i] = 0;

                  gl .uniform1fv (location, array);
                  return;
               }
               case Base_X3DConstants.MFImage:
               {
                  const array = location .array;

                  for (let i = 0, a = 0, length = field .length; i < length; ++ i)
                  {
                     const
                        value  = field [i],
                        pixels = value .array;

                     array [a ++] = value .width;
                     array [a ++] = value .height;
                     array [a ++] = value .comp;

                     for (let p = 0, pl = pixels .length; p < pl; ++ p)
                        array [a ++] = pixels [p];
                  }

                  gl .uniform1iv (location, array);
                  return;
               }
               case Base_X3DConstants.MFMatrix3d:
               case Base_X3DConstants.MFMatrix3f:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const matrix = field [i];

                     for (let m = 0; m < 9; ++ m)
                        array [k++] = matrix [m];
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniformMatrix3fv (location, false, array);
                  return;
               }
               case Base_X3DConstants.MFMatrix4d:
               case Base_X3DConstants.MFMatrix4f:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const matrix = field [i];

                     for (let m = 0; m < 16; ++ m)
                        array [k++] = matrix [m];
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniformMatrix4fv (location, false, array);
                  return;
               }
               case Base_X3DConstants.MFNode:
               {
                  const locations = location .locations;

                  for (let i = 0, length = field .length; i < length; ++ i)
                  {
                     const texture = X3DCast (Base_X3DConstants.X3DTextureNode, field [i]);

                     if (texture)
                     {
                        locations [i] .name    = field .getName ();
                        locations [i] .texture = texture;

                        this .textures .add (locations [i]);
                     }
                     else
                     {
                        this .textures .delete (locations [i]);
                     }
                  }

                  return;
               }
               case Base_X3DConstants.MFRotation:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     field [i] .getValue () .getMatrix (rotation);

                     array [k++] = rotation [0];
                     array [k++] = rotation [1];
                     array [k++] = rotation [2];
                     array [k++] = rotation [3];
                     array [k++] = rotation [4];
                     array [k++] = rotation [5];
                     array [k++] = rotation [6];
                     array [k++] = rotation [7];
                     array [k++] = rotation [8];
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniformMatrix3fv (location, false, array);
                  return;
               }
               case Base_X3DConstants.MFString:
               {
                  return;
               }
               case Base_X3DConstants.MFVec2d:
               case Base_X3DConstants.MFVec2f:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const vector = field [i];

                     array [k++] = vector .x;
                     array [k++] = vector .y;
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniform2fv (location, array);
                  return;
               }
               case Base_X3DConstants.MFVec3d:
               case Base_X3DConstants.MFVec3f:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const vector = field [i];

                     array [k++] = vector .x;
                     array [k++] = vector .y;
                     array [k++] = vector .z;
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniform3fv (location, array);
                  return;
               }
               case Base_X3DConstants.MFVec4d:
               case Base_X3DConstants.MFVec4f:
               {
                  const array = location .array;

                  for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                  {
                     const vector = field [i];

                     array [k++] = vector .x;
                     array [k++] = vector .y;
                     array [k++] = vector .z;
                     array [k++] = vector .w;
                  }

                  for (let length = array .length; k < length; ++ k)
                     array [k] = 0;

                  gl .uniform4fv (location, array);
                  return;
               }
            }
         }
      };
   })(),
   getImagesLength: function (field)
   {
      const images = field .getValue ();

      let length = 3 * images .length;

      for (const image of images)
         length += image .array .length;

      return length;
   },
   getLocationLength: function (gl, program, field)
   {
      const name = field .getName ();

      for (let i = 0; ; ++ i)
      {
         const location = gl .getUniformLocation (program, name + "[" + i + "]");

         if (! location)
            return i;
      }
   },
   hasFog: function (fogNode)
   {
      if (this .fogNode === fogNode)
         return true;

      this .fogNode = fogNode;

      return false;
   },
   hasLight: function (i, lightNode)
   {
      if (this .lightNodes [i] === lightNode)
         return true;

      this .lightNodes [i] = lightNode;

      return false;
   },
   hasTextureProjector: function (i, textureProjectorNode)
   {
      if (this .projectiveTextureNodes [i] === textureProjectorNode)
         return true;

      this .projectiveTextureNodes [i] = textureProjectorNode;

      return false;
   },
   setClipPlanes: function (gl, clipPlanes)
   {
      this .numClipPlanes = 0;

      for (const clipPlane of clipPlanes)
         clipPlane .setShaderUniforms (gl, this);
   },
   setUniforms: (function ()
   {
      const normalMatrix = new Float32Array (9);

      return function (gl, geometryContext, renderContext, front = true)
      {
         const
            renderObject        = renderContext .renderObject,
            fogNode             = renderContext .fogNode,
            appearanceNode      = renderContext .appearanceNode,
            stylePropertiesNode = appearanceNode .getStyleProperties (geometryContext .geometryType),
            materialNode        = front ? appearanceNode .getMaterial () : appearanceNode .getBackMaterial (),
            textureNode         = renderContext .textureNode || appearanceNode .getTexture (),
            modelViewMatrix     = renderContext .modelViewMatrix;

         // Set global uniforms.

         if (this .renderTime !== renderObject .getRenderTime ())
         {
            this .renderTime = renderObject .getRenderTime ();

            // Set viewport.

            gl .uniform4iv (this .x3d_Viewport, renderObject .getViewportArray ());

            // Set projection matrix.

            gl .uniformMatrix4fv (this .x3d_ProjectionMatrix,  false, renderObject .getProjectionMatrixArray ());
            gl .uniformMatrix4fv (this .x3d_CameraSpaceMatrix, false, renderObject .getCameraSpaceMatrixArray ());

            // Fog

            this .fogNode = null;

            // Set global lights and global texture projectors.

            this .numLights                      = 0;
            this .numProjectiveTextures          = 0;
            this .lightNodes .length             = 0;
            this .projectiveTextureNodes .length = 0;

            const globalObjects = renderObject .getGlobalObjects ();

            for (const globalObject of globalObjects)
               globalObject .setShaderUniforms (gl, this, renderObject);

            this .numGlobalLights             = this .numLights;
            this .numGlobalProjectiveTextures = this .numProjectiveTextures;

            // Logarithmic depth buffer support

            const viewpoint = renderObject .getViewpoint ();

            if (this .logarithmicDepthBuffer || viewpoint .getLogarithmicDepthBuffer ())
            {
               const navigationInfo = renderObject .getNavigationInfo ();

               gl .uniform1f (this .x3d_LogarithmicFarFactor1_2, 1 / Math .log2 (navigationInfo .getFarValue (viewpoint) + 1));
            }
         }

         // Model view matrix

         gl .uniformMatrix4fv (this .x3d_ModelViewMatrix, false, modelViewMatrix);

         // Normal matrix

         normalMatrix [0] = modelViewMatrix [0]; normalMatrix [3] = modelViewMatrix [1]; normalMatrix [6] = modelViewMatrix [ 2];
         normalMatrix [1] = modelViewMatrix [4]; normalMatrix [4] = modelViewMatrix [5]; normalMatrix [7] = modelViewMatrix [ 6];
         normalMatrix [2] = modelViewMatrix [8]; normalMatrix [5] = modelViewMatrix [9]; normalMatrix [8] = modelViewMatrix [10];

         Numbers_Matrix3.prototype.inverse.call (normalMatrix);

         gl .uniformMatrix3fv (this .x3d_NormalMatrix, false, normalMatrix);

         // Fog

         if (fogNode)
            fogNode .setShaderUniforms (gl, this);

         // Clip planes and local lights

         this .numClipPlanes         = 0;
         this .numLights             = this .numGlobalLights;
         this .numProjectiveTextures = this .numGlobalProjectiveTextures;

         for (const localObject of renderContext .localObjects)
            localObject .setShaderUniforms (gl, this, renderObject);

         // Alpha

         gl .uniform1f (this .x3d_AlphaCutoff, appearanceNode .getAlphaCutoff ());

         // Style Properties

         if (stylePropertiesNode)
            stylePropertiesNode .setShaderUniforms (gl, this);

         // Material

         materialNode .setShaderUniforms (gl, this, renderObject, appearanceNode .getTextureTransformMapping (), geometryContext .getTextureCoordinateMapping (), front);

         // Texture

         if (textureNode)
            textureNode .setShaderUniforms (gl, this, renderObject);

         appearanceNode  .getTextureTransform ()  .setShaderUniforms (gl, this);
         geometryContext .getTextureCoordinate () .setShaderUniforms (gl, this);
      };
   })(),
   enable: function (gl)
   {
      gl .useProgram (this .getProgram ());

      for (const location of this .textures)
      {
         const
            texture     = location .texture,
            textureUnit = this .getBrowser () .getTextureUnit (texture .getTextureType ());

         if (textureUnit === undefined)
         {
            console .warn ("Not enough combined texture units for uniform variable '" + location .name + "' available.");
            return;
         }

         gl .activeTexture (gl .TEXTURE0 + textureUnit);
         gl .bindTexture (texture .getTarget (), texture .getTexture ());
         gl .uniform1i (location, textureUnit);
      }
   },
   enableFloatAttrib: function (gl, name, buffer, components, stride, offset)
   {
      const location = gl .getAttribLocation (this .getProgram (), name);

      if (location === -1)
         return;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, components, gl .FLOAT, false, stride, offset);
   },
   enableMatrix3Attrib: function (gl, name, buffer, stride, offset)
   {
      const location0 = gl .getAttribLocation (this .getProgram (), name);

      if (location0 === -1)
         return;

      stride = stride || 36;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

      for (let i = 0; i < 3; ++ i)
      {
         const location = location0 + i;

         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 3, gl .FLOAT, false, stride, offset + 12 * i);
      }
   },
   enableMatrix4Attrib: function (gl, name, buffer, stride, offset)
   {
      const location0 = gl .getAttribLocation (this .getProgram (), name);

      if (location0 === -1)
         return;

      stride = stride || 64;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

      for (let i = 0; i < 4; ++ i)
      {
         const location = location0 + i;

         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset + 16 * i);
      }
   },
   enableLineStippleAttribute: function (gl, buffer, stride, offset)
   {
      const location = this .x3d_LineStipple;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 3, gl .FLOAT, false, stride, offset);
   },
   enableFogDepthAttribute: function (gl, buffer, stride, offset)
   {
      const location = this .x3d_FogDepth;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 1, gl .FLOAT, false, stride, offset);
   },
   enableColorAttribute: function (gl, buffer, stride, offset)
   {
      const location = this .x3d_Color;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
   },
   colorAttributeDivisor: function (gl, divisor)
   {
      gl .vertexAttribDivisor (this .x3d_Color, divisor);
   },
   enableTexCoordAttribute: function (gl, buffers, stride, offset)
   {
      for (const [i, location] of this .x3d_TexCoord)
      {
         gl .bindBuffer (gl .ARRAY_BUFFER, buffers [i]);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
      }
   },
   texCoordAttributeDivisor: function (gl, divisor)
   {
      for (const [i, location] of this .x3d_TexCoord)
      {
         gl .vertexAttribDivisor (location, divisor);
      }
   },
   enableNormalAttribute: function (gl, buffer, stride, offset)
   {
      const location = this .x3d_Normal;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 3, gl .FLOAT, false, stride, offset);
   },
   normalAttributeDivisor: function (gl, divisor)
   {
      gl .vertexAttribDivisor (this .x3d_Normal, divisor);
   },
   enableVertexAttribute: function (gl, buffer, stride, offset)
   {
      const location = this .x3d_Vertex;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
   },
   vertexAttributeDivisor: function (gl, divisor)
   {
      gl .vertexAttribDivisor (this .x3d_Vertex, divisor);
   },
   enableParticleAttribute: function (gl, buffer, stride, offset, divisor)
   {
      const location = this .x3d_Particle;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
      gl .enableVertexAttribArray (location);
      gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
      gl .vertexAttribDivisor (location, divisor);
   },
   enableParticleMatrixAttribute: function (gl, buffer, stride, offset, divisor)
   {
      const location0 = this .x3d_ParticleMatrix;

      stride = stride || 64;

      gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

      for (let i = 0; i < 4; ++ i)
      {
         const location = location0 + i;

         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset + 16 * i);
         gl .vertexAttribDivisor (location, divisor);
      }
   },
   getProgramInfo: function ()
   {
      function cmp (lhs, rhs) { return lhs < rhs ? -1 : lhs > rhs ? 1 : 0; }

      const
         program = this .getProgram (),
         gl      = this .getBrowser () .getContext ();

      const
         result = {
            attributes: [ ],
            uniforms: [ ],
            attributeCount: 0,
            uniformCount: 0,
         },
         activeUniforms   = gl .getProgramParameter (program, gl .ACTIVE_UNIFORMS),
         activeAttributes = gl .getProgramParameter (program, gl .ACTIVE_ATTRIBUTES);

      // Taken from the WebGl spec:
      // http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14
      const enums = {
         0x8B50: 'vec2',
         0x8B51: 'vec3',
         0x8B52: 'vec4',
         0x8B53: 'ivec2',
         0x8B54: 'ivec3',
         0x8B55: 'ivec4',
         0x8B56: 'bool',
         0x8B57: 'bvec2',
         0x8B58: 'bvec3',
         0x8B59: 'bvec4',
         0x8B5A: 'mat2',
         0x8B5B: 'mat3',
         0x8B5C: 'mat4',
         0x8B5E: 'sampler2D',
         0x8B60: 'samplerCube',
         0x1400: 'byte',
         0x1401: 'ubyte',
         0x1402: 'short',
         0x1403: 'ushort',
         0x1404: 'int',
         0x1405: 'uint',
         0x1406: 'float',
      };

      // Loop through active uniforms
      for (let i = 0; i < activeUniforms; ++ i)
      {
         const uniform = gl .getActiveUniform (program, i);
         uniform .typeName = enums [uniform.type];
         result .uniforms .push (Object .assign ({ }, uniform));
         result .uniformCount += uniform .size;
      }

      // Loop through active attributes
      for (let i = 0; i < activeAttributes; ++ i)
      {
         const attribute = gl .getActiveAttrib (program, i);
         attribute .typeName = enums [attribute .type];
         result .attributes .push (Object .assign ({ }, attribute));
         result .attributeCount += attribute .size;
      }

      result .uniforms   .sort (function (a, b) { return cmp (a .name, b .name); });
      result .attributes .sort (function (a, b) { return cmp (a .name, b .name); });

      return result;
   },
   printProgramInfo: function ()
   {
      const programInfo = this .getProgramInfo ();

      console .log (this .getName ());
      console .table (programInfo .attributes);
      console .log (this .getName (), "attributeCount", programInfo .attributeCount);
      console .log (this .getName ());
      console .table (programInfo .uniforms);
      console .log (this .getName (), "uniformCount", programInfo .uniformCount);
   },
   dispose: function () { },
};

function lcfirst (string)
{
   return string [0] .toLowerCase () + string .slice (1);
}

/* harmony default export */ const Shaders_X3DProgrammableShaderObject = (X3DProgrammableShaderObject);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking/X3DNetworkSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DNetworkSensorNode (executionContext)
{
   Core_X3DSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DNetworkSensorNode);
}

X3DNetworkSensorNode .prototype = Object .assign (Object .create (Core_X3DSensorNode.prototype),
{
   constructor: X3DNetworkSensorNode,
});

/* harmony default export */ const Networking_X3DNetworkSensorNode = (X3DNetworkSensorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking/LoadSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function LoadSensor (executionContext)
{
   Networking_X3DNetworkSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.LoadSensor);

   this .urlObjects = [ ];
   this .aborted    = false;
   this .timeOutId  = undefined;
}

LoadSensor .prototype = Object .assign (Object .create (Networking_X3DNetworkSensorNode.prototype),
{
   constructor: LoadSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",   new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "timeOut",   new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",  new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isLoaded",  new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "progress",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "loadTime",  new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "watchList", new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "LoadSensor";
   },
   getComponentName: function ()
   {
      return "Networking";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Networking_X3DNetworkSensorNode.prototype.initialize.call (this);

      this ._enabled   .addInterest ("set_enabled__",   this);
      this ._timeOut   .addInterest ("set_timeOut__",   this);
      this ._watchList .addInterest ("set_watchList__", this);

      this .set_watchList__ ();
   },
   set_enabled__: function ()
   {
      if (this ._enabled .getValue ())
         this .reset ();

      else
      {
         this .abort ();
         this .remove ();
      }
   },
   set_timeOut__: function ()
   {
      if (this ._isActive .getValue ())
      {
         this .clearTimeout ();

         this .aborted = false;

         if (this ._timeOut .getValue () > 0)
            this .timeOutId = setTimeout (this .abort .bind (this), this ._timeOut .getValue () * 1000);
      }
   },
   set_watchList__: function ()
   {
      this .reset ();
   },
   set_loadState__: function (urlObject)
   {
      switch (urlObject .checkLoadState ())
      {
         case Base_X3DConstants.NOT_STARTED_STATE:
            break;
         case Base_X3DConstants.IN_PROGRESS_STATE:
         case Base_X3DConstants.COMPLETE_STATE:
         case Base_X3DConstants.FAILED_STATE:
         {
            this .count ();
            break;
         }
      }
   },
   count: function ()
   {
      const urlObjects = this .urlObjects;

      let
         complete = 0,
         failed   = 0;

      for (const urlObject of urlObjects)
      {
         complete += urlObject .checkLoadState () == Base_X3DConstants.COMPLETE_STATE;
         failed   += urlObject .checkLoadState () == Base_X3DConstants.FAILED_STATE;
      }

      const
         loaded   = complete == urlObjects .length,
         progress = complete / urlObjects .length;

      if (this .aborted || failed || loaded)
      {
         this .clearTimeout ();

         this ._isActive = false;
         this ._isLoaded = loaded;
         this ._progress = progress;

         if (loaded)
            this ._loadTime = this .getBrowser () .getCurrentTime ();
      }
      else
      {
         if (this ._isActive .getValue ())
         {
            this ._progress = progress;
         }
         else
         {
            this ._isActive = true;
            this ._progress = progress;

            this .set_timeOut__ ();
         }
      }
   },
   abort: function ()
   {
      this .clearTimeout ();

      this .aborted = true;

      if (this ._enabled .getValue ())
         this .count ();
   },
   reset: function ()
   {
      this .remove ();

      if (this ._enabled .getValue ())
      {
         const urlObjects = this .urlObjects;

         for (const node of this ._watchList)
         {
            const urlObject = X3DCast (Base_X3DConstants.X3DUrlObject, node);

            if (urlObject)
            {
               urlObjects .push (urlObject);

               urlObject ._loadState .addInterest ("set_loadState__", this, urlObject);
            }
         }

         this .count ();
      }
   },
   remove: function ()
   {
      this .clearTimeout ();

      const urlObjects = this .urlObjects;

      for (const urlObject of urlObjects)
         urlObject ._loadState .removeInterest ("set_loadState__", this);

      urlObjects .length = 0;
   },
   clearTimeout: function ()
   {
      clearTimeout (this .timeOutId);

      this .timeOutId = undefined;
   },
});

/* harmony default export */ const Networking_LoadSensor = (LoadSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/ComposedShader.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function ComposedShader (executionContext)
{
   Shaders_X3DShaderNode.call (this, executionContext);
   Shaders_X3DProgrammableShaderObject.call (this, executionContext);

   this .addType (Base_X3DConstants.ComposedShader);

   this .loadSensor                = new Networking_LoadSensor (executionContext);
   this .transformFeedbackVaryings = [ ];
}

ComposedShader .prototype = Object .assign (Object .create (Shaders_X3DShaderNode.prototype),
   Shaders_X3DProgrammableShaderObject.prototype,
{
   constructor: ComposedShader,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "activate",   new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isSelected", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isValid",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "language",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "parts",      new x_ite_Fields.MFNode ()),
   ]),
   wireframe: false,
   getTypeName: function ()
   {
      return "ComposedShader";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "shaders";
   },
   initialize: function ()
   {
      Shaders_X3DShaderNode.prototype.initialize.call (this);
      Shaders_X3DProgrammableShaderObject.prototype.initialize.call (this);

      this .isLive () .addInterest ("set_live__", this);

      // https://www.web3d.org/documents/specifications/19775-1/V4.0/Part01/shaders_glsl.html#relinkingprograms
      this ._activate .addInterest ("set_activate__", this);

      this ._parts .addFieldInterest (this .loadSensor ._watchList);

      this .loadSensor ._isLoaded .addInterest ("connectLoaded", this);
      this .loadSensor ._watchList = this ._parts;
      this .loadSensor .setPrivate (true);
      this .loadSensor .setup ();

      if (this .loadSensor ._isLoaded .getValue ())
         this .set_loaded__ ();
      else
         this .connectLoaded ();
   },
   connectLoaded: function ()
   {
      this .loadSensor ._isLoaded .removeInterest ("connectLoaded", this);
      this .loadSensor ._isLoaded .addInterest ("set_loaded__", this);
   },
   addUserDefinedField: function (accessType, name, field)
   {
      const shaderFields = this .isInitialized () && this .isLive () .getValue () && this .isValid ();

      if (shaderFields)
         this .removeShaderFields ();

      Shaders_X3DShaderNode.prototype.addUserDefinedField.call (this, accessType, name, field);

      if (shaderFields)
         this .addShaderFields ();
   },
   removeUserDefinedField: function (name)
   {
      const shaderFields = this .isInitialized () && this .isLive () .getValue () && this .isValid ();

      if (shaderFields)
         this .removeShaderFields ();

      Shaders_X3DShaderNode.prototype.removeUserDefinedField.call (this, name);

      if (shaderFields)
         this .addShaderFields ();
   },
   setTransformFeedbackVaryings: function (value)
   {
      this .transformFeedbackVaryings = value;
   },
   getProgram: function ()
   {
      return this .program;
   },
   set_live__: function ()
   {
      if (this .isLive () .getValue ())
      {
         if (this .isValid ())
            this .addShaderFields ();
      }
      else
      {
         if (this .isValid ())
            this .removeShaderFields ();
      }
   },
   set_activate__: function ()
   {
      if (! this ._activate .getValue ())
         return;

      this .set_loaded__ ();
   },
   set_loaded__: function ()
   {
      if (this .loadSensor ._isLoaded .getValue () && this ._language .getValue () === "GLSL")
      {
         const
            gl      = this .getBrowser () .getContext (),
            program = gl .createProgram ();

         if (this .isValid ())
            this .removeShaderFields ();

         gl .deleteProgram (this .program);

         this .program = program;

         for (const node of this ._parts)
         {
            const partNode = X3DCast (Base_X3DConstants.ShaderPart, node);

            if (partNode)
               gl .attachShader (program, partNode .getShader ());
         }

         if (this .transformFeedbackVaryings .length)
            gl .transformFeedbackVaryings (program, this .transformFeedbackVaryings, gl .INTERLEAVED_ATTRIBS);

         gl .linkProgram (program);

         if (gl .getProgramParameter (program, gl .LINK_STATUS))
         {
            this .setValid (true);
            this .getDefaultUniformsAndAttributes ();
            this .addShaderFields ();
         }
         else
         {
            this .setValid (false);

            if (this ._parts .length)
            {
               console .warn ("Couldn't initialize " + this .getTypeName () + " '" + this .getName () + "': " + gl .getProgramInfoLog (program));
            }
         }
      }
      else
      {
         this .setValid (false);
      }
   },
   dispose: function ()
   {
      this .getBrowser () .getContext () .deleteProgram (this .program);

      Shaders_X3DProgrammableShaderObject.prototype.dispose.call (this);
      Shaders_X3DShaderNode.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Shaders_ComposedShader = (ComposedShader);

;// CONCATENATED MODULE: ./src/assets/shaders/Types.glsl.js
/* harmony default export */ const Types_glsl = (/* glsl */`
#if defined (X3D_FOG)
struct x3d_FogParameters {
   mediump int   type;
   mediump vec3  color;
   mediump float visibilityRange;
   mediump mat3  matrix;
};
#endif

//uniform x3d_FogParameters x3d_Fog;

#if defined (X3D_LIGHTING)
struct x3d_LightSourceParameters {
   mediump int   type;
   mediump vec3  color;
   mediump float intensity;
   mediump float ambientIntensity;
   mediump vec3  attenuation;
   mediump vec3  location;
   mediump vec3  direction;
   mediump float radius;
   mediump float beamWidth;
   mediump float cutOffAngle;
   mediump mat3  matrix;
   #if defined (X3D_SHADOWS)
   mediump vec3  shadowColor;
   mediump float shadowIntensity;
   mediump float shadowBias;
   mediump mat4  shadowMatrix;
   mediump int   shadowMapSize;
   #endif
};
#endif

//uniform x3d_LightSourceParameters x3d_LightSource [x3d_MaxLights];

#if defined (X3D_GEOMETRY_0D) && defined (X3D_STYLE_PROPERTIES)
struct x3d_PointPropertiesParameters
{
   mediump float pointSizeScaleFactor;
   mediump float pointSizeMinValue;
   mediump float pointSizeMaxValue;
   mediump vec3  pointSizeAttenuation;
};
#endif

//uniform x3d_PointPropertiesParameters x3d_PointProperties;

#if defined (X3D_GEOMETRY_1D) && defined (X3D_STYLE_PROPERTIES)
struct x3d_LinePropertiesParameters
{
   bool          applied;
   mediump int   linetype;
   mediump float lineStippleScale;
   sampler2D     texture;
};
#endif

//uniform x3d_LinePropertiesParameters x3d_LineProperties;

#if (defined (X3D_GEOMETRY_2D) || defined (X3D_GEOMETRY_3D)) && defined (X3D_STYLE_PROPERTIES)
struct x3d_FillPropertiesParameters
{
   bool         filled;
   bool         hatched;
   mediump vec3 hatchColor;
   sampler2D    texture;
};
#endif

//uniform x3d_FillPropertiesParameters x3d_FillProperties;

#if defined (X3D_UNLIT_MATERIAL)
struct x3d_UnlitMaterialParameters
{
   mediump vec3  emissiveColor;
   mediump float normalScale;
   mediump float transparency;
};
#endif

//uniform x3d_UnlitMaterialParameters x3d_Material;

#if defined (X3D_MATERIAL)
struct x3d_MaterialParameters
{
   mediump float ambientIntensity;
   mediump vec3  diffuseColor;
   mediump vec3  specularColor;
   mediump vec3  emissiveColor;
   mediump float shininess;
   mediump float occlusionStrength;
   mediump float normalScale;
   mediump float transparency;
};
#endif

//uniform x3d_MaterialParameters x3d_Material;

#if defined (X3D_PHYSICAL_MATERIAL)
struct x3d_PhysicalMaterialParameters
{
   mediump vec3  baseColor;
   mediump vec3  emissiveColor;
   mediump float metallic;
   mediump float roughness;
   mediump float occlusionStrength;
   mediump float normalScale;
   mediump float transparency;
};
#endif

//uniform x3d_PhysicalMaterialParameters x3d_Material;

#if defined (X3D_AMBIENT_TEXTURE)
struct x3d_AmbientTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_AMBIENT_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_AMBIENT_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_AMBIENT_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_AmbientTextureParameters x3d_AmbientTexture;

#if defined (X3D_DIFFUSE_TEXTURE)
struct x3d_DiffuseTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_DIFFUSE_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_DIFFUSE_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_DIFFUSE_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_DiffuseTextureParameters x3d_DiffuseTexture;

#if defined (X3D_SPECULAR_TEXTURE)
struct x3d_SpecularTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_SPECULAR_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_SPECULAR_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_SPECULAR_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_SpecularTextureParameters x3d_SpecularTexture;

#if defined (X3D_EMISSIVE_TEXTURE)
struct x3d_EmissiveTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_EMISSIVE_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_EMISSIVE_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_EMISSIVE_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;

#if defined (X3D_SHININESS_TEXTURE)
struct x3d_ShininessTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_SHININESS_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_SHININESS_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_SHININESS_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_ShininessTextureParameters x3d_ShininessTexture;

#if defined (X3D_BASE_TEXTURE)
struct x3d_BaseTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_BASE_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_BASE_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_BASE_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_BaseTextureParameters x3d_BaseTexture;

#if defined (X3D_METALLIC_ROUGHNESS_TEXTURE)
struct x3d_MetallicRoughnessTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_METALLIC_ROUGHNESS_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_MetallicRoughnessTextureParameters x3d_MetallicRoughnessTexture;

#if defined (X3D_OCCLUSION_TEXTURE)
struct x3d_OcclusionTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_OCCLUSION_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_OCCLUSION_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_OCCLUSION_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;

#if defined (X3D_NORMAL_TEXTURE)
struct x3d_NormalTextureParameters
{
   mediump int         textureTransformMapping;
   mediump int         textureCoordinateMapping;
   #if defined (X3D_NORMAL_TEXTURE_2D)
   mediump sampler2D   texture2D;
   #endif
   #if defined (X3D_NORMAL_TEXTURE_3D) && __VERSION__ != 100
   mediump sampler3D   texture3D;
   #endif
   #if defined (X3D_NORMAL_TEXTURE_CUBE)
   mediump samplerCube textureCube;
   #endif
};
#endif

//uniform x3d_NormalTextureParameters x3d_NormalTexture;

#if defined (X3D_MULTI_TEXTURING)
struct x3d_MultiTextureParameters
{
   mediump int mode;
   mediump int alphaMode;
   mediump int source;
   mediump int function;
};
#endif

//uniform x3d_MultiTextureParameters x3d_MultiTexture [x3d_MaxTextures];

#if defined (X3D_TEXTURE) || defined (X3D_MATERIAL_TEXTURES)
struct x3d_TextureCoordinateGeneratorParameters
{
   mediump int   mode;
   mediump float parameter [6];
};
#endif

//uniform x3d_TextureCoordinateGeneratorParameters x3d_TextureCoordinateGenerator [x3d_MaxTextures];
`);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Texturing/ModeType.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let ModeType_i = 0;

const ModeType =
{
   REPLACE:                   ModeType_i ++,
   MODULATE:                  ModeType_i ++,
   MODULATE2X:                ModeType_i ++,
   MODULATE4X:                ModeType_i ++,
   ADD:                       ModeType_i ++,
   ADDSIGNED:                 ModeType_i ++,
   ADDSIGNED2X:               ModeType_i ++,
   ADDSMOOTH:                 ModeType_i ++,
   SUBTRACT:                  ModeType_i ++,
   BLENDDIFFUSEALPHA:         ModeType_i ++,
   BLENDTEXTUREALPHA:         ModeType_i ++,
   BLENDFACTORALPHA:          ModeType_i ++,
   BLENDCURRENTALPHA:         ModeType_i ++,
   MODULATEALPHA_ADDCOLOR:    ModeType_i ++,
   MODULATEINVALPHA_ADDCOLOR: ModeType_i ++,
   MODULATEINVCOLOR_ADDALPHA: ModeType_i ++,
   DOTPRODUCT3:               ModeType_i ++,
   SELECTARG1:                ModeType_i ++,
   SELECTARG2:                ModeType_i ++,
   OFF:                       ModeType_i ++,
};

/* harmony default export */ const Texturing_ModeType = (ModeType);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Texturing/SourceType.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let SourceType_i = 0;

const SourceType =
{
   DEFAULT:  SourceType_i ++,
   DIFFUSE:  SourceType_i ++,
   SPECULAR: SourceType_i ++,
   FACTOR:   SourceType_i ++,
};

/* harmony default export */ const Texturing_SourceType = (SourceType);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Texturing/FunctionType.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let FunctionType_i = 0;

const FunctionType =
{
   DEFAULT:        FunctionType_i ++,
   COMPLEMENT:     FunctionType_i ++,
   ALPHAREPLICATE: FunctionType_i ++,
};

/* harmony default export */ const Texturing_FunctionType = (FunctionType);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let TextureCoordinateGeneratorModeType_i = 0;

const TextureCoordinateGeneratorModeType_ModeType =
{
   NONE:                        TextureCoordinateGeneratorModeType_i ++,
   SPHERE:                      TextureCoordinateGeneratorModeType_i ++,
   CAMERASPACENORMAL:           TextureCoordinateGeneratorModeType_i ++,
   CAMERASPACEPOSITION:         TextureCoordinateGeneratorModeType_i ++,
   CAMERASPACEREFLECTIONVECTOR: TextureCoordinateGeneratorModeType_i ++,
   SPHERE_LOCAL:                TextureCoordinateGeneratorModeType_i ++,
   COORD:                       TextureCoordinateGeneratorModeType_i ++,
   COORD_EYE:                   TextureCoordinateGeneratorModeType_i ++,
   NOISE:                       TextureCoordinateGeneratorModeType_i ++,
   NOISE_EYE:                   TextureCoordinateGeneratorModeType_i ++,
   SPHERE_REFLECT:              TextureCoordinateGeneratorModeType_i ++,
   SPHERE_REFLECT_LOCAL:        TextureCoordinateGeneratorModeType_i ++,
};

/* harmony default export */ const TextureCoordinateGeneratorModeType = (TextureCoordinateGeneratorModeType_ModeType);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shaders/ShaderSource.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const ShaderSource =
{
   getSource: function (gl, browser, source, options)
   {
			const
				COMMENTS     = "\\s+|/\\*[\\s\\S]*?\\*/|//.*?\\n",
				LINE         = "#line\\s+.*?\\n",
				IF           = "#if\\s+.*?\\n",
				ELIF         = "#elif\\s+.*?\\n",
				IFDEF        = "#ifdef\\s+.*?\\n",
				IFNDEF       = "#ifndef\\s+.*?\\n",
				ELSE         = "#else.*?\\n",
				ENDIF        = "#endif.*?\\n",
				DEFINE       = "#define\\s+(?:[^\\n\\\\]|\\\\[^\\r\\n]|\\\\\\r?\\n)*\\n",
				UNDEF        = "#undef\\s+.*?\\n",
				PRAGMA       = "#pragma\\s+.*?\\n",
				PREPROCESSOR =  LINE + "|" + IF + "|" + ELIF + "|" + IFDEF + "|" + IFNDEF + "|" + ELSE + "|" + ENDIF + "|" + DEFINE + "|" + UNDEF + "|" + PRAGMA,
				VERSION      = "#version\\s+.*?\\n",
				EXTENSION    = "#extension\\s+.*?\\n",
				ANY          = "[\\s\\S]*";

			const
				GLSL  = new RegExp ("^((?:" + COMMENTS + "|" + PREPROCESSOR + ")*(?:" + VERSION + ")?(?:" + COMMENTS + "|" + PREPROCESSOR + "|" + EXTENSION + ")*)(" + ANY + ")$"),
				match = source .match (GLSL);

      // const
      //    COMMENTS = "\\s+|/\\*[^]*?\\*/|//.*?\\n",
      //    VERSION  = "#version\\s+.*?\\n",
      //    ANY      = "[^]*";

      // const
      //    GLSL  = new RegExp ("^((?:" + COMMENTS + ")?(?:" + VERSION + ")?)(" + ANY + ")$"),
      //    match = source .match (GLSL);

      if (! match)
         return source;

      // Constants

      let constants = "";

      constants += "#define X_ITE\n";

      if (gl .HAS_FEATURE_DEPTH_TEXTURE)
         constants += "#define X3D_DEPTH_TEXTURE\n";

      for (const option of options)
         constants += "#define " + option + "\n";

      // Definitions

      let definitions = "";

      definitions += "#define x3d_None 0\n";

      definitions += "#define x3d_Points      0\n";
      definitions += "#define x3d_Lines       1\n";
      definitions += "#define x3d_Geometry2D  2\n";
      definitions += "#define x3d_Geometry3D  3\n";

      definitions += "#define x3d_MaxClipPlanes  " + browser .getMaxClipPlanes () + "\n";

      definitions += "#define x3d_LinearFog        1\n";
      definitions += "#define x3d_ExponentialFog   2\n";
      definitions += "#define x3d_Exponential2Fog  3\n";

      definitions += "#define x3d_MaxLights         " + browser .getMaxLights () + "\n";
      definitions += "#define x3d_DirectionalLight  1\n";
      definitions += "#define x3d_PointLight        2\n";
      definitions += "#define x3d_SpotLight         3\n";

      definitions += "#define x3d_MaxTextures      " + browser .getMaxTextures () + "\n";
      definitions += "#define x3d_TextureType2D    2\n";
      definitions += "#define x3d_TextureType3D    3\n";
      definitions += "#define x3d_TextureTypeCube  4\n";

      definitions += "#define x3d_Replace                   " + Texturing_ModeType.REPLACE                   + "\n";
      definitions += "#define x3d_Modulate                  " + Texturing_ModeType.MODULATE                  + "\n";
      definitions += "#define x3d_Modulate2X                " + Texturing_ModeType.MODULATE2X                + "\n";
      definitions += "#define x3d_Modulate4X                " + Texturing_ModeType.MODULATE4X                + "\n";
      definitions += "#define x3d_Add                       " + Texturing_ModeType.ADD                       + "\n";
      definitions += "#define x3d_AddSigned                 " + Texturing_ModeType.ADDSIGNED                 + "\n";
      definitions += "#define x3d_AddSigned2X               " + Texturing_ModeType.ADDSIGNED2X               + "\n";
      definitions += "#define x3d_AddSmooth                 " + Texturing_ModeType.ADDSMOOTH                 + "\n";
      definitions += "#define x3d_Subtract                  " + Texturing_ModeType.SUBTRACT                  + "\n";
      definitions += "#define x3d_BlendDiffuseAlpha         " + Texturing_ModeType.BLENDDIFFUSEALPHA         + "\n";
      definitions += "#define x3d_BlendTextureAlpha         " + Texturing_ModeType.BLENDTEXTUREALPHA         + "\n";
      definitions += "#define x3d_BlendFactorAlpha          " + Texturing_ModeType.BLENDFACTORALPHA          + "\n";
      definitions += "#define x3d_BlendCurrentAlpha         " + Texturing_ModeType.BLENDCURRENTALPHA         + "\n";
      definitions += "#define x3d_ModulateAlphaAddColor     " + Texturing_ModeType.MODULATEALPHA_ADDCOLOR    + "\n";
      definitions += "#define x3d_ModulateInvAlphaAddColor  " + Texturing_ModeType.MODULATEINVALPHA_ADDCOLOR + "\n";
      definitions += "#define x3d_ModulateInvColorAddAlpha  " + Texturing_ModeType.MODULATEINVCOLOR_ADDALPHA + "\n";
      definitions += "#define x3d_DotProduct3               " + Texturing_ModeType.DOTPRODUCT3               + "\n";
      definitions += "#define x3d_SelectArg1                " + Texturing_ModeType.SELECTARG1                + "\n";
      definitions += "#define x3d_SelectArg2                " + Texturing_ModeType.SELECTARG2                + "\n";
      definitions += "#define x3d_Off                       " + Texturing_ModeType.OFF                       + "\n";

      definitions += "#define x3d_Diffuse  " + Texturing_SourceType.DIFFUSE  + "\n";
      definitions += "#define x3d_Specular " + Texturing_SourceType.SPECULAR + "\n";
      definitions += "#define x3d_Factor   " + Texturing_SourceType.FACTOR   + "\n";

      definitions += "#define x3d_Complement     " + Texturing_FunctionType.COMPLEMENT     + "\n";
      definitions += "#define x3d_AlphaReplicate " + Texturing_FunctionType.ALPHAREPLICATE + "\n";

      definitions += "#define x3d_Sphere                      " + TextureCoordinateGeneratorModeType.SPHERE                      + "\n";
      definitions += "#define x3d_CameraSpaceNormal           " + TextureCoordinateGeneratorModeType.CAMERASPACENORMAL           + "\n";
      definitions += "#define x3d_CameraSpacePosition         " + TextureCoordinateGeneratorModeType.CAMERASPACEPOSITION         + "\n";
      definitions += "#define x3d_CameraSpaceReflectionVector " + TextureCoordinateGeneratorModeType.CAMERASPACEREFLECTIONVECTOR + "\n";
      definitions += "#define x3d_SphereLocal                 " + TextureCoordinateGeneratorModeType.SPHERE_LOCAL                + "\n";
      definitions += "#define x3d_Coord                       " + TextureCoordinateGeneratorModeType.COORD                       + "\n";
      definitions += "#define x3d_CoordEye                    " + TextureCoordinateGeneratorModeType.COORD_EYE                   + "\n";
      definitions += "#define x3d_Noise                       " + TextureCoordinateGeneratorModeType.NOISE                       + "\n";
      definitions += "#define x3d_NoiseEye                    " + TextureCoordinateGeneratorModeType.NOISE_EYE                   + "\n";
      definitions += "#define x3d_SphereReflect               " + TextureCoordinateGeneratorModeType.SPHERE_REFLECT              + "\n";
      definitions += "#define x3d_SphereReflectLocal          " + TextureCoordinateGeneratorModeType.SPHERE_REFLECT_LOCAL        + "\n";

      // Legacy
      definitions += "#define x3d_GeometryPoints  0\n";
      definitions += "#define x3d_GeometryLines   1\n";
      definitions += "#define x3d_NoneClipPlane   vec4 (88.0, 51.0, 68.0, 33.0)\n"; // ASCII »X3D!«
      definitions += "#define x3d_NoneFog         0\n";
      definitions += "#define x3d_NoneLight       0\n";
      definitions += "#define x3d_NoneTexture     0\n";

      // Adjust precision of struct types;

      const
         matchFloat       = source .match (/\s*precision\s+(lowp|mediump|highp)\s+float\s*;/),
         matchInt         = source .match (/\s*precision\s+(lowp|mediump|highp)\s+int\s*;/),
         precisionFloat   = matchFloat ? matchFloat [1] : "mediump",
         precisionInt     = matchInt   ? matchInt   [1] : "mediump";

      const types = Types_glsl.replace (/mediump\s+(float|vec2|vec3|mat3|mat4)/g, precisionFloat + " $1")
         .replace (/mediump\s+(int)/g,                       precisionInt   + " $1");

      const lines = (match [1] .match (/\n/g) || [ ]) .length + 1;

      return match [1] + constants + definitions + types + "#line " + (lines + 1) + " -1\n" + match [2];
   },
};

function depreciatedWarning (source, depreciated, current)
{
   if (source .indexOf (depreciated) === -1)
      return;

   console .warn ("Use of '" + depreciated + "' is depreciated, use '" + current + "' instead. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
}

/* harmony default export */ const Shaders_ShaderSource = (ShaderSource);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shaders/ShaderCompiler.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const include = /^\s*#pragma\s+X3D\s+include\s+".*?([^\/]+)\.glsl"\s*$/;

function ShaderCompiler (gl)
{
   this .includes          = Shaders_Shaders.includes [gl .getVersion ()];
   this .sourceFileNumbers = { };

   for (const [i, name] of Object .getOwnPropertyNames (this .includes) .entries ())
      this .sourceFileNumbers [name] = i + 1;
}

ShaderCompiler .prototype =
{
   getSourceFileName: function (sourceFileNumber)
   {
      return Object .getOwnPropertyNames (this .includes) [sourceFileNumber - 1];
   },
   process: function (source, parent = 0)
   {
      const lines = source .split ("\n");

      source = "";

      for (let i = 0, length = lines .length; i < length; ++ i)
      {
         const
            line  = lines [i],
            match = line .match (include);

         if (match)
         {
            source += "#line 1 " + this .sourceFileNumbers [match [1]] + "\n";
            source += this .process (this .includes [match [1]], this .sourceFileNumbers [match [1]]);
            source += "\n";
            source += "#line " + (i + 2) + " " + parent + "\n";
         }
         else
         {
            source += line;
            source += "\n";
         }
      }

      return source;
   },
};

/* harmony default export */ const Shaders_ShaderCompiler = (ShaderCompiler);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/ShaderPart.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const customOptions = [
   "X3D_GEOMETRY_0D",
   "X3D_GEOMETRY_1D",
   "X3D_GEOMETRY_2D",
   "X3D_GEOMETRY_3D",
   "X3D_FOG",
   "X3D_STYLE_PROPERTIES",
   "X3D_UNLIT_MATERIAL",
   "X3D_MATERIAL",
   "X3D_LIGHTING",
   "X3D_TEXTURE",
   "X3D_MULTI_TEXTURING",
];

function ShaderPart (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.ShaderPart);

   this .options = [ ];
}

ShaderPart .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: ShaderPart,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "type",                 new x_ite_Fields.SFString ("VERTEX")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
   ]),
   getTypeName: function ()
   {
      return "ShaderPart";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "parts";
   },
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      if (! this .isPrivate ())
         this .options = customOptions .slice ();

      this ._type .addInterest ("set_type__", this);

      this .requestImmediateLoad ();
   },
   set_type__: function ()
   {
      this .setLoadState (Base_X3DConstants.NOT_STARTED_STATE);

      this .requestImmediateLoad ();
   },
   getSourceText: function ()
   {
      return this ._url;
   },
   getOptions: function ()
   {
      return this .options;
   },
   setOptions: function (value)
   {
      this .options = value;
   },
   getShader: function ()
   {
      return this .shader;
   },
   getShaderType: (function ()
   {
      const shaderTypes = new Map ([
         ["VERTEX",          "VERTEX_SHADER"],
         ["TESS_CONTROL",    "TESS_CONTROL_SHADER"],
         ["TESS_EVALUATION", "TESS_EVALUATION_SHADER"],
         ["GEOMETRY",        "GEOMETRY_SHADER"],
         ["FRAGMENT",        "FRAGMENT_SHADER"],
         ["COMPUTE",         "COMPUTE_SHADER"],
      ]);

      return function ()
      {
         return shaderTypes .get (this ._type .getValue ()) || "VERTEX_SHADER";
      };
   })(),
   unLoadNow: function ()
   {
      this .valid = false;
   },
   loadNow: function ()
   {
      new InputOutput_FileLoader (this) .loadDocument (this ._url,
      function (data, url)
      {
         if (data === null)
         {
            // No URL could be loaded.
            this .setLoadState (Base_X3DConstants.FAILED_STATE);
         }
         else
         {
            const
               browser        = this .getBrowser (),
               gl             = browser .getContext (),
               type           = this .getShaderType (),
               options        = ["X3D_" + type] .concat (this .options),
               shaderCompiler = new Shaders_ShaderCompiler (gl),
               source         = Shaders_ShaderSource.getSource (gl, browser, shaderCompiler .process (data), options),
               shader         = gl .createShader (gl [type]);

            gl .deleteShader (this .shader);

            this .shader = shader;

            gl .shaderSource (shader, source);
            gl .compileShader (shader);

            if (! gl .getShaderParameter (shader, gl .COMPILE_STATUS))
            {
               const
                  typeName = this .getTypeName (),
                  name     = this .getName (),
                  log      = gl .getShaderInfoLog (shader),
                  match    = log .match (/(\d+):(\d+)/);

               if (match)
               {
                  const fileName = shaderCompiler .getSourceFileName (match [1]) || url || this .getExecutionContext () .getWorldURL ();

                  throw new Error ("Error in " + typeName + " '" + name + "' in URL '" + fileName + "', line " + match [2] + ", " + log);
               }
               else
               {
                  const fileName = url || this .getExecutionContext () .getWorldURL ();

                  throw new Error ("Error in " + typeName + " '" + name + "' in URL '" + fileName + "', " + log);
               }
            }

            this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
         }
      }
      .bind (this));
   },
   dispose: function ()
   {
      this .getBrowser () .getContext () .deleteShader (this .shader);

      Core_X3DNode.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Shaders_ShaderPart = (ShaderPart);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shaders/X3DShadersContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _wireframe      = Symbol (),
   _primitiveModes = Symbol (),
   _defaultShader  = Symbol (),
   _shaderNodes    = Symbol ();

function X3DShadersContext ()
{
   this [_wireframe]      = false;
   this [_primitiveModes] = new Map ();
   this [_shaderNodes]    = new Map ();
}

X3DShadersContext .prototype =
{
   initialize: function ()
   {
      this .setShading (this .getBrowserOptions () .getShading ());
   },
   getShadingLanguageVersion: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .SHADING_LANGUAGE_VERSION);
   },
   getMaxVertexUniformVectors: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .MAX_VERTEX_UNIFORM_VECTORS);
   },
   getMaxFragmentUniformVectors: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .MAX_FRAGMENT_UNIFORM_VECTORS);
   },
   getMaxVertexAttribs: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .MAX_VERTEX_ATTRIBS);
   },
   getMaxVaryingVectors: function ()
   {
      const gl = this .getContext ();

      return gl .getParameter (gl .MAX_VARYING_VECTORS);
   },
   getWireframe: function ()
   {
      return this [_wireframe];
   },
   getPrimitiveMode: function (primitiveMode)
   {
      return this [_primitiveModes] .get (primitiveMode);
   },
   getShaders: function ()
   {
      return this [_shaderNodes];
   },
   setShading: function (type)
   {
      const gl = this .getContext ();

      switch (type)
      {
         case Core_Shading.POINT:
         {
            this [_wireframe] = false;

            this [_primitiveModes] .set (gl .POINTS,    gl .POINTS);
            this [_primitiveModes] .set (gl .LINES,     gl .POINTS);
            this [_primitiveModes] .set (gl .TRIANGLES, gl .POINTS);
            break;
         }
         case Core_Shading.WIREFRAME:
         {
            this [_wireframe] = true;

            this [_primitiveModes] .set (gl .POINTS,    gl .POINTS);
            this [_primitiveModes] .set (gl .LINES,     gl .LINES);
            this [_primitiveModes] .set (gl .TRIANGLES, gl .LINE_LOOP);
            break;
         }
         default:
         {
            // case Shading .FLAT:
            // case Shading .GOURAUD:
            // case Shading .PHONG:

            this [_wireframe] = false;

            this [_primitiveModes] .set (gl .POINTS,    gl .POINTS);
            this [_primitiveModes] .set (gl .LINES,     gl .LINES);
            this [_primitiveModes] .set (gl .TRIANGLES, gl .TRIANGLES);
            break;
         }
      }
   },
   createShader: function (name, vs, fs = vs, options = [ ], uniformNames = [ ], transformFeedbackVaryings = [ ])
   {
      if (this .getDebug ())
         console .info ("Initializing " + name);

      const
         gl      = this .getContext (),
         version = gl .getVersion ();

      const vertexShader = new Shaders_ShaderPart (this .getPrivateScene ());
      vertexShader ._url .push (vs .startsWith ("data:") ? vs : "data:x-shader/x-vertex," + Shaders_Shaders.vertex [version] [vs]);
      vertexShader .setPrivate (true);
      vertexShader .setName (name + "Vertex");
      vertexShader .setOptions (options);
      vertexShader .setup ();

      const fragmentShader = new Shaders_ShaderPart (this .getPrivateScene ());
      fragmentShader ._type  = "FRAGMENT";
      fragmentShader ._url .push (fs .startsWith ("data:") ? fs : "data:x-shader/x-fragment," + Shaders_Shaders.fragment [version] [fs]);
      fragmentShader .setPrivate (true);
      fragmentShader .setName (name + "Fragment");
      fragmentShader .setOptions (options);
      fragmentShader .setup ();

      const shaderNode = new Shaders_ComposedShader (this .getPrivateScene ());
      shaderNode ._language = "GLSL";
      shaderNode ._parts .push (vertexShader);
      shaderNode ._parts .push (fragmentShader);
      shaderNode .setPrivate (true);
      shaderNode .setName (name);
      shaderNode .setUniformNames (uniformNames);
      shaderNode .setTransformFeedbackVaryings (transformFeedbackVaryings);
      shaderNode .setup ();

      return shaderNode;
   },
};

/* harmony default export */ const Shaders_X3DShadersContext = (X3DShadersContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/X3DAppearanceNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DAppearanceNode (executionContext)
{
   Core_X3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DAppearanceNode);

   this .addChildObjects ("transparent", new x_ite_Fields.SFBool ());

   this ._transparent .setAccessType (Base_X3DConstants.outputOnly);
}

X3DAppearanceNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
{
   constructor: X3DAppearanceNode,
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
});

/* harmony default export */ const Shape_X3DAppearanceNode = (X3DAppearanceNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/Appearance.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Appearance (executionContext)
{
   Shape_X3DAppearanceNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Appearance);

   this .stylePropertiesNode     = [ ];
   this .textureTransformMapping = new Map ();
   this .textureBits             = new Utility_BitSet ();
   this .shaderNodes             = [ ];
}

Appearance .prototype = Object .assign (Object .create (Shape_X3DAppearanceNode.prototype),
{
   constructor: Appearance,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "alphaMode",          new x_ite_Fields.SFString ("AUTO")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "alphaCutoff",        new x_ite_Fields.SFFloat (0.5)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "acousticProperties", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pointProperties",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "lineProperties",     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fillProperties",     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "material",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backMaterial",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "texture",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "textureTransform",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "shaders",            new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "blendMode",          new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Appearance";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "appearance";
   },
   initialize: function ()
   {
      Shape_X3DAppearanceNode.prototype.initialize.call (this);

      this ._alphaMode  		.addInterest ("set_alphaMode__",        this);
      this ._alphaCutoff  		.addInterest ("set_alphaCutoff__",      this);
      this ._pointProperties  .addInterest ("set_pointProperties__",  this);
      this ._lineProperties   .addInterest ("set_lineProperties__",   this);
      this ._fillProperties   .addInterest ("set_fillProperties__",   this);
      this ._material         .addInterest ("set_material__",         this);
      this ._backMaterial     .addInterest ("set_backMaterial__",     this);
      this ._texture          .addInterest ("set_texture__",          this);
      this ._textureTransform .addInterest ("set_textureTransform__", this);
      this ._shaders          .addInterest ("set_shaders__",          this);
      this ._blendMode        .addInterest ("set_blendMode__",        this);

      this ._alphaMode      .addInterest ("set_transparent__", this);
      this ._fillProperties .addInterest ("set_transparent__", this);
      this ._material       .addInterest ("set_transparent__", this);
      this ._texture        .addInterest ("set_transparent__", this);
      this ._blendMode      .addInterest ("set_transparent__", this);

      this .set_alphaMode__ ();
      this .set_pointProperties__ ();
      this .set_lineProperties__ ();
      this .set_fillProperties__ ();
      this .set_material__ ();
      this .set_backMaterial__ ();
      this .set_texture__ ();
      this .set_textureTransform__ ();
      this .set_shaders__ ();
      this .set_blendMode__ ();
      this .set_transparent__ ();
   },
   getAlphaMode: function ()
   {
      return this .alphaMode;
   },
   getAlphaCutoff: function ()
   {
      return this .alphaCutoff;
   },
   getStyleProperties: function (geometryType)
   {
      return this .stylePropertiesNode [geometryType];
   },
   getPointProperties: function ()
   {
      return this .stylePropertiesNode [0];
   },
   getLineProperties: function ()
   {
      return this .stylePropertiesNode [1];
   },
   getFillProperties: function ()
   {
      return this .stylePropertiesNode [2];
   },
   getMaterial: function ()
   {
      return this .materialNode;
   },
   getBackMaterial: function ()
   {
      return this .backMaterialNode;
   },
   getTexture: function ()
   {
      return this .textureNode;
   },
   getTextureBits: function ()
   {
      return this .textureBits;
   },
   updateTextureBits: function ()
   {
      this .textureBits .clear ();
      this .textureNode .updateTextureBits (this .textureBits);
   },
   getTextureTransform: function ()
   {
      return this .textureTransformNode;
   },
   getTextureTransformMapping: function ()
   {
      return this .textureTransformMapping;
   },
   getShader: function (geometryContext, renderContext)
   {
      return this .materialNode .getShader (geometryContext, renderContext);
   },
   getBackShader: function (geometryContext, renderContext)
   {
      return this .backMaterialNode .getShader (geometryContext, renderContext);
   },
   getBlendMode: function ()
   {
      return this .blendModeNode;
   },
   set_alphaMode__: function ()
   {
      this .alphaMode = this .getEnum (Shape_AlphaMode, this ._alphaMode .getValue (), Shape_AlphaMode.AUTO);

      this .set_alphaCutoff__ ();
   },
   set_alphaCutoff__: function ()
   {
      this .alphaCutoff = this .alphaMode === Shape_AlphaMode.MASK ? this ._alphaCutoff .getValue () : 0;
   },
   set_pointProperties__: function ()
   {
      this .stylePropertiesNode [0] = X3DCast (Base_X3DConstants.PointProperties, this ._pointProperties);
   },
   set_lineProperties__: function ()
   {
      if (this .linePropertiesNode)
         this .linePropertiesNode ._applied .removeInterest ("set_applied__", this);

      this .linePropertiesNode = X3DCast (Base_X3DConstants.LineProperties, this ._lineProperties);

      if (this .linePropertiesNode)
         this .linePropertiesNode ._applied .addInterest ("set_applied__", this);

      this .set_applied__ ();
   },
   set_applied__: function ()
   {
      if (this .linePropertiesNode && this .linePropertiesNode ._applied .getValue ())
         this .stylePropertiesNode [1] = this .linePropertiesNode;
      else
         this .stylePropertiesNode [1] = null;
   },
   set_fillProperties__: function ()
   {
      if (this .stylePropertiesNode [2])
         this .stylePropertiesNode [2] ._transparent .removeInterest ("set_transparent__", this);

      this .stylePropertiesNode [2] = X3DCast (Base_X3DConstants.FillProperties, this ._fillProperties);

      if (this .stylePropertiesNode [2])
         this .stylePropertiesNode [2] ._transparent .addInterest ("set_transparent__", this);

      this .stylePropertiesNode [3] = this .stylePropertiesNode [2];
   },
   set_material__: function ()
   {
      if (this .materialNode)
         this .materialNode ._transparent .removeInterest ("set_transparent__", this);

      this .materialNode = X3DCast (Base_X3DConstants.X3DMaterialNode, this ._material);

      if (! this .materialNode)
         this .materialNode = this .getBrowser () .getDefaultMaterial ();

      if (this .materialNode)
         this .materialNode ._transparent .addInterest ("set_transparent__", this);

      // Depreciated TwoSidedMaterial handling.

      if (this .materialNode .getTypeName () === "TwoSidedMaterial")
         this .set_backMaterial__ ();
   },
   set_backMaterial__: function ()
   {
      if (this .backMaterialNode)
         this .backMaterialNode ._transparent .removeInterest ("set_transparent__", this);

      this .backMaterialNode = X3DCast (Base_X3DConstants.X3DOneSidedMaterialNode, this ._backMaterial);

      if (this .backMaterialNode)
         this .backMaterialNode ._transparent .addInterest ("set_transparent__", this);

      // Depreciated TwoSidedMaterial handling.

      if (! this .backMaterialNode && this .materialNode .getTypeName () === "TwoSidedMaterial")
         this .backMaterialNode = this .materialNode;
   },
   set_texture__: function ()
   {
      if (this .textureNode)
      {
         this .textureNode .removeInterest ("updateTextureBits", this);
         this .textureNode ._transparent .removeInterest ("set_transparent__", this);
      }

      this .textureNode = X3DCast (Base_X3DConstants.X3DTextureNode, this ._texture);

      if (this .textureNode)
      {
         this .textureNode .addInterest ("updateTextureBits", this);
         this .textureNode ._transparent .addInterest ("set_transparent__", this);

         this .updateTextureBits ();
      }
      else
      {
         this .textureBits .clear ();
      }
   },
   set_textureTransform__: function ()
   {
      if (this .textureTransformNode)
         this .textureTransformNode .removeInterest ("updateTextureTransformMapping", this);

      this .textureTransformNode = X3DCast (Base_X3DConstants.X3DTextureTransformNode, this ._textureTransform);

      if (! this .textureTransformNode)
         this .textureTransformNode = this .getBrowser () .getDefaultTextureTransform ();

      this .textureTransformNode .addInterest ("updateTextureTransformMapping", this);

      this .updateTextureTransformMapping ();
   },
   updateTextureTransformMapping: function ()
   {
      this .textureTransformMapping .clear ();

      this .textureTransformNode .getTextureTransformMapping (this .textureTransformMapping);
   },
   set_shaders__: function ()
   {
      const shaderNodes = this .shaderNodes;

      for (const shaderNode of shaderNodes)
         shaderNode ._isValid .removeInterest ("set_shader__", this);

      shaderNodes .length = 0;

      for (const node of this ._shaders)
      {
         const shaderNode = X3DCast (Base_X3DConstants.X3DShaderNode, node);

         if (shaderNode)
            shaderNodes .push (shaderNode);
      }

      for (const shaderNode of shaderNodes)
         shaderNode ._isValid .addInterest ("set_shader__", this);

      this .set_shader__ ();
   },
   set_shader__: (function ()
   {
      function getShader ()
      {
         return this .shaderNode;
      }

      return function ()
      {
         const shaderNodes = this .shaderNodes;

         if (this .shaderNode)
            this .shaderNode .deselect ();

         this .shaderNode = null;

         for (const shaderNode of shaderNodes)
         {
            if (shaderNode ._isValid .getValue ())
            {
               this .shaderNode = shaderNode;
               break;
            }
         }

         if (this .shaderNode)
         {
            this .shaderNode .select ();

            this .getShader     = getShader;
            this .getBackShader = getShader;
         }
         else
         {
            delete this .getShader;
            delete this .getBackShader;
         }
      };
   })(),
   set_blendMode__: function ()
   {
      this .blendModeNode = X3DCast (Base_X3DConstants.BlendMode, this ._blendMode);
   },
   set_transparent__: function ()
   {
      switch (this .alphaMode)
      {
         case Shape_AlphaMode.AUTO:
            this .setTransparent (Boolean (this .stylePropertiesNode [3] && this .stylePropertiesNode [3] .getTransparent () ||
                                  (this .materialNode && this .materialNode .getTransparent ()) ||
                                  (this .backMaterialNode && this .backMaterialNode .getTransparent ()) ||
                                  (this .textureNode && this .textureNode .getTransparent ()) ||
                                  this .blendModeNode));
            break;
         case Shape_AlphaMode.OPAQUE:
            this .setTransparent (false);
            break;
         case Shape_AlphaMode.MASK:
            // Alpha testing using alphaCutoff.
            this .setTransparent (false);
            break;
         case Shape_AlphaMode.BLEND:
            this .setTransparent (true);
            break;
      }
   },
   traverse: function (type, renderObject)
   {
      if (this .textureNode)
         this .textureNode .traverse (type, renderObject);
   },
});

/* harmony default export */ const Shape_Appearance = (Appearance);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/X3DMaterialNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DMaterialNode (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DMaterialNode);

   this .addChildObjects ("transparent", new x_ite_Fields.SFBool ());

   this ._transparent .setAccessType (Base_X3DConstants.outputOnly);

   this .textureBits = new Utility_BitSet ();
   this .shaderNodes = this .getBrowser () .getShaders ();
}

X3DMaterialNode .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: X3DMaterialNode,
   initialize: function ()
   {
      Shape_X3DAppearanceChildNode.prototype.initialize.call (this);

      this .getBrowser () .getRenderingProperties () ._LogarithmicDepthBuffer .addInterest ("set_logarithmicDepthBuffer__", this);

      this .set_logarithmicDepthBuffer__ ();
   },
   set_logarithmicDepthBuffer__: function ()
   {
      this .logarithmicDepthBuffer = this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer");
   },
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
   setTexture: function (index, textureNode)
   {
      const textureType = textureNode ? textureNode .getTextureType () - 1 : 0;

      this .textureBits .set (index * 2 + 0, textureType & 0b01);
      this .textureBits .set (index * 2 + 1, textureType & 0b10);
   },
   getTextureBits: function ()
   {
      return this .textureBits;
   },
   getShader: function (geometryContext, renderContext)
   {
      let key = "";

      key += this .textureBits .toString (4);
      key += ".";
      key += geometryContext .geometryKey;

      if (renderContext)
      {
         const { renderObject, shadows, fogNode, shapeNode, appearanceNode, textureNode, objectsCount } = renderContext;

         key += this .logarithmicDepthBuffer || renderObject .getViewpoint () .getLogarithmicDepthBuffer () ? "1" : "0";
         key += shadows ? "1" : "0";
         key += fogNode ? fogNode .getFogKey () : "0";
         key += shapeNode .getShapeKey ();
         key += appearanceNode .getStyleProperties (geometryContext .geometryType) ? "1" : "0";
         key += ".";
         key += objectsCount [0]; // Clip planes
         key += ".";
         key += objectsCount [1]; // Lights
         key += ".";
         key += objectsCount [2]; // Texture projectors
         key += ".";
         key += textureNode ? "1" : appearanceNode .getTextureBits () .toString (4);
         key += ".";
         key += appearanceNode .getTextureTransformMapping () .size || "1";
         key += geometryContext .textureCoordinateMapping .size || "1";
         key += this .getMaterialKey (shadows);
      }
      else
      {
         const { textureNode, objectsCount } = geometryContext;

         key += this .logarithmicDepthBuffer ? "1" : "0";
         key += "0000.";
         key += objectsCount [0]; // Clip planes
         key += ".";
         key += objectsCount [1]; // Lights
         key += ".";
         key += objectsCount [2]; // Texture projectors
         key += ".";
         key += textureNode ? "1" : "0";
         key += ".11";
         key += this .getMaterialKey (false);
      }

      return this .shaderNodes .get (key) || this .createShader (key, geometryContext, renderContext);
   },
   getShaderOptions: (function ()
   {
      const geometryTypes = [
         "X3D_GEOMETRY_0D",
         "X3D_GEOMETRY_1D",
         "X3D_GEOMETRY_2D",
         "X3D_GEOMETRY_3D",
      ];

      return function (geometryContext, renderContext)
      {
         const
            browser = this .getBrowser (),
            options = [ ];

         options .push (geometryTypes [geometryContext .geometryType]);

         if (geometryContext .hasFogCoords)
            options .push ("X3D_FOG_COORDS");

         if (geometryContext .colorMaterial)
            options .push ("X3D_COLOR_MATERIAL");

         if (geometryContext .hasNormals)
            options .push ("X3D_NORMALS");

         if (renderContext)
         {
            const { renderObject, appearanceNode, objectsCount } = renderContext;

            if (this .logarithmicDepthBuffer || renderObject .getViewpoint () .getLogarithmicDepthBuffer ())
               options .push ("X3D_LOGARITHMIC_DEPTH_BUFFER");

            if (renderContext .shadows)
               options .push ("X3D_SHADOWS", "X3D_PCF_FILTERING");

            if (renderContext .fogNode)
            {
               options .push ("X3D_FOG");

               switch (renderContext .fogNode .getFogKey ())
               {
                  case "1":
                     options .push ("X3D_FOG_LINEAR");
                     break;
                  case "2":
                     options .push ("X3D_FOG_EXPONENTIAL");
                     break;
               }
            }

            if (objectsCount [0])
            {
               options .push ("X3D_CLIP_PLANES")
               options .push ("X3D_NUM_CLIP_PLANES " + Math .min (objectsCount [0], browser .getMaxClipPlanes ()));
            }

            if (objectsCount [1])
            {
               options .push ("X3D_LIGHTING")
               options .push ("X3D_NUM_LIGHTS " + Math .min (objectsCount [1], browser .getMaxLights ()));
            }

            if (objectsCount [2])
            {
               options .push ("X3D_PROJECTIVE_TEXTURE_MAPPING")
               options .push ("X3D_NUM_TEXTURE_PROJECTORS " + Math .min (objectsCount [2], browser .getMaxTextures ()));
            }

            if (appearanceNode .getStyleProperties (geometryContext .geometryType))
               options .push ("X3D_STYLE_PROPERTIES");

            if (+this .textureBits)
            {
               options .push ("X3D_MATERIAL_TEXTURES");
               options .push ("X3D_NUM_TEXTURE_TRANSFORMS " + (appearanceNode .getTextureTransformMapping () .size || "1"));
               options .push ("X3D_NUM_TEXTURE_COORDINATES " + (geometryContext .getTextureCoordinateMapping () .size || "1"));
            }
            else
            {
               if (renderContext .textureNode)
               {
                  // ScreenText

                  options .push ("X3D_TEXTURE",
                                 "X3D_NUM_TEXTURES 1",
                                 "X3D_NUM_TEXTURE_TRANSFORMS 1",
                                 "X3D_NUM_TEXTURE_COORDINATES 1",
                                 "X3D_TEXTURE0_2D");
               }
               else if (+appearanceNode .getTextureBits ())
               {
                  const textureNode = appearanceNode .getTexture ();

                  options .push ("X3D_TEXTURE");
                  options .push ("X3D_NUM_TEXTURES "            + textureNode .getCount ());
                  options .push ("X3D_NUM_TEXTURE_TRANSFORMS "  + textureNode .getCount ());
                  options .push ("X3D_NUM_TEXTURE_COORDINATES " + textureNode .getCount ());

                  textureNode .getShaderOptions (options);

                  if (textureNode .getType () .includes (Base_X3DConstants.MultiTexture))
                     options .push ("X3D_MULTI_TEXTURING");
               }
            }

            switch (renderContext .shapeNode .getShapeKey ())
            {
               case "1":
                  options .push ("X3D_PARTICLE_SYSTEM");
                  break;
               case "2":
                  options .push ("X3D_PARTICLE_SYSTEM", "X3D_TEX_COORD_RAMP");
                  break;
            }
         }
         else
         {
            const { textureNode, objectsCount } = geometryContext;

            if (this .logarithmicDepthBuffer)
               options .push ("X3D_LOGARITHMIC_DEPTH_BUFFER");

            if (objectsCount [0])
            {
               options .push ("X3D_CLIP_PLANES")
               options .push ("X3D_NUM_CLIP_PLANES " + Math .min (objectsCount [0], browser .getMaxClipPlanes ()));
            }

            if (objectsCount [1])
            {
               options .push ("X3D_LIGHTING")
               options .push ("X3D_NUM_LIGHTS " + Math .min (objectsCount [1], browser .getMaxLights ()));
            }

            if (objectsCount [2])
            {
               options .push ("X3D_PROJECTIVE_TEXTURE_MAPPING")
               options .push ("X3D_NUM_TEXTURE_PROJECTORS " + Math .min (objectsCount [2], browser .getMaxTextures ()));
            }

            if (textureNode)
            {
               // X3DBackgroundNode textures

               options .push ("X3D_TEXTURE",
                              "X3D_NUM_TEXTURES 1",
                              "X3D_NUM_TEXTURE_TRANSFORMS 1",
                              "X3D_NUM_TEXTURE_COORDINATES 1",
                              "X3D_TEXTURE0_2D");
            }
         }

         return options;
      };
   })(),
});

/* harmony default export */ const Shape_X3DMaterialNode = (X3DMaterialNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/X3DOneSidedMaterialNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function X3DOneSidedMaterialNode (executionContext)
{
   Shape_X3DMaterialNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DOneSidedMaterialNode);

   this .addChildObjects ("textures", new x_ite_Fields.SFTime ());

   this .emissiveColor = new Float32Array (3);
}

X3DOneSidedMaterialNode .prototype = Object .assign (Object .create (Shape_X3DMaterialNode.prototype),
{
   constructor: X3DOneSidedMaterialNode,
   initialize: function ()
   {
      Shape_X3DMaterialNode.prototype.initialize.call (this);

      this ._emissiveColor   .addInterest ("set_emissiveColor__",   this);
      this ._emissiveTexture .addInterest ("set_emissiveTexture__", this);
      this ._normalTexture   .addInterest ("set_normalTexture__",   this);
      this ._transparency    .addInterest ("set_transparency__",    this);
      this ._transparency    .addInterest ("set_transparent__",     this);

      this .set_emissiveColor__ ();
      this .set_emissiveTexture__ ();
      this .set_normalTexture__ ();
      this .set_transparency__ ();
   },
   set_emissiveColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .emissiveColor .set (this ._emissiveColor .getValue ());

      const
         emissiveColor  = this .emissiveColor,
         emissiveColor_ = this ._emissiveColor .getValue ();

      emissiveColor [0] = emissiveColor_ .r;
      emissiveColor [1] = emissiveColor_ .g;
      emissiveColor [2] = emissiveColor_ .b;
   },
   set_emissiveTexture__: function ()
   {
      this .emissiveTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._emissiveTexture);

      this .setTexture (this .getTextureIndices () .EMISSIVE_TEXTURE, this .emissiveTextureNode);
   },
   set_normalTexture__: function ()
   {
      this .normalTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._normalTexture);

      this .setTexture (this .getTextureIndices () .NORMAL_TEXTURE, this .normalTextureNode);
   },
   set_transparency__: function ()
   {
      this .transparency = Math_Algorithm.clamp (this ._transparency .getValue (), 0, 1);
   },
   set_transparent__: function ()
   {
      this .setTransparent (Boolean (this .transparency));
   },
   getEmissiveTexture: function ()
   {
      return this .emissiveTextureNode;
   },
   getNormalTexture: function ()
   {
      return this .normalTextureNode;
   },
   getTransparency: function ()
   {
      return this .transparency;
   },
   getTextureIndices: (function ()
   {
      let i = 0;

      const textureIndices = {
         EMISSIVE_TEXTURE: i ++,
         NORMAL_TEXTURE: i ++,
      };

      return function ()
      {
         return textureIndices;
      };
   })(),
   getShaderOptions: function (geometryContext, renderContext)
   {
      const options = Shape_X3DMaterialNode.prototype.getShaderOptions.call (this, geometryContext, renderContext);

      if (+this .getTextureBits ())
      {
         if (this .getEmissiveTexture ())
            options .push ("X3D_EMISSIVE_TEXTURE", "X3D_EMISSIVE_TEXTURE", "X3D_EMISSIVE_TEXTURE_" + this .getEmissiveTexture () .getTextureTypeString ());

         if (this .getNormalTexture ())
            options .push ("X3D_NORMAL_TEXTURE", "X3D_NORMAL_TEXTURE_" + this .getNormalTexture () .getTextureTypeString ());
      }

      return options;
   },
   setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
   {
      gl .uniform3fv (shaderObject .x3d_EmissiveColor, this .emissiveColor);
      gl .uniform1f  (shaderObject .x3d_Transparency,  this .transparency);

      if (+this .getTextureBits ())
      {
         // Emissive parameters

         if (this .emissiveTextureNode)
         {
            const emissiveTexture = shaderObject .x3d_EmissiveTexture;

            this .emissiveTextureNode .setShaderUniforms (gl, shaderObject, renderObject, emissiveTexture);

            gl .uniform1i (emissiveTexture .textureTransformMapping,  textureTransformMapping  .get (this ._emissiveTextureMapping .getValue ()) || 0);
            gl .uniform1i (emissiveTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._emissiveTextureMapping .getValue ()) || 0);
         }

         // Normal parameters

         if (this .normalTextureNode)
         {
            const normalTexture = shaderObject .x3d_NormalTexture;

            this .normalTextureNode .setShaderUniforms (gl, shaderObject, renderObject, normalTexture);

            gl .uniform1i (normalTexture .textureTransformMapping,  textureTransformMapping  .get (this ._normalTextureMapping .getValue ()) || 0);
            gl .uniform1i (normalTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._normalTextureMapping .getValue ()) || 0);

            gl .uniform1f (shaderObject .x3d_NormalScale, this ._normalScale .getValue ());
         }
      }
   },
});

/* harmony default export */ const Shape_X3DOneSidedMaterialNode = (X3DOneSidedMaterialNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/UnlitMaterial.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function UnlitMaterial (executionContext)
{
   Shape_X3DOneSidedMaterialNode.call (this, executionContext);

   this .addType (Base_X3DConstants.UnlitMaterial);
}

UnlitMaterial .prototype = Object .assign (Object .create (Shape_X3DOneSidedMaterialNode.prototype),
{
   constructor: UnlitMaterial,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",               new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveColor",          new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTexture",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTextureMapping", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalScale",            new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTexture",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTextureMapping",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency",           new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "UnlitMaterial";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "material";
   },
   initialize: function ()
   {
      Shape_X3DOneSidedMaterialNode.prototype.initialize.call (this);

      this .set_transparent__ ();
   },
   set_emissiveTexture__: function ()
   {
      if (this .getEmissiveTexture ())
         this .getEmissiveTexture () ._transparent .removeInterest ("set_transparent__", this);

      Shape_X3DOneSidedMaterialNode.prototype.set_emissiveTexture__.call (this);

      if (this .getEmissiveTexture ())
         this .getEmissiveTexture () ._transparent .addInterest ("set_transparent__", this);
   },
   set_transparent__: function ()
   {
      this .setTransparent (Boolean (this .getTransparency () ||
                            (this .getEmissiveTexture () && this .getEmissiveTexture () .getTransparent ())));
   },
   getMaterialKey: function ()
   {
      return "0";
   },
   createShader: function (key, geometryContext, renderContext)
   {
      const
         browser = this .getBrowser (),
         options = this .getShaderOptions (geometryContext, renderContext);

      options .push ("X3D_UNLIT_MATERIAL");

      const shaderNode = browser .createShader ("UnlitShader", "Default", "Unlit", options);

      browser .getShaders () .set (key, shaderNode);

      return shaderNode;
   },
});

/* harmony default export */ const Shape_UnlitMaterial = (UnlitMaterial);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Shape/X3DShapeContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const
   _lineStippleScale          = Symbol (),
   _linetypeTextures          = Symbol (),
   _hatchStyleTextures        = Symbol (),
   _defaultAppearance         = Symbol (),
   _defaultMaterial           = Symbol (),
   _lineFillTextureProperties = Symbol (),
   _lineTransformShaderNode   = Symbol (),
   _lineTransformFeedback     = Symbol ();

function X3DShapeContext ()
{
   this [_hatchStyleTextures] = [ ];
   this [_lineStippleScale]   = 1 / (this .getPixelPerPoint () * 32); // 32px
}

X3DShapeContext .prototype =
{
   initialize: function ()
   { },
   getDefaultAppearance: function ()
   {
      this [_defaultAppearance] = new Shape_Appearance (this .getPrivateScene ());
      this [_defaultAppearance] .setPrivate (true);
      this [_defaultAppearance] .setup ();

      this .getDefaultAppearance = function () { return this [_defaultAppearance]; };

      Object .defineProperty (this, "getDefaultAppearance", { enumerable: false });

      return this [_defaultAppearance];
   },
   getLineStippleScale: function ()
   {
      return this [_lineStippleScale];
   },
   getDefaultMaterial: function ()
   {
      this [_defaultMaterial] = new Shape_UnlitMaterial (this .getPrivateScene ());
      this [_defaultMaterial] .setPrivate (true);
      this [_defaultMaterial] .setup ();

      this .getDefaultMaterial = function () { return this [_defaultMaterial]; };

      Object .defineProperty (this, "getDefaultMaterial", { enumerable: false });

      return this [_defaultMaterial];
   },
   getLinetypeTexture: function ()
   {
      this [_linetypeTextures] = new Texturing_ImageTexture (this .getPrivateScene ());
      this [_linetypeTextures] ._url [0]           = Networking_URLs.getLinetypeUrl ();
      this [_linetypeTextures] ._textureProperties = this .getLineFillTextureProperties ();
      this [_linetypeTextures] .setPrivate (true);
      this [_linetypeTextures] .setup ();

      this .getLinetypeTexture = function () { return this [_linetypeTextures]; };

      Object .defineProperty (this, "getLinetypeTexture", { enumerable: false });

      return this [_linetypeTextures];
   },
   getHatchStyleTexture: function (index)
   {
      let hatchStyleTexture = this [_hatchStyleTextures] [index];

      if (hatchStyleTexture)
         return hatchStyleTexture;

      hatchStyleTexture = this [_hatchStyleTextures] [index] = new Texturing_ImageTexture (this .getPrivateScene ());

      hatchStyleTexture ._url [0]           = Networking_URLs.getHatchingUrl (index);
      hatchStyleTexture ._textureProperties = this .getLineFillTextureProperties ();
      hatchStyleTexture .setPrivate (true);
      hatchStyleTexture .setup ();

      return hatchStyleTexture;
   },
   getLineFillTextureProperties: function ()
   {
      this [_lineFillTextureProperties] = new Texturing_TextureProperties (this .getPrivateScene ());
      this [_lineFillTextureProperties] ._minificationFilter  = "NEAREST_PIXEL";
      this [_lineFillTextureProperties] ._magnificationFilter = "NEAREST_PIXEL";
      this [_lineFillTextureProperties] .setPrivate (true);
      this [_lineFillTextureProperties] .setup ();

      this .getLineFillTextureProperties = function () { return this [_lineFillTextureProperties]; };

      Object .defineProperty (this, "getLineFillTextureProperties", { enumerable: false });

      return this [_lineFillTextureProperties];
   },
   getLineTransformShader: function ()
   {
      const uniformNames = [
         "viewport",
         "modelViewProjectionMatrix",
         "invModelViewProjectionMatrix",
         "scale",
      ];

      const transformFeedbackVaryings = [
         "lineStipple0", "fogDepth0", "color0", "vertex0",
         "lineStipple1", "fogDepth1", "color1", "vertex1",
         "lineStipple2", "fogDepth2", "color2", "vertex2",
      ];

      this [_lineTransformShaderNode] = this .createShader ("LineTransformShader", "LineTransform", "LineTransform", [ ], uniformNames, transformFeedbackVaryings);

      this .getLineTransformShader = function () { return this [_lineTransformShaderNode]; };

      Object .defineProperty (this, "getLineTransformShader", { enumerable: false });

      return this [_lineTransformShaderNode];
   },
   getLineTransformFeedback: function ()
   {
      const gl = this .getContext ();

      this [_lineTransformFeedback] = gl .createTransformFeedback ();

      this .getLineTransformFeedback = function () { return this [_lineTransformFeedback]; };

      Object .defineProperty (this, "getLineTransformFeedback", { enumerable: false });

      return this [_lineTransformFeedback];
   },
};

/* harmony default export */ const Shape_X3DShapeContext = (X3DShapeContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Sound/X3DSoundContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function X3DSoundContext ()
{
   this .addChildObjects ("volume", new x_ite_Fields.SFFloat (1),
                          "mute",   new x_ite_Fields.SFBool ());
}

X3DSoundContext .prototype =
{
   initialize: function () { },
};

/* harmony default export */ const Sound_X3DSoundContext = (X3DSoundContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Text/TextAlignment.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


let TextAlignment_i = 0;

const TextAlignment =
{
   BEGIN:  ++ TextAlignment_i,
   FIRST:  ++ TextAlignment_i,
   MIDDLE: ++ TextAlignment_i,
   END:    ++ TextAlignment_i,
};

/* harmony default export */ const Text_TextAlignment = (TextAlignment);

;// CONCATENATED MODULE: ./src/x_ite/Components/Text/X3DFontStyleNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










/*
 * Font paths for default SERIF, SANS and TYPWRITER families.
 */

const Fonts =
{
   SERIF: {
      PLAIN:      Networking_URLs.getFontsUrl ("DroidSerif-Regular.ttf"),
      ITALIC:     Networking_URLs.getFontsUrl ("DroidSerif-Italic.ttf"),
      BOLD:       Networking_URLs.getFontsUrl ("DroidSerif-Bold.ttf"),
      BOLDITALIC: Networking_URLs.getFontsUrl ("DroidSerif-BoldItalic.ttf"),
   },
   SANS: {
      PLAIN:      Networking_URLs.getFontsUrl ("Ubuntu-R.ttf"),
      ITALIC:     Networking_URLs.getFontsUrl ("Ubuntu-RI.ttf"),
      BOLD:       Networking_URLs.getFontsUrl ("Ubuntu-B.ttf"),
      BOLDITALIC: Networking_URLs.getFontsUrl ("Ubuntu-BI.ttf"),
   },
   TYPEWRITER: {
      PLAIN:      Networking_URLs.getFontsUrl ("UbuntuMono-R.ttf"),
      ITALIC:     Networking_URLs.getFontsUrl ("UbuntuMono-RI.ttf"),
      BOLD:       Networking_URLs.getFontsUrl ("UbuntuMono-B.ttf"),
      BOLDITALIC: Networking_URLs.getFontsUrl ("UbuntuMono-BI.ttf"),
   },
};

function X3DFontStyleNode (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DFontStyleNode);

   this .addChildObjects ("load",                 new x_ite_Fields.SFBool (true),
                          "autoRefresh",          new x_ite_Fields.SFTime (),
                          "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600));

   this .addAlias ("url", this ._family);

   this .familyStack = [ ];
   this .alignments  = [ ];
   this .loader      = new InputOutput_FileLoader (this);
}

X3DFontStyleNode .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: X3DFontStyleNode,
   initialize: function ()
   {
      Core_X3DNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      this ._style   .addInterest ("set_style__",   this);
      this ._justify .addInterest ("set_justify__", this);

      this .font        = null;
      this .familyIndex = 0;

      this .set_justify__ ();
      this .set_style__ ();

      this .requestImmediateLoad ();
   },
   set_style__: function ()
   {
      if (!this ._load .getValue ())
         return;

      this .setLoadState (Base_X3DConstants.NOT_STARTED_STATE);

      this .requestImmediateLoad ();
   },
   set_justify__: function ()
   {
      const majorNormal = this ._horizontal .getValue () ? this ._leftToRight .getValue () : this ._topToBottom .getValue ();

      this .alignments [0] = this ._justify .length > 0
                             ? this .getAlignment (0, majorNormal)
                             : majorNormal ? Text_TextAlignment.BEGIN : Text_TextAlignment.END;

      const minorNormal = this ._horizontal .getValue () ? this ._topToBottom .getValue () : this ._leftToRight .getValue ();

      this .alignments [1] = this ._justify .length > 1
                             ? this .getAlignment (1, minorNormal)
                             : minorNormal ? Text_TextAlignment.FIRST : Text_TextAlignment.END;
   },
   getMajorAlignment: function ()
   {
      return this .alignments [0];
   },
   getMinorAlignment: function ()
   {
      return this .alignments [1];
   },
   getAlignment: function (index, normal)
   {
      if (normal)
      {
         // Return for west-european normal alignment.

         switch (this ._justify [index])
         {
            case "FIRST":  return Text_TextAlignment.FIRST;
            case "BEGIN":  return Text_TextAlignment.BEGIN;
            case "MIDDLE": return Text_TextAlignment.MIDDLE;
            case "END":    return Text_TextAlignment.END;
         }
      }
      else
      {
         // Return appropriate alignment if topToBottom or leftToRight are FALSE.

         switch (this ._justify [index])
         {
            case "FIRST":  return Text_TextAlignment.END;
            case "BEGIN":  return Text_TextAlignment.END;
            case "MIDDLE": return Text_TextAlignment.MIDDLE;
            case "END":    return Text_TextAlignment.BEGIN;
         }
      }

      return index ? Text_TextAlignment.FIRST : Text_TextAlignment.BEGIN;
   },
   getDefaultFont: function (familyName)
   {
      const family = Fonts [familyName];

      if (family)
         return family [this ._style .getValue ()] || family .PLAIN;

      return;
   },
   loadNow: function ()
   {
      // Add default font to family array.

      const family = this ._url .copy ();

      family .push ("SERIF");

      // Build family stack.

      this .familyStack .length = 0;

      for (const familyName of family)
         this .familyStack .push (this .getDefaultFont (familyName) || familyName);

      this .loadNext ();
   },
   loadNext: function ()
   {
      try
      {
         if (this .familyStack .length === 0)
         {
            this .setLoadState (Base_X3DConstants.FAILED_STATE);
            this .font = null;
            return;
         }

         this .family = this .familyStack .shift ();
         this .URL    = new URL (this .family, this .loader .getReferer ());

         if (this .URL .protocol !== "data:")
         {
            if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
               this .URL .searchParams .set ("_", Date .now ());
         }

         this .getBrowser () .getFont (this .URL)
            .done (this .setFont .bind (this))
            .fail (this .setError .bind (this));
      }
      catch (error)
      {
         this .setError (error .message);
      }
   },
   setError: function (error)
   {
      if (this .URL .protocol !== "data:")
         console .warn ("Error loading font '" + decodeURI (this .URL .href) + "':", error);

      this .loadNext ();
   },
   setFont: function (font)
   {
      this .font = font;

      this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
      this .addNodeEvent ();
   },
   getFont: function ()
   {
      return this .font;
   },
});

/* harmony default export */ const Text_X3DFontStyleNode = (X3DFontStyleNode);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Box2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function Box2 (size, center)
{
   switch (arguments .length)
   {
      case 0:
      {
         this .matrix = new Numbers_Matrix3 (0, 0, 0,
                                     0, 0, 0,
                                     0, 0, 0);
         return;
      }
      case 2:
      {
         this .matrix = new Numbers_Matrix3 (size .x / 2, 0, 0,
                                     0, size .y / 2, 0,
                                     center .x, center .y, 1);
         return;
      }
      case 3:
      {
         const
            min = arguments [0],
            max = arguments [1],
            sx  = (max .x - min .x) / 2,
            sy  = (max .y - min .y) / 2,
            cx  = (max .x + min .x) / 2,
            cy  = (max .y + min .y) / 2;

         this .matrix = new Numbers_Matrix3 (sx, 0,  0,
                                     0,  sy, 0,
                                     cx, cy, 1);
         return;
      }
   }
}

Box2 .prototype =
{
   constructor: Box2,
   copy: function ()
   {
      const copy = Object .create (Box2 .prototype);
      copy .matrix = this .matrix .copy ();
      return copy;
   },
   assign: function (box)
   {
      this .matrix .assign (box .matrix);
      return this;
   },
   equals: function (box)
   {
      return this .matrix .equals (box .matrix);
   },
   set: function (size, center)
   {
      const m = this .matrix;

      switch (arguments .length)
      {
         case 0:
         {
            m [0] = 0.5; m [1] = 0;   m [2] = 0;
            m [3] = 0;   m [4] = 0.5; m [5] = 0;
            m [6] = 0;   m [7] = 0;   m [8] = 0;
            return this;
         }
         case 2:
         {
            // size, center
            m [0] = size .x / 2; m [1] = 0;           m [2] = 0;
            m [3] = 0;           m [4] = size .y / 2; m [5] = 0;
            m [6] = center .x;   m [7] = center .y;   m [8] = 1;
            return this;
         }
         case 3:
         {
            const
               min = arguments [0],
               max = arguments [1],
               sx  = (max .x - min .x) / 2,
               sy  = (max .y - min .y) / 2,
               cx  = (max .x + min .x) / 2,
               cy  = (max .y + min .y) / 2;

            this .matrix .set (sx, 0,  0,
                               0,  sy, 0,
                               cx, cy, 1);
            return this;
         }
      }
   },
   setExtents: function (min, max)
   {
      const
         m  = this .matrix,
         sx = (max .x - min .x) / 2,
         sy = (max .y - min .y) / 2,
         cx = (max .x + min .x) / 2,
         cy = (max .y + min .y) / 2;

      m [0] = sx; m [1] = 0;  m [2] = 0;
      m [3] = 0;  m [4] = sy; m [5] = 0;
      m [6] = cx; m [7] = cy; m [8] = 1;
      return this;
   },
   isEmpty: function ()
   {
      return this .matrix [8] === 0;
   },
   add: (function ()
   {
      const
         lhs_min = new Numbers_Vector2 (0, 0),
         lhs_max = new Numbers_Vector2 (0, 0),
         rhs_min = new Numbers_Vector2 (0, 0),
         rhs_max = new Numbers_Vector2 (0, 0);

      return function (box)
      {
         if (this .isEmpty ())
            return this .assign (box);

         if (box .isEmpty ())
            return this;

         this .getExtents (lhs_min, lhs_max);
         box  .getExtents (rhs_min, rhs_max);

         return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
      };
   })(),
   multLeft: function (matrix)
   {
      this .matrix .multLeft (matrix);
      return this;
   },
   multRight: function (matrix)
   {
      this .matrix .multRight (matrix);
      return this;
   },
   getExtents: function (min, max)
   {
      this .getAbsoluteExtents (min, max);

      min .add (this .center);
      max .add (this .center);
   },
   getAbsoluteExtents: (function ()
   {
      const p1 = new Numbers_Vector2 (0, 0);

      return function (min, max)
      {
         const
            m = this .matrix,
            x = m .xAxis,
            y = m .yAxis;

         p1 .assign (x) .add (y);

         const p2 = y .subtract (x);

         min .assign (p1) .min (p2);
         max .assign (p1) .max (p2);

         p1 .negate ();
         p2 .negate ();

         min .min (p1, p2);
         max .max (p1, p2);
      };
   })(),
   containsPoint: (function ()
   {
      const
         min = new Numbers_Vector2 (0, 0),
         max = new Numbers_Vector2 (0, 0);

      return function (point)
      {
         this .getExtents (min, max);

         return min .x <= point .x &&
                max .x >= point .x &&
                min .y <= point .y &&
                max .y >= point .y;
      };
   })(),
   toString: function ()
   {
      return this .size + ", " + this .center;
   },
};

Object .defineProperty (Box2 .prototype, "size",
{
   get: (function ()
   {
      const
         min = new Numbers_Vector2 (0, 0),
         max = new Numbers_Vector2 (0, 0);

      return function ()
      {
         this .getAbsoluteExtents (min, max);

         return max .subtract (min);
      };
   })(),
   enumerable: true,
   configurable: false
});

Object .defineProperty (Box2 .prototype, "center",
{
   get: function ()
   {
      return this .matrix .origin;
   },
   enumerable: true,
   configurable: false
});

/* harmony default export */ const Geometry_Box2 = (Box2);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Text/X3DTextGeometry.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








var
   bbox        = new Geometry_Box2 (),
   lineBBox    = new Geometry_Box2 (),
   min         = new Numbers_Vector2 (0, 0),
   max         = new Numbers_Vector2 (0, 0),
   glyphMin    = new Numbers_Vector2 (0, 0),
   glyphMax    = new Numbers_Vector2 (0, 0),
   min3        = new Numbers_Vector3 (0, 0, 0),
   max3        = new Numbers_Vector3 (0, 0, 0),
   size        = new Numbers_Vector2 (0, 0),
   center      = new Numbers_Vector2 (0, 0),
   size1_2     = new Numbers_Vector2 (0, 0),
   translation = new Numbers_Vector2 (0, 0),
   lineBound   = new Numbers_Vector2 (0, 0),
   origin      = new Numbers_Vector3 (0, 0, 0),
   X3DTextGeometry_vector      = new Numbers_Vector2 (0, 0),
   box2        = new Geometry_Box2 (),
   zero2       = new Numbers_Vector2 (0, 0),
   zero3       = new Numbers_Vector3 (0, 0, 0);

function X3DTextGeometry (text, fontStyle)
{
   this .browser        = text .getBrowser ();
   this .text           = text;
   this .fontStyle      = fontStyle;
   this .glyphs         = [ ];
   this .minorAlignment = new Numbers_Vector2 (0, 0);
   this .translations   = [ ];
   this .charSpacings   = [ ];
   this .bearing        = new Numbers_Vector2 (0, 0);
   this .yPad           = [ ];
   this .bbox           = new Geometry_Box3 ();
}

X3DTextGeometry .prototype =
{
   constructor: X3DTextGeometry,
   getBrowser: function ()
   {
      return this .browser;
   },
   getText: function ()
   {
      return this .text;
   },
   getFontStyle: function ()
   {
      return this .fontStyle;
   },
   getGlyphs: function ()
   {
      return this .glyphs;
   },
   getMinorAlignment: function ()
   {
      return this .minorAlignment;
   },
   getTranslations: function ()
   {
      return this .translations;
   },
   getCharSpacings: function ()
   {
      return this .charSpacings;
   },
   getBearing: function ()
   {
      return this .bearing;
   },
   getBBox: function ()
   {
      return this .bbox;
   },
   update: function ()
   {
      var
         text      = this .text,
         fontStyle = this .fontStyle,
         numLines  = text ._string .length;

      text ._lineBounds .length = numLines;
      this .glyphs      .length = 0;

      if (numLines === 0 || ! fontStyle .getFont ())
      {
         text ._origin     .setValue (zero3);
         text ._textBounds .setValue (zero2);

         this .bbox .set ();
         return;
      }

      if (fontStyle ._horizontal .getValue ())
      {
         this .resizeArray (this .translations, numLines);
         this .resizeArray (this .charSpacings, numLines);

         this .horizontal (text, fontStyle);
      }
      else
      {
         var
            string   = text ._string,
            numChars = 0;

         for (var i = 0, length = string .length; i < length; ++ i)
            numChars += string [i] .length;

         this .resizeArray (this .translations, numChars);
         this .resizeArray (this .charSpacings, numChars);

         this .vertical (text, fontStyle);
      }
   },
   resizeArray: function (array, size)
   {
      // Resize array in grow only fashion.

      for (var i = array .length; i < size; ++ i)
         array .push (new Numbers_Vector2 (0, 0));

      array .length = size;
   },
   horizontal: function (text, fontStyle)
   {
      var
         font        = fontStyle .getFont (),
         string      = text ._string,
         numLines    = string .length,
         maxExtent   = Math .max (0, text ._maxExtent .getValue ()),
         topToBottom = fontStyle ._topToBottom .getValue (),
         scale       = fontStyle .getScale (),
         spacing     = fontStyle ._spacing .getValue ();

      bbox .set ();

      // Calculate bboxes.

      var
         first = topToBottom ? 0 : numLines - 1,
         last  = topToBottom ? numLines : -1,
         step  = topToBottom ? 1 : -1;

      for (var l = first, ll = 0; l !== last; l += step, ++ ll)
      {
         var line = string [l];

         // Get line extents.

         var glyphs = this .getHorizontalLineExtents (fontStyle, line, min, max, ll);

         size .assign (max) .subtract (min);

         // Calculate charSpacing and lineBounds.

         var
            charSpacing = 0,
            length      = text .getLength (l);

         lineBound .set (size .x * scale, ll == 0 ? max .y - font .descender / font .unitsPerEm * scale : spacing);

         if (maxExtent)
         {
            if (length)
               length = Math .min (maxExtent, length);

            else
               length = Math .min (maxExtent, size .x * scale);
         }

         if (length)
         {
            charSpacing  = (length - lineBound .x) / (glyphs .length - 1);
            lineBound .x = length;
            size .x      = length / scale;
         }

         this .charSpacings [ll] = charSpacing;
         text ._lineBounds [l]   = lineBound;

         // Calculate line translation.

         switch (fontStyle .getMajorAlignment ())
         {
            case Text_TextAlignment.BEGIN:
            case Text_TextAlignment.FIRST:
               this .translations [ll] .set (0, -ll * spacing);
               break;
            case Text_TextAlignment.MIDDLE:
               this .translations [ll] .set (-min .x - size .x / 2, -ll * spacing);
               break;
            case Text_TextAlignment.END:
               this .translations [ll] .set (-min .x - size .x, -ll * spacing);
               break;
         }

         this .translations [ll] .multiply (scale);

         // Calculate center.

         center .assign (min) .add (size1_2 .assign (size) .divide (2));

         // Add bbox.

         bbox .add (box2 .set (size .multiply (scale), center .multiply (scale) .add (this .translations [ll])));
      }

      //console .log ("size", bbox .size, "center", bbox .center);

      // Get text extents.

      bbox .getExtents (min, max);

      size .assign (max) .subtract (min);

      // Calculate text position

      text ._textBounds = size;
      this .bearing .set (0, -max .y);

      switch (fontStyle .getMinorAlignment ())
      {
         case Text_TextAlignment.BEGIN:
            this .minorAlignment .assign (this .bearing);
            break;
         case Text_TextAlignment.FIRST:
            this .minorAlignment .set (0, 0);
            break;
         case Text_TextAlignment.MIDDLE:
            this .minorAlignment .set (0, size .y / 2 - max .y);
            break;
         case Text_TextAlignment.END:
            this .minorAlignment .set (0, (numLines - 1) * spacing * scale);
            break;
      }

      // Translate bbox by minorAlignment.

      min .add (this .minorAlignment);
      max .add (this .minorAlignment);

      // The value of the origin field represents the upper left corner of the textBounds.

      text ._origin .setValue (origin .set (min .x, max .y, 0));

      this .bbox .setExtents (min3 .set (min .x, min .y, 0),
                              max3 .set (max .x, max .y, 0));
   },
   vertical: function (text, fontStyle)
   {
      var
         font             = fontStyle .getFont (),
         string           = text ._string,
         numLines         = string .length,
         maxExtent        = Math .max (0, text ._maxExtent .getValue ()),
         leftToRight      = fontStyle ._leftToRight .getValue (),
         topToBottom      = fontStyle ._topToBottom .getValue (),
         scale            = fontStyle .getScale (),
         spacing          = fontStyle ._spacing .getValue (),
         yPad             = this .yPad,
         primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality ();

      bbox .set ();

      // Calculate bboxes.

      var
         firstL = leftToRight ? 0 : numLines - 1,
         lastL  = leftToRight ? numLines : -1,
         stepL  = leftToRight ? 1 : -1,
         t      = 0; // Translation index

      for (var l = firstL; l !== lastL; l += stepL)
      {
         var glyphs = this .stringToGlyphs (font, string [l], true, l);

         var
            t0       = t,
            numChars = glyphs .length;

         // Calculate line bbox

         lineBBox .set ();

         var
            firstG = topToBottom ? 0 : numChars - 1,
            lastG  = topToBottom ? numChars : -1,
            stepG  = topToBottom ? 1 : -1;

         for (var g = firstG; g !== lastG; g += stepG, ++ t)
         {
            var glyph = glyphs [g];

            // Get glyph extents.

            this .getGlyphExtents (font, glyph, primitiveQuality, min, max);

            size .assign (max) .subtract (min);

            // Calculate glyph translation

            var glyphNumber = topToBottom ? g : numChars - g - 1;

            this .translations [t] .set ((spacing - size .x - min .x) / 2, -glyphNumber);

            // Calculate center.

            center .assign (min) .add (size1_2 .assign (size) .divide (2)) .add (this .translations [t]);

            // Add bbox.

            lineBBox .add (box2 .set (size, center));
         }

         // Get line extents.

         lineBBox .getExtents (min, max);

         size .assign (max) .subtract (min);

         // Calculate charSpacing and lineBounds.

         var
            lineNumber  = leftToRight ? l : numLines - l - 1,
            padding     = (spacing - size .x) / 2,
            charSpacing = 0,
            length      = text .getLength (l);

         lineBound .set (l === 0 ? spacing - padding: spacing, numChars ? size .y : 0) .multiply (scale);

         if (maxExtent)
         {
            if (length)
               length = Math .min (maxExtent, length);

            else
               length = Math .min (maxExtent, size .y * scale);
         }

         if (length)
         {
            charSpacing  = (length - lineBound .y) / (glyphs .length - 1) / scale;
            lineBound .y = length;
            size .y      = length / scale;
            min .y       = max .y  - size .y;
         }

         text ._lineBounds [l] = lineBound;

         // Calculate line translation.

         switch (fontStyle .getMajorAlignment ())
         {
            case Text_TextAlignment.BEGIN:
            case Text_TextAlignment.FIRST:
               translation .set (lineNumber * spacing, -1);
               break;
            case Text_TextAlignment.MIDDLE:
               translation .set (lineNumber * spacing, (size .y / 2 - max .y));
               break;
            case Text_TextAlignment.END:
            {
               // This is needed to make maxExtend and charSpacing work.
               if (numChars)
                  this .getGlyphExtents (font, glyphs [topToBottom ? numChars - 1 : 0], primitiveQuality, glyphMin .assign (Numbers_Vector2.Zero), X3DTextGeometry_vector);

               translation .set (lineNumber * spacing, (size .y - max .y + glyphMin .y));
               break;
            }
         }

         // Calculate glyph translation

         var space = 0;

         for (var tt = t0; tt < t; ++ tt)
         {
            this .translations [tt] .add (translation);

            this .translations [tt] .y -= space;

            this .translations [tt] .multiply (scale);

            space += charSpacing;
         }

         // Calculate ypad to extend line bounds.

         switch (fontStyle .getMajorAlignment ())
         {
            case Text_TextAlignment.BEGIN:
            case Text_TextAlignment.FIRST:
               yPad [l] = max .y + translation .y;
               break;
            case Text_TextAlignment.MIDDLE:
               yPad [l] = 0;
               break;
            case Text_TextAlignment.END:
               yPad [l] = min .y + translation .y;
               break;
         }

         // Calculate center.

         center .assign (min) .add (size1_2 .assign (size) .divide (2));

         // Add bbox.

         bbox .add (box2 .set (size .multiply (scale), center .add (translation) .multiply (scale)));
      }

      // Get text extents.

      bbox .getExtents (min, max);

      size .assign (max) .subtract (min);

      // Extend lineBounds.

      switch (fontStyle .getMajorAlignment ())
      {
         case Text_TextAlignment.BEGIN:
         case Text_TextAlignment.FIRST:
         {
            var lineBounds = text ._lineBounds;

            for (var i = 0, length = lineBounds .length; i < length; ++ i)
               lineBounds [i] .y += max .y - yPad [i] * scale;

            break;
         }
         case Text_TextAlignment.MIDDLE:
            break;
         case Text_TextAlignment.END:
         {
            var lineBounds = text ._lineBounds;

            for (var i = 0, length = lineBounds .length; i < length; ++ i)
               lineBounds [i] .y += yPad [i] * scale - min .y;

            break;
         }
      }

      // Calculate text position

      text ._textBounds = size;

      switch (fontStyle .getMajorAlignment ())
      {
         case Text_TextAlignment.BEGIN:
         case Text_TextAlignment.FIRST:
            this .bearing .set (-min .x, max .y);
            break;
         case Text_TextAlignment.MIDDLE:
            this .bearing .set (-min .x, 0);
            break;
         case Text_TextAlignment.END:
            this .bearing .set (-min .x, min .y);
            break;
      }

      switch (fontStyle .getMinorAlignment ())
      {
         case Text_TextAlignment.BEGIN:
         case Text_TextAlignment.FIRST:
            this .minorAlignment .set (-min .x, 0);
            break;
         case Text_TextAlignment.MIDDLE:
            this .minorAlignment .set (-min .x - size .x / 2, 0);
            break;
         case Text_TextAlignment.END:
            this .minorAlignment .set (-min .x - size .x, 0);
            break;
      }

      // Translate bbox by minorAlignment.

      min .add (this .minorAlignment);
      max .add (this .minorAlignment);

      // The value of the origin field represents the upper left corner of the textBounds.

      text ._origin .setValue (origin .set (min .x, max .y, 0));

      this .bbox .set (min3 .set (min .x, min .y, 0),
                       max3 .set (max .x, max .y, 0),
                       true);
   },
   stringToGlyphs: function (font, line, normal, lineNumber)
   {
      var glypes = this .glyphs [lineNumber];

      if (! glypes)
         glypes = this .glyphs [lineNumber] = [ ];

      glypes .length = line .length;

      var
         first = normal ? 0 : line .length - 1,
         last  = normal ? line .length : -1,
         step  = normal ? 1 : -1;

      for (var c = first, g = 0; c !== last; c += step, ++ g)
         glypes [g] = font .charToGlyph (line [c]);

      return glypes;
   },
   getHorizontalLineExtents: function (fontStyle, line, min, max, lineNumber)
   {
      var
         font             = fontStyle .getFont (),
         normal           = fontStyle ._horizontal .getValue () ? fontStyle ._leftToRight .getValue () : fontStyle ._topToBottom .getValue (),
         glyphs           = this .stringToGlyphs (font, line, normal, lineNumber),
         primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
         xMin             = 0,
         xMax             = 0,
         yMin             = Number .POSITIVE_INFINITY,
         yMax             = Number .NEGATIVE_INFINITY;

      for (var g = 0, length = glyphs .length; g < length; ++ g)
      {
         var
            glyph   = glyphs [g],
            kerning = g + 1 < length ? font .getKerningValue (glyph, glyphs [g + 1]) : 0;

         this .getGlyphExtents (font, glyph, primitiveQuality, glyphMin, glyphMax);

         xMax += glyph .advanceWidth + kerning;
         yMin  = Math .min (yMin, glyphMin .y);
         yMax  = Math .max (yMax, glyphMax .y);
      }

      if (glyphs .length)
      {
         this .getGlyphExtents (font, glyphs [0], primitiveQuality, glyphMin, glyphMax);

         xMin  = glyphMin .x;
      }
      else
      {
         yMin = 0;
         yMax = 0;
      }

      min .set (xMin, yMin);
      max .set (xMax / font .unitsPerEm, yMax);

      switch (fontStyle .getMajorAlignment ())
      {
         case Text_TextAlignment.BEGIN:
         case Text_TextAlignment.FIRST:
            min .x = 0;
            break;
      }

      return glyphs;
   },
   traverse: function (type, renderObject)
   { },
};

/* harmony default export */ const Text_X3DTextGeometry = (X3DTextGeometry);

;// CONCATENATED MODULE: ./src/standard/Math/Algorithms/Bezier.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const lerp = Math_Algorithm.lerp;

function Bezier (x0, y0, x1, y1, x2, y2, x3, y3)
{
   this .x0 = x0;
   this .y0 = y0;
   this .x1 = x1;
   this .y1 = y1;
   this .x2 = x2;
   this .y2 = y2;
   this .x3 = x3;
   this .y3 = y3;

   this .order = arguments .length / 2 - 1;
}

Bezier .prototype =
{
   getLUT: function (dimension)
   {
      const
         x0  = this .x0,
         y0  = this .y0,
         x1  = this .x1,
         y1  = this .y1,
         x2  = this .x2,
         y2  = this .y2,
         x3  = this .x3,
         y3  = this .y3,
         lut = [ ];

      switch (this .order)
      {
         case 2:
         {
            for (let i = 0, d = dimension - 1; i < dimension; ++ i)
            {
               lut .push (quadric (x0, y0, x1, y1, x2, y2, i / d));
            }

            break;
         }
         case 3:
         {
            for (let i = 0, d = dimension - 1; i < dimension; ++ i)
            {
               lut .push (cubic (x0, y0, x1, y1, x2, y2, x3, y3, i / d));
            }

            break;
         }
      }

      return lut;
   }
};

function quadric (x0, y0, x1, y1, x2, y2, t)
{
   const
      ax0 = lerp (x0, x1, t),
      ay0 = lerp (y0, y1, t),
      ax1 = lerp (x1, x2, t),
      ay1 = lerp (y1, y2, t),
      bx0 = lerp (ax0, ax1, t),
      by0 = lerp (ay0, ay1, t);

   return {x: bx0, y: by0};
}

function cubic (x0, y0, x1, y1, x2, y2, x3, y3, t)
{
   const
      ax0 = lerp (x0, x1, t),
      ay0 = lerp (y0, y1, t),
      ax1 = lerp (x1, x2, t),
      ay1 = lerp (y1, y2, t),
      ax2 = lerp (x2, x3, t),
      ay2 = lerp (y2, y3, t),
      bx0 = lerp (ax0, ax1, t),
      by0 = lerp (ay0, ay1, t),
      bx1 = lerp (ax1, ax2, t),
      by1 = lerp (ay1, ay2, t),
      cx0 = lerp (bx0, bx1, t),
      cy0 = lerp (by0, by1, t);

   return {x: cx0, y: cy0};
}

/* harmony default export */ const Algorithms_Bezier = (Bezier);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Text/PolygonText.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function PolygonText (text, fontStyle)
{
   Text_X3DTextGeometry.call (this, text, fontStyle);

   text ._transparent = false;

   this .texCoordArray = Rendering_X3DGeometryNode.createArray ();
}

PolygonText .prototype = Object .assign (Object .create (Text_X3DTextGeometry.prototype),
{
   constructor: PolygonText,
   getTransparent: function ()
   {
      return false;
   },
   getMatrix: function ()
   {
      return Numbers_Matrix4.Identity;
   },
   build: (function ()
   {
      var
         min = new Numbers_Vector3 (0, 0, 0),
         max = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         var
            fontStyle = this .getFontStyle (),
            font      = fontStyle .getFont ();

         if (! font)
            return;

         var
            text             = this .getText (),
            glyphs           = this .getGlyphs (),
            minorAlignment   = this .getMinorAlignment (),
            translations     = this .getTranslations (),
            charSpacings     = this .getCharSpacings (),
            size             = fontStyle .getScale (),
            spacing          = fontStyle ._spacing .getValue (),
            origin           = text ._origin .getValue (),
            sizeUnitsPerEm   = size / font .unitsPerEm,
            primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
            texCoordArray    = this .texCoordArray,
            normalArray      = text .getNormals (),
            vertexArray      = text .getVertices ();

         // Set texCoords.

         text .getMultiTexCoords () .push (texCoordArray);

         this .getBBox () .getExtents (min, max);
         text .getMin () .assign (min);
         text .getMax () .assign (max);

         if (fontStyle ._horizontal .getValue ())
         {
            for (var l = 0, length = glyphs .length; l < length; ++ l)
            {
               var
                  line         = glyphs [l],
                  charSpacing  = charSpacings [l],
                  translation  = translations [l],
                  advanceWidth = 0;

               for (var g = 0, gl = line .length; g < gl; ++ g)
               {
                  var
                     glyph         = line [g],
                     glyphVertices = this .getGlyphGeometry (font, glyph, primitiveQuality),
                     xOffset       = minorAlignment .x + translation .x + advanceWidth + g * charSpacing,
                     yOffset       = minorAlignment .y + translation .y;

                  for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
                  {
                     var
                        x = glyphVertices [v] .x * size + xOffset,
                        y = glyphVertices [v] .y * size + yOffset;

                     texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
                     normalArray   .push (0, 0, 1);
                     vertexArray   .push (x, y, 0, 1);
                  }

                  // Calculate advanceWidth.

                  var kerning = 0;

                  if (g + 1 < line .length)
                     kerning = font .getKerningValue (glyph, line [g + 1]);

                  advanceWidth += (glyph .advanceWidth + kerning) * sizeUnitsPerEm;
               }
            }
         }
         else
         {
            var
               leftToRight = fontStyle ._leftToRight .getValue (),
               topToBottom = fontStyle ._topToBottom .getValue (),
               first       = leftToRight ? 0 : text ._string .length - 1,
               last        = leftToRight ? text ._string .length  : -1,
               step        = leftToRight ? 1 : -1;

            for (var l = first, t = 0; l !== last; l += step)
            {
               var line = glyphs [l];

               var
                  numChars = line .length,
                  firstG   = topToBottom ? 0 : numChars - 1,
                  lastG    = topToBottom ? numChars : -1,
                  stepG    = topToBottom ? 1 : -1;

               for (var g = firstG; g !== lastG; g += stepG, ++ t)
               {
                  var
                     translation   = translations [t],
                     glyphVertices = this .getGlyphGeometry (font, line [g], primitiveQuality);

                  for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
                  {
                     var
                        x = glyphVertices [v] .x * size + minorAlignment .x + translation .x,
                        y = glyphVertices [v] .y * size + minorAlignment .y + translation .y;

                     texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
                     normalArray   .push (0, 0, 1);
                     vertexArray   .push (x, y, 0, 1);
                  }
               }
            }
         }
      };
   })(),
   getGlyphExtents: function (font, glyph, primitiveQuality, min, max)
   {
      var
         glyphCache = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
         extents    = glyphCache .extents;

      if (extents)
      {
         min .assign (extents .min);
         max .assign (extents .max);
         return;
      }

      var vertices = this .getGlyphGeometry (font, glyph, primitiveQuality);

      if (vertices .length)
      {
         var vertex = vertices [0];

         min .assign (vertex);
         max .assign (vertex);

         for (var i = 1, length = vertices .length; i < length; ++ i)
         {
            var vertex = vertices [i];

            min .min (vertex);
            max .max (vertex);
         }
      }
      else
      {
         min .set (0, 0, 0);
         max .set (0, 0, 0);
      }

      var extents = glyphCache .extents = { };

      extents .min = min .copy ();
      extents .max = max .copy ();
   },
   getGlyphGeometry: function (font, glyph, primitiveQuality)
   {
      var
         glyphCache    = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
         glyphGeometry = glyphCache .geometry;

      if (glyphGeometry)
         return glyphGeometry;

      glyphGeometry = glyphCache .geometry = [ ];

      this .createGlyphGeometry (glyph, glyphGeometry, primitiveQuality);

      return glyphGeometry;
   },
   createGlyphGeometry: (function ()
   {
      var
         points = [ ],
         curves = [ ],
         normal = new Numbers_Vector3 (0, 0, 0);

      return function (glyph, vertices, primitiveQuality)
      {
         // Get curves for the current glyph.

         var
            dimension  = this .getBezierDimension (primitiveQuality),
            path       = glyph .getPath (0, 0, 1),
            commands   = path .commands,
            x          = 0,
            y          = 0;

         points .length = 0;
         curves .length = 0;

         for (var i = 0, cl = commands .length; i < cl; ++ i)
         {
            var command = commands [i];

            switch (command .type)
            {
               case "M": // Start
               case "Z": // End
               {
                  if (points .length > 2)
                  {
                     if (points [0] .x === points .at (-1) .x && points [0] .y === points .at (-1) .y)
                        points .pop ();

                     curves .push (points);
                  }

                  points = [ ];

                  if (command .type === "M")
                     points .push (new Numbers_Vector3 (command .x, -command .y, 0));

                  break;
               }
               case "L": // Linear
               {
                  points .push (new Numbers_Vector3 (command .x, -command .y, 0));
                  break;
               }
               case "Q": // Quadric
               {
                  var
                     curve = new Algorithms_Bezier (x, -y, command .x1, -command .y1, command .x, -command .y),
                     lut   = curve .getLUT (dimension);

                  for (var l = 1, ll = lut .length; l < ll; ++ l)
                     points .push (new Numbers_Vector3 (lut [l] .x, lut [l] .y, 0));

                  break;
               }
               case "C": // Cubic
               {
                  var
                     curve = new Algorithms_Bezier (x, -y, command .x1, -command .y1, command .x2, -command .y2, command .x, -command .y),
                     lut   = curve .getLUT (dimension);

                  for (var l = 1, ll = lut .length; l < ll; ++ l)
                     points .push (new Numbers_Vector3 (lut [l] .x, lut [l] .y, 0));

                  break;
               }
               default:
                  continue;
            }

            x = command .x;
            y = command .y;
         }

         // Triangulate contours.

         curves = curves .map (function (curve)
         {
            Triangle3.getPolygonNormal (curve, normal);

            if (normal .dot (Numbers_Vector3.zAxis) > 0)
               return curve;

            return curve .reverse ();
         });

         curves .push (vertices);

         Triangle3.triangulatePolygon.apply (Triangle3, curves);
      };
   })(),
   getBezierDimension: function (primitiveQuality)
   {
      switch (primitiveQuality)
      {
         case Core_PrimitiveQuality.LOW:
            return 3;
         case Core_PrimitiveQuality.HIGH:
            return 7;
         default:
            return 5;
      }
   },
   display: function (gl, renderContext)
   { },
   transformLine: function (line)
   { },
   transformMatrix: function (matrix)
   { },
});

/* harmony default export */ const Text_PolygonText = (PolygonText);

;// CONCATENATED MODULE: ./src/x_ite/Components/Text/FontStyle.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function FontStyle (executionContext)
{
   Text_X3DFontStyleNode.call (this, executionContext);

   this .addType (Base_X3DConstants.FontStyle);

   this ._size .setUnit ("length");
}

FontStyle .prototype = Object .assign (Object .create (Text_X3DFontStyleNode.prototype),
{
   constructor: FontStyle,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "language",    new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "family",      new x_ite_Fields.MFString ("SERIF")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "style",       new x_ite_Fields.SFString ("PLAIN")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "size",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "spacing",     new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "horizontal",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "leftToRight", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "topToBottom", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "justify",     new x_ite_Fields.MFString ("BEGIN")),
   ]),
   getTypeName: function ()
   {
      return "FontStyle";
   },
   getComponentName: function ()
   {
      return "Text";
   },
   getContainerField: function ()
   {
      return "fontStyle";
   },
   getTextGeometry: function (text)
   {
      return new Text_PolygonText (text, this);
   },
   getScale: function ()
   {
      return this ._size .getValue ();
   },
});

/* harmony default export */ const Text_FontStyle = (FontStyle);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Text/X3DTextContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _defaultFontStyle = Symbol (),
   _fontCache        = Symbol (),
   _glyphCache       = Symbol ();

function X3DTextContext ()
{
   this [_fontCache]  = new Map ();
   this [_glyphCache] = new Map (); // [font] [primitiveQuality] [glyphIndex]
}

X3DTextContext .prototype =
{
   initialize: function ()
   { },
   getDefaultFontStyle: function ()
   {
      this [_defaultFontStyle] = new Text_FontStyle (this .getPrivateScene ());
      this [_defaultFontStyle] .setPrivate (true);
      this [_defaultFontStyle] .setup ();

      this .getDefaultFontStyle = function () { return this [_defaultFontStyle]; };

      Object .defineProperty (this, "getDefaultFontStyle", { enumerable: false });

      return this [_defaultFontStyle];
   },
   getFont: function (url)
   {
      url = url .toString ();

      let deferred = this [_fontCache] .get (url);

      if (deferred === undefined)
      {
         this [_fontCache] .set (url, deferred = $.Deferred ());

         opentype .load (url, this .setFont .bind (this, deferred));
      }

      return deferred;
   },
   setFont: function (deferred, error, font)
   {
      if (error)
         deferred .reject (error);
      else
         deferred .resolve (font);
   },
   getGlyph: function (font, primitiveQuality, glyphIndex)
   {
      let cachedFont = this [_glyphCache] .get (font);

      if (!cachedFont)
         this [_glyphCache] .set (font, cachedFont = [ ]);

      let cachedQuality = cachedFont [primitiveQuality];

      if (!cachedQuality)
         cachedQuality = cachedFont [primitiveQuality] = [ ];

      let cachedGlyph = cachedQuality [glyphIndex];

      if (!cachedGlyph)
         cachedGlyph = cachedQuality [glyphIndex] = { };

      return cachedGlyph;
   },
};

/* harmony default export */ const Text_X3DTextContext = (X3DTextContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DTextureTransformNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DTextureTransformNode (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTextureTransformNode);
}

X3DTextureTransformNode .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: X3DTextureTransformNode,
});

/* harmony default export */ const Texturing_X3DTextureTransformNode = (X3DTextureTransformNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/X3DSingleTextureTransformNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DSingleTextureTransformNode (executionContext)
{
   Texturing_X3DTextureTransformNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSingleTextureTransformNode);

   this .matrixArray = new Float32Array (Numbers_Matrix4.Identity);
}

X3DSingleTextureTransformNode .prototype = Object .assign (Object .create (Texturing_X3DTextureTransformNode.prototype),
{
   constructor: X3DSingleTextureTransformNode,
   getCount: function ()
   {
      return 1;
   },
   setMatrix: function (value)
   {
      this .matrixArray .set (value);
   },
   getTextureTransformMapping: function (textureTransformMapping, channel = 0)
   {
      if (this ._mapping .getValue ())
         textureTransformMapping .set (this ._mapping .getValue (), channel);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      for (let i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
         this .setShaderUniformsToChannel (gl, shaderObject, i);
   },
   setShaderUniformsToChannel: function (gl, shaderObject, channel = 0)
   {
      gl .uniformMatrix4fv (shaderObject .x3d_TextureMatrix [channel], false, this .matrixArray);
   },
});

/* harmony default export */ const Texturing_X3DSingleTextureTransformNode = (X3DSingleTextureTransformNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/TextureTransform.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function TextureTransform (executionContext)
{
   Texturing_X3DSingleTextureTransformNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TextureTransform);

   this ._rotation .setUnit ("angle");

   this .matrix = new Numbers_Matrix4 ();
}

TextureTransform .prototype = Object .assign (Object .create (Texturing_X3DSingleTextureTransformNode.prototype),
{
   constructor: TextureTransform,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "mapping",     new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "translation", new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "rotation",    new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "scale",       new x_ite_Fields.SFVec2f (1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "center",      new x_ite_Fields.SFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "TextureTransform";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "textureTransform";
   },
   initialize: function ()
   {
      Texturing_X3DSingleTextureTransformNode.prototype.initialize.call (this);

      this .addInterest ("eventsProcessed", this);

      this .eventsProcessed ();
   },
   getMatrix: function ()
   {
      return this .matrix;
   },
   eventsProcessed: (function ()
   {
      const
         vector  = new Numbers_Vector2 (0, 0),
         matrix3 = new Numbers_Matrix3 ();

      return function ()
      {
         const
            translation = this ._translation .getValue (),
            rotation    = this ._rotation .getValue (),
            scale       = this ._scale .getValue (),
            center      = this ._center .getValue (),
            matrix4     = this .matrix;

         matrix3 .identity ();

         if (! center .equals (Numbers_Vector2.Zero))
            matrix3 .translate (vector .assign (center) .negate ());

         if (! scale .equals (Numbers_Vector2.One))
            matrix3 .scale (scale);

         if (rotation !== 0)
            matrix3 .rotate (rotation);

         if (! center .equals (Numbers_Vector2.Zero))
            matrix3 .translate (center);

         if (! translation .equals (Numbers_Vector2.Zero))
            matrix3 .translate (translation);

         matrix4 [ 0] = matrix3 [0];
         matrix4 [ 1] = matrix3 [1];
         matrix4 [ 4] = matrix3 [3];
         matrix4 [ 5] = matrix3 [4];
         matrix4 [12] = matrix3 [6];
         matrix4 [13] = matrix3 [7];

         this .setMatrix (matrix4);
      };
   })(),
});

/* harmony default export */ const Texturing_TextureTransform = (TextureTransform);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Texturing/X3DTexturingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const
   _maxTextures              = Symbol (),
   _maxTextureSize           = Symbol (),
   _maxCombinedTextureUnits  = Symbol (),
   _textureMemory            = Symbol (),
   _combinedTextureUnits     = Symbol (),
   _texture2DUnits           = Symbol (),
   _texture3DUnits           = Symbol (),
   _textureCubeUnits         = Symbol (),
   _texture2DUnitIndex       = Symbol (),
   _texture3DUnitIndex       = Symbol (),
   _textureCubeUnitIndex     = Symbol (),
   _defaultTexture2D         = Symbol (),
   _defaultTexture3D         = Symbol (),
   _defaultTextureCube       = Symbol (),
   _defaultTextureProperties = Symbol (),
   _defaultTextureTransform  = Symbol (),
   _defaultTextureCoordinate = Symbol ();

function X3DTexturingContext ()
{
   const
      gl                   = this .getContext (),
      maxTextureImageUnits = gl .getParameter (gl .MAX_TEXTURE_IMAGE_UNITS);

   // console .log (gl .getParameter (gl .MAX_TEXTURE_IMAGE_UNITS))
   // console .log (gl .getParameter (gl .MAX_ARRAY_TEXTURE_LAYERS))

   this [_maxTextures] = maxTextureImageUnits > 8 ? 2 : 1;
}

X3DTexturingContext .prototype =
{
   initialize: function ()
   {
      const gl = this .getContext ();

      gl .pixelStorei (gl .UNPACK_ALIGNMENT, 1);

      this [_maxTextureSize]          = gl .getParameter (gl .MAX_TEXTURE_SIZE);
      this [_maxCombinedTextureUnits] = gl .getParameter (gl .MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      this [_textureMemory]           = NaN;

      // Get texture Units

      this [_combinedTextureUnits] = [...Array (this [_maxCombinedTextureUnits]) .keys ()];
      this [_texture2DUnits]       = [this [_combinedTextureUnits] .pop ()];
      this [_texture3DUnits]       = [this [_combinedTextureUnits] .pop ()];
      this [_textureCubeUnits]     = [this [_combinedTextureUnits] .pop ()];

      // Default Texture 2D Unit

      const defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

      this [_defaultTexture2D] = gl .createTexture ();

      gl .activeTexture (gl .TEXTURE0 + this [_texture2DUnits] [0]);
      gl .bindTexture (gl .TEXTURE_2D, this [_defaultTexture2D]);
      gl .texImage2D (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

      // Default Texture 3D Unit

      if (gl .getVersion () >= 2)
      {
         this [_defaultTexture3D] = gl .createTexture ();

         gl .activeTexture (gl .TEXTURE0 + this [_texture3DUnits] [0]);
         gl .bindTexture (gl .TEXTURE_3D, this [_defaultTexture3D]);
         gl .texImage3D (gl .TEXTURE_3D, 0, gl .RGBA, 1, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      }

      // Default Texture Cube Unit

      this [_defaultTextureCube] = gl .createTexture ();

      gl .activeTexture (gl .TEXTURE0 + this [_textureCubeUnits] [0]);
      gl .bindTexture (gl .TEXTURE_CUBE_MAP, this [_defaultTextureCube]);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

      // Init texture units.

      this .resetTextureUnits ();

      // Set texture quality.

      this .setTextureQuality (this .getBrowserOptions () .getTextureQuality ());
   },
   getMaxTextures: function ()
   {
      return this [_maxTextures];
   },
   getMinTextureSize: function ()
   {
      return 16;
   },
   getMaxTextureSize: function ()
   {
      return this [_maxTextureSize];
   },
   getMaxCombinedTextureUnits: function ()
   {
      return this [_maxCombinedTextureUnits];
   },
   popTexture2DUnit: function ()
   {
      if (this [_texture2DUnitIndex] > 0)
      {
         -- this [_texture2DUnitIndex];

         return this [_texture2DUnits] .pop ();
      }
      else
      {
         return this [_combinedTextureUnits] .pop ();
      }
   },
   pushTexture2DUnit: function (textureUnit)
   {
      if (textureUnit === undefined)
         return;

      ++ this [_texture2DUnitIndex];

      this [_texture2DUnits] .push (textureUnit);
   },
   getTexture2DUnit: function ()
   {
      if (this [_texture2DUnitIndex] > 0)
         return this [_texture2DUnits] [-- this [_texture2DUnitIndex]];

      const textureUnit = this [_combinedTextureUnits] .pop ();

      if (textureUnit !== undefined)
         this [_texture2DUnits] .push (textureUnit);

      return textureUnit;
   },
   getTexture3DUnit: function ()
   {
      if (this [_texture3DUnitIndex] > 0)
         return this [_texture3DUnits] [-- this [_texture3DUnitIndex]];

      const textureUnit = this [_combinedTextureUnits] .pop ();

      if (textureUnit !== undefined)
         this [_texture3DUnits] .push (textureUnit);

      return textureUnit;
   },
   getTextureCubeUnit: function ()
   {
      if (this [_textureCubeUnitIndex] > 0)
         return this [_textureCubeUnits] [-- this [_textureCubeUnitIndex]];

      const textureUnit = this [_combinedTextureUnits] .pop ();

      if (textureUnit !== undefined)
         this [_textureCubeUnits] .push (textureUnit);

      return textureUnit;
   },
   getTextureUnit: function (textureType)
   {
      switch (textureType)
      {
         case 2: return this .getTexture2DUnit ();
         case 3: return this .getTexture3DUnit ();
         case 4: return this .getTextureCubeUnit ();
      }
   },
   resetTextureUnits: function ()
   {
      this [_texture2DUnitIndex]   = this [_texture2DUnits]   .length;
      this [_texture3DUnitIndex]   = this [_texture3DUnits]   .length;
      this [_textureCubeUnitIndex] = this [_textureCubeUnits] .length;
   },
   getDefaultTexture2DUnit: function ()
   {
      return this [_texture2DUnits] [0];
   },
   getDefaultTexture3DUnit: function ()
   {
      return this [_texture3DUnits] [0];
   },
   getDefaultTextureCubeUnit: function ()
   {
      return this [_textureCubeUnits] [0];
   },
   getTextureMemory: function ()
   {
      return this [_textureMemory];
   },
   getDefaultTextureProperties: function ()
   {
      this [_defaultTextureProperties] = new Texturing_TextureProperties (this .getPrivateScene ());
      this [_defaultTextureProperties] ._magnificationFilter = "NICEST";
      this [_defaultTextureProperties] ._minificationFilter  = "NEAREST_PIXEL_AVG_MIPMAP";
      this [_defaultTextureProperties] ._textureCompression  = "NICEST";
      this [_defaultTextureProperties] ._generateMipMaps     = true;

      this [_defaultTextureProperties] .setup ();

      this .getDefaultTextureProperties = function () { return this [_defaultTextureProperties]; };

      Object .defineProperty (this, "getDefaultTextureProperties", { enumerable: false });

      return this [_defaultTextureProperties];
   },
   getDefaultTextureTransform: function ()
   {
      this [_defaultTextureTransform] = new Texturing_TextureTransform (this .getPrivateScene ());
      this [_defaultTextureTransform] .setPrivate (true);
      this [_defaultTextureTransform] .setup ();

      this .getDefaultTextureTransform = function () { return this [_defaultTextureTransform]; };

      Object .defineProperty (this, "getDefaultTextureTransform", { enumerable: false });

      return this [_defaultTextureTransform];
   },
   getDefaultTextureCoordinate: function ()
   {
      this [_defaultTextureCoordinate] = new Texturing_TextureCoordinate (this .getPrivateScene ());
      this [_defaultTextureCoordinate] .setPrivate (true);
      this [_defaultTextureCoordinate] .setup ();

      this .getDefaultTextureCoordinate = function () { return this [_defaultTextureCoordinate]; };

      Object .defineProperty (this, "getDefaultTextureCoordinate", { enumerable: false });

      return this [_defaultTextureCoordinate];
   },
   setTextureQuality: function (textureQuality)
   {
      const textureProperties = this .getDefaultTextureProperties ();

      switch (textureQuality)
      {
         case Core_TextureQuality.LOW:
         {
            textureProperties ._magnificationFilter = "AVG_PIXEL";
            textureProperties ._minificationFilter  = "AVG_PIXEL";
            textureProperties ._textureCompression  = "FASTEST";
            textureProperties ._generateMipMaps     = true;

            //glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
            //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
            break;
         }
         case Core_TextureQuality.MEDIUM:
         {
            textureProperties ._magnificationFilter = "NICEST";
            textureProperties ._minificationFilter  = "NEAREST_PIXEL_AVG_MIPMAP";
            textureProperties ._textureCompression  = "NICEST";
            textureProperties ._generateMipMaps     = true;

            //glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
            //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
            break;
         }
         case Core_TextureQuality.HIGH:
         {
            textureProperties ._magnificationFilter = "NICEST";
            textureProperties ._minificationFilter  = "NICEST";
            textureProperties ._textureCompression  = "NICEST";
            textureProperties ._generateMipMaps     = true;

            //glHint (GL_GENERATE_MIPMAP_HINT,        GL_NICEST);
            //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
            break;
         }
      }
   },
};

/* harmony default export */ const Texturing_X3DTexturingContext = (X3DTexturingContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Time/X3DTimeContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _currentTime      = Symbol (),
   _currentFrameRate = Symbol (),
   _currentPosition  = Symbol (),
   _currentSpeed     = Symbol ();

function X3DTimeContext ()
{
   this [_currentTime]      = 0;
   this [_currentFrameRate] = 60;
   this [_currentPosition]  = new Numbers_Vector3 (0, 0, 0);
   this [_currentSpeed]     = 0;
}

X3DTimeContext .prototype =
{
   initialize: function ()
   {
      this .advanceTime (performance .now ());
   },
   getCurrentTime: function ()
   {
      return this [_currentTime];
   },
   getCurrentFrameRate: function ()
   {
      return this [_currentFrameRate];
   },
   getCurrentSpeed: function ()
   {
      return this [_currentSpeed];
   },
   advanceTime: (function ()
   {
      const lastPosition = new Numbers_Vector3 (0, 0, 0);

      return function (now)
      {
         const
            time     = (performance .timeOrigin + now) / 1000,
            interval = time - this [_currentTime];

         this [_currentTime]      = time;
         this [_currentFrameRate] = interval ? 1 / interval : 60;

         if (this .getWorld () && this .getActiveLayer ())
         {
            const cameraSpaceMatrix = this .getActiveLayer () .getViewpoint () .getCameraSpaceMatrix ();

            lastPosition .assign (this [_currentPosition]);
            this [_currentPosition] .set (cameraSpaceMatrix [12], cameraSpaceMatrix [13], cameraSpaceMatrix [14]);

            this [_currentSpeed] = lastPosition .subtract (this [_currentPosition]) .magnitude () * this [_currentFrameRate];
         }
         else
         {
            this [_currentSpeed] = 0;
         }
      };
   })(),
};

/* harmony default export */ const Time_X3DTimeContext = (X3DTimeContext);

;// CONCATENATED MODULE: ./src/x_ite/Routing/X3DRoutingContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const
   _taintedFields     = Symbol (),
   _taintedFieldsTemp = Symbol (),
   _taintedNodes      = Symbol (),
   _taintedNodesTemp  = Symbol ();

function X3DRoutingContext ()
{
   this [_taintedFields]     = [ ];
   this [_taintedFieldsTemp] = [ ];
   this [_taintedNodes]      = [ ];
   this [_taintedNodesTemp]  = [ ];
}

X3DRoutingContext .prototype =
{
   constructor: X3DRoutingContext,
   initialize: function () { },
   addTaintedField: function (field, event)
   {
      this [_taintedFields] .push (field, event);
   },
   addTaintedNode: function (node)
   {
      this [_taintedNodes] .push (node);
   },
   [Symbol .for ("X_ITE.X3DRoutingContext.processEvents")]: function ()
   {
      do
      {
         // Process field events
         do
         {
            const taintedFields = this [_taintedFields];

            // Swap tainted fields.
            this [_taintedFields]         = this [_taintedFieldsTemp];
            this [_taintedFields] .length = 0;

            for (let i = 0, length = taintedFields .length; i < length; i += 2)
               taintedFields [i] .processEvent (taintedFields [i + 1]);

            // Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
            this [_taintedFieldsTemp] = taintedFields;
         }
         while (this [_taintedFields] .length);

         // Process node events
         do
         {
            const taintedNodes = this [_taintedNodes];

            // Swap tainted nodes.
            this [_taintedNodes]         = this [_taintedNodesTemp];
            this [_taintedNodes] .length = 0;

            for (const taintedNode of taintedNodes)
               taintedNode .processEvents ();

            // Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
            this [_taintedNodesTemp] = taintedNodes;
         }
         while (! this [_taintedFields] .length && this [_taintedNodes] .length);
      }
      while (this [_taintedFields] .length);
   },
};

/* harmony default export */ const Routing_X3DRoutingContext = (X3DRoutingContext);

;// CONCATENATED MODULE: ./src/x_ite/Browser/X3DBrowserContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


























const
   _world           = Symbol (),
   _changedTime     = Symbol (),
   _limitFrameRate  = Symbol (),
   _traverse        = Symbol (),
   _renderCallback  = Symbol (),
   _previousTime    = Symbol (),
   _systemTime      = Symbol (),
   _systemStartTime = Symbol (),
   _browserTime     = Symbol (),
   _cameraTime      = Symbol (),
   _collisionTime   = Symbol (),
   _displayTime     = Symbol (),
   _processEvents   = Symbol .for ("X_ITE.X3DRoutingContext.processEvents");

const browserContexts = [ ];

function X3DBrowserContext (element)
{
   Base_X3DBaseNode.call (this, this);
   Routing_X3DRoutingContext.call (this);
   Core_X3DCoreContext.call (this, element);
   Scripting_X3DScriptingContext.call (this);
   Networking_X3DNetworkingContext.call (this);
   Texturing_X3DTexturingContext.call (this);
   Shaders_X3DShadersContext.call (this);
   Rendering_X3DRenderingContext.call (this);
   Shape_X3DShapeContext.call (this);
   Grouping_X3DGroupingContext.call (this);
   Geometry3D_X3DGeometry3DContext.call (this);
   PointingDeviceSensor_X3DPointingDeviceSensorContext.call (this);
   Navigation_X3DNavigationContext.call (this);
   Layering_X3DLayeringContext.call (this);
   EnvironmentalEffects_X3DEnvironmentalEffectsContext.call (this);
   Lighting_X3DLightingContext.call (this);
   Picking_X3DPickingContext.call (this);
   Sound_X3DSoundContext.call (this);
   Text_X3DTextContext.call (this);
   Time_X3DTimeContext.call (this);

   for (const browserContext of browserContexts)
      browserContext .call (this);

   this .addChildObjects ("initialized",   new Fields_SFTime (),
                          "shutdown",      new Fields_SFTime (),
                          "prepareEvents", new Fields_SFTime (),
                          "timeEvents",    new Fields_SFTime (),
                          "sensorEvents",  new Fields_SFTime (),
                          "finished",      new Fields_SFTime ());

   this [_changedTime]     = 0;
   this [_previousTime]    = 0;
   this [_renderCallback]  = this [_traverse] .bind (this);
   this [_systemTime]      = 0;
   this [_systemStartTime] = 0;
   this [_browserTime]     = 0;
   this [_cameraTime]      = 0;
   this [_collisionTime]   = 0;
   this [_displayTime]     = 0;
};

X3DBrowserContext .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
   Core_X3DCoreContext.prototype,
   EnvironmentalEffects_X3DEnvironmentalEffectsContext.prototype,
   Geometry3D_X3DGeometry3DContext.prototype,
   Grouping_X3DGroupingContext.prototype,
   Layering_X3DLayeringContext.prototype,
   Lighting_X3DLightingContext.prototype,
   Navigation_X3DNavigationContext.prototype,
   Networking_X3DNetworkingContext.prototype,
   Picking_X3DPickingContext.prototype,
   PointingDeviceSensor_X3DPointingDeviceSensorContext.prototype,
   Rendering_X3DRenderingContext.prototype,
   Routing_X3DRoutingContext.prototype,
   Scripting_X3DScriptingContext.prototype,
   Shaders_X3DShadersContext.prototype,
   Shape_X3DShapeContext.prototype,
   Sound_X3DSoundContext.prototype,
   Text_X3DTextContext.prototype,
   Texturing_X3DTexturingContext.prototype,
   Time_X3DTimeContext.prototype,
{
   constructor: X3DBrowserContext,
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);
      Routing_X3DRoutingContext.prototype.initialize.call (this);
      Core_X3DCoreContext.prototype.initialize.call (this);
      Scripting_X3DScriptingContext.prototype.initialize.call (this);
      Networking_X3DNetworkingContext.prototype.initialize.call (this);
      Texturing_X3DTexturingContext.prototype.initialize.call (this);
      Shaders_X3DShadersContext.prototype.initialize.call (this);
      Rendering_X3DRenderingContext.prototype.initialize.call (this);
      Shape_X3DShapeContext.prototype.initialize.call (this);
      Grouping_X3DGroupingContext.prototype.initialize.call (this);
      Geometry3D_X3DGeometry3DContext.prototype.initialize.call (this);
      PointingDeviceSensor_X3DPointingDeviceSensorContext.prototype.initialize.call (this);
      Navigation_X3DNavigationContext.prototype.initialize.call (this);
      Layering_X3DLayeringContext.prototype.initialize.call (this);
      EnvironmentalEffects_X3DEnvironmentalEffectsContext.prototype.initialize.call (this);
      Lighting_X3DLightingContext.prototype.initialize.call (this);
      Picking_X3DPickingContext.prototype.initialize.call (this);
      Sound_X3DSoundContext.prototype.initialize.call (this);
      Text_X3DTextContext.prototype.initialize.call (this);
      Time_X3DTimeContext.prototype.initialize.call (this);

      for (const browserContext of browserContexts)
      {
         if (typeof browserContext .prototype .initialize === "function")
            browserContext .prototype .initialize .call (this);
      }

      // Process events from context creation. This will setup nodes like
      // geometry option nodes before any node is created.
      this [_processEvents] ();
   },
   initialized: function ()
   {
      return this ._initialized;
   },
   shutdown: function ()
   {
      return this ._shutdown;
   },
   prepareEvents: function ()
   {
      return this ._prepareEvents;
   },
   timeEvents: function ()
   {
      return this ._timeEvents;
   },
   sensorEvents: function ()
   {
      return this ._sensorEvents;
   },
   finished: function ()
   {
      return this ._finished;
   },
   getBrowser: function ()
   {
      return this;
   },
   getWorld: function ()
   {
      return this [_world];
   },
   setExecutionContext: function (executionContext)
   {
      this [_world] = new Execution_X3DWorld (executionContext);
      this [_world] .setup ();
   },
   getExecutionContext: function ()
   {
      return this [_world] .getExecutionContext ();
   },
   addBrowserEvent: function ()
   {
      if (this [_changedTime] === this .getCurrentTime ())
         return;

      this [_changedTime] = this .getCurrentTime ();

      requestAnimationFrame (this [_renderCallback]);
   },
   [_limitFrameRate]: function (now)
   {
      if (now === this [_previousTime])
      {
         requestAnimationFrame (this [_renderCallback]);

         return true;
      }
      else
      {
         this [_previousTime] = now;

         return false;
      }
   },
   [_traverse]: function (now)
   {
      // Limit frame rate.

      if (this [_limitFrameRate] (now))
         return;

      // Start rendering.

      const gl = this .getContext ();

      const t0 = performance .now ();
      this [_systemTime] = t0 - this [_systemStartTime];
      this .advanceTime (now);

      this ._prepareEvents .processInterests ();
      this [_processEvents] ();

      this ._timeEvents .processInterests ();
      this [_processEvents] ();

      const t1 = performance .now ();
      this [_world] .traverse (Rendering_TraverseType.CAMERA, null);
      this [_cameraTime] = performance .now () - t1;

      const t2 = performance .now ();
      if (this .getCollisionCount ())
         this [_world] .traverse (Rendering_TraverseType.COLLISION, null);
      this [_collisionTime] = performance .now () - t2;

      this ._sensorEvents .processInterests ();
      this [_processEvents] ();

      const t3 = performance .now ();
      gl .clearColor (0, 0, 0, 0);
      gl .clear (gl .COLOR_BUFFER_BIT);
      this [_world] .traverse (Rendering_TraverseType.DISPLAY, null);
      this [_displayTime] = performance .now () - t3;

      this [_browserTime]     = performance .now () - t0;
      this [_systemStartTime] = performance .now ();

      this ._finished .processInterests ();
   },
   getSystemTime: function ()
   {
      return this [_systemTime];
   },
   getBrowserTime: function ()
   {
      return this [_browserTime];
   },
   getCameraTime: function ()
   {
      return this [_cameraTime];
   },
   getCollisionTime: function ()
   {
      return this [_collisionTime];
   },
   getDisplayTime: function ()
   {
      return this [_displayTime];
   },
});

for (const key of Reflect .ownKeys (X3DBrowserContext .prototype))
   Object .defineProperty (X3DBrowserContext .prototype, key, { enumerable: false });

Object .assign (X3DBrowserContext,
{
   addBrowserContext: function (browserContext)
   {
      browserContexts .push (browserContext);

      for (const key of Object .keys (browserContext .prototype) .concat (Object .getOwnPropertySymbols (browserContext .prototype)))
      {
         if (X3DBrowserContext .prototype .hasOwnProperty (key))
            continue;

         Object .defineProperty (X3DBrowserContext .prototype, key,
         {
            value: browserContext .prototype [key],
            enumerable: false,
            writable: true,
         });
      }

      $("x3d-canvas, X3DCanvas") .each (function (_, canvas)
      {
         const
            X3D     = window [Symbol .for ("X_ITE.X3D-7.0.0")],
            browser = X3D .getBrowser (canvas);

         browserContext .call (browser);

         if (typeof browserContext .prototype .initialize === "function")
            browserContext .prototype .initialize .call (browser);

         // Process events from context creation. This will setup nodes like
         // geometry option nodes before any node is created.
         browser [_processEvents] ();
      });
   },
});

/* harmony default export */ const Browser_X3DBrowserContext = (X3DBrowserContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DMetadataObject.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function X3DMetadataObject (executionContext)
{
   this .addType (Base_X3DConstants.X3DMetadataObject);
}

X3DMetadataObject .prototype =
{
   constructor: X3DMetadataObject,
   initialize: function () { },
   dispose: function () { },
};

/* harmony default export */ const Core_X3DMetadataObject = (X3DMetadataObject);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataBoolean.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataBoolean (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataBoolean);
}

MetadataBoolean .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataBoolean,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFBool ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataBoolean";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataBoolean = (MetadataBoolean);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataDouble.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataDouble (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataDouble);
}

MetadataDouble .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataDouble,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFDouble ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataDouble";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataDouble = (MetadataDouble);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataFloat.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataFloat (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataFloat);
}

MetadataFloat .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataFloat,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataFloat";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataFloat = (MetadataFloat);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataInteger.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataInteger (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataInteger);
}

MetadataInteger .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataInteger,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFInt32 ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataInteger";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataInteger = (MetadataInteger);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataSet (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataSet);
}

MetadataSet .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataSet";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataSet = (MetadataSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/MetadataString.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MetadataString (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Core_X3DMetadataObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MetadataString);
}

MetadataString .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Core_X3DMetadataObject.prototype,
{
   constructor: MetadataString,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "name",      new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "reference", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "value",     new x_ite_Fields.MFString ()),
   ]),
   getTypeName: function ()
   {
      return "MetadataString";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "metadata";
   },
});

/* harmony default export */ const Core_MetadataString = (MetadataString);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/X3DInfoNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DInfoNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DInfoNode);
}

X3DInfoNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DInfoNode,
});

/* harmony default export */ const Core_X3DInfoNode = (X3DInfoNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core/WorldInfo.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function WorldInfo (executionContext)
{
   Core_X3DInfoNode.call (this, executionContext);

   this .addType (Base_X3DConstants.WorldInfo);
}

WorldInfo .prototype = Object .assign (Object .create (Core_X3DInfoNode.prototype),
{
   constructor: WorldInfo,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "title",    new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "info",     new x_ite_Fields.MFString ()),
   ]),
   getTypeName: function ()
   {
      return "WorldInfo";
   },
   getComponentName: function ()
   {
      return "Core";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DInfoNode.prototype.initialize.call (this);

      this .getExecutionContext () .addWorldInfo (this);
   },
   dispose: function ()
   {
      this .getExecutionContext () .removeWorldInfo (this);

      Core_X3DInfoNode.prototype.dispose.call (this);
   },
});

/* harmony default export */ const Core_WorldInfo = (WorldInfo);

;// CONCATENATED MODULE: ./src/x_ite/Components/Core.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


















const Types =
{
   MetadataBoolean: Core_MetadataBoolean,
   MetadataDouble:  Core_MetadataDouble,
   MetadataFloat:   Core_MetadataFloat,
   MetadataInteger: Core_MetadataInteger,
   MetadataSet:     Core_MetadataSet,
   MetadataString:  Core_MetadataString,
   WorldInfo:       Core_WorldInfo,
};

const AbstractTypes =
{
   X3DBindableNode:      Core_X3DBindableNode,
   X3DChildNode:         Core_X3DChildNode,
   X3DInfoNode:          Core_X3DInfoNode,
   X3DMetadataObject:    Core_X3DMetadataObject,
   X3DNode:              Core_X3DNode,
   X3DPrototypeInstance: Core_X3DPrototypeInstance,
   X3DSensorNode:        Core_X3DSensorNode,
};

for (const typeName in Types)
   Configuration_SupportedNodes.addType (typeName, Types [typeName]);

for (const typeName in AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, AbstractTypes [typeName]);

/* harmony default export */ const Core = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/FogCoordinate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function FogCoordinate (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.FogCoordinate);

   this ._depth .setUnit ("length");
}

FogCoordinate .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: FogCoordinate,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "depth",    new x_ite_Fields.MFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "FogCoordinate";
   },
   getComponentName: function ()
   {
      return "EnvironmentalEffects";
   },
   getContainerField: function ()
   {
      return "fogCoord";
   },
   initialize: function ()
   {
      Rendering_X3DGeometricPropertyNode.prototype.initialize.call (this);

      this ._depth .addInterest ("set_depth__", this);

      this .set_depth__ ();
   },
   set_depth__: function ()
   {
      this .depth  = this ._depth .getValue ();
      this .length = this ._depth .length;
   },
   isEmpty: function ()
   {
      return this .length === 0;
   },
   getSize: function ()
   {
      return this .length;
   },
   addDepth: function (index, array)
   {
      if (index < this .length)
         array .push (this .depth [index]);

      else if (this .length)
         array .push (this .depth [this .length - 1]);

      else
         array .push (0);
   },
   addDepths: function (array, min)
   {
      const length = this .length;

      if (length)
      {
         const depth = this .depth;

         for (let index = 0; index < length; ++ index)
            array .push (depth [index]);

         const last = depth [length - 1];

         for (let index = length; index < min; ++ index)
            array .push (last);
      }
      else
      {
         for (let index = 0; index < min; ++ index)
            array .push (0);
      }
   },
});

/* harmony default export */ const EnvironmentalEffects_FogCoordinate = (FogCoordinate);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/LocalFog.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function LocalFog (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   EnvironmentalEffects_X3DFogObject.call (this, executionContext);

   this .addType (Base_X3DConstants.LocalFog);
}

LocalFog .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   EnvironmentalEffects_X3DFogObject.prototype,
{
   constructor: LocalFog,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fogType",         new x_ite_Fields.SFString ("LINEAR")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",           new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "visibilityRange", new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "LocalFog";
   },
   getComponentName: function ()
   {
      return "EnvironmentalEffects";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      EnvironmentalEffects_X3DFogObject.prototype.initialize.call (this);
   },
   push: function (renderObject)
   {
      if (this ._enabled .getValue () && this .getFogType ())
      {
         const fogContainer = this .getFogs () .pop ();

         fogContainer .set (this, renderObject .getModelViewMatrix () .get ());

         renderObject .getLocalFogs () .push (fogContainer);
      }
   },
   pop: function (renderObject)
   {
      if (this ._enabled .getValue () && this .getFogType ())
         this .getBrowser () .getLocalObjects () .push (renderObject .getLocalFogs () .pop ());
   },
});

/* harmony default export */ const EnvironmentalEffects_LocalFog = (LocalFog);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects/TextureBackground.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function TextureBackground (executionContext)
{
   EnvironmentalEffects_X3DBackgroundNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TextureBackground);
}

TextureBackground .prototype = Object .assign (Object .create (EnvironmentalEffects_X3DBackgroundNode.prototype),
{
   constructor: TextureBackground,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_bind",      new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "skyAngle",      new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "skyColor",      new x_ite_Fields.MFColor (new x_ite_Fields.SFColor ())),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "groundAngle",   new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "groundColor",   new x_ite_Fields.MFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isBound",       new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "bindTime",      new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "frontTexture",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backTexture",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "leftTexture",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "rightTexture",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "topTexture",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "bottomTexture", new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "TextureBackground";
   },
   getComponentName: function ()
   {
      return "EnvironmentalEffects";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.initialize.call (this);

      this ._frontTexture  .addInterest ("set_frontTexture__", this);
      this ._backTexture   .addInterest ("set_backTexture__", this);
      this ._leftTexture   .addInterest ("set_leftTexture__", this);
      this ._rightTexture  .addInterest ("set_rightTexture__", this);
      this ._topTexture    .addInterest ("set_topTexture__", this);
      this ._bottomTexture .addInterest ("set_bottomTexture__", this);

      this .set_frontTexture__  (this ._frontTexture);
      this .set_backTexture__   (this ._backTexture);
      this .set_leftTexture__   (this ._leftTexture);
      this .set_rightTexture__  (this ._rightTexture);
      this .set_topTexture__    (this ._topTexture);
      this .set_bottomTexture__ (this ._bottomTexture);
   },
   set_frontTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_frontTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._frontTexture));
   },
   set_backTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_backTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._backTexture));
   },
   set_leftTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_leftTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._leftTexture));
   },
   set_rightTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_rightTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._rightTexture));
   },
   set_topTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_topTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._topTexture));
   },
   set_bottomTexture__: function ()
   {
      EnvironmentalEffects_X3DBackgroundNode.prototype.set_bottomTexture__.call (this, X3DCast (Base_X3DConstants.X3DTextureNode, this ._bottomTexture));
   },
});

/* harmony default export */ const EnvironmentalEffects_TextureBackground = (TextureBackground);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalEffects.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











const EnvironmentalEffects_Types =
{
   Background:        EnvironmentalEffects_Background,
   Fog:               EnvironmentalEffects_Fog,
   FogCoordinate:     EnvironmentalEffects_FogCoordinate,
   LocalFog:          EnvironmentalEffects_LocalFog,
   TextureBackground: EnvironmentalEffects_TextureBackground,
};

const EnvironmentalEffects_AbstractTypes =
{
   X3DBackgroundNode: EnvironmentalEffects_X3DBackgroundNode,
   X3DFogObject:      EnvironmentalEffects_X3DFogObject,
};

for (const typeName in EnvironmentalEffects_Types)
   Configuration_SupportedNodes.addType (typeName, EnvironmentalEffects_Types [typeName]);

for (const typeName in EnvironmentalEffects_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, EnvironmentalEffects_AbstractTypes [typeName]);

/* harmony default export */ const EnvironmentalEffects = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function X3DEnvironmentalSensorNode (executionContext)
{
   Core_X3DSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DEnvironmentalSensorNode);

   this .addChildObjects ("traversed", new x_ite_Fields.SFBool (true));

   this ._size   .setUnit ("length");
   this ._center .setUnit ("length");

   this .zeroTest         = false;
   this .currentTraversed = true;
}

X3DEnvironmentalSensorNode .prototype = Object .assign (Object .create (Core_X3DSensorNode.prototype),
{
   constructor: X3DEnvironmentalSensorNode,
   initialize: function ()
   {
      Core_X3DSensorNode.prototype.initialize.call (this);

      this .isLive () .addInterest ("set_live__", this);

      this ._enabled   .addInterest ("set_live__", this);
      this ._size      .addInterest ("set_live__", this);
      this ._traversed .addInterest ("set_live__", this);

      this .set_live__ ();
   },
   set_live__: function ()
   {
      if (this ._traversed .getValue () && this .isLive () .getValue () && this ._enabled .getValue () && ! (this .zeroTest && this ._size. getValue () .equals (Numbers_Vector3.Zero)))
      {
         this .getBrowser () .sensorEvents () .addInterest ("update", this);
      }
      else
      {
         this .getBrowser () .sensorEvents () .removeInterest ("update", this);

         if (this ._isActive .getValue ())
         {
            this ._isActive = false;
            this ._exitTime = this .getBrowser () .getCurrentTime ();
         }
      }
   },
   setZeroTest: function (value)
   {
      this .zeroTest = value;
   },
   getZeroTest: function ()
   {
      return this .zeroTest;
   },
   setTraversed: function (value)
   {
      if (value)
      {
         if (this ._traversed .getValue () === false)
            this ._traversed = true;
      }
      else
      {
         if (this .currentTraversed !== this ._traversed .getValue ())
            this ._traversed = this .currentTraversed;
      }

      this .currentTraversed = value;
   },
   getTraversed: function ()
   {
      return this .currentTraversed;
   },
   update: function () { },
});

/* harmony default export */ const EnvironmentalSensor_X3DEnvironmentalSensorNode = (X3DEnvironmentalSensorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalSensor/ProximitySensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function ProximitySensor (executionContext)
{
   EnvironmentalSensor_X3DEnvironmentalSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ProximitySensor);

   this .setCameraObject (true);

   this ._centerOfRotation_changed .setUnit ("length");
   this ._position_changed         .setUnit ("length");

   this .setZeroTest (true);

   this .min           = new Numbers_Vector3 (0, 0, 0);
   this .max           = new Numbers_Vector3 (0, 0, 0);
   this .viewpointNode = null;
   this .modelMatrix   = new Numbers_Matrix4 ();
   this .inside        = false;
}

ProximitySensor .prototype = Object .assign (Object .create (EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype),
{
   constructor: ProximitySensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",                 new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",                  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "size",                     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "center",                   new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "enterTime",                new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "exitTime",                 new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",                 new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "position_changed",         new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "orientation_changed",      new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "centerOfRotation_changed", new x_ite_Fields.SFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "ProximitySensor";
   },
   getComponentName: function ()
   {
      return "EnvironmentalSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype.initialize.call (this);

      this ._enabled .addInterest ("set_enabled__", this);
      this ._size    .addInterest ("set_extents__", this);
      this ._center  .addInterest ("set_extents__", this);

      this ._traversed .addFieldInterest (this ._isCameraObject);

      this .set_enabled__ ();
      this .set_extents__ ();
   },
   set_enabled__: function ()
   {
      this .setCameraObject (this ._enabled .getValue ());

      if (this ._enabled .getValue ())
         delete this .traverse;
      else
         this .traverse = Function .prototype;
   },
   set_extents__: function ()
   {
      const
         s  = this ._size .getValue (),
         c  = this ._center .getValue (),
         sx = s .x / 2,
         sy = s .y / 2,
         sz = s .z / 2,
         cx = c .x,
         cy = c .y,
         cz = c .z;

      this .min .set (cx - sx, cy - sy, cz - sz);
      this .max .set (cx + sx, cy + sy, cz + sz);
   },
   update: (function ()
   {
      const
         invModelMatrix         = new Numbers_Matrix4 (),
         centerOfRotationMatrix = new Numbers_Matrix4 (),
         position               = new Numbers_Vector3 (0, 0, 0),
         orientation            = new Numbers_Rotation4 (0, 0, 1, 0),
         centerOfRotation       = new Numbers_Vector3 (0, 0, 0);

      return function ()
      {
         if (this .inside && this .getTraversed ())
         {
            if (this .viewpointNode)
            {
               const modelMatrix = this .modelMatrix;

               centerOfRotationMatrix .assign (this .viewpointNode .getModelMatrix ());
               centerOfRotationMatrix .translate (this .viewpointNode .getUserCenterOfRotation ());
               centerOfRotationMatrix .multRight (invModelMatrix .assign (modelMatrix) .inverse ());

               modelMatrix .multRight (this .viewpointNode .getViewMatrix ());
               modelMatrix .get (null, orientation);
               modelMatrix .inverse ();

               position .set (modelMatrix [12], modelMatrix [13], modelMatrix [14]);

               orientation .inverse ();

               centerOfRotation .set (centerOfRotationMatrix [12], centerOfRotationMatrix [13], centerOfRotationMatrix [14]);

               if (this ._isActive .getValue ())
               {
                  if (! this ._position_changed .getValue () .equals (position))
                     this ._position_changed = position;

                  if (! this ._orientation_changed .getValue () .equals (orientation))
                     this ._orientation_changed = orientation;

                  if (! this ._centerOfRotation_changed .getValue () .equals (centerOfRotation))
                     this ._centerOfRotation_changed = centerOfRotation;
               }
               else
               {
                  this ._isActive                 = true;
                  this ._enterTime                = this .getBrowser () .getCurrentTime ();
                  this ._position_changed         = position;
                  this ._orientation_changed      = orientation;
                  this ._centerOfRotation_changed = centerOfRotation;
               }
            }
         }
         else
         {
            if (this ._isActive .getValue ())
            {
               this ._isActive = false;
               this ._exitTime = this .getBrowser () .getCurrentTime ();
            }
         }

         this .inside        = false;
         this .viewpointNode = null;

         this .setTraversed (false);
      };
   })(),
   traverse: (function ()
   {
      const
         invModelViewMatrix = new Numbers_Matrix4 (),
         infinity           = new Numbers_Vector3 (-1, -1, -1);

      return function (type, renderObject)
      {
         switch (type)
         {
            case Rendering_TraverseType.CAMERA:
            {
               this .viewpointNode = renderObject .getViewpoint ();
               this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
               return;
            }
            case Rendering_TraverseType.DISPLAY:
            {
               this .setTraversed (true);

               if (this .inside)
                  return;

               if (this ._size .getValue () .equals (infinity))
               {
                  this .inside = true;
               }
               else
               {
                  invModelViewMatrix .assign (renderObject .getModelViewMatrix () .get ()) .inverse ();

                  this .inside = this .containsPoint (invModelViewMatrix .origin);
               }

               return;
            }
         }
      };
   })(),
   containsPoint: function (point)
   {
      const
         min = this .min,
         max = this .max;

      return min .x <= point .x &&
             max .x >= point .x &&
             min .y <= point .y &&
             max .y >= point .y &&
             min .z <= point .z &&
             max .z >= point .z;
   },
});

/* harmony default export */ const EnvironmentalSensor_ProximitySensor = (ProximitySensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalSensor/TransformSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













const
   ModelMatrixCache  = ObjectCache (Numbers_Matrix4),
   TargetMatrixCache = ObjectCache (Numbers_Matrix4);

function TransformSensor (executionContext)
{
   EnvironmentalSensor_X3DEnvironmentalSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TransformSensor);

   this ._position_changed .setUnit ("length");

   this .setZeroTest (true);

   this .min              = new Numbers_Vector3 ();
   this .max              = new Numbers_Vector3 ();
   this .targetObjectNode = null;
   this .modelMatrices    = [ ];
   this .targetMatrices   = [ ];
}

TransformSensor .prototype = Object .assign (Object .create (EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype),
{
   constructor: TransformSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "size",                new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "center",              new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "enterTime",           new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "exitTime",            new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "position_changed",    new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "orientation_changed", new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "targetObject",        new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "TransformSensor";
   },
   getComponentName: function ()
   {
      return "EnvironmentalSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype.initialize.call (this);

      this .isLive () .addInterest ("set_enabled__", this);

      this ._enabled      .addInterest ("set_enabled__",      this);
      this ._size         .addInterest ("set_enabled__",      this);
      this ._size         .addInterest ("set_extents__",      this);
      this ._center       .addInterest ("set_extents__",      this);
      this ._targetObject .addInterest ("set_targetObject__", this);

      this .set_extents__ ();
      this .set_targetObject__ ();
   },
   set_live__: function ()
   { },
   set_enabled__: function ()
   {
      if (this .isLive () .getValue () && this .targetObjectNode && this ._enabled .getValue () && ! this ._size. getValue () .equals (Numbers_Vector3.Zero))
      {
         this .setPickableObject (true);
         this .getBrowser () .addTransformSensor (this);
         this .targetObjectNode .addTransformSensor (this);
      }
      else
      {
         this .setPickableObject (false);
         this .getBrowser () .removeTransformSensor (this);

         if (this .targetObjectNode)
            this .targetObjectNode .removeTransformSensor (this);

         if (this ._isActive .getValue ())
         {
            this ._isActive = false;
            this ._exitTime = this .getBrowser () .getCurrentTime ();
         }
      }
   },
   set_extents__: function ()
   {
      const
         s  = this ._size .getValue (),
         c  = this ._center .getValue (),
         sx = s .x / 2,
         sy = s .y / 2,
         sz = s .z / 2,
         cx = c .x,
         cy = c .y,
         cz = c .z;

      this .min .set (cx - sx, cy - sy, cz - sz);
      this .max .set (cx + sx, cy + sy, cz + sz);
   },
   set_targetObject__: function ()
   {
      this .targetObjectNode = null;

      try
      {
         const
            node = this ._targetObject .getValue () .getInnerNode (),
            type = node .getType ();

         for (let t = type .length - 1; t >= 0; -- t)
         {
            switch (type [t])
            {
               case Base_X3DConstants.X3DGroupingNode:
               case Base_X3DConstants.X3DShapeNode:
               {
                  this .targetObjectNode = node;
                  break;
               }
               default:
                  continue;
            }

            break;
         }
      }
      catch (error)
      { }

      this .set_enabled__ ();
   },
   traverse: function (type, renderObject)
   {
      // TransformSensor nodes are sorted out and only traversed during PICKING, except if is child of a LOD or Switch node.

      if (type !== Rendering_TraverseType.PICKING)
         return;

      if (this .getPickableObject ())
         this .modelMatrices .push (ModelMatrixCache .pop () .assign (renderObject .getModelViewMatrix () .get ()));
   },
   collect: function (targetMatrix)
   {
      this .targetMatrices .push (TargetMatrixCache .pop () .assign (targetMatrix));
   },
   process: (function ()
   {
      const
         position    = new Numbers_Vector3 (0, 0, 0),
         orientation = new Numbers_Rotation4 (0, 0, 1, 0);

      return function ()
      {
         const
            modelMatrices  = this .modelMatrices,
            targetMatrices = this .targetMatrices,
            matrix         = this .intersects ();

         if (matrix)
         {
            matrix .get (position, orientation);

            if (this ._isActive .getValue ())
            {
               if (! this ._position_changed .getValue () .equals (position))
                  this ._position_changed = position;

               if (! this ._orientation_changed .getValue () .equals (orientation))
                  this ._orientation_changed = orientation;
            }
            else
            {
               this ._isActive            = true;
               this ._enterTime           = this .getBrowser () .getCurrentTime ();
               this ._position_changed    = position;
               this ._orientation_changed = orientation;
            }
         }
         else
         {
            if (this ._isActive .getValue ())
            {
               this ._isActive = false;
               this ._exitTime = this .getBrowser () .getCurrentTime ();
            }
         }

         for (const modelMatrix of modelMatrices)
            ModelMatrixCache .push (modelMatrix);

         for (const targetMatrix of targetMatrices)
            TargetMatrixCache .push (targetMatrix);

         modelMatrices  .length = 0;
         targetMatrices .length = 0;
      };
   })(),
   intersects: (function ()
   {
      const infinity = new Numbers_Vector3 (-1, -1, -1);

      return function ()
      {
         const
            modelMatrices  = this .modelMatrices,
            targetMatrices = this .targetMatrices,
            always         = this ._size .getValue () .equals (infinity);

         for (const modelMatrix of modelMatrices)
         {
            const invModelMatrix = modelMatrix .inverse ();

            for (const targetMatrix of targetMatrices)
            {
               const matrix = targetMatrix .multRight (invModelMatrix);

               if (always || this .containsPoint (matrix .origin))
               {
                  return matrix;
               }
            }
         }

         return null;
      };
   })(),
   containsPoint: function (point)
   {
      const
         min = this .min,
         max = this .max;

      return min .x <= point .x &&
             max .x >= point .x &&
             min .y <= point .y &&
             max .y >= point .y &&
             min .z <= point .z &&
             max .z >= point .z;
   },
});

/* harmony default export */ const EnvironmentalSensor_TransformSensor = (TransformSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalSensor/VisibilitySensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function VisibilitySensor (executionContext)
{
   EnvironmentalSensor_X3DEnvironmentalSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.VisibilitySensor);

   this .setZeroTest (false);

   this .visible = false;
}

VisibilitySensor .prototype = Object .assign (Object .create (EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype),
{
   constructor: VisibilitySensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",   new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "size",      new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "center",    new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "enterTime", new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "exitTime",  new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",  new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "VisibilitySensor";
   },
   getComponentName: function ()
   {
      return "EnvironmentalSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      EnvironmentalSensor_X3DEnvironmentalSensorNode.prototype.initialize.call (this);

      this ._enabled .addInterest ("set_enabled__", this);

      this .set_enabled__ ();
   },
   set_enabled__: function ()
   {
      if (this ._enabled .getValue ())
         delete this .traverse;
      else
         this .traverse = Function .prototype;
   },
   update: function ()
   {
      if (this .visible && this .getTraversed ())
      {
         if (! this ._isActive .getValue ())
         {
            this ._isActive  = true;
            this ._enterTime = this .getBrowser () .getCurrentTime ();
         }

         this .visible = false;
      }
      else
      {
         if (this ._isActive .getValue ())
         {
            this ._isActive = false;
            this ._exitTime = this .getBrowser () .getCurrentTime ();
         }
      }

      this .setTraversed (false);
   },
   traverse: (function ()
   {
      const
         bbox     = new Geometry_Box3 (),
         infinity = new Numbers_Vector3 (-1, -1, -1);

      return function (type, renderObject)
      {
         if (type !== Rendering_TraverseType.DISPLAY)
            return;

         this .setTraversed (true);

         if (this .visible)
            return;

         if (this ._size .getValue () .equals (infinity))
         {
            this .visible = true;
         }
         else
         {
            bbox
               .set (this ._size .getValue (), this ._center .getValue ())
               .multRight (renderObject .getModelViewMatrix () .get ());

            this .visible = renderObject .getViewVolume () .intersectsBox (bbox);
         }
      };
   })(),
});

/* harmony default export */ const EnvironmentalSensor_VisibilitySensor = (VisibilitySensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/EnvironmentalSensor.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const EnvironmentalSensor_Types =
{
   ProximitySensor:  EnvironmentalSensor_ProximitySensor,
   TransformSensor:  EnvironmentalSensor_TransformSensor,
   VisibilitySensor: EnvironmentalSensor_VisibilitySensor,
};

const EnvironmentalSensor_AbstractTypes =
{
   X3DEnvironmentalSensorNode: EnvironmentalSensor_X3DEnvironmentalSensorNode,
};

for (const typeName in EnvironmentalSensor_Types)
   Configuration_SupportedNodes.addType (typeName, EnvironmentalSensor_Types [typeName]);

for (const typeName in EnvironmentalSensor_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, EnvironmentalSensor_AbstractTypes [typeName]);

/* harmony default export */ const EnvironmentalSensor = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/ColorChaser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var
   initialValue       = new Numbers_Vector3 (0, 0, 0),
   initialDestination = new Numbers_Vector3 (0, 0, 0),
   deltaOut           = new Numbers_Vector3 (0, 0, 0),
   ColorChaser_vector             = new Numbers_Vector3 (0, 0, 0);

function ColorChaser (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ColorChaser);
}

ColorChaser .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
{
   constructor: ColorChaser,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFColor ()),
   ]),
   getTypeName: function ()
   {
      return "ColorChaser";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
   getValue: function ()
   {
      return this ._set_value .getValue () .getHSV (ColorChaser_vector);
   },
   getDestination: function ()
   {
      return this ._set_destination .getValue () .getHSV (ColorChaser_vector);
   },
   getInitialValue: function ()
   {
      return this ._initialValue .getValue () .getHSV (initialValue);
   },
   getInitialDestination: function ()
   {
      return this ._initialDestination .getValue () .getHSV (initialDestination);
   },
   setValue: function (value)
   {
      this ._value_changed .setHSV (value .x, value .y, value .z);
   },
   interpolate: function (source, destination, weight)
   {
      return Numbers_Color3.lerp (source, destination, weight, ColorChaser_vector);
   },
   step: function (value1, value2, t)
   {
      deltaOut .assign (this .output) .add (value1) .subtract (value2);

      //step .x = Algorithm .interval (step .x, 0, 2 * Math .PI);

      Numbers_Color3.lerp (this .output, deltaOut, t, this .output);
   },
});

/* harmony default export */ const Followers_ColorChaser = (ColorChaser);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/X3DDamperNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DDamperNode (executionContext)
{
   Followers_X3DFollowerNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DDamperNode);
}

X3DDamperNode .prototype = Object .assign (Object .create (Followers_X3DFollowerNode.prototype),
{
   constructor: X3DDamperNode,
   initialize: function ()
   {
      Followers_X3DFollowerNode.prototype.initialize.call (this);

      this ._order           .addInterest ("set_order__", this);
      this ._set_value       .addInterest ("set_value__", this);
      this ._set_destination .addInterest ("set_destination__", this);

      var
         buffer             = this .getBuffer (),
         initialValue       = this .getInitialValue (),
         initialDestination = this .getInitialDestination ();

      buffer [0] = this .duplicate (initialDestination);

      for (var i = 1, length = this .getOrder () + 1; i < length; ++ i)
         buffer [i] = this .duplicate (initialValue);

      if (this .equals (initialDestination, initialValue, this .getTolerance ()))
         this .setValue (initialDestination);

      else
         this .set_active (true);
   },
   getOrder: function ()
   {
      return Math_Algorithm.clamp (this ._order .getValue (), 0, 5);
   },
   getTolerance: function ()
   {
      if (this ._tolerance .getValue () < 0)
         return 1e-4;

      return this ._tolerance .getValue ();
   },
   prepareEvents: function ()
   {
      var
         buffer = this .getBuffer (),
         order  = buffer .length - 1;

      if (this ._tau .getValue ())
      {
         var
            delta = 1 / this .getBrowser () .currentFrameRate,
            alpha = Math .exp (-delta / this ._tau .getValue ());

         for (var i = 0; i < order; ++ i)
         {
            this .assign (buffer, i + 1, this .interpolate (buffer [i], buffer [i + 1], alpha));
         }

         this .setValue (buffer [order]);

         if (! this .equals (buffer [order], buffer [0], this .getTolerance ()))
            return;
      }
      else
      {
         this .setValue (buffer [0]);

         order = 0;
      }

      for (var i = 1, length = buffer .length; i < length; ++ i)
         this .assign (buffer, i, buffer [order]);

      this .set_active (false);
   },
   set_value__: function ()
   {
      var
         buffer = this .getBuffer (),
         value  = this .getValue ();

      for (var i = 1, length = buffer .length; i < length; ++ i)
         this .assign (buffer, i, value);

      this .setValue (value);

      this .set_active (true);
   },
   set_destination__: function ()
   {
      this .assign (this .getBuffer (), 0, this .getDestination ());

      this .set_active (true);
   },
   set_order__: function ()
   {
      var
         buffer = this .getBuffer (),
         value  = buffer [buffer .length - 1];

      for (var i = buffer .length, length = this .getOrder () + 1; i < length; ++ i)
         buffer [i] = this .duplicate (value);

      buffer .length = length;
   },
});

/* harmony default export */ const Followers_X3DDamperNode = (X3DDamperNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/ColorDamper.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var
   ColorDamper_a                  = new Numbers_Vector3 (0, 0, 0),
   ColorDamper_initialValue       = new Numbers_Vector3 (0, 0, 0),
   ColorDamper_initialDestination = new Numbers_Vector3 (0, 0, 0),
   ColorDamper_vector             = new Numbers_Vector3 (0, 0, 0);

function ColorDamper (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ColorDamper);
}

ColorDamper .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
{
   constructor: ColorDamper,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFColor ()),
   ]),
   getTypeName: function ()
   {
      return "ColorDamper";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
   getValue: function ()
   {
      return this ._set_value .getValue () .getHSV (ColorDamper_vector);
   },
   getDestination: function ()
   {
      return this ._set_destination .getValue () .getHSV (ColorDamper_vector);
   },
   getInitialValue: function ()
   {
      return this ._initialValue .getValue () .getHSV (ColorDamper_initialValue);
   },
   getInitialDestination: function ()
   {
      return this ._initialDestination .getValue () .getHSV (ColorDamper_initialDestination);
   },
   setValue: function (value)
   {
      this ._value_changed .setHSV (value .x, value .y, value .z);
   },
   equals: function (lhs, rhs, tolerance)
   {
      return ColorDamper_a .assign (lhs) .subtract (rhs) .magnitude () < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return Numbers_Color3.lerp (source, destination, weight, ColorDamper_vector);
   },
});

/* harmony default export */ const Followers_ColorDamper = (ColorDamper);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Followers/X3DArrayFollowerTemplate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


/* harmony default export */ function X3DArrayFollowerTemplate(Type)
{
   function X3DArrayFollowerObject ()
   {
      this .array = this .getArray ();
      this .zero  = this .getVector ();
   }

   X3DArrayFollowerObject .prototype =
   {
      getArray: function ()
      {
         const array = [ ];

         array .assign = function (value)
         {
            if (Array .isArray (value))
            {
               for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
                  this [i] .assign (value [i]);

               for (var i = length, length = value .length; i < length; ++ i)
                  this [i] = value [i] .copy ();

               this .length = length;
            }
            else
            {
               for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
                  this [i] .assign (value [i] .getValue ());

               for (var i = length, length = value .length; i < length; ++ i)
                  this [i] = value [i] .getValue () .copy ();

               this .length = length;
            }
         };

         return array;
      },
      getValue: function ()
      {
         return this ._set_value;
      },
      getDestination: function ()
      {
         return this ._set_destination;
      },
      getInitialValue: function ()
      {
         return this ._initialValue;
      },
      getInitialDestination: function ()
      {
         return this ._initialDestination;
      },
      setValue: function (value)
      {
         if (Array .isArray (value))
         {
            const value_changed = this ._value_changed;

            for (var i = 0, length = value .length; i < length; ++ i)
               value_changed [i] = value [i];

            value_changed .length = length;
         }
         else
         {
            this ._value_changed = value;
         }
      },
      duplicate: function (value)
      {
         const array = this .getArray ();

         array .assign (value);

         return array;
      },
      equals: function (lhs, rhs, tolerance)
      {
         if (lhs .length !== rhs .length)
            return false;

         const a = this .a;

         let distance = 0;

         for (let i = 0, length = lhs .length; i < length; ++ i)
           distance = Math .max (a .assign (lhs [i]) .subtract (rhs [i]) .magnitude ());

         return distance < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         const array = this .array;

         array .assign (source);

         for (let i = 0, length = array .length; i < length; ++ i)
            array [i] .lerp (destination [i] || this .zero, weight);

         return array;
      },
      set_destination__: function ()
      {
         const
            buffers = this .getBuffer (),
            l       = this ._set_destination .length;

         for (let i = 0, length = buffers .length; i < length; ++ i)
         {
            const buffer = buffers [i];

            for (let b = buffer .length; b < l; ++ b)
               buffer [b] = this .getVector ();

            buffer .length = l;
         }

         Type .prototype .set_destination__ .call (this);
      },
   };

   return X3DArrayFollowerObject;
};

;// CONCATENATED MODULE: ./src/x_ite/Browser/Followers/X3DArrayChaserTemplate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ function X3DArrayChaserTemplate(Type)
{
   const X3DArrayFollower = X3DArrayFollowerTemplate (Type);

   function X3DArrayChaserObject ()
   {
      X3DArrayFollower .call (this);

      this .array = this .getArray ();
   }

   Object .assign (X3DArrayChaserObject .prototype,
      X3DArrayFollower .prototype,
   {
      step: function (value1, value2, t)
      {
         const
            output   = this .output,
            deltaOut = this .deltaOut;

         for (let i = 0, length = output .length; i < length; ++ i)
            output [i] .add (deltaOut .assign (value1 [i] || this .zero) .subtract (value2 [i] || this .zero) .multiply (t));
      },
   });

   return X3DArrayChaserObject;
};

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/CoordinateChaser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var X3DArrayChaserObject = X3DArrayChaserTemplate (Followers_X3DChaserNode);

function CoordinateChaser (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);
   X3DArrayChaserObject .call (this, executionContext);

   this .addType (Base_X3DConstants.CoordinateChaser);
}

CoordinateChaser .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
   X3DArrayChaserObject .prototype,
{
   constructor: CoordinateChaser,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.MFVec3f (new Numbers_Vector3 (0, 0, 0))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.MFVec3f (new Numbers_Vector3 (0, 0, 0))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "CoordinateChaser";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
});

/* harmony default export */ const Followers_CoordinateChaser = (CoordinateChaser);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/CoordinateDamper.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var X3DArrayFollowerObject = X3DArrayFollowerTemplate (Followers_X3DDamperNode);

function CoordinateDamper (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);
   X3DArrayFollowerObject .call (this, executionContext);

   this .addType (Base_X3DConstants.CoordinateDamper);
}

CoordinateDamper .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
   X3DArrayFollowerObject .prototype,
{
   constructor: CoordinateDamper,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.MFVec3f (new Numbers_Vector3 (0, 0, 0))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.MFVec3f (new Numbers_Vector3 (0, 0, 0))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "CoordinateDamper";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
});

/* harmony default export */ const Followers_CoordinateDamper = (CoordinateDamper);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/OrientationDamper.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









var
   OrientationDamper_a        = new Numbers_Rotation4 (0, 0, 1, 0),
   OrientationDamper_rotation = new Numbers_Rotation4 (0, 0, 1, 0);

function OrientationDamper (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);

   this .addType (Base_X3DConstants.OrientationDamper);

   this ._set_value          .setUnit ("angle");
   this ._set_destination    .setUnit ("angle");
   this ._initialValue       .setUnit ("angle");
   this ._initialDestination .setUnit ("angle");
   this ._value_changed      .setUnit ("angle");
}

OrientationDamper .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
{
   constructor: OrientationDamper,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFRotation ()),
   ]),
   getTypeName: function ()
   {
      return "OrientationDamper";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Rotation4 (0, 0, 1, 0);
   },
   equals: function (lhs, rhs, tolerance)
   {
      OrientationDamper_a .assign (lhs) .inverse () .multRight (rhs);

      return Math .abs (OrientationDamper_a .angle) < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return OrientationDamper_rotation .assign (source) .slerp (destination, weight);
   },
});

/* harmony default export */ const Followers_OrientationDamper = (OrientationDamper);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/PositionChaser2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionChaser2D (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionChaser2D);
}

PositionChaser2D .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
{
   constructor: PositionChaser2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "PositionChaser2D";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector2 (0, 0);
   },
});

/* harmony default export */ const Followers_PositionChaser2D = (PositionChaser2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/PositionDamper.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionDamper (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionDamper);
}

PositionDamper .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
{
   constructor: PositionDamper,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "PositionDamper";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector3 (0, 0, 0);
   },
});

/* harmony default export */ const Followers_PositionDamper = (PositionDamper);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/PositionDamper2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionDamper2D (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionDamper2D);
}

PositionDamper2D .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
{
   constructor: PositionDamper2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "PositionDamper2D";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector2 (0, 0);
   },
});

/* harmony default export */ const Followers_PositionDamper2D = (PositionDamper2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/ScalarChaser.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function ScalarChaser (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ScalarChaser);
}

ScalarChaser .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
{
   constructor: ScalarChaser,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "ScalarChaser";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return 0;
   },
   setPreviousValue: function (value)
   {
      this .previousValue = value;
   },
   setDestination: function (value)
   {
      this .destination = value;
   },
   duplicate: function (value)
   {
      return value;
   },
   assign: function (buffer, i, value)
   {
      buffer [i] = value;
   },
   equals: function (lhs, rhs, tolerance)
   {
      return Math .abs (lhs - rhs) < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return Math_Algorithm.lerp (source, destination, weight);
   },
   step: function (value1, value2, t)
   {
      this .output += (value1 - value2) * t;
   },
});

/* harmony default export */ const Followers_ScalarChaser = (ScalarChaser);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/ScalarDamper.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function ScalarDamper (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ScalarDamper);
}

ScalarDamper .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
{
   constructor: ScalarDamper,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "ScalarDamper";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return 0;
   },
   duplicate: function (value)
   {
      return value;
   },
   assign: function (buffer, i, value)
   {
      buffer [i] = value;
   },
   equals: function (lhs, rhs, tolerance)
   {
      return Math .abs (lhs - rhs) < tolerance;
   },
   interpolate: function (source, destination, weight)
   {
      return Math_Algorithm.lerp (source, destination, weight);
   },
});

/* harmony default export */ const Followers_ScalarDamper = (ScalarDamper);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/TexCoordChaser2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var TexCoordChaser2D_X3DArrayChaserObject = X3DArrayChaserTemplate (Followers_X3DChaserNode);

function TexCoordChaser2D (executionContext)
{
   Followers_X3DChaserNode.call (this, executionContext);
   TexCoordChaser2D_X3DArrayChaserObject .call (this, executionContext);

   this .addType (Base_X3DConstants.TexCoordChaser2D);
}

TexCoordChaser2D .prototype = Object .assign (Object .create (Followers_X3DChaserNode.prototype),
   TexCoordChaser2D_X3DArrayChaserObject .prototype,
{
   constructor: TexCoordChaser2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "duration",           new x_ite_Fields.SFTime (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "TexCoordChaser2D";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector2 (0, 0);
   },
});

/* harmony default export */ const Followers_TexCoordChaser2D = (TexCoordChaser2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers/TexCoordDamper2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










var TexCoordDamper2D_X3DArrayFollowerObject = X3DArrayFollowerTemplate (Followers_X3DDamperNode);

function TexCoordDamper2D (executionContext)
{
   Followers_X3DDamperNode.call (this, executionContext);
   TexCoordDamper2D_X3DArrayFollowerObject .call (this, executionContext);

   this .addType (Base_X3DConstants.TexCoordDamper2D);
}

TexCoordDamper2D .prototype = Object .assign (Object .create (Followers_X3DDamperNode.prototype),
   TexCoordDamper2D_X3DArrayFollowerObject .prototype,
{
   constructor: TexCoordDamper2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_value",          new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_destination",    new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialValue",       new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "initialDestination", new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "order",              new x_ite_Fields.SFInt32 (3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tau",                new x_ite_Fields.SFTime (0.3)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "tolerance",          new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "value_changed",      new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "TexCoordDamper2D";
   },
   getComponentName: function ()
   {
      return "Followers";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getVector: function ()
   {
      return new Numbers_Vector2 (0, 0, 0);
   },
});

/* harmony default export */ const Followers_TexCoordDamper2D = (TexCoordDamper2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Followers.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





















const Followers_Types =
{
   ColorChaser:       Followers_ColorChaser,
   ColorDamper:       Followers_ColorDamper,
   CoordinateChaser:  Followers_CoordinateChaser,
   CoordinateDamper:  Followers_CoordinateDamper,
   OrientationChaser: Followers_OrientationChaser,
   OrientationDamper: Followers_OrientationDamper,
   PositionChaser:    Followers_PositionChaser,
   PositionChaser2D:  Followers_PositionChaser2D,
   PositionDamper:    Followers_PositionDamper,
   PositionDamper2D:  Followers_PositionDamper2D,
   ScalarChaser:      Followers_ScalarChaser,
   ScalarDamper:      Followers_ScalarDamper,
   TexCoordChaser2D:  Followers_TexCoordChaser2D,
   TexCoordDamper2D:  Followers_TexCoordDamper2D,
};

const Followers_AbstractTypes =
{
   X3DChaserNode: Followers_X3DChaserNode,
   X3DDamperNode: Followers_X3DDamperNode,
   X3DFollowerNode: Followers_X3DFollowerNode,
};

for (const typeName in Followers_Types)
   Configuration_SupportedNodes.addType (typeName, Followers_Types [typeName]);

for (const typeName in Followers_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Followers_AbstractTypes [typeName]);

/* harmony default export */ const Followers = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/Box.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function Box (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Box);

   this ._size .setUnit ("length");
}

Box .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Box,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "size",     new x_ite_Fields.SFVec3f (2, 2, 2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",    new x_ite_Fields.SFBool (true)),
   ]),
   getTypeName: function ()
   {
      return "Box";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: (function ()
   {
      const defaultSize = new Numbers_Vector3 (2, 2, 2);

      return function ()
      {
         const
            options  = this .getBrowser () .getBoxOptions (),
            geometry = options .getGeometry (),
            size     = this ._size .getValue ();

         this .setMultiTexCoords (geometry .getMultiTexCoords ());
         this .setNormals        (geometry .getNormals ());

         if (size .equals (defaultSize))
         {
            this .setVertices (geometry .getVertices ());

            this .getMin () .assign (geometry .getMin ());
            this .getMax () .assign (geometry .getMax ());
         }
         else
         {
            const
               scale           = Numbers_Vector3.divide (size, 2),
               defaultVertices = geometry .getVertices () .getValue (),
               vertexArray     = this .getVertices ();

            let
               x = scale .x,
               y = scale .y,
               z = scale .z;

            for (let i = 0, length = defaultVertices .length; i < length; i += 4)
            {
               vertexArray .push (x * defaultVertices [i],
                                  y * defaultVertices [i + 1],
                                  z * defaultVertices [i + 2],
                                  1);
            }

            x = Math .abs (x);
            y = Math .abs (y);
            z = Math .abs (z);

            this .getMin () .set (-x, -y, -z);
            this .getMax () .set ( x,  y,  z);
         }

         this .setSolid (this ._solid .getValue ());
      };
   })(),
});

/* harmony default export */ const Geometry3D_Box = (Box);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/Cone.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Cone (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Cone);

   this ._height       .setUnit ("length");
   this ._bottomRadius .setUnit ("length");
}

Cone .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Cone,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "side",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bottom",       new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "height",       new x_ite_Fields.SFFloat (2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bottomRadius", new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",        new x_ite_Fields.SFBool (true)),
   ]),
   getTypeName: function ()
   {
      return "Cone";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getConeOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getConeOptions () .removeInterest ("requestRebuild", this);
   },
   build: function ()
   {
      const
         options       = this .getBrowser () .getConeOptions (),
         xDimension    = options ._xDimension .getValue (),
         height        = this ._height .getValue (),
         bottomRadius  = this ._bottomRadius .getValue (),
         texCoordArray = this .getTexCoords (),
         normalArray   = this .getNormals (),
         vertexArray   = this .getVertices ();

      this .getMultiTexCoords () .push (texCoordArray);

      const
         y1 = height / 2,
         y2 = -y1,
         nz = Numbers_Complex.Polar (1, -Math .PI / 2 + Math .atan (bottomRadius / height));

      if (this ._side .getValue ())
      {
         for (let i = 0; i < xDimension; ++ i)
         {
            const
               u1     = (i + 0.5) / xDimension,
               theta1 = 2 * Math .PI * u1,
               n1     = Numbers_Complex.Polar (nz .imag, theta1);

            const
               u2     = i / xDimension,
               theta2 = 2 * Math .PI * u2,
               p2     = Numbers_Complex.Polar (-bottomRadius, theta2),
               n2     = Numbers_Complex.Polar (nz .imag, theta2);

            const
               u3     = (i + 1) / xDimension,
               theta3 = 2 * Math .PI * u3,
               p3     = Numbers_Complex.Polar (-bottomRadius, theta3),
               n3     = Numbers_Complex.Polar (nz .imag, theta3);

            /*    p1
             *   /  \
             *  /    \
             * p2 -- p3
             */

            // p1
            texCoordArray .push (u1, 1, 0, 1);
            normalArray   .push (n1 .imag, nz .real, n1 .real);
            vertexArray   .push (0, y1, 0, 1);

            // p2
            texCoordArray .push (u2, 0, 0, 1);
            normalArray   .push (n2 .imag, nz .real, n2 .real);
            vertexArray   .push (p2 .imag, y2, p2 .real, 1);

            // p3
            texCoordArray .push (u3, 0, 0, 1);
            normalArray   .push (n3 .imag , nz .real, n3 .real);
            vertexArray   .push (p3 .imag, y2, p3 .real, 1);
         }
      }

      if (this ._bottom .getValue ())
      {
         const
            texCoord = [ ],
            points   = [ ];

         for (let i = xDimension - 1; i > -1; -- i)
         {
            const
               u     = i / xDimension,
               theta = 2 * Math .PI * u,
               t     = Numbers_Complex.Polar (-1, theta),
               p     = Numbers_Complex.multiply (t, bottomRadius);

            texCoord .push (new Numbers_Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
            points   .push (new Numbers_Vector3 (p .imag, y2, p .real));
         }

         const
            t0 = texCoord [0],
            p0 = points [0];

         for (let i = 1, length = points .length - 1; i < length; ++ i)
         {
            const
               t1 = texCoord [i],
               t2 = texCoord [i + 1],
               p1 = points [i],
               p2 = points [i + 1];

            texCoordArray .push (t0 .x, t0 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

            texCoordArray .push (t1 .x, t1 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

            texCoordArray .push (t2 .x, t2 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
         }
      }

      this .setSolid (this ._solid .getValue ());
      this .setExtents ();
   },
   setExtents: function ()
   {
      const
         bottomRadius = this ._bottomRadius .getValue (),
         y1           = this ._height .getValue () / 2,
         y2           = -y1;

      if (!this ._side .getValue () && !this ._bottom .getValue ())
      {
         this .getMin () .set (0, 0, 0);
         this .getMax () .set (0, 0, 0);
      }
      else if (! this ._side .getValue ())
      {
         this .getMin () .set (-bottomRadius, y2, -bottomRadius);
         this .getMax () .set ( bottomRadius, y2,  bottomRadius);
      }
      else
      {
         this .getMin () .set (-bottomRadius, y2, -bottomRadius);
         this .getMax () .set ( bottomRadius, y1, bottomRadius);
      }
   },
});

/* harmony default export */ const Geometry3D_Cone = (Cone);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/Cylinder.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Cylinder (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Cylinder);

   this ._height .setUnit ("length");
   this ._radius .setUnit ("length");
}

Cylinder .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Cylinder,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "top",      new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "side",     new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bottom",   new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "height",   new x_ite_Fields.SFFloat (2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "radius",   new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",    new x_ite_Fields.SFBool (true)),
   ]),
   getTypeName: function ()
   {
      return "Cylinder";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getCylinderOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getCylinderOptions () .removeInterest ("requestRebuild", this);
   },
   build: function ()
   {
      const
         options       = this .getBrowser () .getCylinderOptions (),
         xDimension    = options ._xDimension .getValue (),
         texCoordArray = this .getTexCoords (),
         normalArray   = this .getNormals (),
         vertexArray   = this .getVertices ();

      this .getMultiTexCoords () .push (texCoordArray);

      const
         radius = this ._radius .getValue (),
         y1     = this ._height .getValue () / 2,
         y2     = -y1;

      if (this ._side .getValue ())
      {
         for (let i = 0; i < xDimension; ++ i)
         {
            const
               u1     = i / xDimension,
               theta1 = 2 * Math .PI * u1,
               n1     = Numbers_Complex.Polar (-1, theta1),
               p1     = Numbers_Complex.multiply (n1, radius);

            const
               u2     = (i + 1) / xDimension,
               theta2 = 2 * Math .PI * u2,
               n2     = Numbers_Complex.Polar (-1, theta2),
               p2     = Numbers_Complex.multiply (n2, radius);

            // p1 - p4
            //  | \ |
            // p2 - p3

            // Triangle one

            // p1
            texCoordArray .push (u1, 1, 0, 1);
            normalArray   .push (n1 .imag,  0, n1 .real);
            vertexArray   .push (p1 .imag, y1, p1 .real, 1);

            // p2
            texCoordArray .push (u1, 0, 0, 1);
            normalArray   .push (n1 .imag,  0, n1 .real);
            vertexArray   .push (p1 .imag, y2, p1 .real, 1);

            // p3
            texCoordArray .push (u2, 0, 0, 1);
            normalArray   .push (n2 .imag,  0, n2 .real);
            vertexArray   .push (p2 .imag, y2, p2 .real, 1);

            // Triangle two

            // p1
            texCoordArray .push (u1, 1, 0, 1);
            normalArray   .push (n1 .imag,  0, n1 .real);
            vertexArray   .push (p1 .imag, y1, p1 .real, 1);

            // p3
            texCoordArray .push (u2, 0, 0, 1);
            normalArray   .push (n2 .imag,  0, n2 .real);
            vertexArray   .push (p2 .imag, y2, p2 .real, 1);

            // p4
            texCoordArray .push (u2, 1, 0, 1);
            normalArray   .push (n2 .imag,  0, n2 .real);
            vertexArray   .push (p2 .imag, y1, p2 .real, 1);
         }
      }

      if (this ._top .getValue ())
      {
         const
            texCoord = [ ],
            points   = [ ];

         for (let i = 0; i < xDimension; ++ i)
         {
            const
               u     = i / xDimension,
               theta = 2 * Math .PI * u,
               t     = Numbers_Complex.Polar (-1, theta);

            texCoord .push (new Numbers_Vector2 ((t .imag + 1) / 2, -(t .real - 1) / 2));
            points   .push (new Numbers_Vector3 (t .imag * radius, y1, t .real * radius));
         }

         const
            t0 = texCoord [0],
            p0 = points [0];

         for (let i = 1, length = points .length - 1; i < length; ++ i)
         {
            const
               t1 = texCoord [i],
               t2 = texCoord [i + 1],
               p1 = points [i],
               p2 = points [i + 1];

            texCoordArray .push (t0 .x, t0 .y, 0, 1);
            normalArray   .push (0, 1, 0);
            vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

            texCoordArray .push (t1 .x, t1 .y, 0, 1);
            normalArray   .push (0, 1, 0);
            vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

            texCoordArray .push (t2 .x, t2 .y, 0, 1);
            normalArray   .push (0, 1, 0);
            vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
         }
      }

      if (this ._bottom .getValue ())
      {
         const
            texCoord = [ ],
            points   = [ ];

         for (let i = xDimension - 1; i > -1; -- i)
         {
            const
               u     = i / xDimension,
               theta = 2 * Math .PI * u,
               t     = Numbers_Complex.Polar (-1, theta);

            texCoord .push (new Numbers_Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
            points   .push (new Numbers_Vector3 (t .imag * radius, y2, t .real * radius));
         }

         const
            t0 = texCoord [0],
            p0 = points [0];

         for (let i = 1, length = points .length - 1; i < length; ++ i)
         {
            const
               t1 = texCoord [i],
               t2 = texCoord [i + 1],
               p1 = points [i],
               p2 = points [i + 1];

            texCoordArray .push (t0 .x, t0 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

            texCoordArray .push (t1 .x, t1 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

            texCoordArray .push (t2 .x, t2 .y, 0, 1);
            normalArray   .push (0, -1, 0);
            vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
         }
      }

      this .setSolid (this ._solid .getValue ());
      this .setExtents ();
   },
   setExtents: function ()
   {
      const
         radius = this ._radius .getValue (),
         y1     = this ._height .getValue () / 2,
         y2     = -y1;

      if (! this ._top .getValue () && ! this ._side .getValue () && ! this ._bottom .getValue ())
      {
         this .getMin () .set (0, 0, 0);
         this .getMax () .set (0, 0, 0);
      }

      else if (! this ._top .getValue () && ! this ._side .getValue ())
      {
         this .getMin () .set (-radius, y2, -radius);
         this .getMax () .set ( radius, y2,  radius);
      }

      else if (! this ._bottom .getValue () && ! this ._side .getValue ())
      {
         this .getMin () .set (-radius, y1, -radius);
         this .getMax () .set ( radius, y1,  radius);
      }

      else
      {
         this .getMin () .set (-radius, y2, -radius);
         this .getMax () .set ( radius, y1,  radius);
      }
   },
});

/* harmony default export */ const Geometry3D_Cylinder = (Cylinder);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/ElevationGrid.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function ElevationGrid (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ElevationGrid);

   this ._xSpacing    .setUnit ("length");
   this ._zSpacing    .setUnit ("length");
   this ._creaseAngle .setUnit ("angle");
   this ._height      .setUnit ("length");

   this .fogCoordNode = null;
   this .colorNode    = null;
   this .texCoordNode = null;
   this .normalNode   = null;
   this .coordNode    = null;
}

ElevationGrid .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: ElevationGrid,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_height",      new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "xDimension",      new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "zDimension",      new x_ite_Fields.SFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "xSpacing",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "zSpacing",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "creaseAngle",     new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "height",          new x_ite_Fields.MFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "ElevationGrid";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DGeometryNode.prototype.initialize.call (this);

      this ._set_height .addFieldInterest (this ._height);
      this ._attrib     .addInterest ("set_attrib__",   this);
      this ._fogCoord   .addInterest ("set_fogCoord__", this);
      this ._color      .addInterest ("set_color__",    this);
      this ._texCoord   .addInterest ("set_texCoord__", this);
      this ._normal     .addInterest ("set_normal__",   this);

      this .set_attrib__ ();
      this .set_fogCoord__ ();
      this .set_color__ ();
      this .set_texCoord__ ();
      this .set_normal__ ();
   },
   set_attrib__: function ()
   {
      const attribNodes = this .getAttrib ();

      for (const attribNode of attribNodes)
      {
         attribNode .removeInterest ("requestRebuild", this);
         attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
      }

      attribNodes .length = 0;

      for (const node of this ._attrib)
      {
         const attribNode = X3DCast (Base_X3DConstants.X3DVertexAttributeNode, node);

         if (attribNode)
            attribNodes .push (attribNode);
      }

      for (const attribNode of attribNodes)
      {
         attribNode .addInterest ("requestRebuild", this);
         attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
      }

      this .updateVertexArrays ();
   },
   set_fogCoord__: function ()
   {
      if (this .fogCoordNode)
         this .fogCoordNode .removeInterest ("requestRebuild", this);

      this .fogCoordNode = X3DCast (Base_X3DConstants.FogCoordinate, this ._fogCoord);

      if (this .fogCoordNode)
         this .fogCoordNode .addInterest ("requestRebuild", this);
   },
   set_color__: function ()
   {
      if (this .colorNode)
      {
         this .colorNode .removeInterest ("requestRebuild", this);
         this .colorNode ._transparent .removeInterest ("set_transparent__", this);
      }

      this .colorNode = X3DCast (Base_X3DConstants.X3DColorNode, this ._color);

      if (this .colorNode)
      {
         this .colorNode .addInterest ("requestRebuild", this);
         this .colorNode ._transparent .addInterest ("set_transparent__", this);

         this .set_transparent__ ();
      }
      else
         this .setTransparent (false);
   },
   set_transparent__: function ()
   {
      this .setTransparent (this .colorNode .getTransparent ());
   },
   set_texCoord__: function ()
   {
      if (this .texCoordNode)
         this .texCoordNode .removeInterest ("requestRebuild", this);

      this .texCoordNode = X3DCast (Base_X3DConstants.X3DTextureCoordinateNode, this ._texCoord);

      if (this .texCoordNode)
         this .texCoordNode .addInterest ("requestRebuild", this);

      this .setTextureCoordinate (this .texCoordNode);
   },
   set_normal__: function ()
   {
      if (this .normalNode)
         this .normalNode .removeInterest ("requestRebuild", this);

      this .normalNode = X3DCast (Base_X3DConstants.X3DNormalNode, this ._normal);

      if (this .normalNode)
         this .normalNode .addInterest ("requestRebuild", this);
   },
   getColor: function ()
   {
      return this .colorNode;
   },
   getTexCoord: function ()
   {
      return this .texCoordNode;
   },
   getNormal: function ()
   {
      return this .normalNode;
   },
   getHeight: function (index)
   {
      if (index < this ._height .length)
         return this ._height [index];

      return 0;
   },
   createTexCoords: function ()
   {
      const
         texCoords  = [ ],
         xDimension = this ._xDimension .getValue (),
         zDimension = this ._zDimension .getValue (),
         xSize      = xDimension - 1,
         zSize      = zDimension - 1;

      for (let z = 0; z < zDimension; ++ z)
      {
         for (let x = 0; x < xDimension; ++ x)
            texCoords .push (new Numbers_Vector2 (x / xSize, z / zSize));
      }

      return texCoords;
   },
   createNormals: function (points, coordIndex, creaseAngle)
   {
      const
         cw          = ! this ._ccw .getValue (),
         normalIndex = [ ],
         normals     = [ ];

      for (let p = 0, length = points .length; p < length; ++ p)
         normalIndex [p] = [ ];

      for (let c = 0, length = coordIndex .length; c < length; c += 3)
      {
         const
            c0 = coordIndex [c],
            c1 = coordIndex [c + 1],
            c2 = coordIndex [c + 2];

         normalIndex [c0] .push (normals .length);
         normalIndex [c1] .push (normals .length + 1);
         normalIndex [c2] .push (normals .length + 2);

         const normal = Triangle3.normal (points [c0], points [c1], points [c2], new Numbers_Vector3 (0, 0, 0));

         if (cw)
            normal .negate ();

         normals .push (normal);
         normals .push (normal);
         normals .push (normal);
      }

      return this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());
   },
   createCoordIndex: function ()
   {
      // p1 - p4
      //  | \ |
      // p2 - p3

      const
         coordIndex = [ ],
         xDimension = this ._xDimension .getValue (),
         zDimension = this ._zDimension .getValue (),
         xSize      = xDimension - 1,
         zSize      = zDimension - 1;

      for (let z = 0; z < zSize; ++ z)
      {
         for (let x = 0; x < xSize; ++ x)
         {
            const
               i1 =       z * xDimension + x,
               i2 = (z + 1) * xDimension + x,
               i3 = (z + 1) * xDimension + (x + 1),
               i4 =       z * xDimension + (x + 1);

            coordIndex .push (i1); // p1
            coordIndex .push (i2); // p2
            coordIndex .push (i3); // p3

            coordIndex .push (i1); // p1
            coordIndex .push (i3); // p3
            coordIndex .push (i4); // p4
         }
      }

      return coordIndex;
   },
   createPoints: function ()
   {
      const
         points     = [ ],
         xDimension = this ._xDimension .getValue (),
         zDimension = this ._zDimension .getValue (),
         xSpacing   = this ._xSpacing .getValue (),
         zSpacing   = this ._zSpacing .getValue ();

      for (let z = 0; z < zDimension; ++ z)
      {
         for (let x = 0; x < xDimension; ++ x)
         {
            points .push (new Numbers_Vector3 (xSpacing * x,
                                       this .getHeight (x + z * xDimension),
                                       zSpacing * z));
         }
      }

      return points;
   },
   build: function ()
   {
      if (this ._xDimension .getValue () < 2 || this ._zDimension .getValue () < 2)
         return;

      const
         colorPerVertex     = this ._colorPerVertex .getValue (),
         normalPerVertex    = this ._normalPerVertex .getValue (),
         coordIndex         = this .createCoordIndex (),
         attribNodes        = this .getAttrib (),
         numAttribNodes     = attribNodes .length,
         attribArrays       = this .getAttribs (),
         fogCoordNode       = this .fogCoordNode,
         colorNode          = this .getColor (),
         texCoordNode       = this .getTexCoord (),
         normalNode         = this .getNormal (),
         points             = this .createPoints (),
         fogDepthArray      = this .getFogDepths (),
         colorArray         = this .getColors (),
         multiTexCoordArray = this .getMultiTexCoords (),
         normalArray        = this .getNormals (),
         vertexArray        = this .getVertices ();

      let face = 0;

      if (texCoordNode)
      {
         texCoordNode .init (multiTexCoordArray);
      }
      else
      {
         var
            texCoords     = this .createTexCoords (),
            texCoordArray = this .getTexCoords ();

         multiTexCoordArray .push (texCoordArray);
      }

      // Build geometry

      for (let c = 0, numCoordIndices = coordIndex .length; c < numCoordIndices; ++ face)
      {
         for (let p = 0; p < 6; ++ p, ++ c)
         {
            const
               index = coordIndex [c],
               point = points [index];

            for (let a = 0; a < numAttribNodes; ++ a)
               attribNodes [a] .addValue (index, attribArrays [a]);

            if (fogCoordNode)
               fogCoordNode .addDepth (index, fogDepthArray);

            if (colorNode)
            {
               if (colorPerVertex)
                  colorNode .addColor (index, colorArray);
               else
                  colorNode .addColor (face, colorArray);
            }

            if (texCoordNode)
            {
               texCoordNode .addTexCoord (index, multiTexCoordArray);
            }
            else
            {
               const t = texCoords [index];

               texCoordArray .push (t .x, t .y, 0, 1);
            }

            if (normalNode)
            {
               if (normalPerVertex)
                  normalNode .addVector (index, normalArray);

               else
                  normalNode .addVector (face, normalArray);
            }

            vertexArray .push (point .x, point .y, point .z, 1);
         }
      }

      // Add auto-generated normals if needed.

      if (!normalNode)
      {
         const normals = this .createNormals (points, coordIndex);

         for (const normal of normals)
         {
            normalArray .push (normal .x, normal .y, normal .z);
         }
      }

      this .setSolid (this ._solid .getValue ());
      this .setCCW (this ._ccw .getValue ());
   },
});

/* harmony default export */ const Geometry3D_ElevationGrid = (ElevationGrid);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/Extrusion.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













function Extrusion (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Extrusion);

   this ._creaseAngle  .setUnit ("angle");
   this ._crossSection .setUnit ("length");
   this ._spine        .setUnit ("length");
}

Extrusion .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Extrusion,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_crossSection", new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_orientation",  new x_ite_Fields.MFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_scale",        new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_spine",        new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "beginCap",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "endCap",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "convex",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "creaseAngle",      new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "crossSection",     new x_ite_Fields.MFVec2f (new Numbers_Vector2 (1, 1), new Numbers_Vector2 (1, -1), new Numbers_Vector2 (-1, -1), new Numbers_Vector2 (-1, 1), new Numbers_Vector2 (1, 1))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "orientation",      new x_ite_Fields.MFRotation (new Numbers_Rotation4 ())),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "scale",            new x_ite_Fields.MFVec2f (new Numbers_Vector2 (1, 1))),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "spine",            new x_ite_Fields.MFVec3f (new Numbers_Vector3 (0, 0, 0), new Numbers_Vector3 (0, 1, 0))),
   ]),
   getTypeName: function ()
   {
      return "Extrusion";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DGeometryNode.prototype.initialize.call (this);

      this ._set_crossSection .addFieldInterest (this ._crossSection);
      this ._set_orientation  .addFieldInterest (this ._orientation);
      this ._set_scale        .addFieldInterest (this ._scale);
      this ._set_spine        .addFieldInterest (this ._spine);
   },
   getClosedOrientation: function ()
   {
      const orientation = this ._orientation;

      if (orientation .length)
      {
         const
            firstOrientation = orientation [0] .getValue (),
            lastOrientation  = orientation [orientation .length - 1] .getValue ();

         return firstOrientation .equals (lastOrientation);
      }

      return true;
   },
   createPoints: (function ()
   {
      const scale3 = new Numbers_Vector3 (1, 1, 1);

      return function ()
      {
         const
            crossSection = this ._crossSection,
            orientation  = this ._orientation,
            scale        = this ._scale,
            spine        = this ._spine,
            points       = [ ];

         // calculate SCP rotations

         const rotations = this .createRotations ();

         // calculate vertices.

         for (let i = 0, length = spine .length; i < length; ++ i)
         {
            const matrix = rotations [i];

            if (orientation .length)
               matrix .rotate (orientation [Math .min (i, orientation .length - 1)] .getValue ());

            if (scale .length)
            {
               const s = scale [Math .min (i, scale .length - 1)] .getValue ();
               matrix .scale (scale3 .set (s .x, 1, s .y));
            }

            for (let cs = 0, csLength = crossSection .length; cs < csLength; ++ cs)
            {
               const vector = crossSection [cs] .getValue ();
               points .push (matrix .multVecMatrix (new Numbers_Vector3 (vector .x, 0, vector .y)));
            }
         }

         return points;
      };
   })(),
   createRotations: (function ()
   {
      const rotations = [ ];

      const
         SCPxAxis = new Numbers_Vector3 (0, 0, 0),
         SCPyAxis = new Numbers_Vector3 (0, 0, 0),
         SCPzAxis = new Numbers_Vector3 (0, 0, 0);

         const
         SCPyAxisPrevious = new Numbers_Vector3 (0, 0, 0),
         SCPzAxisPrevious = new Numbers_Vector3 (0, 0, 0);

         const
         vector3  = new Numbers_Vector3 (0, 0, 0),
         rotation = new Numbers_Rotation4 (0, 0, 1, 0);

      return function ()
      {
         // calculate SCP rotations

         const
            spine       = this ._spine,
            numSpines   = spine .length,
            firstSpine  = spine [0] .getValue (),
            lastSpine   = spine [spine .length - 1] .getValue (),
            closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

         // Extend or shrink static rotations array:
         for (let i = rotations .length; i < numSpines; ++ i)
            rotations [i] = new Numbers_Matrix4 ();

         rotations .length = numSpines;

         // SCP axes:
         SCPxAxis .set (0, 0, 0);
         SCPyAxis .set (0, 0, 0);
         SCPzAxis .set (0, 0, 0);

         // SCP for the first point:
         if (closedSpine)
         {
            const s = firstSpine;

            // Find first defined Y-axis.
            for (let i = 1, length = numSpines - 2; i < length; ++ i)
            {
               SCPyAxis .assign (spine [i] .getValue ()) .subtract (s) .normalize ()
                  .subtract (vector3 .assign (spine [length] .getValue ()) .subtract (s) .normalize ())
                  .normalize ();

               if (! SCPyAxis .equals (Numbers_Vector3.Zero))
                  break;
            }

            // Find first defined Z-axis.
            for (let i = 0, length = numSpines - 2; i < length; ++ i)
            {
               SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
                          .cross (vector3 .assign (spine [length] .getValue ()) .subtract (spine [i] .getValue ()))
                          .normalize ();

               if (! SCPzAxis .equals (Numbers_Vector3.Zero))
                  break;
            }
         }
         else
         {
            // Find first defined Y-axis.
            for (let i = 0, length = numSpines - 1; i < length; ++ i)
            {
               SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ()) .normalize ();

               if (! SCPyAxis .equals (Numbers_Vector3.Zero))
                  break;
            }

            // Find first defined Z-axis.
            for (let i = 1, length = numSpines - 1; i < length; ++ i)
            {
               SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
                        .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (spine [i] .getValue ()))
                        .normalize ();

               if (! SCPzAxis .equals (Numbers_Vector3.Zero))
                  break;
            }
         }

         // The entire spine is coincident:
         if (SCPyAxis .equals (Numbers_Vector3.Zero))
            SCPyAxis .set (0, 1, 0);

         // The entire spine is collinear:
         if (SCPzAxis .equals (Numbers_Vector3.Zero))
            rotation .setFromToVec (Numbers_Vector3.yAxis, SCPyAxis) .multVecRot (SCPzAxis .assign (Numbers_Vector3.zAxis));

         // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
         SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

         // Get first spine
         const s = firstSpine;

         rotations [0] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                             SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                             SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                             s .x,        s .y,        s .z,        1);

         // For all points other than the first or last:

         SCPyAxisPrevious .assign (SCPyAxis);
         SCPzAxisPrevious .assign (SCPzAxis);

         for (let i = 1, length = numSpines - 1; i < length; ++ i)
         {
            const s = spine [i] .getValue ();

            SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (s) .normalize ()
                     .subtract (vector3 .assign (spine [i - 1] .getValue ()) .subtract (s) .normalize ())
                     .normalize ();
            SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (s)
                     .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (s))
                     .normalize ();

            // g.
            if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
               SCPzAxis .negate ();

            // The two points used in computing the Y-axis are coincident.
            if (SCPyAxis .equals (Numbers_Vector3.Zero))
               SCPyAxis .assign (SCPyAxisPrevious);
            else
               SCPyAxisPrevious .assign (SCPyAxis);

            // The three points used in computing the Z-axis are collinear.
            if (SCPzAxis .equals (Numbers_Vector3.Zero))
               SCPzAxis .assign (SCPzAxisPrevious);
            else
               SCPzAxisPrevious .assign (SCPzAxis);

            // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
            SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

            rotations [i] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                                SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                                SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                                s .x,        s .y,        s .z,        1);
         }

         // SCP for the last point
         if (closedSpine)
         {
            // The SCPs for the first and last points are the same.
            rotations [numSpines - 1] .assign (rotations [0]);
         }
         else
         {
            const s = lastSpine;

            SCPyAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ()) .normalize ();

            if (numSpines > 2)
            {
               SCPzAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ())
                        .cross (vector3 .assign (spine [numSpines - 3] .getValue ()) .subtract (spine [numSpines - 2] .getValue ()))
                        .normalize ();
            }

            // g.
            if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
               SCPzAxis .negate ();

            // The two points used in computing the Y-axis are coincident.
            if (SCPyAxis .equals (Numbers_Vector3.Zero))
               SCPyAxis .assign (SCPyAxisPrevious);

            // The three points used in computing the Z-axis are collinear.
            if (SCPzAxis .equals (Numbers_Vector3.Zero))
               SCPzAxis .assign (SCPzAxisPrevious);

            // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
            SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

            rotations [numSpines - 1] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                                            SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                                            SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                                            s .x,        s .y,        s .z,        1);
         }

         return rotations;
      };
   })(),
   build: (function ()
   {
      const
         min     = new Numbers_Vector2 (0, 0, 0),
         max     = new Numbers_Vector2 (0, 0, 0),
         vector2 = new Numbers_Vector2 (0, 0, 0);

      return function ()
      {
         const
            cw            = ! this ._ccw .getValue (),
            crossSection  = this ._crossSection,
            spine         = this ._spine,
            numSpines     = spine .length,
            texCoordArray = this .getTexCoords ();

         if (numSpines < 2 || crossSection .length < 2)
            return;

         this .getMultiTexCoords () .push (texCoordArray);

         const crossSectionSize = crossSection .length; // This one is used only in the INDEX macro.

         function INDEX (n, k) { return n * crossSectionSize + k; }

         const
            firstSpine  = spine [0] .getValue (),
            lastSpine   = spine [numSpines - 1] .getValue (),
            closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

         const
            firstCrossSection  = crossSection [0] .getValue (),
            lastCrossSection   = crossSection [crossSection .length - 1] .getValue (),
            closedCrossSection = firstCrossSection .equals (lastCrossSection);

         // For caps calculation

         min .assign (crossSection [0] .getValue ());
         max .assign (crossSection [0] .getValue ());

         for (let k = 1, length = crossSection .length; k < length; ++ k)
         {
            min .min (crossSection [k] .getValue ());
            max .max (crossSection [k] .getValue ());
         }

         const
            capSize      = vector2 .assign (max) .subtract (min),
            capMax       = Math .max (capSize .x, capSize .y),
            numCapPoints = closedCrossSection ? crossSection .length - 1 : crossSection .length;

         // Create

         const
            normalIndex = [ ],
            normals     = [ ],
            points      = this .createPoints ();

         for (let p = 0, length = points .length; p < length; ++ p)
            normalIndex [p] = [ ];

         // Build body.

         const
            normalArray = this .getNormals (),
            vertexArray = this .getVertices ();

         const
            numCrossSection_1 = crossSection .length - 1,
            numSpine_1        = numSpines - 1;

         let
            indexLeft  = INDEX (0, 0),
            indexRight = INDEX (0, closedCrossSection ? 0 : numCrossSection_1);

         for (let n = 0; n < numSpine_1; ++ n)
         {
            for (let k = 0; k < numCrossSection_1; ++ k)
            {
               const
                  n1 = closedSpine && n === numSpines - 2 ? 0 : n + 1,
                  k1 = closedCrossSection && k === crossSection .length - 2 ? 0 : k + 1;

               // k      k+1
               //
               // p4 ----- p3   n+1
               //  |     / |
               //  |   /   |
               //  | /     |
               // p1 ----- p2   n

               let
                  i1 = INDEX (n,  k),
                  i2 = INDEX (n,  k1),
                  i3 = INDEX (n1, k1),
                  i4 = INDEX (n1, k),
                  p1 = points [i1],
                  p2 = points [i2],
                  p3 = points [i3],
                  p4 = points [i4],
                  l1 = p2 .distance (p3) >= 1e-7,
                  l2 = p4 .distance (p1) >= 1e-7;

               if (cw)
               {
                  var
                     normal1 = Triangle3.normal (p3, p2, p1, new Numbers_Vector3 (0, 0, 0)),
                     normal2 = Triangle3.normal (p4, p3, p1, new Numbers_Vector3 (0, 0, 0));
               }
               else
               {
                  var
                     normal1 = Triangle3.normal (p1, p2, p3, new Numbers_Vector3 (0, 0, 0)),
                     normal2 = Triangle3.normal (p1, p3, p4, new Numbers_Vector3 (0, 0, 0));
               }

               // Merge points on the left and right side if spine is coincident for better normal generation.

               if (k == 0)
               {
                  if (l2)
                  {
                     indexLeft = i1;
                  }
                  else
                  {
                     i1 = indexLeft;
                     p1 = points [i1];
                  }
               }

               if (k == crossSection .length - 2)
               {
                  if (l1)
                  {
                     indexRight = i2;
                  }
                  else
                  {
                     i3 = indexRight;
                     p3 = points [i3];
                  }
               }

               // If there are coincident spine points then one length can be zero.

               // Triangle one

               if (l1)
               {
                  // p1
                  if (l2)
                  {
                     texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
                  }
                  else
                  {
                     // Cone case: ((texCoord1 + texCoord4) / 2)
                     const y = (n / numSpine_1 + (n + 1) / numSpine_1) / 2;

                     texCoordArray .push (k / numCrossSection_1, y, 0, 1);
                  }

                  normalIndex [i1] .push (normals .length);
                  normals .push (normal1);
                  vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

                  // p2
                  texCoordArray .push ((k + 1) / numCrossSection_1, n / numSpine_1, 0, 1);
                  normalIndex [i2] .push (normals .length);
                  normals .push (normal1);
                  vertexArray .push (p2 .x, p2 .y, p2 .z, 1);

                  // p3
                  texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                  normalIndex [i3] .push (normals .length);
                  normals .push (normal1);
                  vertexArray .push (p3 .x, p3 .y, p3 .z, 1);
               }

               // Triangle two

               if (l2)
               {
                  // p1
                  texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
                  normalIndex [i1] .push (normals .length);
                  normals .push (normal2);
                  vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

                  // p3
                  if (l1)
                  {
                     texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                  }
                  else
                  {
                     // Cone case: ((texCoord3 + texCoord2) / 2)
                     const y = ((n + 1) / numSpine_1 + n / numSpine_1) / 2;

                     texCoordArray .push ((k + 1) / numCrossSection_1, y, 0, 1);
                  }

                  normalIndex [i3] .push (normals .length);
                  normals .push (normal2);
                  vertexArray .push (p3 .x, p3 .y, p3 .z, 1);

                  // p4
                  texCoordArray .push (k / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                  normalIndex [i4] .push (normals .length);
                  normals .push (normal2);
                  vertexArray .push (p4 .x, p4 .y, p4 .z, 1);
               }
            }
         }

         // Refine body normals and add them.

         const refineNormals = this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());

         for (const normal of refineNormals)
         {
            normalArray .push (normal .x, normal .y, normal .z);
         }

         // Build caps

         if (capMax && numCapPoints > 2)
         {
            if (this ._beginCap .getValue ())
            {
               const
                  j         = 0, // spine
                  polygon   = [ ],
                  triangles = [ ];

               for (let k = 0; k < numCapPoints; ++ k)
               {
                  const
                     index = INDEX (j, numCapPoints - 1 - k),
                     point = points [index] .copy ();

                  point .index    = index;
                  point .texCoord = Numbers_Vector2.subtract (crossSection [numCapPoints - 1 - k] .getValue (), min) .divide (capMax);
                  polygon .push (point);
               }

               if (this ._convex .getValue ())
                  Triangle3.triangulateConvexPolygon (polygon, triangles);

               else
                  Triangle3.triangulatePolygon (polygon, triangles);

               if (triangles .length >= 3)
               {
                  const normal = Triangle3.normal (points [triangles [0] .index],
                                                    points [triangles [1] .index],
                                                    points [triangles [2] .index],
                                                    new Numbers_Vector3 (0, 0, 0));

                  if (cw)
                     normal .negate ();

                  this .addCap (texCoordArray, normal, points, triangles);
               }
            }

            if (this ._endCap .getValue ())
            {
               const
                  j         = numSpines - 1, // spine
                  polygon   = [ ],
                  triangles = [ ];

               for (let k = 0; k < numCapPoints; ++ k)
               {
                  const
                     index = INDEX (j, k),
                     point = points [index] .copy ();

                  point .index    = index;
                  point .texCoord = Numbers_Vector2.subtract (crossSection [k] .getValue (), min) .divide (capMax);
                  polygon .push (point);
               }

               if (this ._convex .getValue ())
                  Triangle3.triangulateConvexPolygon (polygon, triangles);

               else
                  Triangle3.triangulatePolygon (polygon, triangles);

               if (triangles .length >= 3)
               {
                  const normal = Triangle3.normal (points [triangles [0] .index],
                                                    points [triangles [1] .index],
                                                    points [triangles [2] .index],
                                                    new Numbers_Vector3 (0, 0, 0));

                  if (cw)
                     normal .negate ();

                  this .addCap (texCoordArray, normal, points, triangles);
               }
            }
         }

         this .setSolid (this ._solid .getValue ());
         this .setCCW (this ._ccw .getValue ());
      };
   })(),
   addCap: function (texCoordArray, normal, vertices, triangles)
   {
      const
         normalArray = this .getNormals (),
         vertexArray = this .getVertices ();

      for (let i = 0, length = triangles .length; i < length; i += 3)
      {
         const
            p0 = vertices [triangles [i]     .index],
            p1 = vertices [triangles [i + 1] .index],
            p2 = vertices [triangles [i + 2] .index],
            t0 = triangles [i]     .texCoord,
            t1 = triangles [i + 1] .texCoord,
            t2 = triangles [i + 2] .texCoord;

         texCoordArray .push (t0 .x, t0 .y, 0, 1);
         texCoordArray .push (t1 .x, t1 .y, 0, 1);
         texCoordArray .push (t2 .x, t2 .y, 0, 1);

         normalArray .push (normal .x, normal .y, normal .z,
                            normal .x, normal .y, normal .z,
                            normal .x, normal .y, normal .z);

         vertexArray .push (p0 .x, p0 .y, p0 .z, 1,
                            p1 .x, p1 .y, p1 .z, 1,
                            p2 .x, p2 .y, p2 .z, 1);
      }
   },
});

/* harmony default export */ const Geometry3D_Extrusion = (Extrusion);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D/Sphere.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Sphere (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Sphere);

   this ._radius .setUnit ("length");
}

Sphere .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Sphere,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "radius",   new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",    new x_ite_Fields.SFBool (true)),
   ]),
   getTypeName: function ()
   {
      return "Sphere";
   },
   getComponentName: function ()
   {
      return "Geometry3D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getSphereOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getSphereOptions () .removeInterest ("requestRebuild", this);
   },
   build: function ()
   {
      const
         options  = this .getBrowser () .getSphereOptions (),
         geometry = options .getGeometry (),
         radius   = Math .abs (this ._radius .getValue ());

      this .setMultiTexCoords (geometry .getMultiTexCoords ());
      this .setNormals        (geometry .getNormals ());

      if (radius === 1)
      {
         this .setVertices (geometry .getVertices ());

         this .getMin () .assign (geometry .getMin ());
         this .getMax () .assign (geometry .getMax ());
      }
      else
      {
         const
            defaultVertices = geometry .getVertices () .getValue (),
            vertexArray     = this .getVertices ();

         for (let i = 0, length = defaultVertices .length; i < length; i += 4)
         {
            vertexArray .push (radius * defaultVertices [i],
                               radius * defaultVertices [i + 1],
                               radius * defaultVertices [i + 2],
                               1);
         }

         this .getMin () .set (-radius, -radius, -radius);
         this .getMax () .set ( radius,  radius,  radius);
      }

      this .setSolid (this ._solid .getValue ());
   },
});

/* harmony default export */ const Geometry3D_Sphere = (Sphere);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry3D.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











const Geometry3D_Types =
{
   Box:            Geometry3D_Box,
   Cone:           Geometry3D_Cone,
   Cylinder:       Geometry3D_Cylinder,
   ElevationGrid:  Geometry3D_ElevationGrid,
   Extrusion:      Geometry3D_Extrusion,
   IndexedFaceSet: Geometry3D_IndexedFaceSet,
   Sphere:         Geometry3D_Sphere,
};

const Geometry3D_AbstractTypes =
{
};

for (const typeName in Geometry3D_Types)
   Configuration_SupportedNodes.addType (typeName, Geometry3D_Types [typeName]);

for (const typeName in Geometry3D_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Geometry3D_AbstractTypes [typeName]);

/* harmony default export */ const Geometry3D = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/StaticGroup.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













// No support for X3DBindableNode nodes, local lights. X3DLocalFog, local ClipPlane nodes, LOD, Billboard, Switch node.

function StaticGroup (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   Grouping_X3DBoundedObject.call (this, executionContext);

   this .addType (Base_X3DConstants.StaticGroup);

   this .group             = new Grouping_Group (this .getExecutionContext ());
   this .collisionShapes   = null;
   this .shadowShapes      = null;
   this .opaqueShapes      = null;
   this .transparentShapes = null;
   this .bbox              = new Geometry_Box3 ();
   this .shadowBBox        = new Geometry_Box3 ();
}

StaticGroup .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   Grouping_X3DBoundedObject.prototype,
{
   constructor: StaticGroup,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",     new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",    new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",  new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "children",    new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "StaticGroup";
   },
   getComponentName: function ()
   {
      return "Grouping";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      Grouping_X3DBoundedObject.prototype.initialize.call (this);

      this ._bboxSize   .addFieldInterest (this .group ._bboxSize);
      this ._bboxCenter .addFieldInterest (this .group ._bboxCenter);
      this ._children   .addFieldInterest (this .group ._children);

      this .group ._bboxSize   = this ._bboxSize;
      this .group ._bboxCenter = this ._bboxCenter;
      this .group ._children   = this ._children;
      this .group .setPrivate (true);
      this .group .setup ();

      // Connect after Group setup.
      this .group ._isCameraObject   .addFieldInterest (this ._isCameraObject);
      this .group ._isPickableObject .addFieldInterest (this ._isPickableObject);
      this .group ._children         .addInterest ("set_children__", this);

      this .setCameraObject   (this .group .getCameraObject ());
      this .setPickableObject (this .group .getPickableObject ());

      this .set_children__ ();
   },
   getBBox: function (bbox, shadows)
   {
      return bbox .assign (shadows ? this .shadowBBox : this .bbox);
   },
   set_children__: function ()
   {
      this .group .getBBox (this .bbox);
      this .group .getBBox (this .shadowBBox, true);

      this .collisionShapes   = null;
      this .shadowShapes      = null;
      this .opaqueShapes      = null;
      this .transparentShapes = null;
   },
   traverse: (function ()
   {
      const viewVolume = new Geometry_ViewVolume ();

      viewVolume .intersectsSphere = function () { return true; };

      return function (type, renderObject)
      {
         switch (type)
         {
            case Rendering_TraverseType.CAMERA:
            {
               return;
            }
            case Rendering_TraverseType.POINTER:
            case Rendering_TraverseType.COLLISION:
            {
               if (! this .collisionShapes)
               {
                  //console .log ("Rebuilding StaticGroup collisionShapes");

                  const
                     viewVolumes         = renderObject .getViewVolumes (),
                     viewport            = renderObject .getViewport (),
                     projectionMatrix    = renderObject .getProjectionMatrix (),
                     modelViewMatrix     = renderObject .getModelViewMatrix (),
                     firstCollisionShape = renderObject .getNumCollisionShapes ();

                  viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                  modelViewMatrix .push ();
                  modelViewMatrix .identity ();

                  this .group .traverse (type, renderObject);

                  modelViewMatrix .pop ();
                  viewVolumes     .pop ();

                  const lastCollisionShape = renderObject .getNumCollisionShapes ();

                  this .collisionShapes = renderObject .getCollisionShapes () .splice (firstCollisionShape, lastCollisionShape - firstCollisionShape);

                  renderObject .setNumCollisionShapes (firstCollisionShape);
               }

               const modelViewMatrix = renderObject .getModelViewMatrix ();

               for (const collisionShape of this .collisionShapes)
               {
                  modelViewMatrix .push ();
                  modelViewMatrix .multLeft (collisionShape .modelViewMatrix);
                  collisionShape .shapeNode .traverse (type, renderObject);
                  modelViewMatrix .pop ();
               }

               return;
            }
            case Rendering_TraverseType.SHADOW:
            {
               if (! this .shadowShapes)
               {
                  //console .log ("Rebuilding StaticGroup shadowShapes");

                  const
                     viewVolumes      = renderObject .getViewVolumes (),
                     viewport         = renderObject .getViewport (),
                     projectionMatrix = renderObject .getProjectionMatrix (),
                     modelViewMatrix  = renderObject .getModelViewMatrix (),
                     firstShadowShape = renderObject .getNumShadowShapes ();

                  viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                  modelViewMatrix .push ();
                  modelViewMatrix .identity ();

                  this .group .traverse (type, renderObject);

                  modelViewMatrix .pop ();
                  viewVolumes     .pop ();

                  const lastShadowShape = renderObject .getNumShadowShapes ();

                  this .shadowShapes = renderObject .getShadowShapes () .splice (firstShadowShape, lastShadowShape - firstShadowShape);

                  renderObject .setNumShadowShapes (firstShadowShape);
               }

               const modelViewMatrix = renderObject .getModelViewMatrix ();

               for (const depthShape of this .shadowShapes)
               {
                  modelViewMatrix .push ();
                  modelViewMatrix .multLeft (depthShape .modelViewMatrix);
                  depthShape .shapeNode .traverse (type, renderObject);
                  modelViewMatrix .pop ();
               }

               return;
            }
            case Rendering_TraverseType.DISPLAY:
            {
               if (! this .opaqueShapes)
               {
                  //console .log ("Rebuilding StaticGroup opaqueShapes and transparentShapes");

                  const
                     viewVolumes           = renderObject .getViewVolumes (),
                     viewport              = renderObject .getViewport (),
                     projectionMatrix      = renderObject .getProjectionMatrix (),
                     modelViewMatrix       = renderObject .getModelViewMatrix (),
                     firstOpaqueShape      = renderObject .getNumOpaqueShapes (),
                     firstTransparentShape = renderObject .getNumTransparentShapes ();

                  viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                  modelViewMatrix .push ();
                  modelViewMatrix .identity ();

                  this .group .traverse (type, renderObject);

                  modelViewMatrix .pop ();
                  viewVolumes     .pop ();

                  const
                     lastOpaqueShape      = renderObject .getNumOpaqueShapes (),
                     lastTransparentShape = renderObject .getNumTransparentShapes ();

                  this .opaqueShapes      = renderObject .getOpaqueShapes () .splice (firstOpaqueShape, lastOpaqueShape - firstOpaqueShape);
                  this .transparentShapes = renderObject .getTransparentShapes () .splice (firstTransparentShape, lastTransparentShape - firstTransparentShape);

                  renderObject .setNumOpaqueShapes (firstOpaqueShape);
                  renderObject .setNumTransparentShapes (firstTransparentShape);
               }

               const modelViewMatrix = renderObject .getModelViewMatrix ();

               for (const opaqueShape of this .opaqueShapes)
               {
                  modelViewMatrix .push ();
                  modelViewMatrix .multLeft (opaqueShape .modelViewMatrix);
                  opaqueShape .shapeNode .traverse (type, renderObject);
                  modelViewMatrix .pop ();
               }

               for (const transparentShape of this .transparentShapes)
               {
                  modelViewMatrix .push ();
                  modelViewMatrix .multLeft (transparentShape .modelViewMatrix);
                  transparentShape .shapeNode .traverse (type, renderObject);
                  modelViewMatrix .pop ();
               }

               return;
            }
         }
      };
   })(),
});

/* harmony default export */ const Grouping_StaticGroup = (StaticGroup);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/Switch.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function Switch (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Switch);

   if (executionContext .getSpecificationVersion () === "2.0")
      this .addAlias ("choice", this ._children);

   this .childNode     = null;
   this .visibleNode   = null;
   this .boundedObject = null;
}

Switch .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: Switch,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "whichChoice",    new x_ite_Fields.SFInt32 (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",       new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Switch";
   },
   getComponentName: function ()
   {
      return "Grouping";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Grouping_X3DGroupingNode.prototype.initialize.call (this);

      this ._whichChoice .addInterest ("set_child__", this);
      this ._children    .addInterest ("set_child__", this);

      this .set_child__ ();
   },
   getSubBBox: function (bbox, shadows)
   {
      if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
      {
         const boundedObject = X3DCast (Base_X3DConstants.X3DBoundedObject, this .visibleNode);

         if (boundedObject)
            return boundedObject .getBBox (bbox, shadows);

         return bbox .set ();
      }

      return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
   },
   clear: function () { },
   add: function () { },
   remove: function () { },
   set_child__: function ()
   {
      if (this .childNode)
      {
         this .childNode ._isCameraObject   .removeInterest ("set_cameraObject__",     this);
         this .childNode ._isPickableObject .removeInterest ("set_transformSensors__", this);
      }

      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .childNode ._visible     .removeInterest ("set_visible__",     this);
         this .childNode ._bboxDisplay .removeInterest ("set_bboxDisplay__", this);
      }

      const whichChoice = this ._whichChoice .getValue ();

      if (whichChoice >= 0 && whichChoice < this ._children .length)
      {
         this .childNode = X3DCast (Base_X3DConstants.X3DChildNode, this ._children [whichChoice]);

         if (this .childNode)
         {
            this .childNode ._isCameraObject   .addInterest ("set_cameraObject__",     this);
            this .childNode ._isPickableObject .addInterest ("set_transformSensors__", this);

            if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
            {
               this .childNode ._visible     .addInterest ("set_visible__",     this);
               this .childNode ._bboxDisplay .addInterest ("set_bboxDisplay__", this);
            }

            delete this .traverse;
         }
      }
      else
      {
         this .childNode = null;

         this .traverse = Function .prototype;
      }

      this .set_transformSensors__ ();
      this .set_visible__ ();
      this .set_bboxDisplay__ ();
   },
   set_cameraObject__: function ()
   {
      if (this .childNode && this .childNode .getCameraObject ())
      {
         if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
         {
            this .setCameraObject (this .childNode ._visible .getValue ());
         }
         else
         {
            this .setCameraObject (true);
         }
      }
      else
      {
         this .setCameraObject (false);
      }
   },
   set_transformSensors__: function ()
   {
      this .setPickableObject (Boolean (this .getTransformSensors () .size || this .childNode && this .childNode .getPickableObject ()));
   },
   set_visible__: function ()
   {
      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .visibleNode = this .childNode ._visible .getValue () ? this .childNode : null;
      }
      else
      {
         this .visibleNode = this .childNode;
      }

      this .set_cameraObject__ ();
   },
   set_bboxDisplay__: function ()
   {
      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .boundedObject = this .childNode ._bboxDisplay .getValue () ? this .childNode : null;
      }
      else
      {
         this .boundedObject = null;
      }
   },
   traverse: function (type, renderObject)
   {
      switch (type)
      {
         case Rendering_TraverseType.POINTER:
         case Rendering_TraverseType.CAMERA:
         case Rendering_TraverseType.SHADOW:
         {
            const visibleNode = this .visibleNode;

            if (visibleNode)
               visibleNode .traverse (type, renderObject);

            return;
         }
         case Rendering_TraverseType.PICKING:
         {
            if (this .getTransformSensors () .size)
            {
               const modelMatrix = renderObject .getModelViewMatrix () .get ();

               for (const transformSensorNode of this .getTransformSensors ())
                  transformSensorNode .collect (modelMatrix);
            }

            const childNode = this .childNode;

            if (childNode)
            {
               const
                  browser          = this .getBrowser (),
                  pickingHierarchy = browser .getPickingHierarchy ();

               pickingHierarchy .push (this);

               childNode .traverse (type, renderObject);

               pickingHierarchy .pop ();
            }

            return;
         }
         case Rendering_TraverseType.COLLISION:
         {
            const childNode = this .childNode;

            if (childNode)
               childNode .traverse (type, renderObject);

            return;
         }
         case Rendering_TraverseType.DISPLAY:
         {
            const visibleNode = this .visibleNode;

            if (visibleNode)
               visibleNode .traverse (type, renderObject);

            const boundedObject = this .boundedObject;

            if (boundedObject)
               boundedObject .displayBBox (type, renderObject);

            return;
         }
      }
   },
});

/* harmony default export */ const Grouping_Switch = (Switch);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/X3DTransformMatrix3DNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function X3DTransformMatrix3DNode (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTransformMatrix3DNode);

   this .matrix   = new Numbers_Matrix4 ();
   this .getBBox  = this .getGetGroupBBox ();
   this .traverse = this .getGroupTraverse ();
}

X3DTransformMatrix3DNode .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: X3DTransformMatrix3DNode,
   setMatrix: function (matrix)
   {
      if (matrix .equals (Numbers_Matrix4.Identity))
      {
         this .matrix .identity ();

         this .getBBox  = this .getGetGroupBBox ();
         this .traverse = this .getGroupTraverse ();
      }
      else
      {
         this .matrix .assign (matrix);

         this .getBBox  = this .getGetBBox ();
         this .traverse = this .getTraverse ();
      }
   },
   getMatrix: function ()
   {
      return this .matrix;
   },
   setTransform: function (t, r, s, so, c)
   {
      if (t .equals (Numbers_Vector3.Zero) && r .equals (Numbers_Rotation4.Identity) && s .equals (Numbers_Vector3.One))
      {
         this .matrix .identity ();

         this .getBBox  = this .getGetGroupBBox ();
         this .traverse = this .getGroupTraverse ();
      }
      else
      {
         this .matrix .set (t, r, s, so, c);

         this .getBBox  = this .getGetBBox ();
         this .traverse = this .getTraverse ();
      }
   },
   getGetBBox: (function ()
   {
      function getBBox (bbox, shadows)
      {
         return this .getSubBBox (bbox, shadows) .multRight (this .matrix);
      }

      return function ()
      {
         return getBBox;
      };
   })(),
   getGetGroupBBox: function ()
   {
      return Grouping_X3DGroupingNode.prototype.getBBox;
   },
   getTraverse: (function ()
   {
      function traverse (type, renderObject)
      {
         const modelViewMatrix = renderObject .getModelViewMatrix ();

         modelViewMatrix .push ();
         modelViewMatrix .multLeft (this .matrix);

         Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);

         modelViewMatrix .pop ();
      }

      return function ()
      {
         return traverse;
      };
   })(),
   getGroupTraverse: function ()
   {
      return Grouping_X3DGroupingNode.prototype.traverse;
   },
});

/* harmony default export */ const Grouping_X3DTransformMatrix3DNode = (X3DTransformMatrix3DNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/X3DTransformNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DTransformNode (executionContext)
{
   Grouping_X3DTransformMatrix3DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTransformNode);

   this ._translation .setUnit ("length");
   this ._center      .setUnit ("length");
}

X3DTransformNode .prototype = Object .assign (Object .create (Grouping_X3DTransformMatrix3DNode.prototype),
{
   constructor: X3DTransformNode,
   initialize: function ()
   {
      Grouping_X3DTransformMatrix3DNode.prototype.initialize.call (this);

      this .addInterest ("eventsProcessed", this);

      this .eventsProcessed ();
   },
   eventsProcessed: function ()
   {
      this .setTransform (this ._translation      .getValue (),
                          this ._rotation         .getValue (),
                          this ._scale            .getValue (),
                          this ._scaleOrientation .getValue (),
                          this ._center           .getValue ());
   },
});

/* harmony default export */ const Grouping_X3DTransformNode = (X3DTransformNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping/Transform.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Transform (executionContext)
{
   Grouping_X3DTransformNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Transform);
}

Transform .prototype = Object .assign (Object .create (Grouping_X3DTransformNode.prototype),
{
   constructor: Transform,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "translation",      new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "rotation",         new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "scale",            new x_ite_Fields.SFVec3f (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "scaleOrientation", new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "center",           new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",      new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",         new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",       new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",      new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren",   new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",         new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Transform";
   },
   getComponentName: function ()
   {
      return "Grouping";
   },
   getContainerField: function ()
   {
      return "children";
   },
});

/* harmony default export */ const Grouping_Transform = (Transform);

;// CONCATENATED MODULE: ./src/x_ite/Components/Grouping.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const Grouping_Types =
{
   Group:       Grouping_Group,
   StaticGroup: Grouping_StaticGroup,
   Switch:      Grouping_Switch,
   Transform:   Grouping_Transform,
};

const Grouping_AbstractTypes =
{
   X3DBoundedObject:         Grouping_X3DBoundedObject,
   X3DGroupingNode:          Grouping_X3DGroupingNode,
   X3DTransformMatrix3DNode: Grouping_X3DTransformMatrix3DNode,
   X3DTransformNode:         Grouping_X3DTransformNode,
};

for (const typeName in Grouping_Types)
   Configuration_SupportedNodes.addType (typeName, Grouping_Types [typeName]);

for (const typeName in Grouping_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Grouping_AbstractTypes [typeName]);

/* harmony default export */ const Grouping = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/ColorInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function ColorInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ColorInterpolator);

   this .hsv = [ ];
}

ColorInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: ColorInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFColor ()),
   ]),
   getTypeName: function ()
   {
      return "ColorInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const keyValue = this ._keyValue;

      if (keyValue .length < this ._key .length)
         this ._keyValue .resize (this ._key .length, keyValue .length ? keyValue [this ._keyValue .length - 1] : new x_ite_Fields.SFColor ());

      this .hsv .length = 0;

      for (const value of keyValue)
         this .hsv .push (value .getHSV ([ ]));
   },
   interpolate: (function ()
   {
      const value = [ ];

      return function (index0, index1, weight)
      {
         Numbers_Color3.lerp (this .hsv [index0], this .hsv [index1], weight, value);

         this ._value_changed .setHSV (value [0], value [1], value [2]);
      };
   })(),
});

/* harmony default export */ const Interpolation_ColorInterpolator = (ColorInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/CoordinateInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function CoordinateInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.CoordinateInterpolator);
}

CoordinateInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: CoordinateInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "CoordinateInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   set_keyValue__: function () { },
   interpolate: function (index0, index1, weight)
   {
      const keyValue = this ._keyValue .getValue ();

      let size = this ._key .length ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

      this ._value_changed .length = size;

      const value_changed = this ._value_changed .getValue ();

      index0 *= size;
      index1  = index0 + (this ._key .length > 1 ? size : 0);

      index0 *= 3;
      index1 *= 3;
      size   *= 3;

      for (let i0 = 0; i0 < size; i0 += 3)
      {
         const
            i1 = i0 + 1,
            i2 = i0 + 2;

         value_changed [i0] = Math_Algorithm.lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
         value_changed [i1] = Math_Algorithm.lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
         value_changed [i2] = Math_Algorithm.lerp (keyValue [index0 + i2], keyValue [index1 + i2], weight);
      }

      this ._value_changed .addEvent ();
   },
});

/* harmony default export */ const Interpolation_CoordinateInterpolator = (CoordinateInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/CoordinateInterpolator2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function CoordinateInterpolator2D (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.CoordinateInterpolator2D);
}

CoordinateInterpolator2D .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: CoordinateInterpolator2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "CoordinateInterpolator2D";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   set_keyValue__: function () { },
   interpolate: function (index0, index1, weight)
   {
      const keyValue = this ._keyValue .getValue ();

      let size = this ._key .length ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

      this ._value_changed .length = size;

      const value_changed = this ._value_changed .getValue ();

      index0 *= size;
      index1  = index0 + (this ._key .length > 1 ? size : 0);

      index0 *= 2;
      index1 *= 2;
      size   *= 2;

      for (let i0 = 0; i0 < size; i0 += 2)
      {
         const i1 = i0 + 1;

         value_changed [i0] = Math_Algorithm.lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
         value_changed [i1] = Math_Algorithm.lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
      }

      this ._value_changed .addEvent ();
   },
});

/* harmony default export */ const Interpolation_CoordinateInterpolator2D = (CoordinateInterpolator2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/NormalInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function NormalInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.NormalInterpolator);
}

NormalInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: NormalInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "NormalInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function () { },
   interpolate: (function ()
   {
      const
         keyValue0 = new Numbers_Vector3 (0, 0, 0),
         keyValue1 = new Numbers_Vector3 (0, 0, 0);

      return function (index0, index1, weight)
      {
         const keyValue = this ._keyValue .getValue ();

         let size = this ._key .length > 1 ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

         this ._value_changed .length = size;

         const value_changed = this ._value_changed .getValue ();

         index0 *= size;
         index1  = index0 + size;

         index0 *= 3;
         index1 *= 3;
         size   *= 3;

         for (let i0 = 0; i0 < size; i0 += 3)
         {
            try
            {
               const
                  i1 = i0 + 1,
                  i2 = i0 + 2;

               keyValue0 .set (keyValue [index0 + i0], keyValue [index0 + i1], keyValue [index0 + i2]);
               keyValue1 .set (keyValue [index1 + i0], keyValue [index1 + i1], keyValue [index1 + i2]);

               const value = Math_Algorithm.simpleSlerp (keyValue0, keyValue1, weight);

               value_changed [i0] = value [0];
               value_changed [i1] = value [1];
               value_changed [i2] = value [2];
            }
            catch (error)
            {
               //console .log (error);
            }
         }

         this ._value_changed .addEvent ();
      };
   })(),
});

/* harmony default export */ const Interpolation_NormalInterpolator = (NormalInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/PositionInterpolator2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PositionInterpolator2D (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PositionInterpolator2D);
}

PositionInterpolator2D .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: PositionInterpolator2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "PositionInterpolator2D";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFVec2f ());
   },
   interpolate:  (function ()
   {
      const keyValue = new Numbers_Vector2 (0, 0);

      return function (index0, index1, weight)
      {
         this ._value_changed = keyValue .assign (this ._keyValue [index0] .getValue ()) .lerp (this ._keyValue [index1] .getValue (), weight);
      };
   })(),
});

/* harmony default export */ const Interpolation_PositionInterpolator2D = (PositionInterpolator2D);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/CatmullRomSplineInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





const
   T  = [ ],
   Fp = [ ],
   Fm = [ ],
   S  = new Numbers_Vector4 (0, 0, 0, 0);

const H = new Numbers_Matrix4 ( 2, -2,  1,  1,
                       -3,  3, -2, -1,
                        0,  0,  1,  0,
                        1,  0,  0,  0);

function CatmullRomSplineInterpolator ()
{
   this .T0 = [ ];
   this .T1 = [ ];
}

CatmullRomSplineInterpolator .prototype =
{
   constructor: CatmullRomSplineInterpolator,
   generate: function (closed, key, keyValue, keyVelocity, normalizeVelocity)
   {
      const
         T0 = this .T0,
         T1 = this .T1;

      T0 .length = 0;
      T1 .length = 0;

      T  .length = 0;
      Fp .length = 0;
      Fm .length = 0;

      if (key .length > 1)
      {
         // T

         if (keyVelocity .length === 0)
         {
            if (closed)
               T .push (this .divide (this .subtract (keyValue [1], keyValue [keyValue .length - 2]), 2));

            else
               T .push (this .create ());

            for (let i = 1, length = keyValue .length - 1; i < length; ++ i)
               T .push (this .divide (this .subtract (keyValue [i + 1], keyValue [i - 1]), 2));

            T .push (this .copy (T [0]));
         }
         else
         {
            for (let i = 0, length = keyVelocity .length; i < length; ++ i)
               T .push (this .copy (keyVelocity [i]));

            if (normalizeVelocity)
            {
               let Dtot = 0;

               for (let i = 0, length = keyValue .length - 1; i < length; ++ i)
                  Dtot += this .abs (this .subtract (keyValue [i], keyValue [i + 1]));

               for (let i = 0, length = T .length - 1; i < length; ++ i)
               {
                  const Tia = this .abs (T [i]);

                  if (Tia)
                     T [i] = this .multiply (T [i], Dtot / Tia);
               }
            }
         }

         // Fm, Fp

         if (closed)
         {
            const i_1 = key .length - 1;
            const i_2 = key .length - 2;

            const d = key [1] - key [0] + key [i_1] - key [i_2];

            Fm .push (2 * (key [1]   - key [0])   / d);
            Fp .push (2 * (key [i_1] - key [i_2]) / d);

         }
         else
         {
            Fm .push (1);
            Fp .push (1);
         }

         for (let i = 1, length = key .length - 1; i < length; ++ i)
         {
            const d = key [i + 1] - key [i - 1];

            Fm .push (2 * (key [i + 1] - key [i])     / d);
            Fp .push (2 * (key [i]     - key [i - 1]) / d);
         }

         Fm .push (Fm [0]);
         Fp .push (Fp [0]);

         // T0, T1

         for (let i = 0, length = T .length; i < length; ++ i)
         {
            T0 .push (this .multiply (T [i], Fp [i]));
            T1 .push (this .multiply (T [i], Fm [i]));
         }
      }
      else
      {
         T0 .push (this .create ());
         T1 .push (this .create ());
      }
   },
   interpolate: function (index0, index1, weight, keyValue)
   {
      S .set (Math .pow (weight, 3), Math .pow (weight, 2), weight, 1);

      // Taking dot product from SH and C;

      return this .dot (H .multVecMatrix (S),
                        keyValue [index0],
                        keyValue [index1],
                        this .T0 [index0],
                        this .T1 [index1]);
   },
};

/* harmony default export */ const Interpolation_CatmullRomSplineInterpolator = (CatmullRomSplineInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




/* harmony default export */ function CatmullRomSplineInterpolatorTemplate(Type)
{
   const
      c0 = new Type (0, 0, 0, 0),
      c1 = new Type (0, 0, 0, 0),
      c2 = new Type (0, 0, 0, 0),
      c3 = new Type (0, 0, 0, 0);

   function CatmullRomSplineInterpolatorInstance ()
   {
      this .T0 = [ ];
      this .T1 = [ ];
   }

   CatmullRomSplineInterpolatorInstance .prototype = Object .assign (Object .create (Interpolation_CatmullRomSplineInterpolator.prototype),
   {
      constructor: CatmullRomSplineInterpolatorInstance,
      create: function ()
      {
         return new Type (0, 0, 0, 0);
      },
      copy: function (value)
      {
         return value .copy ();
      },
      subtract: function (lhs, rhs)
      {
         return Type .subtract (lhs, rhs);
      },
      multiply: function (lhs, rhs)
      {
         return Type .multiply (lhs, rhs);
      },
      divide: function (lhs, rhs)
      {
         return Type .divide (lhs, rhs);
      },
      abs: function (value)
      {
         return value .magnitude ();
      },
      dot: function (SH, C0, C1, C2, C3)
      {
         c0 .assign (C0) .multiply (SH [0]);
         c1 .assign (C1) .multiply (SH [1]);
         c2 .assign (C2) .multiply (SH [2]);
         c3 .assign (C3) .multiply (SH [3]);

         return c0 .add (c1) .add (c2) .add (c3);
      },
   });

   return CatmullRomSplineInterpolatorInstance;
};

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/CatmullRomSplineInterpolator3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





/* harmony default export */ const CatmullRomSplineInterpolator3 = (CatmullRomSplineInterpolatorTemplate (Numbers_Vector3));

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/SplinePositionInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function SplinePositionInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SplinePositionInterpolator);

   this .spline = new CatmullRomSplineInterpolator3 ();
}

SplinePositionInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: SplinePositionInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",      new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "closed",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",               new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",          new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyVelocity",       new x_ite_Fields.MFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalizeVelocity", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed",     new x_ite_Fields.SFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "SplinePositionInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue          .addInterest ("set_keyValue__",          this);
      this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
      this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFVec3f ());

      this .set_keyVelocity__ ();
   },
   set_keyVelocity__: function ()
   {
      if (this ._keyVelocity .length)
      {
         if (this ._keyVelocity .length < this ._key .length)
            this ._keyVelocity .resize (this ._key .length, new x_ite_Fields.SFVec3f ());
      }

      this .set_normalizeVelocity__ ();
   },
   set_normalizeVelocity__: function ()
   {
      this .spline .generate (this ._closed .getValue (),
                              this ._key,
                              this ._keyValue,
                              this ._keyVelocity,
                              this ._normalizeVelocity .getValue ());
   },
   interpolate: function (index0, index1, weight)
   {
      this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
   },
});

/* harmony default export */ const Interpolation_SplinePositionInterpolator = (SplinePositionInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/CatmullRomSplineInterpolator2.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





/* harmony default export */ const CatmullRomSplineInterpolator2 = (CatmullRomSplineInterpolatorTemplate (Numbers_Vector2));

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/SplinePositionInterpolator2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function SplinePositionInterpolator2D (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SplinePositionInterpolator2D);

   this .spline = new CatmullRomSplineInterpolator2 ();
}

SplinePositionInterpolator2D .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: SplinePositionInterpolator2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",      new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "closed",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",               new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",          new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyVelocity",       new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalizeVelocity", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed",     new x_ite_Fields.SFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "SplinePositionInterpolator2D";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue          .addInterest ("set_keyValue__",          this);
      this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
      this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFVec2f ());

      this .set_keyVelocity__ ();
   },
   set_keyVelocity__: function ()
   {
      if (this ._keyVelocity .length)
      {
         if (this ._keyVelocity .length < this ._key .length)
            this ._keyVelocity .resize (this ._key .length, new x_ite_Fields.SFVec2f ());
      }

      this .set_normalizeVelocity__ ();
   },
   set_normalizeVelocity__: function ()
   {
      this .spline .generate (this ._closed .getValue (),
                              this ._key,
                              this ._keyValue,
                              this ._keyVelocity,
                              this ._normalizeVelocity .getValue ());
   },
   interpolate: function (index0, index1, weight)
   {
      this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
   },
});

/* harmony default export */ const Interpolation_SplinePositionInterpolator2D = (SplinePositionInterpolator2D);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/CatmullRomSplineInterpolator1.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function CatmullRomSplineInterpolator1 ()
{
   this .T0 = [ ];
   this .T1 = [ ];
}

CatmullRomSplineInterpolator1 .prototype = Object .assign (Object .create (Interpolation_CatmullRomSplineInterpolator.prototype),
{
   constructor: CatmullRomSplineInterpolator1,
   create: function ()
   {
      return 0;
   },
   copy: function (value)
   {
      return value;
   },
   subtract: function (lhs, rhs)
   {
      return lhs - rhs;
   },
   multiply: function (lhs, rhs)
   {
      return lhs * rhs;
   },
   divide: function (lhs, rhs)
   {
      return lhs / rhs;
   },
   abs: function (value)
   {
      return Math .abs (value);
   },
   dot: function (SH, C0, C1, C2, C3)
   {
      return C0 * SH [0] + C1 * SH [1] + C2 * SH [2] + C3 * SH [3];
   },
});

/* harmony default export */ const Interpolation_CatmullRomSplineInterpolator1 = (CatmullRomSplineInterpolator1);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/SplineScalarInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function SplineScalarInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SplineScalarInterpolator);

   this .spline = new Interpolation_CatmullRomSplineInterpolator1 ();
}

SplineScalarInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: SplineScalarInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",      new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "closed",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",               new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",          new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyVelocity",       new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalizeVelocity", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed",     new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "SplineScalarInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue          .addInterest ("set_keyValue__",          this);
      this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
      this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFFloat ());

      this .set_keyVelocity__ ();
   },
   set_keyVelocity__: function ()
   {
      if (this ._keyVelocity .length)
      {
         if (this ._keyVelocity .length < this ._key .length)
            this ._keyVelocity .resize (this ._key .length, new x_ite_Fields.SFFloat ());
      }

      this .set_normalizeVelocity__ ();
   },
   set_normalizeVelocity__: function ()
   {
      this .spline .generate (this ._closed .getValue (),
                              this ._key,
                              this ._keyValue,
                              this ._keyVelocity,
                              this ._normalizeVelocity .getValue ());
   },
   interpolate: function (index0, index1, weight)
   {
      this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
   },
});

/* harmony default export */ const Interpolation_SplineScalarInterpolator = (SplineScalarInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Interpolation/SquatInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




const result = new Numbers_Rotation4 (0, 0, 1, 0);

function SquatInterpolator ()
{
   this .s = [ ];
}

SquatInterpolator .prototype =
{
   constructor: SquatInterpolator,
   generate: function (closed, key, keyValue)
   {
      const s = this .s;

      s .length = 0;

      if (key .length > 1)
      {
         if (closed)
         {
            s .push (Numbers_Rotation4.spline (keyValue [key .length - 2] .getValue (),
                                        keyValue [0] .getValue (),
                                        keyValue [1] .getValue ()));
         }
         else
         {
            s .push (keyValue [0] .getValue ());
         }

         for (let i = 1, length = key .length - 1; i < length; ++ i)
         {
            s .push (Numbers_Rotation4.spline (keyValue [i - 1] .getValue (),
                                        keyValue [i]     .getValue (),
                                        keyValue [i + 1] .getValue ()));
         }

         if (closed)
         {
            s .push (Numbers_Rotation4.spline (keyValue [key .length - 2] .getValue (),
                                        keyValue [key .length - 1] .getValue (),
                                        keyValue [1] .getValue ()));
         }
         else
         {
            s .push (keyValue [key .length - 1] .getValue ());
         }
      }
      else if (key .length > 0)
         s .push (keyValue [0] .getValue () .copy ());
   },
   interpolate: function (index0, index1, weight, keyValue)
   {
      return result .assign (keyValue [index0] .getValue ()) .squad (this .s [index0],
                                                                     this .s [index1],
                                                                     keyValue [index1] .getValue (), weight);
   },
};

/* harmony default export */ const Interpolation_SquatInterpolator = (SquatInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation/SquadOrientationInterpolator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function SquadOrientationInterpolator (executionContext)
{
   Interpolation_X3DInterpolatorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SquadOrientationInterpolator);

   this ._keyValue      .setUnit ("angle");
   this ._value_changed .setUnit ("angle");

   this .squad = new Interpolation_SquatInterpolator ();
}

SquadOrientationInterpolator .prototype = Object .assign (Object .create (Interpolation_X3DInterpolatorNode.prototype),
{
   constructor: SquadOrientationInterpolator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,   "set_fraction",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "closed",        new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "key",           new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "keyValue",      new x_ite_Fields.MFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "value_changed", new x_ite_Fields.SFRotation ()),
   ]),
   getTypeName: function ()
   {
      return "SquadOrientationInterpolator";
   },
   getComponentName: function ()
   {
      return "Interpolation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Interpolation_X3DInterpolatorNode.prototype.initialize.call (this);

      this ._keyValue    .addInterest ("set_keyValue__", this);
   },
   set_keyValue__: function ()
   {
      const
         key      = this ._key,
         keyValue = this ._keyValue;

      if (keyValue .length < key .length)
         keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new x_ite_Fields.SFRotation ());

      this .squad .generate (this ._closed .getValue (),
                             this ._key,
                             this ._keyValue);
   },
   interpolate: function (index0, index1, weight)
   {
      try
      {
         this ._value_changed = this .squad .interpolate (index0, index1, weight, this ._keyValue);
      }
      catch (error)
      {
         console .error (error);
      }
   },
});

/* harmony default export */ const Interpolation_SquadOrientationInterpolator = (SquadOrientationInterpolator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Interpolation.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


















const Interpolation_Types =
{
   ColorInterpolator:            Interpolation_ColorInterpolator,
   CoordinateInterpolator:       Interpolation_CoordinateInterpolator,
   CoordinateInterpolator2D:     Interpolation_CoordinateInterpolator2D,
   EaseInEaseOut:                Interpolation_EaseInEaseOut,
   NormalInterpolator:           Interpolation_NormalInterpolator,
   OrientationInterpolator:      Interpolation_OrientationInterpolator,
   PositionInterpolator:         Interpolation_PositionInterpolator,
   PositionInterpolator2D:       Interpolation_PositionInterpolator2D,
   ScalarInterpolator:           Interpolation_ScalarInterpolator,
   SplinePositionInterpolator:   Interpolation_SplinePositionInterpolator,
   SplinePositionInterpolator2D: Interpolation_SplinePositionInterpolator2D,
   SplineScalarInterpolator:     Interpolation_SplineScalarInterpolator,
   SquadOrientationInterpolator: Interpolation_SquadOrientationInterpolator,
};

const Interpolation_AbstractTypes =
{
   X3DInterpolatorNode: Interpolation_X3DInterpolatorNode,
};

for (const typeName in Interpolation_Types)
   Configuration_SupportedNodes.addType (typeName, Interpolation_Types [typeName]);

for (const typeName in Interpolation_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Interpolation_AbstractTypes [typeName]);

/* harmony default export */ const Interpolation = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Layering.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









const Layering_Types =
{
   Layer:    Layering_Layer,
   LayerSet: Layering_LayerSet,
   Viewport: Layering_Viewport,
};

const Layering_AbstractTypes =
{
   X3DLayerNode:    Layering_X3DLayerNode,
   X3DViewportNode: Layering_X3DViewportNode,
};

for (const typeName in Layering_Types)
   Configuration_SupportedNodes.addType (typeName, Layering_Types [typeName]);

for (const typeName in Layering_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Layering_AbstractTypes [typeName]);

/* harmony default export */ const Layering = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Lighting/PointLight.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




















// Shadow map layout
// Compact layout:
//
// xzXZ		Char: Axis
// yyYY		Case: Sign

const orientationMatrices = [
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 ( 1,  0,  0), Numbers_Vector3.zAxis)), // left
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 (-1,  0,  0), Numbers_Vector3.zAxis)), // right
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 ( 0,  0, -1), Numbers_Vector3.zAxis)), // front
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 ( 0,  0,  1), Numbers_Vector3.zAxis)), // back
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 ( 0,  1,  0), Numbers_Vector3.zAxis)), // bottom
   new Numbers_Matrix4 () .setRotation (new Numbers_Rotation4 (new Numbers_Vector3 ( 0, -1,  0), Numbers_Vector3.zAxis)), // top
];

const viewports = [
   new Numbers_Vector4 (0,    0.5, 0.25, 0.5), // left
   new Numbers_Vector4 (0.5,  0.5, 0.25, 0.5), // right
   new Numbers_Vector4 (0.75, 0.5, 0.25, 0.5), // front
   new Numbers_Vector4 (0.25, 0.5, 0.25, 0.5), // back
   new Numbers_Vector4 (0.0,  0,   0.5,  0.5), // bottom
   new Numbers_Vector4 (0.5,  0,   0.5,  0.5), // top
];

const PointLights = ObjectCache (PointLightContainer);

function PointLightContainer ()
{
   this .location                      = new Numbers_Vector3 (0, 0, 0);
   this .matrixArray                   = new Float32Array (9);
   this .shadowBuffer                  = null;
   this .viewVolume                    = new Geometry_ViewVolume ();
   this .viewport                      = new Numbers_Vector4 (0, 0, 0, 0);
   this .projectionMatrix              = new Numbers_Matrix4 ();
   this .modelViewMatrix               = new Utility_MatrixStack (Numbers_Matrix4);
   this .modelMatrix                   = new Numbers_Matrix4 ();
   this .invLightSpaceMatrix           = new Numbers_Matrix4 ();
   this .invLightSpaceProjectionMatrix = new Numbers_Matrix4 ();
   this .shadowMatrix                  = new Numbers_Matrix4 ();
   this .shadowMatrixArray             = new Float32Array (16);
   this .rotation                      = new Numbers_Rotation4 ();
   this .rotationMatrix                = new Numbers_Matrix4 ();
   this .textureUnit                   = undefined;
}

PointLightContainer .prototype =
{
   constructor: PointLightContainer,
   getModelViewMatrix: function ()
   {
      return this .modelViewMatrix;
   },
   set: function (lightNode, groupNode, modelViewMatrix)
   {
      const shadowMapSize = lightNode .getShadowMapSize ();

      this .browser   = lightNode .getBrowser ();
      this .lightNode = lightNode;
      this .groupNode = groupNode;

      this .matrixArray .set (modelViewMatrix .submatrix .inverse ());

      this .modelViewMatrix .pushMatrix (modelViewMatrix);

      // Get shadow buffer from browser.

      if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
      {
         this .shadowBuffer = this .browser .popShadowBuffer (shadowMapSize);

         if (!this .shadowBuffer)
            console .warn ("Couldn't create shadow buffer.");
      }
   },
   renderShadowMap: function (renderObject)
   {
      if (! this .shadowBuffer)
         return;

      const
         lightNode           = this .lightNode,
         cameraSpaceMatrix   = renderObject .getCameraSpaceMatrix () .get (),
         modelMatrix         = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
         invLightSpaceMatrix = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Numbers_Matrix4.Identity);

      invLightSpaceMatrix .translate (lightNode .getLocation ());
      invLightSpaceMatrix .inverse ();

      const shadowMapSize  = lightNode .getShadowMapSize ();

      this .shadowBuffer .bind ();

      for (let i = 0; i < 6; ++ i)
      {
         const
            v                = viewports [i],
            viewport         = this .viewport .set (v [0] * shadowMapSize, v [1] * shadowMapSize, v [2] * shadowMapSize, v [3] * shadowMapSize),
            projectionMatrix = Camera.perspective2 (Math_Algorithm.radians (90), 0.125, 10000, viewport [2], viewport [3], this .projectionMatrix); // Use higher far value for better precision.

         renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
         renderObject .getProjectionMatrix () .pushMatrix (this .projectionMatrix);
         renderObject .getModelViewMatrix  () .pushMatrix (orientationMatrices [i]);
         renderObject .getModelViewMatrix  () .multLeft (invLightSpaceMatrix);

         renderObject .render (Rendering_TraverseType.SHADOW, Grouping_X3DGroupingNode.prototype.traverse, this .groupNode);

         renderObject .getModelViewMatrix  () .pop ();
         renderObject .getProjectionMatrix () .pop ();
         renderObject .getViewVolumes () .pop ();
      }

      this .shadowBuffer .unbind ();

      if (! lightNode .getGlobal ())
         invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

      this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix);
   },
   setGlobalVariables: function (renderObject)
   {
      this .modelViewMatrix .get () .multVecMatrix (this .location .assign (this .lightNode ._location .getValue ()));

      if (! this .shadowBuffer)
         return;
         
      this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
      this .shadowMatrixArray .set (this .shadowMatrix);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const i = shaderObject .numLights ++;

      if (this .shadowBuffer)
      {
         const textureUnit = this .lightNode .getGlobal ()
            ? (this .textureUnit = this .textureUnit !== undefined
               ? this .textureUnit
               : this .browser .popTexture2DUnit ())
            : this .browser .getTexture2DUnit ();

         if (textureUnit !== undefined)
         {
            gl .activeTexture (gl .TEXTURE0 + textureUnit);

            if (gl .HAS_FEATURE_DEPTH_TEXTURE)
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
            else
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

            gl .uniform1i (shaderObject .x3d_ShadowMap [i], textureUnit);
         }
         else
         {
            console .warn ("Not enough combined texture units for shadow map available.");
         }
      }

      if (shaderObject .hasLight (i, this))
         return;

      const
         lightNode   = this .lightNode,
         color       = lightNode .getColor (),
         attenuation = lightNode .getAttenuation (),
         location    = this .location;

      gl .uniform1i        (shaderObject .x3d_LightType [i],             2);
      gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
      gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
      gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
      gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
      gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
      gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
      gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

      if (this .shadowBuffer)
      {
         const shadowColor = lightNode .getShadowColor ();

         gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
         gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
         gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
         gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
         gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
      }
   },
   dispose: function ()
   {
      this .browser .pushShadowBuffer (this .shadowBuffer);
      this .browser .pushTexture2DUnit (this .textureUnit);

      this .modelViewMatrix .clear ();

      this .shadowBuffer = null;
      this .textureUnit  = undefined;

      // Return container

      PointLights .push (this);
   },
};

function PointLight (executionContext)
{
   Lighting_X3DLightNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PointLight);

   this ._location .setUnit ("length");
   this ._radius   .setUnit ("length");
}

PointLight .prototype = Object .assign (Object .create (Lighting_X3DLightNode.prototype),
{
   constructor: PointLight,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "global",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "on",               new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",            new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "intensity",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "ambientIntensity", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attenuation",      new x_ite_Fields.SFVec3f (1, 0, 0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "location",         new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "radius",           new x_ite_Fields.SFFloat (100)),

      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadows",         new  x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowColor",     new  x_ite_Fields.SFColor ()),        // Color of shadows.
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowIntensity", new  x_ite_Fields.SFFloat (1)),        // Intensity of shadow color in the range (0, 1).
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowBias",      new  x_ite_Fields.SFFloat (0.005)),   // Bias of the shadow.
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "shadowMapSize",   new  x_ite_Fields.SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
   ]),
   getTypeName: function ()
   {
      return "PointLight";
   },
   getComponentName: function ()
   {
      return "Lighting";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getAttenuation: function ()
   {
      return this ._attenuation .getValue ();
   },
   getLocation: function ()
   {
      return this ._location .getValue ();
   },
   getRadius: function ()
   {
      return Math .max (0, this ._radius .getValue ());
   },
   getLights: function ()
   {
      return PointLights;
   },
});

/* harmony default export */ const Lighting_PointLight = (PointLight);

;// CONCATENATED MODULE: ./src/x_ite/Components/Lighting/SpotLight.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





















const SpotLights = ObjectCache (SpotLightContainer);

function SpotLightContainer ()
{
   this .location                      = new Numbers_Vector3 (0, 0, 0);
   this .direction                     = new Numbers_Vector3 (0, 0, 0);
   this .matrixArray                   = new Float32Array (9);
   this .renderShadow                  = true;
   this .shadowBuffer                  = null;
   this .bbox                          = new Geometry_Box3 ();
   this .viewVolume                    = new Geometry_ViewVolume ();
   this .viewport                      = new Numbers_Vector4 (0, 0, 0, 0);
   this .projectionMatrix              = new Numbers_Matrix4 ();
   this .modelViewMatrix               = new Utility_MatrixStack (Numbers_Matrix4);
   this .modelMatrix                   = new Numbers_Matrix4 ();
   this .invLightSpaceMatrix           = new Numbers_Matrix4 ();
   this .invLightSpaceProjectionMatrix = new Numbers_Matrix4 ();
   this .shadowMatrix                  = new Numbers_Matrix4 ();
   this .shadowMatrixArray             = new Float32Array (16);
   this .rotation                      = new Numbers_Rotation4 ();
   this .lightBBoxMin                  = new Numbers_Vector3 (0, 0, 0);
   this .lightBBoxMax                  = new Numbers_Vector3 (0, 0, 0);
   this .textureUnit                   = undefined;
}

SpotLightContainer .prototype =
{
   constructor: SpotLightContainer,
   getModelViewMatrix: function ()
   {
      return this .modelViewMatrix;
   },
   set: function (lightNode, groupNode, modelViewMatrix)
   {
      const shadowMapSize = lightNode .getShadowMapSize ();

      this .browser   = lightNode .getBrowser ();
      this .lightNode = lightNode;
      this .groupNode = groupNode;

      this .matrixArray .set (modelViewMatrix .submatrix .inverse ());

      this .modelViewMatrix .pushMatrix (modelViewMatrix);

      // Get shadow buffer from browser.

      if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
      {
         this .shadowBuffer = this .browser .popShadowBuffer (shadowMapSize);

         if (!this .shadowBuffer)
            console .warn ("Couldn't create shadow buffer.");
      }
   },
   renderShadowMap: function (renderObject)
   {
      if (! this .shadowBuffer)
         return;

      const
         lightNode            = this .lightNode,
         cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
         modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
         invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Numbers_Matrix4.Identity);

      invLightSpaceMatrix .translate (lightNode .getLocation ());
      invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Numbers_Vector3.zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
      invLightSpaceMatrix .inverse ();

      const
         groupBBox        = this .groupNode .getSubBBox (this .bbox, true),                 // Group bbox.
         lightBBox        = groupBBox .multRight (invLightSpaceMatrix),                     // Group bbox from the perspective of the light.
         lightBBoxExtents = lightBBox .getExtents (this .lightBBoxMin, this .lightBBoxMax), // Result not used, but arguments.
         shadowMapSize    = lightNode .getShadowMapSize (),
         farValue         = Math .min (lightNode .getRadius (), -this .lightBBoxMin .z),
         viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
         projectionMatrix = Camera.perspective (lightNode .getCutOffAngle () * 2, 0.125, Math .max (10000, farValue), shadowMapSize, shadowMapSize, this .projectionMatrix); // Use higher far value for better precision.

      this .renderShadow = farValue > 0;

      this .shadowBuffer .bind ();

      renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
      renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
      renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

      renderObject .render (Rendering_TraverseType.SHADOW, Grouping_X3DGroupingNode.prototype.traverse, this .groupNode);

      renderObject .getModelViewMatrix  () .pop ();
      renderObject .getProjectionMatrix () .pop ();
      renderObject .getViewVolumes      () .pop ();

      this .shadowBuffer .unbind ();

      if (! lightNode .getGlobal ())
         invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

      this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
   },
   setGlobalVariables: function (renderObject)
   {
      const
         lightNode       = this .lightNode,
         modelViewMatrix = this .modelViewMatrix .get ();

      modelViewMatrix .multVecMatrix (this .location  .assign (lightNode ._location  .getValue ()));
      modelViewMatrix .multDirMatrix (this .direction .assign (lightNode ._direction .getValue ())) .normalize ();

      if (! this .shadowBuffer)
         return;

      this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
      this .shadowMatrixArray .set (this .shadowMatrix);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const i = shaderObject .numLights ++;

      if (this .shadowBuffer)
      {
         const textureUnit = this .lightNode .getGlobal ()
            ? (this .textureUnit = this .textureUnit !== undefined
               ? this .textureUnit
               : this .browser .popTexture2DUnit ())
            : this .browser .getTexture2DUnit ();

         if (textureUnit !== undefined)
         {
            gl .activeTexture (gl .TEXTURE0 + textureUnit);

            if (gl .HAS_FEATURE_DEPTH_TEXTURE)
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
            else
               gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

            gl .uniform1i (shaderObject .x3d_ShadowMap [i], textureUnit);
         }
         else
         {
            console .warn ("Not enough combined texture units for shadow map available.");
         }
      }

      if (shaderObject .hasLight (i, this))
         return;

      const
         lightNode   = this .lightNode,
         color       = lightNode .getColor (),
         attenuation = lightNode .getAttenuation (),
         location    = this .location,
         direction   = this .direction;

      gl .uniform1i        (shaderObject .x3d_LightType [i],             3);
      gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
      gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
      gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
      gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
      gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
      gl .uniform3f        (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);
      gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
      gl .uniform1f        (shaderObject .x3d_LightBeamWidth [i],        lightNode .getBeamWidth ());
      gl .uniform1f        (shaderObject .x3d_LightCutOffAngle [i],      lightNode .getCutOffAngle ());
      gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

      if (this .renderShadow && this .shadowBuffer)
      {
         const shadowColor = lightNode .getShadowColor ();

         gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
         gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
         gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
         gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
         gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
      }
   },
   dispose: function ()
   {
      this .browser .pushShadowBuffer (this .shadowBuffer);
      this .browser .pushTexture2DUnit (this .textureUnit);

      this .modelViewMatrix .clear ();

      this .shadowBuffer = null;
      this .textureUnit  = undefined;

      // Return container

      SpotLights .push (this);
   },
};

function SpotLight (executionContext)
{
   Lighting_X3DLightNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SpotLight);

   switch (executionContext .getSpecificationVersion ())
   {
      case "2.0":
      case "3.0":
      case "3.1":
      case "3.2":
      {
         this ._beamWidth   = 1.5708;
         this ._cutOffAngle = 0.785398;
      }
   }

   this ._location    .setUnit ("length");
   this ._radius      .setUnit ("length");
   this ._beamWidth   .setUnit ("angle");
   this ._cutOffAngle .setUnit ("angle");
}

SpotLight .prototype = Object .assign (Object .create (Lighting_X3DLightNode.prototype),
{
   constructor: SpotLight,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "global",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "on",               new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",            new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "intensity",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "ambientIntensity", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attenuation",      new x_ite_Fields.SFVec3f (1, 0, 0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "location",         new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "direction",        new x_ite_Fields.SFVec3f (0, 0, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "radius",           new x_ite_Fields.SFFloat (100)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "beamWidth",        new x_ite_Fields.SFFloat (0.785398)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "cutOffAngle",      new x_ite_Fields.SFFloat (1.5708)),

      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadows",         new  x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowColor",     new  x_ite_Fields.SFColor ()),        // Color of shadows.
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowIntensity", new  x_ite_Fields.SFFloat (1)),       // Intensity of shadow color in the range (0, 1).
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "shadowBias",      new  x_ite_Fields.SFFloat (0.005)),   // Bias of the shadow.
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "shadowMapSize",   new  x_ite_Fields.SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
   ]),
   getTypeName: function ()
   {
      return "SpotLight";
   },
   getComponentName: function ()
   {
      return "Lighting";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getAttenuation: function ()
   {
      return this ._attenuation .getValue ();
   },
   getLocation: function ()
   {
      return this ._location .getValue ();
   },
   getRadius: function ()
   {
      return Math .max (0, this ._radius .getValue ());
   },
   getBeamWidth: function ()
   {
      // If the beamWidth is greater than the cutOffAngle, beamWidth is defined to be equal to the cutOffAngle.

      const
         beamWidth   = this ._beamWidth .getValue (),
         cutOffAngle = this .getCutOffAngle ();

      if (beamWidth > cutOffAngle)
         return cutOffAngle;

      return Math_Algorithm.clamp (beamWidth, 0, Math .PI / 2);
   },
   getCutOffAngle: function ()
   {
      return Math_Algorithm.clamp (this ._cutOffAngle .getValue (), 0, Math .PI / 2);
   },
   getLights: function ()
   {
      return SpotLights;
   },
});

/* harmony default export */ const Lighting_SpotLight = (SpotLight);

;// CONCATENATED MODULE: ./src/x_ite/Components/Lighting.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const Lighting_Types =
{
   DirectionalLight: Lighting_DirectionalLight,
   PointLight:       Lighting_PointLight,
   SpotLight:        Lighting_SpotLight,
};

const Lighting_AbstractTypes =
{
   X3DLightNode: Lighting_X3DLightNode,
};

for (const typeName in Lighting_Types)
   Configuration_SupportedNodes.addType (typeName, Lighting_Types [typeName]);

for (const typeName in Lighting_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Lighting_AbstractTypes [typeName]);

/* harmony default export */ const Lighting = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/Billboard.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function Billboard (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Billboard);

   this .matrix = new Numbers_Matrix4 ();
}

Billboard .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: Billboard,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "axisOfRotation", new x_ite_Fields.SFVec3f (0, 1, 0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",       new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Billboard";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   getBBox: function (bbox, shadows)
   {
      return Grouping_X3DGroupingNode.prototype.getBBox.call (this, bbox, shadows) .multRight (this .matrix);
   },
   getMatrix: function ()
   {
      return this .matrix;
   },
   rotate: (function ()
   {
      const
         inverseModelViewMatrix = new Numbers_Matrix4 (),
         viewerYAxis            = new Numbers_Vector3 (0, 0, 0),
         y                      = new Numbers_Vector3 (0, 0, 0),
         N1                     = new Numbers_Vector3 (0, 0, 0),
         N2                     = new Numbers_Vector3 (0, 0, 0),
         rotation               = new Numbers_Rotation4 (0, 0, 1, 0);

      return function (modelViewMatrix)
      {
         // throws domain error

         inverseModelViewMatrix .assign (modelViewMatrix) .inverse ();

         const billboardToViewer = inverseModelViewMatrix .origin .normalize (); // Normalized to get work with Geo

         if (this ._axisOfRotation .getValue () .equals (Numbers_Vector3.Zero))
         {
            inverseModelViewMatrix .multDirMatrix (viewerYAxis .assign (Numbers_Vector3.yAxis)) .normalize (); // Normalized to get work with Geo

            const x = viewerYAxis .cross (billboardToViewer);
            y .assign (billboardToViewer) .cross (x);
            const z = billboardToViewer;

            // Compose rotation

            x .normalize ();
            y .normalize ();

            this .matrix .set (x .x, x .y, x .z, 0,
                               y .x, y .y, y .z, 0,
                               z .x, z .y, z .z, 0,
                               0,    0,    0,    1);
         }
         else
         {
            N1 .assign (this ._axisOfRotation .getValue ()) .cross (billboardToViewer); // Normal vector of plane as in specification
            N2 .assign (this ._axisOfRotation .getValue ()) .cross (Numbers_Vector3.zAxis);    // Normal vector of plane between axisOfRotation and zAxis

            this .matrix .setRotation (rotation .setFromToVec (N2, N1));                // Rotate zAxis in plane
         }

         return this .matrix;
      };
   })(),
   traverse: function (type, renderObject)
   {
      const modelViewMatrix = renderObject .getModelViewMatrix ();

      modelViewMatrix .push ();

      switch (type)
      {
         case Rendering_TraverseType.CAMERA:
         case Rendering_TraverseType.PICKING:
         case Rendering_TraverseType.SHADOW:
            // No clone support for shadows, generated cube map texture, and bbox
            modelViewMatrix .multLeft (this .matrix);
            break;
         default:
            modelViewMatrix .multLeft (this .rotate (modelViewMatrix .get ()));
            break;
      }

      Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);

      modelViewMatrix .pop ();
   },
});

/* harmony default export */ const Navigation_Billboard = (Billboard);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/Collision.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Collision (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);
   Core_X3DSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Collision);

   if (executionContext .getSpecificationVersion () === "2.0")
      this .addAlias ("collide", this ._enabled); // VRML2
}

Collision .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
   Core_X3DSensorNode.prototype,
{
   constructor: Collision,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "enabled",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",       new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "collideTime",    new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",        new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",       new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "proxy",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",    new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren", new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",       new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Collision";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Grouping_X3DGroupingNode.prototype.initialize.call (this);
      //X3DSensorNode   .prototype .initialize .call (this); // We can only call the base of a *Objects.

      this .isLive () .addInterest ("set_live__", this);
      this ._enabled  .addInterest ("set_live__", this);
      this ._proxy    .addInterest ("set_proxy__", this);

      this .set_live__ ();
      this .set_proxy__ ();
   },
   set_live__: function ()
   {
      if (this .isLive () .getValue () && this ._enabled .getValue ())
         this .getBrowser () .addCollision (this);

      else
         this .getBrowser () .removeCollision (this);
   },
   set_active: function (value)
   {
      if (this ._isActive .getValue () !== value)
      {
         this ._isActive = value;

         if (value)
            this ._collideTime = this .getBrowser () .getCurrentTime ();
      }
   },
   set_proxy__: function ()
   {
      this .proxyNode = X3DCast (Base_X3DConstants.X3DChildNode, this ._proxy);
   },
   traverse: function (type, renderObject)
   {
      switch (type)
      {
         case Rendering_TraverseType.COLLISION:
         {
            if (this ._enabled .getValue ())
            {
               const collisions = renderObject .getCollisions ();

               collisions .push (this);

               if (this .proxyNode)
                  this .proxyNode .traverse (type, renderObject);

               else
                  Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);

               collisions .pop ();
            }

            return;
         }
         default:
         {
            Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);
            return;
         }
      }
   },
});

/* harmony default export */ const Navigation_Collision = (Collision);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/LOD.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function LOD (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);

   this .addType (Base_X3DConstants.LOD);

   if (executionContext .getSpecificationVersion () === "2.0")
      this .addAlias ("level", this ._children); // VRML2

   this ._center .setUnit ("length");
   this ._range  .setUnit ("length");

   this .frameRate        = 60;
   this .keepCurrentLevel = false;
   this .childNode        = null;
   this .visibleNode      = null;
   this .boundedObject    = null;
}

LOD .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
{
   constructor: LOD,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "forceTransitions", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "center",           new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "range",            new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "level_changed",    new x_ite_Fields.SFInt32 (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",      new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",         new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",       new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",      new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren",   new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",         new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "LOD";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Grouping_X3DGroupingNode.prototype.initialize.call (this);

      this ._children .addInterest ("set_child__", this);
   },
   getSubBBox: function (bbox, shadows)
   {
      if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
      {
         const boundedObject = X3DCast (Base_X3DConstants.X3DBoundedObject, this .visibleNode);

         if (boundedObject)
            return boundedObject .getBBox (bbox, shadows);

         return bbox .set ();
      }

      return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
   },
   clear: function () { },
   add: function () { },
   remove: function () { },
   set_child__: function ()
   {
      this .set_level__ (Math .min (this ._level_changed .getValue (), this ._children .length - 1));
   },
   set_level__: function (level)
   {
      if (this .childNode)
      {
         this .childNode ._isCameraObject   .removeInterest ("set_cameraObject__",     this);
         this .childNode ._isPickableObject .removeInterest ("set_transformSensors__", this);
      }

      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .childNode ._visible     .removeInterest ("set_visible__",     this);
         this .childNode ._bboxDisplay .removeInterest ("set_bboxDisplay__", this);
      }

      if (level >= 0 && level < this ._children .length)
      {
         this .childNode = X3DCast (Base_X3DConstants.X3DChildNode, this ._children [level]);

         if (this .childNode)
         {
            this .childNode ._isCameraObject   .addInterest ("set_cameraObject__",     this);
            this .childNode ._isPickableObject .addInterest ("set_transformSensors__", this);

            if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
            {
               this .childNode ._visible     .addInterest ("set_visible__",     this);
               this .childNode ._bboxDisplay .addInterest ("set_bboxDisplay__", this);
            }

            //delete this .traverse;
         }
      }
      else
      {
         this .childNode = null;

         //this .traverse = Function .prototype; // Don't do that.
      }

      this .set_transformSensors__ ();
      this .set_visible__ ();
      this .set_bboxDisplay__ ();
   },
   set_cameraObject__: function ()
   {
      if (this .childNode && this .childNode .getCameraObject ())
      {
         if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
         {
            this .setCameraObject (this .childNode ._visible .getValue ());
         }
         else
         {
            this .setCameraObject (true);
         }
      }
      else
      {
         this .setCameraObject (false);
      }
   },
   set_transformSensors__: function ()
   {
      this .setPickableObject (Boolean (this .getTransformSensors () .size || this .childNode && this .childNode .getPickableObject ()));
   },
   set_visible__: function ()
   {
      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .visibleNode = this .childNode ._visible .getValue () ? this .childNode : null;
      }
      else
      {
         this .visibleNode = this .childNode;
      }

      this .set_cameraObject__ ();
   },
   set_bboxDisplay__: function ()
   {
      if (X3DCast (Base_X3DConstants.X3DBoundedObject, this .childNode))
      {
         this .boundedObject = this .childNode ._bboxDisplay .getValue () ? this .childNode : null;
      }
      else
      {
         this .boundedObject = null;
      }
   },
   getLevel: (function ()
   {
      const
         FRAMES         = 180, // Number of frames after wich a level change takes in affect.
         FRAME_RATE_MIN = 20,  // Lowest level of detail.
         FRAME_RATE_MAX = 55;  // Highest level of detail.

      return function (browser, modelViewMatrix)
      {
         if (this ._range .length === 0)
         {
            this .frameRate = ((FRAMES - 1) * this .frameRate + browser .currentFrameRate) / FRAMES;

            const size = this ._children .length;

            switch (size)
            {
               case 0:
                  return -1;
               case 1:
                  return 0;
               case 2:
                  return +(this .frameRate > FRAME_RATE_MAX);
               default:
               {
                  const fraction = 1 - Math_Algorithm.clamp ((this .frameRate - FRAME_RATE_MIN) / (FRAME_RATE_MAX - FRAME_RATE_MIN), 0, 1);

                  return Math .min (Math .floor (fraction * size), size - 1);
               }
            }
         }

         const distance = modelViewMatrix .translate (this ._center .getValue ()) .origin .magnitude ();

         return Math_Algorithm.upperBound (this ._range, 0, this ._range .length, distance);
      };
   })(),
   traverse: (function ()
   {
      const modelViewMatrix = new Numbers_Matrix4 ();

      return function (type, renderObject)
      {
         switch (type)
         {
            case Rendering_TraverseType.POINTER:
            case Rendering_TraverseType.CAMERA:
            case Rendering_TraverseType.SHADOW:
            {
               const visibleNode = this .visibleNode;

               if (visibleNode)
                  visibleNode .traverse (type, renderObject);

               return;
            }
            case Rendering_TraverseType.PICKING:
            {
               if (this .getTransformSensors () .size)
               {
                  const modelMatrix = renderObject .getModelViewMatrix () .get ();

                  for (const transformSensorNode of this .getTransformSensors ())
                     transformSensorNode .collect (modelMatrix);
               }

               const childNode = this .childNode;

               if (childNode)
               {
                  const
                     browser          = this .getBrowser (),
                     pickingHierarchy = browser .getPickingHierarchy ();

                  pickingHierarchy .push (this);

                  childNode .traverse (type, renderObject);

                  pickingHierarchy .pop ();
               }

               return;
            }
            case Rendering_TraverseType.COLLISION:
            {
               const childNode = this .childNode;

               if (childNode)
                  childNode .traverse (type, renderObject);

               return;
            }
            case Rendering_TraverseType.DISPLAY:
            {
               if (! this .keepCurrentLevel)
               {
                  let
                     level        = this .getLevel (this .getBrowser (), modelViewMatrix .assign (renderObject .getModelViewMatrix () .get ())),
                     currentLevel = this ._level_changed .getValue ();

                  if (this ._forceTransitions .getValue ())
                  {
                     if (level > currentLevel)
                        level = currentLevel + 1;

                     else if (level < currentLevel)
                        level = currentLevel - 1;
                  }

                  if (level !== currentLevel)
                  {
                     this ._level_changed = level;

                     this .set_level__ (Math .min (level, this ._children .length - 1));
                  }
               }

               const visibleNode = this .visibleNode;

               if (visibleNode)
                  visibleNode .traverse (type, renderObject);

               const boundedObject = this .boundedObject;

               if (boundedObject)
                  boundedObject .displayBBox (type, renderObject);

               return;
            }
         }
      };
   })(),
});

/* harmony default export */ const Navigation_LOD = (LOD);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation/ViewpointGroup.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function ViewpointGroup (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ViewpointGroup);

   this ._size   .setUnit ("length");
   this ._center .setUnit ("length");

   this .proximitySensor  = new EnvironmentalSensor_ProximitySensor (executionContext);
   this .cameraObjects    = [ ];
   this .viewpointGroups  = [ ];
}

ViewpointGroup .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: ViewpointGroup,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",       new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "displayed",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "retainUserOffsets", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "size",              new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "center",            new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "children",          new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "ViewpointGroup";
   },
   getComponentName: function ()
   {
      return "Navigation";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);

      this .proximitySensor .setup ();

      this ._size   .addFieldInterest (this .proximitySensor ._size);
      this ._center .addFieldInterest (this .proximitySensor ._center);

      this .proximitySensor ._size   = this ._size;
      this .proximitySensor ._center = this ._center;

      this ._displayed .addInterest ("set_displayed__", this);
      this ._size      .addInterest ("set_displayed__", this);
      this ._children  .addInterest ("set_children__", this);

      this .set_displayed__ ();
      this .set_children__ ();
   },
   isActive: function ()
   {
      return this .proximitySensor ._isActive .getValue ();
   },
   set_displayed__: function ()
   {
      var
         proxy     = ! this ._size .getValue () .equals (Numbers_Vector3.Zero),
         displayed = this ._displayed .getValue ();

      this .proximitySensor ._enabled = displayed && proxy;

      if (displayed && proxy)
      {
         this .proximitySensor ._isCameraObject   .addFieldInterest (this ._isCameraObject);
         this .proximitySensor ._isPickableObject .addFieldInterest (this ._isPickableObject);

         this .setCameraObject   (this .proximitySensor .getCameraObject ());
         this .setPickableObject (this .proximitySensor .getPickableObject ());

         this .traverse = traverseWithProximitySensor;
      }
      else
      {
         this .proximitySensor ._isCameraObject    .removeFieldInterest (this ._isCameraObject);
         this .proximitySensor ._isPickableObject .removeFieldInterest (this ._isPickableObject);

         this .setCameraObject   (displayed);
         this .setPickableObject (false);

         if (displayed)
            this .traverse = traverse;
         else
            delete this .traverse;
      }
   },
   set_children__: function ()
   {
      this .cameraObjects   .length = 0;
      this .viewpointGroups .length = 0;

      var children = this ._children;

      for (var i = 0, length = children .length; i < length; ++ i)
      {
         try
         {
            var
               innerNode = children [i] .getValue () .getInnerNode (),
               type      = innerNode .getType ();

            for (var t = type .length - 1; t >= 0; -- t)
            {
               switch (type [t])
               {
                  case Base_X3DConstants.X3DViewpointNode:
                  {
                     this .cameraObjects .push (innerNode);
                     break;
                  }
                  case Base_X3DConstants.ViewpointGroup:
                  {
                     this .cameraObjects   .push (innerNode);
                     this .viewpointGroups .push (innerNode);
                     break;
                  }
               }
            }
         }
         catch (error)
         { }
      }
   },
   traverse: function () { },
});

function traverseWithProximitySensor (type, renderObject)
{
   switch (type)
   {
      case Rendering_TraverseType.CAMERA:
      {
         this .proximitySensor .traverse (type, renderObject);

         if (this .proximitySensor ._isActive .getValue ())
         {
            for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
               this .cameraObjects [i] .traverse (type, renderObject);
         }

         return;
      }
      case Rendering_TraverseType.DISPLAY:
      {
         this .proximitySensor .traverse (type, renderObject);

         if (this .proximitySensor ._isActive .getValue ())
         {
            for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
               this .viewpointGroups [i] .traverse (type, renderObject);
         }

         return;
      }
   }
}

function traverse (type, renderObject)
{
   switch (type)
   {
      case Rendering_TraverseType.CAMERA:
      {
         for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
            this .cameraObjects [i] .traverse (type, renderObject);

         return;
      }
      case Rendering_TraverseType.DISPLAY:
      {
         for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
            this .viewpointGroups [i] .traverse (type, renderObject);

         return;
      }
   }
}

/* harmony default export */ const Navigation_ViewpointGroup = (ViewpointGroup);

;// CONCATENATED MODULE: ./src/x_ite/Components/Navigation.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const Navigation_Types =
{
   Billboard:      Navigation_Billboard,
   Collision:      Navigation_Collision,
   LOD:            Navigation_LOD,
   NavigationInfo: Navigation_NavigationInfo,
   OrthoViewpoint: Navigation_OrthoViewpoint,
   Viewpoint:      Navigation_Viewpoint,
   ViewpointGroup: Navigation_ViewpointGroup,
};

const Navigation_AbstractTypes =
{
   X3DViewpointNode: Navigation_X3DViewpointNode,
};

for (const typeName in Navigation_Types)
   Configuration_SupportedNodes.addType (typeName, Navigation_Types [typeName]);

for (const typeName in Navigation_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Navigation_AbstractTypes [typeName]);

/* harmony default export */ const Navigation = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Browser/PointingDeviceSensor/PointingDeviceSensorContainer.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function PointingDeviceSensorContainer (node, modelViewMatrix, projectionMatrix, viewport)
{
   this .node             = null;
   this .modelViewMatrix  = new Numbers_Matrix4 ();
   this .projectionMatrix = new Numbers_Matrix4 ();
   this .viewport         = new Numbers_Vector4 (0, 0, 0, 0);

   this .set (node, modelViewMatrix, projectionMatrix, viewport);
}

PointingDeviceSensorContainer .prototype =
{
   set: function (node, modelViewMatrix, projectionMatrix, viewport)
   {
      this .node = node;

      this .modelViewMatrix  .assign (modelViewMatrix);
      this .projectionMatrix .assign (projectionMatrix);
      this .viewport         .assign (viewport);
   },
   set_over__: function (over, hit)
   {
      this .node .set_over__ (over, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
   },
   set_active__: function (active, hit)
   {
      this .node .set_active__ (active, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
   },
   set_motion__: function (hit)
   {
      this .node .set_motion__ (hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
   },
};

/* harmony default export */ const PointingDeviceSensor_PointingDeviceSensorContainer = (PointingDeviceSensorContainer);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DPointingDeviceSensorNode (executionContext)
{
   Core_X3DSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DPointingDeviceSensorNode);
}

X3DPointingDeviceSensorNode .prototype = Object .assign (Object .create (Core_X3DSensorNode.prototype),
{
   constructor: X3DPointingDeviceSensorNode,
   initialize: function ()
   {
      Core_X3DSensorNode.prototype.initialize.call (this);

      this ._enabled .addInterest ("set_enabled__", this);
   },
   getMatrices: function ()
   {
      return this .matrices;
   },
   set_enabled__: function ()
   {
      if (this ._enabled .getValue ())
         return;

      if (this ._isActive .getValue ())
         this ._isActive = false;

      if (this ._isOver .getValue ())
         this ._isOver = false;
   },
   set_over__: function (over, hit)
   {
      if (over !== this ._isOver .getValue ())
      {
         this ._isOver = over;

         if (over)
            this .getBrowser () .getNotification () ._string = this ._description;
      }
   },
   set_active__: function (active, hit)
   {
      if (active !== this ._isActive .getValue ())
         this ._isActive = active
   },
   set_motion__: function (hit)
   { },
   push: function (renderObject, sensors)
   {
      if (this ._enabled .getValue ())
      {
         sensors .set (this, new PointingDeviceSensor_PointingDeviceSensorContainer (this,
                                                                renderObject .getModelViewMatrix  () .get (),
                                                                renderObject .getProjectionMatrix () .get (),
                                                                renderObject .getViewVolume () .getViewport ()));
      }
   },
});

/* harmony default export */ const PointingDeviceSensor_X3DPointingDeviceSensorNode = (X3DPointingDeviceSensorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DTouchSensorNode (executionContext)
{
   PointingDeviceSensor_X3DPointingDeviceSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DTouchSensorNode);
}

X3DTouchSensorNode .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DPointingDeviceSensorNode.prototype),
{
   constructor: X3DTouchSensorNode,
   set_active__: function (active, hit)
   {
      PointingDeviceSensor_X3DPointingDeviceSensorNode.prototype.set_active__.call (this, active, hit);

      if (this ._enabled .getValue () && this ._isOver .getValue () && ! active)
         this ._touchTime = this .getBrowser () .getCurrentTime ();
   },
});

/* harmony default export */ const PointingDeviceSensor_X3DTouchSensorNode = (X3DTouchSensorNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/TouchSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









var invModelViewMatrix = new Numbers_Matrix4 ();

function TouchSensor (executionContext)
{
   PointingDeviceSensor_X3DTouchSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TouchSensor);

   this ._hitPoint_changed .setUnit ("length");
}

TouchSensor .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DTouchSensorNode.prototype),
{
   constructor: TouchSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",         new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "hitTexCoord_changed", new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "hitNormal_changed",   new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "hitPoint_changed",    new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isOver",              new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",            new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "touchTime",           new x_ite_Fields.SFTime ()),
   ]),
   getTypeName: function ()
   {
      return "TouchSensor";
   },
   getComponentName: function ()
   {
      return "PointingDeviceSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   set_over__: function (over, hit, modelViewMatrix, projectionMatrix, viewport)
   {
      PointingDeviceSensor_X3DTouchSensorNode.prototype.set_over__.call (this, over, hit, modelViewMatrix, projectionMatrix, viewport);

      if (this ._isOver .getValue ())
      {
         var intersection = hit .intersection;

         invModelViewMatrix .assign (modelViewMatrix) .inverse ();

         this ._hitTexCoord_changed = intersection .texCoord;
         this ._hitNormal_changed   = modelViewMatrix .multMatrixDir (intersection .normal .copy ()) .normalize ();
         this ._hitPoint_changed    = invModelViewMatrix .multVecMatrix (intersection .point .copy ());
      }
   },
});

/* harmony default export */ const PointingDeviceSensor_TouchSensor = (TouchSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking/Anchor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function Anchor (executionContext)
{
   Grouping_X3DGroupingNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.Anchor);

   this .touchSensorNode = new PointingDeviceSensor_TouchSensor (executionContext);
   this .anchorSensors   = new Map ();
}

Anchor .prototype = Object .assign (Object .create (Grouping_X3DGroupingNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: Anchor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "description",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "parameter",            new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",          new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",             new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",           new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "addChildren",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "removeChildren",       new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "children",             new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Anchor";
   },
   getComponentName: function ()
   {
      return "Networking";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Grouping_X3DGroupingNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      this ._description .addFieldInterest (this .touchSensorNode ._description);
      this ._load        .addFieldInterest (this .touchSensorNode ._enabled);

      this .touchSensorNode ._description = this ._description;
      this .touchSensorNode ._enabled     = this ._load;
      this .touchSensorNode .setup ();

      // Modify set_active__ to get immediate response to user action (click event), otherwise links are not opened in this window.

      const
         anchor       = this,
         set_active__ = this .touchSensorNode .set_active__;

      this .touchSensorNode .set_active__ = function (active, hit)
      {
         set_active__ .call (this, active, hit);

         if (this ._isOver .getValue () && ! active)
            anchor .requestImmediateLoad ();
      };
   },
   set_load__: function ()
   { },
   set_url__: function ()
   { },
   requestImmediateLoad: function (cache = true)
   {
      this .setCache (cache);
      this .setLoadState (Base_X3DConstants.IN_PROGRESS_STATE, false);

      new InputOutput_FileLoader (this) .createX3DFromURL (this ._url, this ._parameter,
      function (scene)
      {
         if (scene)
         {
            this .getBrowser () .replaceWorld (scene);
            this .setLoadState (Base_X3DConstants.COMPLETE_STATE, false);
         }
         else
            this .setLoadState (Base_X3DConstants.FAILED_STATE, false);
      }
      .bind (this),
      function (viewpointName)
      {
         this .getBrowser () .changeViewpoint (viewpointName);
         this .setLoadState (Base_X3DConstants.COMPLETE_STATE, false);
      }
      .bind (this),
      function (url, target)
      {
         if (target)
            window .open (url, target);
         else
            location = url;

         this .setLoadState (Base_X3DConstants.COMPLETE_STATE, false);
      }
      .bind (this));
   },
   requestUnload ()
   { },
   traverse: function (type, renderObject)
   {
      if (type === Rendering_TraverseType.POINTER)
      {
         const
            sensorsStack = this .getBrowser () .getSensors (),
            sensors      = this .anchorSensors;

         sensors .clear ();

         this .touchSensorNode .push (renderObject, sensors);

         if (sensors .size)
         {
            sensorsStack .push (sensors);

            Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);

            sensorsStack .pop ();
         }
         else
         {
            Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);
         }
       }
      else
      {
         Grouping_X3DGroupingNode.prototype.traverse.call (this, type, renderObject);
      }
   },
});

/* harmony default export */ const Networking_Anchor = (Anchor);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking/Inline.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













function Inline (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);
   Grouping_X3DBoundedObject.call (this, executionContext);

   this .addType (Base_X3DConstants.Inline);

   this .scene = this .getBrowser () .getDefaultScene ();
   this .group = new Grouping_Group (executionContext);

   this .group .addParent (this);
}

Inline .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   Networking_X3DUrlObject.prototype,
   Grouping_X3DBoundedObject.prototype,
{
   constructor: Inline,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "visible",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "bboxDisplay",          new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxSize",             new x_ite_Fields.SFVec3f (-1, -1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "bboxCenter",           new x_ite_Fields.SFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "Inline";
   },
   getComponentName: function ()
   {
      return "Networking";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);
      Grouping_X3DBoundedObject.prototype.initialize.call (this);

      this .group .setPrivate (true);
      this .group .setup ();

      this .group ._isCameraObject   .addFieldInterest (this ._isCameraObject);
      this .group ._isPickableObject .addFieldInterest (this ._isPickableObject);

      this .requestImmediateLoad ();
   },
   getBBox: function (bbox, shadows)
   {
      if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
         return this .group .getBBox (bbox, shadows);

      return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
   },
   set_live__: function ()
   {
      Networking_X3DUrlObject.prototype.set_live__.call (this);

      if (this .isPrivate ())
         return

      this .scene .setLive (this .isLive () .getValue ());
   },
   unLoadNow: function ()
   {
      this .setInternalScene (this .getBrowser () .getDefaultScene ());
   },
   loadNow: function ()
   {
      new InputOutput_FileLoader (this) .createX3DFromURL (this ._url, null, this .setInternalSceneAsync .bind (this));
   },
   setInternalSceneAsync: function (scene)
   {
      if (scene)
      {
         this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
         this .setInternalScene (scene);
      }
      else
      {
         this .setLoadState (Base_X3DConstants.FAILED_STATE);
         this .setInternalScene (this .getBrowser () .getDefaultScene ());
      }
   },
   setInternalScene: function (scene)
   {
      this .scene .setLive (false);
      this .scene .rootNodes .removeFieldInterest (this .group ._children);

      // Set new scene.

      this .scene = scene;
      this .scene .setExecutionContext (this .getExecutionContext ());
      this .scene .setPrivate (this .getExecutionContext () .isPrivate ());

      this .scene .rootNodes .addFieldInterest (this .group ._children);
      this .group ._children = this .scene .rootNodes;

      this .set_live__ ();

      this .getBrowser () .addBrowserEvent ();
   },
   getInternalScene: function ()
   {
      ///  Returns the internal X3DScene of this inline, that is loaded from the url given.
      ///  If the load field was false an empty scene is returned.  This empty scene is the same for all Inline
      ///  nodes (due to performance reasons).

      return this .scene;
   },
   traverse: function (type, renderObject)
   {
      switch (type)
      {
         case Rendering_TraverseType.PICKING:
         {
            const
               browser          = this .getBrowser (),
               pickingHierarchy = browser .getPickingHierarchy ();

            pickingHierarchy .push (this);

            this .group .traverse (type, renderObject);

            pickingHierarchy .pop ();
            return;
         }
         default:
         {
            this .group .traverse (type, renderObject);
            return;
         }
      }
   },
});

/* harmony default export */ const Networking_Inline = (Inline);

;// CONCATENATED MODULE: ./src/x_ite/Components/Networking.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









const Networking_Types =
{
   Anchor:     Networking_Anchor,
   Inline:     Networking_Inline,
   LoadSensor: Networking_LoadSensor,
};

const Networking_AbstractTypes =
{
   X3DNetworkSensorNode: Networking_X3DNetworkSensorNode,
   X3DUrlObject:         Networking_X3DUrlObject,
};

for (const typeName in Networking_Types)
   Configuration_SupportedNodes.addType (typeName, Networking_Types [typeName]);

for (const typeName in Networking_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Networking_AbstractTypes [typeName]);

/* harmony default export */ const Networking = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/X3DDragSensorNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DDragSensorNode (executionContext)
{
   PointingDeviceSensor_X3DPointingDeviceSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DDragSensorNode);

   this ._trackPoint_changed .setUnit ("length");
}

X3DDragSensorNode .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DPointingDeviceSensorNode.prototype),
{
   constructor: X3DDragSensorNode,
});

/* harmony default export */ const PointingDeviceSensor_X3DDragSensorNode = (X3DDragSensorNode);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Cylinder3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function Cylinder3 (axis, radius)
{
   this .axis   = axis .copy ();
   this .radius = radius;
}

Cylinder3 .prototype =
{
   constructor: Cylinder3,
   intersectsLine: function (line, enter, exit)
   {
      ////////////////////////////////////////////////////////////////////////
      //
      // Description:
      //  Intersect given line with this cylinder, returning the
      //  results in enter and exit. Returns TRUE if there was an
      //  intersection (and results are valid).
      //
      // Taken from Inventor SbCylinder.c++

      // The intersection will actually be done on a radius 1 cylinder
      // aligned with the y axis, so we transform the line into that
      // space, then intersect, then transform the results back.

      // rotation to y axis
      const
         rotToYAxis = new Numbers_Rotation4 (this .axis .direction, new Numbers_Vector3 (0, 1, 0)),
         mtxToYAxis = Numbers_Matrix4.Rotation (rotToYAxis);

      // scale to unit space
      const
         scaleFactor    = 1 / this .radius,
         toUnitCylSpace = new Numbers_Matrix4 ();

      toUnitCylSpace .scale (new Numbers_Vector3 (scaleFactor, scaleFactor, scaleFactor));
      toUnitCylSpace .multLeft (mtxToYAxis);

      // find the given line un-translated
      const
         point             = Numbers_Vector3.subtract (line .point, this .axis .point),
         noTranslationLine = new Geometry_Line3 (point, line .direction);

      // find the un-translated line in unit cylinder's space
      const cylLine = noTranslationLine .multLineMatrix (toUnitCylSpace);

      // find the intersection on the unit cylinder
      const intersected = this .unitCylinderIntersectsLine (cylLine, enter, exit);

      if (intersected)
      {
         // transform back to original space
         const fromUnitCylSpace = toUnitCylSpace .inverse ();

         fromUnitCylSpace .multVecMatrix (enter);
         enter .add (this .axis .point);

         fromUnitCylSpace .multVecMatrix (exit);
         exit .add (this .axis .point);
      }

      return intersected;
   },
   unitCylinderIntersectsLine: function (line, enter, exit)
   {
      let t0, t1;

      const
         pos = line .point,
         dir = line .direction;

         const
         A = dir [0] * dir [0] + dir [2] * dir [2],
         B = 2 * (pos [0] * dir [0] + pos [2] * dir [2]),
         C = pos [0] * pos [0] + pos [2] * pos [2] - 1;

      // discriminant = B^2 - 4AC
      const discr = B * B - 4 * A * C;

      // if discriminant is negative, no intersection
      if (discr < 0)
         return false;

         const sqroot = Math .sqrt (discr);

      // magic to stabilize the answer
      if (B > 0)
      {
         t0 = -(2 * C) / (sqroot + B);
         t1 = -(sqroot + B) / (2 * A);
      }
      else
      {
         t0 = (2 * C) / (sqroot - B);
         t1 = (sqroot - B) / (2 * A);
      }

      enter .assign (dir) .multiply (t0) .add (pos);
      exit  .assign (dir) .multiply (t1) .add (pos);

      return true;
   },
   toString: function ()
   {
      return this .axis .toString () + " " + this .radius;
   },
};

/* harmony default export */ const Geometry_Cylinder3 = (Cylinder3);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/CylinderSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















function CylinderSensor (executionContext)
{
   PointingDeviceSensor_X3DDragSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.CylinderSensor);

   this ._diskAngle .setUnit ("angle");
   this ._minAngle  .setUnit ("angle");
   this ._maxAngle  .setUnit ("angle");
   this ._offset    .setUnit ("angle");
}

CylinderSensor .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DDragSensorNode.prototype),
{
   constructor: CylinderSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",        new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "axisRotation",       new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diskAngle",          new x_ite_Fields.SFFloat (0.261792)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "minAngle",           new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "maxAngle",           new x_ite_Fields.SFFloat (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "offset",             new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "autoOffset",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "trackPoint_changed", new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "rotation_changed",   new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isOver",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",           new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "CylinderSensor";
   },
   getComponentName: function ()
   {
      return "PointingDeviceSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.initialize.call (this);

      this .modelViewMatrix    = new Numbers_Matrix4 ();
      this .invModelViewMatrix = new Numbers_Matrix4 ();

      this .cylinder    = new Geometry_Cylinder3 (new Geometry_Line3 (new Numbers_Vector3 (0, 0, 0), new Numbers_Vector3 (0, 0, 0)), 0);
      this .disk        = false;
      this .yPlane      = null;
      this .zPlane      = null;
      this .sxPlane     = null;
      this .szNormal    = null;
      this .behind      = false;
      this .fromVector  = new Numbers_Vector3 (0, 0, 0);
      this .startOffset = new Numbers_Rotation4 (0, 0, 1, 0);
   },
   isBehind: function (hitRay, hitPoint)
   {
      const
         enter = new Numbers_Vector3 (0, 0 ,0),
         exit  = new Numbers_Vector3 (0, 0, 0);

      this .cylinder .intersectsLine (hitRay, enter, exit);

      return Numbers_Vector3.subtract (hitPoint, enter) .magnitude () > Numbers_Vector3.subtract (hitPoint, exit) .magnitude ();
   },
   getTrackPoint: function (hitRay, trackPoint)
   {
      const zPoint = new Numbers_Vector3 (0, 0, 0);

      this .zPlane .intersectsLine (hitRay, zPoint);

      const
         axisPoint = Numbers_Vector3.add (zPoint, this .cylinder .axis .getPerpendicularVectorToPoint (zPoint, new Numbers_Vector3 (0, 0, 0))),
         distance  = this .sxPlane .getDistanceToPoint (zPoint) / this .cylinder .radius,
         section   = Math .floor ((distance + 1) / 2);

      // Use asin on the cylinder and outside linear angle.
      const
         sinp  = Math_Algorithm.interval (distance, -1, 1),
         phi   = section === 0 ? Math .asin (sinp) : sinp * Math .PI / 2,
         angle = phi + section * Math .PI;

      const rotation = new Numbers_Rotation4 (this .cylinder .axis .direction, angle);

      rotation .multVecRot (trackPoint .assign (this .szNormal) .multiply (this .cylinder .radius));
      trackPoint .add (axisPoint);
   },
   getAngle: function (rotation)
   {
      if (Numbers_Vector3.dot (rotation .getAxis (), this .cylinder .axis .direction) > 0)
         return rotation .angle;

      else
         return -rotation .angle;
   },
   set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.set_active__.call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

      if (this ._isActive .getValue ())
      {
         this .modelViewMatrix    .assign (modelViewMatrix);
         this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

         const
            hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
            hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

         const
            yAxis      = this ._axisRotation .getValue () .multVecRot (new Numbers_Vector3 (0, 1, 0)),
            cameraBack = this .invModelViewMatrix .multDirMatrix (new Numbers_Vector3 (0, 0, 1)) .normalize ();

         const
            axis   = new Geometry_Line3 (new Numbers_Vector3 (0, 0, 0), yAxis),
            radius = axis .getPerpendicularVectorToPoint (hitPoint, new Numbers_Vector3 (0, 0, 0)) .magnitude ();

         this .cylinder = new Geometry_Cylinder3 (axis, radius);
         this .disk     = Math .abs (Numbers_Vector3.dot (cameraBack, yAxis)) > Math .cos (this ._diskAngle .getValue ());
         this .behind   = this .isBehind (hitRay, hitPoint);
         this .yPlane   = new Geometry_Plane3 (hitPoint, yAxis);             // Sensor aligned y-plane
         this .zPlane   = new Geometry_Plane3 (hitPoint, cameraBack);        // Screen aligned z-plane

         // Compute normal like in Billboard with yAxis as axis of rotation.
         const
            billboardToViewer = this .invModelViewMatrix .origin,
            sxNormal          = Numbers_Vector3.cross (yAxis, billboardToViewer) .normalize ();

         this .sxPlane  = new Geometry_Plane3 (new Numbers_Vector3 (0, 0, 0), sxNormal);   // Billboarded special x-plane made parallel to sensors axis.
         this .szNormal = Numbers_Vector3.cross (sxNormal, yAxis) .normalize (); // Billboarded special z-normal made parallel to sensors axis.

         const trackPoint = new Numbers_Vector3 (0, 0, 0);

         if (this .disk)
            this .yPlane .intersectsLine (hitRay, trackPoint);
         else
            this .getTrackPoint (hitRay, trackPoint);

         this .fromVector  = this .cylinder .axis .getPerpendicularVectorToPoint (trackPoint, new Numbers_Vector3 (0, 0, 0)) .negate ();
         this .startOffset = new Numbers_Rotation4 (yAxis, this ._offset .getValue ());

         this ._trackPoint_changed = trackPoint;
         this ._rotation_changed   = this .startOffset;

         // For min/max angle.

         this .angle       = this ._offset .getValue ();
         this .startVector = this ._rotation_changed .getValue () .multVecRot (this ._axisRotation .getValue () .multVecRot (new Numbers_Vector3 (0, 0, 1)));
      }
      else
      {
         if (this ._autoOffset .getValue ())
            this ._offset = this .getAngle (this ._rotation_changed .getValue ());
      }
   },
   set_motion__: function (hit)
   {
      const
         hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
         trackPoint = new Numbers_Vector3 (0, 0, 0);

      if (this .disk)
         this .yPlane .intersectsLine (hitRay, trackPoint);
      else
         this .getTrackPoint (hitRay, trackPoint);

      this ._trackPoint_changed = trackPoint;

      const
         toVector = this .cylinder .axis .getPerpendicularVectorToPoint (trackPoint, new Numbers_Vector3 (0, 0, 0)) .negate (),
         rotation = new Numbers_Rotation4 (this .fromVector, toVector);

      if (this .disk)
      {
         // The trackpoint can swap behind the viewpoint if viewpoint is a Viewpoint node
         // as the viewing volume is not a cube where the picking ray goes straight up.
         // This phenomenon is very clear on the viewport corners.

         const trackPoint_ = this .modelViewMatrix .multVecMatrix (trackPoint .copy ());

         if (trackPoint_ .z > 0)
            rotation .multRight (new Numbers_Rotation4 (this .yPlane .normal, Math .PI));
      }
      else
      {
         if (this .behind)
            rotation .inverse ();
      }

      rotation .multLeft (this .startOffset);

      if (this ._minAngle .getValue () > this ._maxAngle .getValue ())
      {
         this ._rotation_changed = rotation;
      }
      else
      {
         const
            endVector     = rotation .multVecRot (this ._axisRotation .getValue () .multVecRot (new Numbers_Vector3 (0, 0, 1))),
            deltaRotation = new Numbers_Rotation4 (this .startVector, endVector),
            axis          = this ._axisRotation .getValue () .multVecRot (new Numbers_Vector3 (0, 1, 0)),
            sign          = axis .dot (deltaRotation .getAxis ()) > 0 ? 1 : -1,
            min           = this ._minAngle .getValue (),
            max           = this ._maxAngle .getValue ();

         this .angle += sign * deltaRotation .angle;

         this .startVector .assign (endVector);

         //console .log (this .angle, min, max);

         if (this .angle < min)
            rotation .setAxisAngle (this .cylinder .axis .direction, min);
         else if (this .angle > max)
            rotation .setAxisAngle (this .cylinder .axis .direction, max);
         else
            rotation .setAxisAngle (this .cylinder .axis .direction, this .angle);

         if (! this ._rotation_changed .getValue () .equals (rotation))
            this ._rotation_changed = rotation;
      }
   },
});

/* harmony default export */ const PointingDeviceSensor_CylinderSensor = (CylinderSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/PlaneSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


















const
   screenLine     = new Geometry_Line2 (Numbers_Vector2.Zero, Numbers_Vector2.Zero),
   trackPoint1    = new Numbers_Vector2 (0, 0, 0),
   trackPointLine = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero);

function PlaneSensor (executionContext)
{
   PointingDeviceSensor_X3DDragSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PlaneSensor);

   this ._offset              .setUnit ("length");
   this ._minPosition         .setUnit ("length");
   this ._maxPosition         .setUnit ("length");
   this ._translation_changed .setUnit ("length");
}

PlaneSensor .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DDragSensorNode.prototype),
{
   constructor: PlaneSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",         new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "axisRotation",        new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "autoOffset",          new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "offset",              new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "minPosition",         new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "maxPosition",         new x_ite_Fields.SFVec2f (-1, -1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "trackPoint_changed",  new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "translation_changed", new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isOver",              new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",            new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "PlaneSensor";
   },
   getComponentName: function ()
   {
      return "PointingDeviceSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.initialize.call (this);

      this .modelViewMatrix    = new Numbers_Matrix4 ();
      this .invModelViewMatrix = new Numbers_Matrix4 ();
      this .projectionMatrix   = new Numbers_Matrix4 ();
      this .viewport           = new Numbers_Vector4 ();

      this .planeSensor = true;
      this .plane       = null;
      this .line        = null;
      this .startOffset = new Numbers_Vector3 (0, 0, 0);
      this .startPoint  = new Numbers_Vector3 (0, 0, 0);
   },
   getLineTrackPoint: function (hit, line, trackPoint)
   {
      Geometry_ViewVolume.projectLine (line, this .modelViewMatrix, this .projectionMatrix, this .viewport, screenLine);
      screenLine .getClosestPointToPoint (hit .pointer, trackPoint1);
      Geometry_ViewVolume.unProjectRay (trackPoint1 .x, trackPoint1 .y, this .modelViewMatrix, this .projectionMatrix, this .viewport, trackPointLine);

      return line .getClosestPointToLine (trackPointLine, trackPoint);
   },
   set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.set_active__.call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

      if (this ._isActive .getValue ())
      {
         this .modelViewMatrix    .assign (modelViewMatrix);
         this .projectionMatrix   .assign (projectionMatrix);
         this .viewport           .assign (viewport);
         this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

         var
            hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
            hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

         var axisRotation = this ._axisRotation .getValue ();

         if (this ._minPosition .x === this ._maxPosition .x)
         {
            this .planeSensor = false;

            var direction = axisRotation .multVecRot (new Numbers_Vector3 (0, Math .abs (this ._maxPosition .y - this ._minPosition .y), 0));

            this .line = new Geometry_Line3 (hitPoint, direction .normalize ());
         }
         else if (this ._minPosition .y === this ._maxPosition .y)
         {
            this .planeSensor = false;

            var direction = axisRotation .multVecRot (new Numbers_Vector3 (Math .abs (this ._maxPosition .x - this ._minPosition .x), 0, 0));

            this .line = new Geometry_Line3 (hitPoint, direction .normalize ());
         }
         else
         {
            this .planeSensor = true;
            this .plane       = new Geometry_Plane3 (hitPoint, axisRotation .multVecRot (new Numbers_Vector3 (0, 0, 1)));
         }

         if (this .planeSensor)
         {
            if (this .plane .intersectsLine (hitRay, this .startPoint))
            {
               this .trackStart (this .startPoint);
            }

//						new Plane3 (new Vector3 (0, 0, 0), this .plane .normal) .intersectsLine (hitRay, trackPoint);
         }
         else
         {
            if (this .getLineTrackPoint (hit, this .line, this .startPoint))
            {
               var trackPoint = new Numbers_Vector3 (0, 0, 0);

               try
               {
                  this .getLineTrackPoint (hit, new Geometry_Line3 (this .line .direction, this .line .direction), trackPoint);
               }
               catch (error)
               {
                  //console .error (error);

                  trackPoint = this .startPoint;
               }

               this .trackStart (trackPoint);
            }
         }
      }
      else
      {
         if (this ._autoOffset .getValue ())
            this ._offset = this ._translation_changed;
      }
   },
   trackStart: function (trackPoint)
   {
      this .startOffset .assign (this ._offset .getValue ());

      this ._trackPoint_changed  = trackPoint;
      this ._translation_changed = this ._offset .getValue ();
   },
   set_motion__: function (hit)
   {
      try
      {
         if (this .planeSensor)
         {
            var
               hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
               endPoint = new Numbers_Vector3 (0, 0, 0);

            if (this .plane .intersectsLine (hitRay, endPoint))
            {
               this .track (endPoint, endPoint .copy ());
            }
            else
               throw new Error ("Plane and line are parallel.");
         }
         else
         {
            var
               endPoint   = new Numbers_Vector3 (0, 0, 0),
               trackPoint = new Numbers_Vector3 (0, 0, 0);

            if (this .getLineTrackPoint (hit, this .line, endPoint))
            {
               try
               {
                  this .getLineTrackPoint (hit, new Geometry_Line3 (Numbers_Vector3.Zero, this .line .direction), trackPoint);
               }
               catch (error)
               {
                  trackPoint .assign (endPoint);
               }

               this .track (endPoint, trackPoint);
            }
            else
               throw new Error ("Lines are parallel.");
         }
      }
      catch (error)
      {
         //console .error (error);

         this ._trackPoint_changed  .addEvent ();
         this ._translation_changed .addEvent ();
      }
   },
   track: function (endPoint, trackPoint)
   {
      var
         axisRotation = this ._axisRotation .getValue (),
         translation  = Numbers_Rotation4.inverse (axisRotation) .multVecRot (endPoint .add (this .startOffset) .subtract (this .startPoint));

      // X component

      if (! (this ._minPosition .x > this ._maxPosition .x))
         translation .x = Math_Algorithm.clamp (translation .x, this ._minPosition .x, this ._maxPosition .x);

      // Y component

      if (! (this ._minPosition .y > this ._maxPosition .y))
         translation .y = Math_Algorithm.clamp (translation .y, this ._minPosition .y, this ._maxPosition .y);

      axisRotation .multVecRot (translation);

      if (! this ._trackPoint_changed .getValue () .equals (trackPoint))
         this ._trackPoint_changed = trackPoint;

      if (! this ._translation_changed .getValue () .equals (translation))
         this ._translation_changed = translation;
   },
});

/* harmony default export */ const PointingDeviceSensor_PlaneSensor = (PlaneSensor);

;// CONCATENATED MODULE: ./src/standard/Math/Geometry/Sphere3.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/




function Sphere3 (radius, center)
{
   this .radius = radius;
   this .center = center .copy ();
}

Sphere3 .prototype =
{
   constructor: Sphere3,
   set: function (radius, center)
   {
      this .radius = radius;
      this .center .assign (center);
   },
   intersectsLine: function (line, enterPoint, exitPoint)
   {
      // https://github.com/Alexpux/Coin3D/blob/master/src/base/SbSphere.cpp

      const
         linepos = line .point,
         linedir = line .direction;

      const
         scenter = this .center,
         r       = this .radius;

      const
         b = 2 * (linepos .dot (linedir) - scenter .dot (linedir)),
         c = (linepos .x * linepos .x + linepos .y * linepos .y + linepos .z * linepos .z) +
             (scenter .x * scenter .x + scenter .y * scenter .y + scenter .z * scenter .z) -
             2 * linepos .dot (scenter) - r * r;

      const core = b * b - 4 * c;

      if (core >= 0)
      {
         let
            t1 = (-b + Math .sqrt (core)) / 2,
            t2 = (-b - Math .sqrt (core)) / 2;

         if (t1 > t2)
         {
            const tmp = t1;
            t1 = t2;
            t2 = tmp;
         }

         enterPoint .assign (linedir) .multiply (t1) .add (linepos);
         exitPoint  .assign (linedir) .multiply (t2) .add (linepos);

         return true;
      }
      else
      {
         return false;
      }
   },
   intersectsTriangle: (function ()
   {
      const
         AB = new Numbers_Vector3 (0, 0, 0),
         AC = new Numbers_Vector3 (0, 0, 0),
         BC = new Numbers_Vector3 (0, 0, 0),
         CA = new Numbers_Vector3 (0, 0, 0),
         Q1 = new Numbers_Vector3 (0, 0, 0),
         Q2 = new Numbers_Vector3 (0, 0, 0),
         Q3 = new Numbers_Vector3 (0, 0, 0);

      return function (A, B, C)
      {
         const
            P = this .center,
            r = this .radius;

         A .subtract (P);
         B .subtract (P);
         C .subtract (P);

         // Testing if sphere lies outside the triangle plane.

         AB .assign (B) .subtract (A);
         AC .assign (C) .subtract (A);

         const
            rr   = r * r,
            V    = AB .cross (AC),
            d    = Numbers_Vector3.dot (A, V),
            e    = Numbers_Vector3.dot (V, V),
            sep1 = d * d > rr * e;

         if (sep1)
            return false;

         // Testing if sphere lies outside a triangle vertex.
         const
            aa   = Numbers_Vector3.dot (A, A),
            ab   = Numbers_Vector3.dot (A, B),
            ac   = Numbers_Vector3.dot (A, C),
            bb   = Numbers_Vector3.dot (B, B),
            bc   = Numbers_Vector3.dot (B, C),
            cc   = Numbers_Vector3.dot (C, C),
            sep2 = (aa > rr) && (ab > aa) && (ac > aa),
            sep3 = (bb > rr) && (ab > bb) && (bc > bb),
            sep4 = (cc > rr) && (ac > cc) && (bc > cc);

         if (sep2 || sep3 || sep4)
            return false;

         // Testing if sphere lies outside a triangle edge.

         AB .assign (B) .subtract (A);
         BC .assign (C) .subtract (B);
         CA .assign (A) .subtract (C);

         const
            d1   = ab - aa,
            d2   = bc - bb,
            d3   = ac - cc,
            e1   = Numbers_Vector3.dot (AB, AB),
            e2   = Numbers_Vector3.dot (BC, BC),
            e3   = Numbers_Vector3.dot (CA, CA);

         Q1 .assign (A) .multiply (e1) .subtract (AB .multiply (d1));
         Q2 .assign (B) .multiply (e2) .subtract (BC .multiply (d2));
         Q3 .assign (C) .multiply (e3) .subtract (CA .multiply (d3));

         const
            QC   = C .multiply (e1) .subtract (Q1),
            QA   = A .multiply (e2) .subtract (Q2),
            QB   = B .multiply (e3) .subtract (Q3),
            sep5 = (Numbers_Vector3.dot (Q1, Q1) > rr * e1 * e1) && (Numbers_Vector3.dot (Q1, QC) > 0),
            sep6 = (Numbers_Vector3.dot (Q2, Q2) > rr * e2 * e2) && (Numbers_Vector3.dot (Q2, QA) > 0),
            sep7 = (Numbers_Vector3.dot (Q3, Q3) > rr * e3 * e3) && (Numbers_Vector3.dot (Q3, QB) > 0);

         if (sep5 || sep6 || sep7)
            return false;

         return true;
      };
   })(),
   toString: function ()
   {
      return this .radius + " " + this .center .toString ();
   },
};

/* harmony default export */ const Geometry_Sphere3 = (Sphere3);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor/SphereSensor.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















function SphereSensor (executionContext)
{
   PointingDeviceSensor_X3DDragSensorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.SphereSensor);
}

SphereSensor .prototype = Object .assign (Object .create (PointingDeviceSensor_X3DDragSensorNode.prototype),
{
   constructor: SphereSensor,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",        new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",            new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "autoOffset",         new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "offset",             new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "trackPoint_changed", new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "rotation_changed",   new x_ite_Fields.SFRotation ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isOver",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",           new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "SphereSensor";
   },
   getComponentName: function ()
   {
      return "PointingDeviceSensor";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.initialize.call (this);

      this .modelViewMatrix    = new Numbers_Matrix4 ();
      this .invModelViewMatrix = new Numbers_Matrix4 ();

      this .sphere      = null;
      this .zPlane      = null;
      this .behind      = false;
      this .fromVector  = new Numbers_Vector3 (0, 0, 0);
      this .startPoint  = new Numbers_Vector3 (0, 0, 0);
      this .startOffset = new Numbers_Rotation4 (0, 0, 1, 0);
   },
   getTrackPoint: function (hitRay, trackPoint, behind)
   {
      var exit = new Numbers_Vector3 (0, 0, 0);

      if (this .sphere .intersectsLine (hitRay, trackPoint, exit))
      {
         if ((Numbers_Vector3.subtract (hitRay .point, exit) .magnitude () < Numbers_Vector3.subtract (hitRay .point, trackPoint) .magnitude ()) - behind)
            trackPoint .assign (exit);

         return true;
      }

      return false;
   },
   set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
   {
      PointingDeviceSensor_X3DDragSensorNode.prototype.set_active__.call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

      if (this ._isActive .getValue ())
      {
         this .modelViewMatrix    .assign (modelViewMatrix);
         this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

         var
            hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ()),
            center   = new Numbers_Vector3 (0, 0, 0);

         this .zPlane = new Geometry_Plane3 (center, this .invModelViewMatrix .multDirMatrix (new Numbers_Vector3 (0, 0, 1)) .normalize ()); // Screen aligned Z-plane
         this .sphere = new Geometry_Sphere3 (hitPoint .magnitude (), center);
         this .behind = this .zPlane .getDistanceToPoint (hitPoint) < 0;

         this .fromVector  .assign (hitPoint);
         this .startPoint  .assign (hitPoint);
         this .startOffset .assign (this ._offset .getValue ());

         this ._trackPoint_changed = hitPoint;
         this ._rotation_changed   = this ._offset .getValue ();
      }
      else
      {
         if (this ._autoOffset .getValue ())
            this ._offset = this ._rotation_changed;
      }
   },
   set_motion__: function (hit)
   {
      var
         hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
         trackPoint = new Numbers_Vector3 (0, 0, 0);

      if (this .getTrackPoint (hitRay, trackPoint, this .behind))
      {
         var zAxis = this .invModelViewMatrix .multDirMatrix (new Numbers_Vector3 (0, 0, 1)) .normalize (); // Camera direction
         this .zPlane = new Geometry_Plane3 (trackPoint, zAxis);                                             // Screen aligned Z-plane
      }
      else
      {
         // Find trackPoint on the plane with sphere

         var tangentPoint = new Numbers_Vector3 (0, 0, 0);
         this .zPlane .intersectsLine (hitRay, tangentPoint);

         hitRay = new Geometry_Line3 (tangentPoint, Numbers_Vector3.subtract (this .sphere .center, tangentPoint) .normalize ());

         //console .log (hitRay .toString ());

         this .getTrackPoint (hitRay, trackPoint, false);

         // Find trackPoint behind sphere

         var
            triNormal     = Triangle3.normal (this .sphere .center, trackPoint, this .startPoint, new Numbers_Vector3 (0, 0, 0)),
            dirFromCenter = Numbers_Vector3.subtract (trackPoint, this .sphere .center) .normalize (),
            normal        = Numbers_Vector3.cross (triNormal, dirFromCenter) .normalize ();

         var point1 = Numbers_Vector3.subtract (trackPoint, normal .multiply (Numbers_Vector3.subtract (tangentPoint, trackPoint) .magnitude ()));

         hitRay = new Geometry_Line3 (point1, Numbers_Vector3.subtract (this .sphere .center, point1) .normalize ());

         this .getTrackPoint (hitRay, trackPoint, false);
      }

      this ._trackPoint_changed = trackPoint;

      var
         toVector = Numbers_Vector3.subtract (trackPoint, this .sphere .center),
         rotation = new Numbers_Rotation4 (this .fromVector, toVector);

      if (this .behind)
         rotation .inverse ();

      this ._rotation_changed = Numbers_Rotation4.multRight (this .startOffset, rotation);
   },
});

/* harmony default export */ const PointingDeviceSensor_SphereSensor = (SphereSensor);

;// CONCATENATED MODULE: ./src/x_ite/Components/PointingDeviceSensor.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











const PointingDeviceSensor_Types =
{
   CylinderSensor: PointingDeviceSensor_CylinderSensor,
   PlaneSensor:    PointingDeviceSensor_PlaneSensor,
   SphereSensor:   PointingDeviceSensor_SphereSensor,
   TouchSensor:    PointingDeviceSensor_TouchSensor,
};

const PointingDeviceSensor_AbstractTypes =
{
   X3DDragSensorNode:           PointingDeviceSensor_X3DDragSensorNode,
   X3DPointingDeviceSensorNode: PointingDeviceSensor_X3DPointingDeviceSensorNode,
   X3DTouchSensorNode:          PointingDeviceSensor_X3DTouchSensorNode,
};

for (const typeName in PointingDeviceSensor_Types)
   Configuration_SupportedNodes.addType (typeName, PointingDeviceSensor_Types [typeName]);

for (const typeName in PointingDeviceSensor_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, PointingDeviceSensor_AbstractTypes [typeName]);

/* harmony default export */ const PointingDeviceSensor = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/ClipPlane.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












const ClipPlanes = ObjectCache (ClipPlaneContainer);

function ClipPlaneContainer ()
{
   this .plane = new Geometry_Plane3 (Numbers_Vector3.Zero, Numbers_Vector3.Zero);
}

ClipPlaneContainer .prototype =
{
   constructor: ClipPlaneContainer,
   isClipped: function (point)
   {
      return this .plane .getDistanceToPoint (point) < 0;
   },
   set: function (clipPlane, modelViewMatrix)
   {
      const
         plane      = this .plane,
         localPlane = clipPlane .plane;

      plane .normal .assign (localPlane);
      plane .distanceFromOrigin = -localPlane .w;

      plane .multRight (modelViewMatrix);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const
         plane  = this .plane,
         normal = plane .normal;

      gl .uniform4f (shaderObject .x3d_ClipPlane [shaderObject .numClipPlanes ++], normal .x, normal .y, normal .z, plane .distanceFromOrigin);
   },
   dispose: function ()
   {
      ClipPlanes .push (this);
   },
};

function ClipPlane (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ClipPlane);

   this .enabled = false;
   this .plane   = new Numbers_Vector4 (0, 0, 0, 0);
}

ClipPlane .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: ClipPlane,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "plane",    new x_ite_Fields.SFVec4f (0, 1, 0, 0)),
   ]),
   getTypeName: function ()
   {
      return "ClipPlane";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);

      this ._enabled .addInterest ("set_enabled__", this);
      this ._plane   .addInterest ("set_enabled__", this);

      this .set_enabled__ ();
   },
   set_enabled__: function ()
   {
      this .plane .assign (this ._plane .getValue ());

      this .enabled = this ._enabled .getValue () && ! this .plane .equals (Numbers_Vector4.Zero);
   },
   push: function (renderObject)
   {
      if (this .enabled)
      {
         const clipPlaneContainer = ClipPlanes .pop ();

         clipPlaneContainer .set (this, renderObject .getModelViewMatrix () .get ());

         renderObject .getLocalObjects () .push (clipPlaneContainer);

         ++ renderObject .getLocalObjectsCount () [0];
      }
   },
   pop: function (renderObject)
   {
      if (this .enabled)
      {
         this .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());

         -- renderObject .getLocalObjectsCount () [0];
      }
   },
});

/* harmony default export */ const Rendering_ClipPlane = (ClipPlane);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/ColorRGBA.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function ColorRGBA (executionContext)
{
   Rendering_X3DColorNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ColorRGBA);

   this .setTransparent (true);
}

ColorRGBA .prototype = Object .assign (Object .create (Rendering_X3DColorNode.prototype),
{
   constructor: ColorRGBA,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",    new x_ite_Fields.MFColorRGBA ()),
   ]),
   getTypeName: function ()
   {
      return "ColorRGBA";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "color";
   },
   initialize: function ()
   {
      Rendering_X3DColorNode.prototype.initialize.call (this);

      this ._color .addInterest ("set_color__", this);

      this .set_color__ ();
   },
   set_color__: function ()
   {
      this .color  = this ._color .getValue ();
      this .length = this ._color .length;
   },
   addColor: function (index, array)
   {
      if (index >= 0 && index < this .length)
      {
         const color = this .color;

         index *= 4;

         array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
      }
      else if (this .length)
      {
         const color = this .color;

         index = (this .length - 1) * 4;

         array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
      }
      else
      {
         array .push (1, 1, 1, 1);
      }
   },
   addColors: function (array, min)
   {
      if (this .length)
      {
         const color = this .color;

         for (var index = 0, length = Math .min (min, this .length) * 4; index < length; index += 4)
            array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);

         if (this .length < min)
         {
            var index = (this .length - 1) * 4;

            const
               r = color [index],
               g = color [index + 1],
               b = color [index + 2],
               a = color [index + 2];

            for (var index = length, length = min * 4; index < length; index += 4)
               array .push (r, g, b, a);
         }
      }
      else
      {
         for (let index = 0; index < min; ++ index)
            array .push (1, 1, 1, 1);
      }

      return array;
   },
});

/* harmony default export */ const Rendering_ColorRGBA = (ColorRGBA);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/IndexedTriangleFanSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function IndexedTriangleFanSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.IndexedTriangleFanSet);

   this .triangleIndex = [ ];
}

IndexedTriangleFanSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: IndexedTriangleFanSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_index",       new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "index",           new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "IndexedTriangleFanSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._set_index .addFieldInterest (this ._index);
      this ._index     .addInterest ("set_index__", this);

      this .set_index__ ();
   },
   set_index__: function ()
   {
      // Build coordIndex

      const
         index         = this ._index,
         triangleIndex = this .triangleIndex;

      triangleIndex .length = 0;

      for (let i = 0, length = index .length; i < length; ++ i)
      {
         const first = index [i];

         if (first < 0)
            continue;

         if (++ i < length)
         {
            let second = index [i];

            if (second < 0)
               continue;

            for (++ i; i < length; ++ i)
            {
               const third = index [i];

               if (third < 0)
                  break;

               triangleIndex .push (first, second, third);

               second = third;
            }
         }
      }
   },
   getPolygonIndex: function (index)
   {
      return this .triangleIndex [index];
   },
   build: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
   },
});

/* harmony default export */ const Rendering_IndexedTriangleFanSet = (IndexedTriangleFanSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/IndexedTriangleSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function IndexedTriangleSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.IndexedTriangleSet);
}

IndexedTriangleSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: IndexedTriangleSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_index",       new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "index",           new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "IndexedTriangleSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   getPolygonIndex: function (i)
   {
      return this ._index [i];
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._set_index .addFieldInterest (this ._index);
   },
   build: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this ._index .length, 3, this ._index .length);
   },
});

/* harmony default export */ const Rendering_IndexedTriangleSet = (IndexedTriangleSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/IndexedTriangleStripSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function IndexedTriangleStripSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.IndexedTriangleStripSet);

   this .triangleIndex = [ ];
}

IndexedTriangleStripSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: IndexedTriangleStripSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "set_index",       new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "index",           new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "IndexedTriangleStripSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._set_index .addFieldInterest (this ._index);
      this ._index     .addInterest ("set_index__", this);

      this .set_index__ ();
   },
   set_index__: function ()
   {
      // Build coordIndex

      const
         index         = this ._index,
         triangleIndex = this .triangleIndex;

      triangleIndex .length = 0;

      // Build coordIndex

      for (let i = 0, length = index .length; i < length; ++ i)
      {
         let first = index [i];

         if (first < 0)
            continue;

         if (++ i < length)
         {
            let second = index [i];

            if (second < 0)
               continue;

            ++ i;

            for (let face = 0; i < length; ++ i, ++ face)
            {
               const third = index [i];

               if (third < 0)
                  break;

               triangleIndex .push (first, second, third);

               if (face & 1)
                  second = third;

               else
                  first = third;
            }
         }
      }
   },
   getPolygonIndex: function (index)
   {
      return this .triangleIndex [index];
   },
   build: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
   },
});

/* harmony default export */ const Rendering_IndexedTriangleStripSet = (IndexedTriangleStripSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/LineSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function LineSet (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.LineSet);

   this .fogCoordNode = null;
   this .colorNode    = null;
   this .normalNode   = null;
   this .coordNode    = null;
}

LineSet .prototype = Object .assign (Object .create (Rendering_X3DLineGeometryNode.prototype),
{
   constructor: LineSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "vertexCount", new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "attrib",      new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fogCoord",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",       new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normal",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "coord",       new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "LineSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DLineGeometryNode.prototype.initialize.call (this);

      this ._attrib   .addInterest ("set_attrib__",   this);
      this ._fogCoord .addInterest ("set_fogCoord__", this);
      this ._color    .addInterest ("set_color__",    this);
      this ._normal   .addInterest ("set_normal__",   this);
      this ._coord    .addInterest ("set_coord__",    this);

      this .set_attrib__ ();
      this .set_fogCoord__ ();
      this .set_color__ ();
      this .set_normal__ ();
      this .set_coord__ ();
   },
   set_attrib__: function ()
   {
      const attribNodes = this .getAttrib ();

      for (const attribNode of attribNodes)
      {
         attribNode .removeInterest ("requestRebuild", this);
         attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
      }

      attribNodes .length = 0;

      for (const node of this ._attrib)
      {
         const attribNode = X3DCast (Base_X3DConstants.X3DVertexAttributeNode, node);

         if (attribNode)
            attribNodes .push (attribNode);
      }

      for (const attribNode of attribNodes)
      {
         attribNode .addInterest ("requestRebuild", this);
         attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
      }

      this .updateVertexArrays ();
   },
   set_fogCoord__: function ()
   {
      if (this .fogCoordNode)
         this .fogCoordNode .removeInterest ("requestRebuild", this);

      this .fogCoordNode = X3DCast (Base_X3DConstants.FogCoordinate, this ._fogCoord);

      if (this .fogCoordNode)
         this .fogCoordNode .addInterest ("requestRebuild", this);
   },
   set_color__: function ()
   {
      if (this .colorNode)
      {
         this .colorNode .removeInterest ("requestRebuild", this);
         this .colorNode ._transparent .removeInterest ("set_transparent__", this);
      }

      this .colorNode = X3DCast (Base_X3DConstants.X3DColorNode, this ._color);

      if (this .colorNode)
      {
         this .colorNode .addInterest ("requestRebuild", this);
         this .colorNode ._transparent .addInterest ("set_transparent__", this);

         this .set_transparent__ ();
      }
      else
         this .setTransparent (false);
   },
   set_transparent__: function ()
   {
      this .setTransparent (this .colorNode .getTransparent ());
   },
   set_normal__: function ()
   {
      if (this .normalNode)
         this .normalNode .removeInterest ("requestRebuild", this);

      this .normalNode = X3DCast (Base_X3DConstants.X3DNormalNode, this ._normal);

      if (this .normalNode)
         this .normalNode .addInterest ("requestRebuild", this);
   },
   set_coord__: function ()
   {
      if (this .coordNode)
         this .coordNode .removeInterest ("requestRebuild", this);

      this .coordNode = X3DCast (Base_X3DConstants.X3DCoordinateNode, this ._coord);

      if (this .coordNode)
         this .coordNode .addInterest ("requestRebuild", this);
   },
   build: function ()
   {
      if (! this .coordNode || this .coordNode .isEmpty ())
         return;

      // Fill GeometryNode

      const
         vertexCount    = this ._vertexCount,
         attribNodes    = this .getAttrib (),
         numAttribNodes = attribNodes .length,
         attribArrays   = this .getAttribs (),
         fogCoordNode   = this .fogCoordNode,
         colorNode      = this .colorNode,
         coordNode      = this .coordNode,
         fogDepthArray  = this .getFogDepths (),
         colorArray     = this .getColors (),
         vertexArray    = this .getVertices (),
         size           = coordNode .getSize ();

      let index = 0;

      for (let count of vertexCount)
      {
         if (index + count > size)
            break;

         if (count > 1)
         {
            count = 2 * count - 2; // numVertices for line lines trip

            for (let i = 0; i < count; ++ i, index += i & 1)
            {
               for (let a = 0; a < numAttribNodes; ++ a)
                  attribNodes [a] .addValue (index, attribArrays [a]);

               if (fogCoordNode)
                  fogCoordNode .addDepth (index, fogDepthArray);

               if (colorNode)
                  colorNode .addColor (index, colorArray);

               coordNode .addPoint (index, vertexArray);
            }

            ++ index;
         }
         else
            index += count;
      }
   },
});

/* harmony default export */ const Rendering_LineSet = (LineSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DNormalNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DNormalNode (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DNormalNode);
}

X3DNormalNode .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: X3DNormalNode,
});

/* harmony default export */ const Rendering_X3DNormalNode = (X3DNormalNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/Normal.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function Normal (executionContext)
{
   Rendering_X3DNormalNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Normal);
}

Normal .prototype = Object .assign (Object .create (Rendering_X3DNormalNode.prototype),
{
   constructor: Normal,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "vector",   new x_ite_Fields.MFVec3f ()),
   ]),
   getTypeName: function ()
   {
      return "Normal";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "normal";
   },
   initialize: function ()
   {
      Rendering_X3DNormalNode.prototype.initialize.call (this);

      this ._vector .addInterest ("set_vector__", this);

      this .set_vector__ ();
   },
   set_vector__: function ()
   {
      this .vector = this ._vector .getValue ();
      this .length = this ._vector .length;
   },
   set1Vector: function (index, vector)
   {
      this ._vector [index] = vector;
   },
   get1Vector: function (index, result)
   {
      if (index >= 0 && index < this .length)
      {
         const vector = this .vector;

         index *= 3;

         return result .set (vector [index], vector [index + 1], vector [index + 2]);
      }
      else if (index >= 0 && this .length)
      {
         const vector = this .vector;

         index %= this .length;
         index *= 3;

         return result .set (vector [index], vector [index + 1], vector [index + 2]);
      }
      else
      {
         return result .set (0, 0, 0);
      }
   },
   addVector: function (index, array)
   {
      if (index >= 0 && index < this .length)
      {
         const vector = this .vector;

         index *= 3;

         array .push (vector [index], vector [index + 1], vector [index + 2]);
      }
      else if (index >= 0 && this .length)
      {
         const vector = this .vector;

         index %= this .length;
         index *= 3;

         array .push (vector [index], vector [index + 1], vector [index + 2]);
      }
      else
      {
         return array .push (0, 0, 0);
      }
   },
});

/* harmony default export */ const Rendering_Normal = (Normal);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/X3DPointGeometryNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function X3DPointGeometryNode_X3DLineGeometryNode (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   const browser = this .getBrowser ();

   this .setGeometryType (0);
   this .setPrimitiveMode (browser .getContext () .POINTS);
   this .setSolid (false);
   this .setTransparent (true);
}

X3DPointGeometryNode_X3DLineGeometryNode .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: X3DPointGeometryNode_X3DLineGeometryNode,
   intersectsLine: (function ()
   {
      const
         bbox                      = new Geometry_Box3 (),
         min                       = new Numbers_Vector3 (0, 0, 0),
         max                       = new Numbers_Vector3 (0, 0, 0),
         screenScale1_             = new Numbers_Vector3 (0, 0, 0),
         screenScale2_             = new Numbers_Vector3 (0, 0, 0),
         point                     = new Numbers_Vector3 (0, 0, 0),
         pointSizePoint            = new Numbers_Vector3 (0, 0, 0),
         modelViewProjectionMatrix = new Numbers_Matrix4 (),
         projected                 = new Numbers_Vector2 (0, 0),
         clipPoint                 = new Numbers_Vector3 (0, 0, 0);

      return function (hitRay, renderObject, invModelViewMatrix, appearanceNode, intersections)
      {
         const
            modelViewMatrix     = renderObject .getModelViewMatrix () .get (),
            viewport            = renderObject .getViewVolume () .getViewport (),
            extents             = bbox .assign (this .getBBox ()) .multRight (modelViewMatrix) .getExtents (min, max),
            pointPropertiesNode = appearanceNode .getPointProperties (),
            pointSize1          = Math .max (1.5, pointPropertiesNode ? pointPropertiesNode .getPointSize (min) / 2 : 1),
            screenScale1        = renderObject .getViewpoint () .getScreenScale (min, viewport, screenScale1_), // in m/px
            offsets1            = invModelViewMatrix .multDirMatrix (screenScale1 .multiply (pointSize1)),
            pointSize2          = Math .max (1.5, pointPropertiesNode ? pointPropertiesNode .getPointSize (max) / 2 : 1),
            screenScale2        = renderObject .getViewpoint () .getScreenScale (max, viewport, screenScale2_), // in m/px
            offsets2            = invModelViewMatrix .multDirMatrix (screenScale2 .multiply (pointSize2));

         if (this .intersectsBBox (hitRay, offsets1 .abs () .max (offsets2 .abs ())))
         {
            const
               pointer          = this .getBrowser () .getPointer (),
               projectionMatrix = renderObject .getProjectionMatrix () .get (),
               clipPlanes       = renderObject .getLocalObjects (),
               vertices         = this .getVertices (),
               numVertices      = vertices .length;

            modelViewProjectionMatrix .assign (modelViewMatrix) .multRight (projectionMatrix);

            for (let i = 0; i < numVertices; i += 4)
            {
               point .set (vertices [i + 0], vertices [i + 1], vertices [i + 2]);

               Geometry_ViewVolume.projectPointMatrix (point, modelViewProjectionMatrix, viewport, projected);

               const pointSize1_2 = Math .max (1.5, pointPropertiesNode ? pointPropertiesNode .getPointSize (modelViewMatrix .multVecMatrix (pointSizePoint .assign (point))) / 2 : 1);

               if (projected .distance (pointer) <= pointSize1_2)
               {
                  if (clipPlanes .length)
                  {
                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
                        continue;
                  }

                  const
                     texCoord = pointer .copy () .subtract (projected) .divide (pointSize1_2) .add (Numbers_Vector2.One) .divide (2),
                     normal   = modelViewMatrix .submatrix .transpose () .z .copy () .normalize ();

                  intersections .push ({ texCoord: texCoord, normal: normal, point: point .copy () });
               }
            }
         }

         return intersections .length;
      };
   })(),
   intersectsLineWithGeometry: function ()
   {
      return false;
   },
   intersectsBox: function (box, clipPlanes, modelViewMatrix)
   {
      return false;
   },
   buildTexCoords: function ()
   { },
   display: function (gl, renderContext)
   {
      const
         appearanceNode = renderContext .appearanceNode,
         shaderNode     = appearanceNode .getShader (this, renderContext),
         blendModeNode  = appearanceNode .getBlendMode (),
         attribNodes    = this .getAttrib (),
         attribBuffers  = this .getAttribBuffers ();

      if (blendModeNode)
         blendModeNode .enable (gl);

      // Setup shader.

      shaderNode .enable (gl);
      shaderNode .setUniforms (gl, this, renderContext);

      // Setup vertex attributes.

      if (this .vertexArrayObject .enable (gl, shaderNode))
      {
         for (let i = 0, length = attribNodes .length; i < length; ++ i)
            attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

         if (this .hasFogCoords)
            shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

         if (this .colorMaterial)
            shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

         shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);
      }

      gl .drawArrays (this .primitiveMode, 0, this .vertexCount);

      if (blendModeNode)
         blendModeNode .disable (gl);
   },
   displayParticles: function (gl, renderContext, particleSystem)
   {
      const
         appearanceNode = renderContext .appearanceNode,
         shaderNode     = appearanceNode .getShader (this, renderContext),
         blendModeNode  = appearanceNode .getBlendMode (),
         attribNodes    = this .getAttrib (),
         attribBuffers  = this .getAttribBuffers ();

      if (blendModeNode)
         blendModeNode .enable (gl);

      // Setup shader.

      shaderNode .enable (gl);
      shaderNode .setUniforms (gl, this, renderContext);

      // Setup vertex attributes.

      const outputParticles = particleSystem .outputParticles;

      if (outputParticles .vertexArrayObject .update (this .updateParticles) .enable (gl, shaderNode))
      {
         const particleStride = particleSystem .particleStride;

         shaderNode .enableParticleAttribute (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
         shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset, 1);

         for (let i = 0, length = attribNodes .length; i < length; ++ i)
            attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

         if (this .hasFogCoords)
            shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

         if (this .colorMaterial)
            shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

         shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);

         this .updateParticles = false;
      }

      // Wireframes are always solid so only one drawing call is needed.

      gl .drawArraysInstanced (this .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);

      if (blendModeNode)
         blendModeNode .disable (gl);
   },
});

/* harmony default export */ const X3DPointGeometryNode = (X3DPointGeometryNode_X3DLineGeometryNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/PointSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function PointSet (executionContext)
{
   X3DPointGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PointSet);

   this .fogCoordNode = null;
   this .colorNode    = null;
   this .normalNode   = null;
   this .coordNode    = null;
}

PointSet .prototype = Object .assign (Object .create (X3DPointGeometryNode.prototype),
{
   constructor: PointSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "attrib",   new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "fogCoord", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normal",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "coord",    new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "PointSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      X3DPointGeometryNode.prototype.initialize.call (this);

      this ._attrib   .addInterest ("set_attrib__",   this);
      this ._fogCoord .addInterest ("set_fogCoord__", this);
      this ._color    .addInterest ("set_color__",    this);
      this ._normal   .addInterest ("set_normal__",   this);
      this ._coord    .addInterest ("set_coord__",    this);

      this .set_attrib__ ();
      this .set_fogCoord__ ();
      this .set_color__ ();
      this .set_normal__ ();
      this .set_coord__ ();
   },
   getCoord: function ()
   {
      return this .coordNode;
   },
   set_attrib__: function ()
   {
      const attribNodes = this .getAttrib ();

      for (const attribNode of attribNodes)
      {
         attribNode .removeInterest ("requestRebuild", this);
         attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
      }

      attribNodes .length = 0;

      for (const node of this ._attrib)
      {
         const attribNode = X3DCast (Base_X3DConstants.X3DVertexAttributeNode, node);

         if (attribNode)
            attribNodes .push (attribNode);
      }

      for (const attribNode of attribNodes)
      {
         attribNode .addInterest ("requestRebuild", this);
         attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
      }

      this .updateVertexArrays ();
   },
   set_fogCoord__: function ()
   {
      if (this .fogCoordNode)
         this .fogCoordNode .removeInterest ("requestRebuild", this);

      this .fogCoordNode = X3DCast (Base_X3DConstants.FogCoordinate, this ._fogCoord);

      if (this .fogCoordNode)
         this .fogCoordNode .addInterest ("requestRebuild", this);
   },
   set_color__: function ()
   {
      if (this .colorNode)
         this .colorNode .removeInterest ("requestRebuild", this);

      this .colorNode = X3DCast (Base_X3DConstants.X3DColorNode, this ._color);

      if (this .colorNode)
         this .colorNode .addInterest ("requestRebuild", this);
   },
   set_normal__: function ()
   {
      if (this .normalNode)
         this .normalNode .removeInterest ("requestRebuild", this);

      this .normalNode = X3DCast (Base_X3DConstants.X3DNormalNode, this ._normal);

      if (this .normalNode)
         this .normalNode .addInterest ("requestRebuild", this);
   },
   set_coord__: function ()
   {
      if (this .coordNode)
         this .coordNode .removeInterest ("requestRebuild", this);

      this .coordNode = X3DCast (Base_X3DConstants.X3DCoordinateNode, this ._coord);

      if (this .coordNode)
         this .coordNode .addInterest ("requestRebuild", this);
   },
   build: function ()
   {
      if (! this .coordNode || this .coordNode .isEmpty ())
         return;

      const
         attribNodes    = this .getAttrib (),
         numAttribNodes = attribNodes .length,
         attribArrays   = this .getAttribs (),
         fogCoordNode   = this .fogCoordNode,
         fogDepthArray  = this .getFogDepths (),
         colorNode      = this .colorNode,
         colorArray     = this .getColors (),
         coordNode      = this .coordNode,
         vertexArray    = this .getVertices (),
         numPoints      = coordNode ._point .length;

      for (let a = 0; a < numAttribNodes; ++ a)
      {
         for (let i = 0; i < numPoints; ++ i)
            attribNodes [a] .addValue (i, attribArrays [a]);
      }

      if (fogCoordNode)
         fogCoordNode .addDepths (fogDepthArray, numPoints);

      if (colorNode)
         colorNode .addColors (colorArray, numPoints);

      coordNode .addPoints (vertexArray, numPoints);
   },
});

/* harmony default export */ const Rendering_PointSet = (PointSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/TriangleFanSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function TriangleFanSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TriangleFanSet);

   this .triangleIndex = [ ];
}

TriangleFanSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: TriangleFanSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fanCount",        new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "TriangleFanSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._fanCount .addInterest ("set_fanCount__", this);

      this .set_fanCount__ ();
   },
   set_fanCount__: function ()
   {
      // Build coordIndex

      const
         fanCount      = this ._fanCount,
         triangleIndex = this .triangleIndex;

      triangleIndex .length = 0;

      let index = 0;

      for (const vertexCount of fanCount)
      {
         for (let i = 1, length = vertexCount - 1; i < length; ++ i)
         {
            triangleIndex .push (index, index + i, index + i + 1);
         }

         index += vertexCount;
      }
   },
   getPolygonIndex: function (index)
   {
      return this .triangleIndex [index];
   },
   build: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
   },
});

/* harmony default export */ const Rendering_TriangleFanSet = (TriangleFanSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/TriangleSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function TriangleSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TriangleSet);
}

TriangleSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: TriangleSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "TriangleSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: function ()
   {
      if (! this .getCoord ())
         return;

      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this .getCoord () .getSize (), 3, this .getCoord () .getSize ());
   },
   createNormals: function (verticesPerPolygon, polygonsSize)
   {
      return this .createFaceNormals (verticesPerPolygon, polygonsSize);
   },
});

/* harmony default export */ const Rendering_TriangleSet = (TriangleSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering/TriangleStripSet.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function TriangleStripSet (executionContext)
{
   Rendering_X3DComposedGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TriangleStripSet);

   this .triangleIndex = [ ];
}

TriangleStripSet .prototype = Object .assign (Object .create (Rendering_X3DComposedGeometryNode.prototype),
{
   constructor: TriangleStripSet,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "ccw",             new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "colorPerVertex",  new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "normalPerVertex", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "stripCount",      new x_ite_Fields.MFInt32 ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "attrib",          new x_ite_Fields.MFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fogCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "color",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "texCoord",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "normal",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "coord",           new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "TriangleStripSet";
   },
   getComponentName: function ()
   {
      return "Rendering";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.initialize.call (this);

      this ._stripCount .addInterest ("set_stripCount__", this);

      this .set_stripCount__ ();
   },
   set_stripCount__: function ()
   {
      // Build coordIndex

      const
         stripCount    = this ._stripCount,
         triangleIndex = this .triangleIndex;

      triangleIndex .length = 0;

      let index = 0;

      for (const vertexCount of stripCount)
      {
         for (let i = 0, count = vertexCount - 2; i < count; ++ i)
         {
            const is_odd = i & 1;

            triangleIndex .push (index + (is_odd ? i + 1 : i),
                                 index + (is_odd ? i : i + 1),
                                 index + (i + 2));
         }

         index += vertexCount;
      }
   },
   getPolygonIndex: function (index)
   {
      return this .triangleIndex [index];
   },
   build: function ()
   {
      Rendering_X3DComposedGeometryNode.prototype.build.call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
   },
});

/* harmony default export */ const Rendering_TriangleStripSet = (TriangleStripSet);

;// CONCATENATED MODULE: ./src/x_ite/Components/Rendering.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

























const Rendering_Types =
{
   ClipPlane:               Rendering_ClipPlane,
   Color:                   Rendering_Color,
   ColorRGBA:               Rendering_ColorRGBA,
   Coordinate:              Rendering_Coordinate,
   IndexedLineSet:          Rendering_IndexedLineSet,
   IndexedTriangleFanSet:   Rendering_IndexedTriangleFanSet,
   IndexedTriangleSet:      Rendering_IndexedTriangleSet,
   IndexedTriangleStripSet: Rendering_IndexedTriangleStripSet,
   LineSet:                 Rendering_LineSet,
   Normal:                  Rendering_Normal,
   PointSet:                Rendering_PointSet,
   TriangleFanSet:          Rendering_TriangleFanSet,
   TriangleSet:             Rendering_TriangleSet,
   TriangleStripSet:        Rendering_TriangleStripSet,
};

const Rendering_AbstractTypes =
{
   X3DColorNode:             Rendering_X3DColorNode,
   X3DComposedGeometryNode:  Rendering_X3DComposedGeometryNode,
   X3DCoordinateNode:        Rendering_X3DCoordinateNode,
   X3DGeometricPropertyNode: Rendering_X3DGeometricPropertyNode,
   X3DGeometryNode:          Rendering_X3DGeometryNode,
   X3DLineGeometryNode:      Rendering_X3DLineGeometryNode,
   X3DNormalNode:            Rendering_X3DNormalNode,
};

for (const typeName in Rendering_Types)
   Configuration_SupportedNodes.addType (typeName, Rendering_Types [typeName]);

for (const typeName in Rendering_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Rendering_AbstractTypes [typeName]);

/* harmony default export */ const Rendering = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/X3DVertexAttributeNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






function X3DVertexAttributeNode (executionContext)
{
   Rendering_X3DGeometricPropertyNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DVertexAttributeNode);

   this .addChildObjects ("attribute_changed", new x_ite_Fields.SFTime ());
}

X3DVertexAttributeNode .prototype = Object .assign (Object .create (Rendering_X3DGeometricPropertyNode.prototype),
{
   constructor: X3DVertexAttributeNode,
   initialize: function ()
   {
      Rendering_X3DGeometricPropertyNode.prototype.initialize.call (this);

      this ._name .addInterest ("set_attribute__", this);
   },
   set_attribute__: function ()
   {
      this ._attribute_changed = this .getBrowser () .getCurrentTime ();
   },
});

/* harmony default export */ const Shaders_X3DVertexAttributeNode = (X3DVertexAttributeNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/FloatVertexAttribute.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function FloatVertexAttribute (executionContext)
{
   Shaders_X3DVertexAttributeNode.call (this, executionContext);

   this .addType (Base_X3DConstants.FloatVertexAttribute);
}

FloatVertexAttribute .prototype = Object .assign (Object .create (Shaders_X3DVertexAttributeNode.prototype),
{
   constructor: FloatVertexAttribute,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",      new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "name",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "numComponents", new x_ite_Fields.SFInt32 (4)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "value",         new x_ite_Fields.MFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "FloatVertexAttribute";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "attrib";
   },
   initialize: function ()
   {
      Shaders_X3DVertexAttributeNode.prototype.initialize.call (this);

      this ._numComponents .addInterest ("set_numComponents__", this);
      this ._numComponents .addInterest ("set_attribute__",     this);
      this ._value         .addInterest ("set_value__",         this);

      this .set_numComponents__ ();
      this .set_value__ ();
   },
   set_numComponents__: function ()
   {
      this .numComponents = Math_Algorithm.clamp (this ._numComponents .getValue (), 1, 4);
   },
   set_value__: function ()
   {
      this .value  = this ._value .getValue ();
      this .length = this ._value .length;
   },
   addValue: function (index, array)
   {
      const value = this .value;

      let
         first = index * this .numComponents,
         last  = first + this .numComponents;

      if (last <= this .length)
      {
         for (; first < last; ++ first)
            array .push (value [first]);
      }
      else if (this .numComponents <= this .length)
      {
         last  = value .length;
         first = last - this .numComponents;

         for (; first < last; ++ first)
            array .push (value [first]);
      }
      else
      {
         for (; first < last; ++ first)
            array .push (0);
      }
   },
   enable: function (gl, shaderNode, buffer)
   {
      shaderNode .enableFloatAttrib (gl, this ._name .getValue (), buffer, this .numComponents, 0, 0);
   },
});

/* harmony default export */ const Shaders_FloatVertexAttribute = (FloatVertexAttribute);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/Matrix3VertexAttribute.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function Matrix3VertexAttribute (executionContext)
{
   Shaders_X3DVertexAttributeNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Matrix3VertexAttribute);
}

Matrix3VertexAttribute .prototype = Object .assign (Object .create (Shaders_X3DVertexAttributeNode.prototype),
{
   constructor: Matrix3VertexAttribute,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "name",     new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "value",    new x_ite_Fields.MFMatrix3f ()),
   ]),
   getTypeName: function ()
   {
      return "Matrix3VertexAttribute";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "attrib";
   },
   initialize: function ()
   {
      Shaders_X3DVertexAttributeNode.prototype.initialize.call (this);

      this ._value .addInterest ("set_value__", this);

      this .set_value__ ();
   },
   set_value__: function ()
   {
      this .value  = this ._value .getValue ();
      this .length = this ._value .length;
   },
   addValue: function (index, array)
   {
      if (index < this .length)
      {
         const value = this .value;

         for (let i = index * 9, l = i + 9; i < l; ++ i)
            array .push (value [i]);
      }
      else if (this .length)
      {
         const value = this .value;

         index = this .length - 1;

         for (let i = index * 9, l = i + 9; i < l; ++ i)
            array .push (value [i]);
      }
      else
      {
         const value = Numbers_Matrix3.Identity;

         for (let i = 0; i < 9; ++ i)
            array .push (value [i]);
      }
   },
   enable: function (gl, shaderNode, buffer)
   {
      shaderNode .enableMatrix3Attrib (gl, this ._name .getValue (), buffer, 0, 0);
   },
});

/* harmony default export */ const Shaders_Matrix3VertexAttribute = (Matrix3VertexAttribute);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/Matrix4VertexAttribute.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Matrix4VertexAttribute (executionContext)
{
   Shaders_X3DVertexAttributeNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Matrix4VertexAttribute);
}

Matrix4VertexAttribute .prototype = Object .assign (Object .create (Shaders_X3DVertexAttributeNode.prototype),
{
   constructor: Matrix4VertexAttribute,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "name",     new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "value",    new x_ite_Fields.MFMatrix4f ()),
   ]),
   getTypeName: function ()
   {
      return "Matrix4VertexAttribute";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "attrib";
   },
   initialize: function ()
   {
      Shaders_X3DVertexAttributeNode.prototype.initialize.call (this);

      this ._value .addInterest ("set_value__", this);

      this .set_value__ ();
   },
   set_value__: function ()
   {
      this .value  = this ._value .getValue ();
      this .length = this ._value .length;
   },
   addValue: function (index, array)
   {
      if (index < this .length)
      {
         const value = this .value;

         for (let i = index * 16, l = i + 16; i < l; ++ i)
            array .push (value [i]);
      }
      else if (this .length)
      {
         const value = this .value;

         index = this .length - 1;

         for (let i = index * 16, l = i + 16; i < l; ++ i)
            array .push (value [i]);
      }
      else
      {
         const value = Matrix4 .Identity;

         for (let i = 0; i < 16; ++ i)
            array .push (value [i]);
      }
   },
   enable: function (gl, shaderNode, buffer)
   {
      shaderNode .enableMatrix4Attrib (gl, this ._name .getValue (), buffer, 0, 0);
   },
});

/* harmony default export */ const Shaders_Matrix4VertexAttribute = (Matrix4VertexAttribute);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/PackagedShader.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function PackagedShader (executionContext)
{
   Shaders_X3DShaderNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);
   Shaders_X3DProgrammableShaderObject.call (this, executionContext);

   this .addType (Base_X3DConstants.PackagedShader);
}

PackagedShader .prototype = Object .assign (Object .create (Shaders_X3DShaderNode.prototype),
   Networking_X3DUrlObject.prototype,
   Shaders_X3DProgrammableShaderObject.prototype,
{
   constructor: PackagedShader,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "activate",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isSelected",           new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isValid",              new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "language",             new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
   ]),
   getTypeName: function ()
   {
      return "PackagedShader";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "shaders";
   },
   getSourceText: function ()
   {
      return this ._url;
   },
   requestImmediateLoad: function (cache = true)
   { },
   requestUnload: function ()
   { },
});

/* harmony default export */ const Shaders_PackagedShader = (PackagedShader);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/ProgramShader.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function ProgramShader (executionContext)
{
   Shaders_X3DShaderNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ProgramShader);
}

ProgramShader .prototype = Object .assign (Object .create (Shaders_X3DShaderNode.prototype),
{
   constructor: ProgramShader,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOnly,      "activate",   new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isSelected", new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isValid",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "language",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "programs",   new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "ProgramShader";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "shaders";
   },
});

/* harmony default export */ const Shaders_ProgramShader = (ProgramShader);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders/ShaderProgram.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function ShaderProgram (executionContext)
{
   Core_X3DNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);
   Shaders_X3DProgrammableShaderObject.call (this, executionContext);

   this .addType (Base_X3DConstants.ShaderProgram);
}

ShaderProgram .prototype = Object .assign (Object .create (Core_X3DNode.prototype),
   Networking_X3DUrlObject.prototype,
   Shaders_X3DProgrammableShaderObject.prototype,
{
   constructor: ShaderProgram,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "type",                 new x_ite_Fields.SFString ("VERTEX")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
   ]),
   getTypeName: function ()
   {
      return "ShaderProgram";
   },
   getComponentName: function ()
   {
      return "Shaders";
   },
   getContainerField: function ()
   {
      return "programs";
   },
   getSourceText: function ()
   {
      return this ._url;
   },
   requestImmediateLoad: function (cache = true)
   { },
   requestUnload: function ()
   { },
});

/* harmony default export */ const Shaders_ShaderProgram = (ShaderProgram);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shaders.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/















const Shaders_Types =
{
   ComposedShader:         Shaders_ComposedShader,
   FloatVertexAttribute:   Shaders_FloatVertexAttribute,
   Matrix3VertexAttribute: Shaders_Matrix3VertexAttribute,
   Matrix4VertexAttribute: Shaders_Matrix4VertexAttribute,
   PackagedShader:         Shaders_PackagedShader,
   ProgramShader:          Shaders_ProgramShader,
   ShaderPart:             Shaders_ShaderPart,
   ShaderProgram:          Shaders_ShaderProgram,
};

const Shaders_AbstractTypes =
{
   X3DProgrammableShaderObject: Shaders_X3DProgrammableShaderObject,
   X3DShaderNode:               Shaders_X3DShaderNode,
   X3DVertexAttributeNode:      Shaders_X3DVertexAttributeNode,
};

for (const typeName in Shaders_Types)
   Configuration_SupportedNodes.addType (typeName, Shaders_Types [typeName]);

for (const typeName in Shaders_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Shaders_AbstractTypes [typeName]);

/* harmony default export */ const Components_Shaders = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/AcousticProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function AcousticProperties (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.AcousticProperties);
}

AcousticProperties .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: AcousticProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",    new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "absorption", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "refraction", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diffuse",    new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "specular",   new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "AcousticProperties";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "AcousticProperties";
   },
});

/* harmony default export */ const Shape_AcousticProperties = (AcousticProperties);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/FillProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function FillProperties (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.FillProperties);

   this .addChildObjects ("transparent", new x_ite_Fields.SFBool ());

   this ._transparent .setAccessType (Base_X3DConstants.outputOnly);

   this .hatchColor = new Float32Array (3);
}

FillProperties .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: FillProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "filled",     new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "hatched",    new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "hatchColor", new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "hatchStyle", new x_ite_Fields.SFInt32 (1)),
   ]),
   getTypeName: function ()
   {
      return "FillProperties";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "fillProperties";
   },
   initialize: function ()
   {
      Shape_X3DAppearanceChildNode.prototype.initialize.call (this);

      this ._filled     .addInterest ("set_filled__",     this);
      this ._hatched    .addInterest ("set_hatched__",    this);
      this ._hatchColor .addInterest ("set_hatchColor__", this);
      this ._hatchStyle .addInterest ("set_hatchStyle__", this);

      this .set_filled__ ();
      this .set_hatched__ ();
      this .set_hatchColor__ ();
      this .set_hatchStyle__ ();
   },
   set_filled__: function ()
   {
      this .filled = this ._filled .getValue ();

      this .setTransparent (! this .filled);
   },
   set_hatched__: function ()
   {
      this .hatched = this ._hatched .getValue ();
   },
   set_hatchColor__: function ()
   {
      this .hatchColor [0] = this ._hatchColor [0];
      this .hatchColor [1] = this ._hatchColor [1];
      this .hatchColor [2] = this ._hatchColor [2];
   },
   set_hatchStyle__: function ()
   {
      let hatchStyle = this ._hatchStyle .getValue ();

      if (hatchStyle < 1 || hatchStyle > 19)
         hatchStyle = 1;

      this .hatchStyle = hatchStyle;
   },
   setTransparent: function (value)
   {
      if (value !== this ._transparent .getValue ())
         this ._transparent = value;
   },
   getTransparent: function ()
   {
      return this ._transparent .getValue ();
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const hatched = this .hatched;

      gl .uniform1i (shaderObject .x3d_FillPropertiesFilled,  this .filled);
      gl .uniform1i (shaderObject .x3d_FillPropertiesHatched, hatched);

      if (hatched)
      {
         const
            browser     = this .getBrowser (),
            texture     = browser .getHatchStyleTexture (this .hatchStyle),
            textureUnit = browser .getTexture2DUnit ();

         gl .uniform3fv (shaderObject .x3d_FillPropertiesHatchColor, this .hatchColor);

         gl .activeTexture (gl .TEXTURE0 + textureUnit);
         gl .bindTexture (gl .TEXTURE_2D, texture .getTexture ());
         gl .uniform1i (shaderObject .x3d_FillPropertiesTexture, textureUnit);
      }
   },
});

/* harmony default export */ const Shape_FillProperties = (FillProperties);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/LineProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function LineProperties (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.LineProperties);
}

LineProperties .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: LineProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "applied",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "linetype",             new x_ite_Fields.SFInt32 (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "linewidthScaleFactor", new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "LineProperties";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "lineProperties";
   },
   initialize: function ()
   {
      Shape_X3DAppearanceChildNode.prototype.initialize.call (this);

      this ._applied              .addInterest ("set_applied__",              this);
      this ._linetype             .addInterest ("set_linetype__",             this);
      this ._linewidthScaleFactor .addInterest ("set_linewidthScaleFactor__", this);

      this .set_applied__ ();
      this .set_linetype__ ();
      this .set_linewidthScaleFactor__ ();
   },
   getApplied: function ()
   {
      return this .applied;
   },
   getLinetype: function ()
   {
      return this .linetype;
   },
   getLinewidthScaleFactor: function ()
   {
      return this .linewidthScaleFactor;
   },
   getTransformLines: function ()
   {
      return this .transformLines;
   },
   set_applied__: function ()
   {
      this .applied = this ._applied .getValue ();
   },
   set_linetype__: function ()
   {
      let linetype = this ._linetype .getValue ();

      if (linetype < 1 || linetype > 16)
         linetype = 1;

      this .linetype = linetype;
   },
   set_linewidthScaleFactor__: function ()
   {
      const
         browser = this .getBrowser (),
         gl      = browser .getContext ();

      this .linewidthScaleFactor = Math .max (1, this ._linewidthScaleFactor .getValue ());
      this .transformLines       = gl .HAS_FEATURE_TRANSFORMED_LINES && this .linewidthScaleFactor > 1;
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      if (this .applied)
      {
         const
            browser     = this .getBrowser (),
            textureUnit = browser .getTexture2DUnit ();

         gl .lineWidth (this .linewidthScaleFactor);
         gl .uniform1i (shaderObject .x3d_LinePropertiesApplied,  true);
         gl .uniform1i (shaderObject .x3d_LinePropertiesLinetype, this .linetype);

         gl .activeTexture (gl .TEXTURE0 + textureUnit);
         gl .bindTexture (gl .TEXTURE_2D, browser .getLinetypeTexture () .getTexture ());
         gl .uniform1i (shaderObject .x3d_LinePropertiesTexture, textureUnit);
      }
      else
      {
         gl .lineWidth (1);
         gl .uniform1i (shaderObject .x3d_LinePropertiesApplied, false);
      }
   },
});

/* harmony default export */ const Shape_LineProperties = (LineProperties);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/Material.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function Material (executionContext)
{
   Shape_X3DOneSidedMaterialNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Material);

   this .diffuseColor  = new Float32Array (3);
   this .specularColor = new Float32Array (3);
}

Material .prototype = Object .assign (Object .create (Shape_X3DOneSidedMaterialNode.prototype),
{
   constructor: Material,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",                 new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "ambientIntensity",         new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "ambientTexture",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "ambientTextureMapping",    new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diffuseColor",             new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diffuseTexture",           new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diffuseTextureMapping",    new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "specularColor",            new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "specularTexture",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "specularTextureMapping",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveColor",            new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTexture",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTextureMapping",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "shininess",                new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "shininessTexture",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "shininessTextureMapping",  new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionStrength",        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionTexture",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionTextureMapping",  new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalScale",              new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTexture",            new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTextureMapping",     new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency",             new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "Material";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "material";
   },
   initialize: function ()
   {
      Shape_X3DOneSidedMaterialNode.prototype.initialize.call (this);

      this ._ambientIntensity  .addInterest ("set_ambientIntensity__",  this);
      this ._ambientTexture    .addInterest ("set_ambientTexture__",    this);
      this ._diffuseColor      .addInterest ("set_diffuseColor__",      this);
      this ._diffuseTexture    .addInterest ("set_diffuseTexture__",    this);
      this ._specularColor     .addInterest ("set_specularColor__",     this);
      this ._specularTexture   .addInterest ("set_specularTexture__",   this);
      this ._shininess         .addInterest ("set_shininess__",         this);
      this ._shininessTexture  .addInterest ("set_shininessTexture__",  this);
      this ._occlusionStrength .addInterest ("set_occlusionStrength__", this);
      this ._occlusionTexture  .addInterest ("set_occlusionTexture__",  this);

      this .set_ambientIntensity__ ();
      this .set_ambientTexture__ ();
      this .set_diffuseColor__ ();
      this .set_diffuseTexture__ ();
      this .set_specularColor__ ();
      this .set_specularTexture__ ();
      this .set_shininess__ ();
      this .set_shininessTexture__ ();
      this .set_occlusionStrength__ ();
      this .set_occlusionTexture__ ();
      this .set_transparent__ ();
   },
   set_ambientIntensity__: function ()
   {
      this .ambientIntensity = Math_Algorithm.clamp (this ._ambientIntensity .getValue (), 0, 1);
   },
   set_ambientTexture__: function ()
   {
      this .ambientTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._ambientTexture);

      this .setTexture (this .getTextureIndices () .AMBIENT_TEXTURE, this .ambientTextureNode);
   },
   set_diffuseColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .diffuseColor .set (this ._diffuseColor .getValue ());

      const
         diffuseColor  = this .diffuseColor,
         diffuseColor_ = this ._diffuseColor .getValue ();

      diffuseColor [0] = diffuseColor_ .r;
      diffuseColor [1] = diffuseColor_ .g;
      diffuseColor [2] = diffuseColor_ .b;
   },
   set_diffuseTexture__: function ()
   {
      if (this .diffuseTextureNode)
         this .diffuseTextureNode ._transparent .removeInterest ("set_transparent__", this);

      this .diffuseTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._diffuseTexture);

      if (this .diffuseTextureNode)
         this .diffuseTextureNode ._transparent .addInterest ("set_transparent__", this);

      this .setTexture (this .getTextureIndices () .DIFFUSE_TEXTURE, this .diffuseTextureNode);
   },
   set_specularColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .specularColor .set (this ._specularColor .getValue ());

      const
         specularColor  = this .specularColor,
         specularColor_ = this ._specularColor .getValue ();

      specularColor [0] = specularColor_ .r;
      specularColor [1] = specularColor_ .g;
      specularColor [2] = specularColor_ .b;
   },
   set_specularTexture__: function ()
   {
      this .specularTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._specularTexture);

      this .setTexture (this .getTextureIndices () .SPECULAR_TEXTURE, this .specularTextureNode);
   },
   set_shininess__: function ()
   {
      this .shininess = Math_Algorithm.clamp (this ._shininess .getValue (), 0, 1);
   },
   set_shininessTexture__: function ()
   {
      this .shininessTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._shininessTexture);

      this .setTexture (this .getTextureIndices () .SHININESS_TEXTURE, this .shininessTextureNode);
   },
   set_occlusionStrength__: function ()
   {
      this .occlusionStrength = Math_Algorithm.clamp (this ._occlusionStrength .getValue (), 0, 1);
   },
   set_occlusionTexture__: function ()
   {
      this .occlusionTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._occlusionTexture);

      this .setTexture (this .getTextureIndices () .OCCLUSION_TEXTURE, this .occlusionTextureNode);
   },
   set_transparent__: function ()
   {
      this .setTransparent (Boolean (this .getTransparency () ||
                            (this .diffuseTextureNode && this .diffuseTextureNode .getTransparent ())));
   },
   getTextureIndices: (function ()
   {
      let i = 0;

      const textureIndices = {
         EMISSIVE_TEXTURE: i ++,
         NORMAL_TEXTURE: i ++,
         AMBIENT_TEXTURE: i ++,
         DIFFUSE_TEXTURE: i ++,
         SPECULAR_TEXTURE: i ++,
         SHININESS_TEXTURE: i ++,
         OCCLUSION_TEXTURE: i ++,
      };

      return function ()
      {
         return textureIndices;
      };
   })(),
   getMaterialKey: function (shadows)
   {
      if (shadows || +this .getTextureBits ())
      {
         return "2";
      }
      else
      {
         switch (this .getBrowser () .getBrowserOptions () .getShading ())
         {
            default:
               return "1";
            case Core_Shading.PHONG:
               return "2";
         }
      }
   },
   createShader: function (key, geometryContext, renderContext)
   {
      const
         browser = this .getBrowser (),
         options = this .getShaderOptions (geometryContext, renderContext);

      if (geometryContext .hasNormals)
      {
         options .push ("X3D_MATERIAL");

         if (+this .getTextureBits ())
         {
            if (this .ambientTextureNode)
               options .push ("X3D_AMBIENT_TEXTURE", "X3D_AMBIENT_TEXTURE_" + this .ambientTextureNode .getTextureTypeString ());

            if (this .diffuseTextureNode)
               options .push ("X3D_DIFFUSE_TEXTURE", "X3D_DIFFUSE_TEXTURE_" + this .diffuseTextureNode .getTextureTypeString ());

            if (this .specularTextureNode)
               options .push ("X3D_SPECULAR_TEXTURE", "X3D_SPECULAR_TEXTURE_" + this .specularTextureNode .getTextureTypeString ());

            if (this .shininessTextureNode)
               options .push ("X3D_SHININESS_TEXTURE", "X3D_SHININESS_TEXTURE_" + this .shininessTextureNode .getTextureTypeString ());

            if (this .occlusionTextureNode)
               options .push ("X3D_OCCLUSION_TEXTURE", "X3D_OCCLUSION_TEXTURE_" + this .occlusionTextureNode .getTextureTypeString ());
         }

         switch (this .getMaterialKey (renderContext && renderContext .shadows))
         {
            case "1":
               var shaderNode = browser .createShader ("GouraudShader", "Gouraud", "Gouraud", options);
               break;
            case "2":
               var shaderNode = browser .createShader ("PhongShader", "Default", "Phong", options);
               break;
         }
      }
      else
      {
         options .push ("X3D_UNLIT_MATERIAL");

         var shaderNode = browser .createShader ("UnlitShader", "Default", "Unlit", options);

         browser .getShaders () .set (key .replace (/^(\d{1,2})\d*/, "$1") .replace (/\d$/, "0"), shaderNode);
      }

      browser .getShaders () .set (key, shaderNode);

      return shaderNode;
   },
   setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
   {
      Shape_X3DOneSidedMaterialNode.prototype.setShaderUniforms.call (this, gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping);

      gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .ambientIntensity);
      gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .diffuseColor);
      gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .specularColor);
      gl .uniform1f  (shaderObject .x3d_Shininess,        this .shininess);

      if (+this .getTextureBits ())
      {
         // Ambient parameters

         if (this .ambientTextureNode)
         {
            const ambientTexture = shaderObject .x3d_AmbientTexture;

            this .ambientTextureNode .setShaderUniforms (gl, shaderObject, renderObject, ambientTexture);

            gl .uniform1i (ambientTexture .textureTransformMapping,  textureTransformMapping  .get (this ._ambientTextureMapping .getValue ()) || 0);
            gl .uniform1i (ambientTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._ambientTextureMapping .getValue ()) || 0);
         }

         // Diffuse parameters

         if (this .diffuseTextureNode)
         {
            const diffuseTexture = shaderObject .x3d_DiffuseTexture;

            this .diffuseTextureNode .setShaderUniforms (gl, shaderObject, renderObject, diffuseTexture);

            gl .uniform1i (diffuseTexture .textureTransformMapping,  textureTransformMapping  .get (this ._diffuseTextureMapping .getValue ()) || 0);
            gl .uniform1i (diffuseTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._diffuseTextureMapping .getValue ()) || 0);
         }

         // Specular parameters

         if (this .specularTextureNode)
         {
            const specularTexture = shaderObject .x3d_SpecularTexture;

            this .specularTextureNode .setShaderUniforms (gl, shaderObject, renderObject, specularTexture);

            gl .uniform1i (specularTexture .textureTransformMapping,  textureTransformMapping  .get (this ._specularTextureMapping .getValue ()) || 0);
            gl .uniform1i (specularTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._specularTextureMapping .getValue ()) || 0);
         }

         // Shininess parameters

         if (this .shininessTextureNode)
         {
            const shininessTexture = shaderObject .x3d_ShininessTexture;

            this .shininessTextureNode .setShaderUniforms (gl, shaderObject, renderObject, shininessTexture);

            gl .uniform1i (shininessTexture .textureTransformMapping,  textureTransformMapping  .get (this ._shininessTextureMapping .getValue ()) || 0);
            gl .uniform1i (shininessTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._shininessTextureMapping .getValue ()) || 0);
         }

         // Occlusion parameters

         if (this .occlusionTextureNode)
         {
            const occlusionTexture = shaderObject .x3d_OcclusionTexture;

            gl .uniform1f (shaderObject .x3d_OcclusionStrength, this .occlusionStrength);

            this .occlusionTextureNode .setShaderUniforms (gl, shaderObject, renderObject, occlusionTexture);

            gl .uniform1i (occlusionTexture .textureTransformMapping,  textureTransformMapping  .get (this ._occlusionTextureMapping .getValue ()) || 0);
            gl .uniform1i (occlusionTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._occlusionTextureMapping .getValue ()) || 0);
         }
      }
   },
});

/* harmony default export */ const Shape_Material = (Material);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/PhysicalMaterial.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function PhysicalMaterial (executionContext)
{
   Shape_X3DOneSidedMaterialNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PhysicalMaterial);

   this .baseColor = new Float32Array (3);
}

PhysicalMaterial .prototype = Object .assign (Object .create (Shape_X3DOneSidedMaterialNode.prototype),
{
   constructor: PhysicalMaterial,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",                        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "baseColor",                       new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "baseTexture",                     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "baseTextureMapping",              new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveColor",                   new x_ite_Fields.SFColor (0, 0, 0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTexture",                 new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveTextureMapping",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metallic",                        new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "roughness",                       new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metallicRoughnessTexture",        new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metallicRoughnessTextureMapping", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionStrength",               new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionTexture",                new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "occlusionTextureMapping",         new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalScale",                     new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTexture",                   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "normalTextureMapping",            new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency",                    new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "PhysicalMaterial";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "material";
   },
   initialize: function ()
   {
      Shape_X3DOneSidedMaterialNode.prototype.initialize.call (this);

      this ._baseColor                .addInterest ("set_baseColor__",                this);
      this ._baseTexture              .addInterest ("set_baseTexture__",              this);
      this ._metallic                 .addInterest ("set_metallic__",                 this);
      this ._roughness                .addInterest ("set_roughness__",                this);
      this ._metallicRoughnessTexture .addInterest ("set_metallicRoughnessTexture__", this);
      this ._occlusionStrength        .addInterest ("set_occlusionStrength__",        this);
      this ._occlusionTexture         .addInterest ("set_occlusionTexture__",         this);

      this .set_baseColor__ ();
      this .set_baseTexture__ ();
      this .set_metallic__ ();
      this .set_roughness__ ();
      this .set_metallicRoughnessTexture__ ();
      this .set_occlusionStrength__ ();
      this .set_occlusionTexture__ ();
      this .set_transparent__ ();
   },
   set_baseColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .baseColor .set (this ._baseColor .getValue ());

      const
         baseColor  = this .baseColor,
         baseColor_ = this ._baseColor .getValue ();

      baseColor [0] = baseColor_ .r;
      baseColor [1] = baseColor_ .g;
      baseColor [2] = baseColor_ .b;
   },
   set_baseTexture__: function ()
   {
      if (this .baseTextureNode)
         this .baseTextureNode ._transparent .removeInterest ("set_transparent__", this);

      this .baseTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._baseTexture);

      this .setTexture (this .getTextureIndices () .BASE_TEXTURE, this .baseTextureNode);

      if (this .baseTextureNode)
         this .baseTextureNode ._transparent .addInterest ("set_transparent__", this);
   },
   set_metallic__: function ()
   {
      this .metallic = Math_Algorithm.clamp (this ._metallic .getValue (), 0, 1);
   },
   set_roughness__: function ()
   {
      this .roughness = Math_Algorithm.clamp (this ._roughness .getValue (), 0, 1);
   },
   set_metallicRoughnessTexture__: function ()
   {
      this .metallicRoughnessTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._metallicRoughnessTexture);

      this .setTexture (this .getTextureIndices () .METALLIC_ROUGHNESS_TEXTURE, this .metallicRoughnessTextureNode);
   },
   set_occlusionStrength__: function ()
   {
      this .occlusionStrength = Math_Algorithm.clamp (this ._occlusionStrength .getValue (), 0, 1);
   },
   set_occlusionTexture__: function ()
   {
      this .occlusionTextureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, this ._occlusionTexture);

      this .setTexture (this .getTextureIndices () .OCCLUSION_TEXTURE, this .occlusionTextureNode);
   },
   set_transparent__: function ()
   {
      this .setTransparent (Boolean (this .getTransparency () ||
                            (this .baseTextureNode && this .baseTextureNode .getTransparent ())));
   },
   getTextureIndices: (function ()
   {
      let i = 0;

      const textureIndices = {
         EMISSIVE_TEXTURE: i ++,
         NORMAL_TEXTURE:  i ++,
         BASE_TEXTURE: i ++,
         METALLIC_ROUGHNESS_TEXTURE: i ++,
         OCCLUSION_TEXTURE:  i ++,
      };

      return function ()
      {
         return textureIndices;
      };
   })(),
   getMaterialKey: function ()
   {
      return "3";
   },
   createShader: function (key, geometryContext, renderContext)
   {
      const
         browser = this .getBrowser (),
         options = this .getShaderOptions (geometryContext, renderContext);

      if (geometryContext .hasNormals)
      {
         options .push ("X3D_PHYSICAL_MATERIAL");

         if (+this .getTextureBits ())
         {
            if (this .baseTextureNode)
               options .push ("X3D_BASE_TEXTURE", "X3D_BASE_TEXTURE_" + this .baseTextureNode .getTextureTypeString ());

            if (this .metallicRoughnessTextureNode)
               options .push ("X3D_METALLIC_ROUGHNESS_TEXTURE", "X3D_METALLIC_ROUGHNESS_TEXTURE_" + this .metallicRoughnessTextureNode .getTextureTypeString ());

            if (this .occlusionTextureNode)
               options .push ("X3D_OCCLUSION_TEXTURE", "X3D_OCCLUSION_TEXTURE_" + this .occlusionTextureNode .getTextureTypeString ());
         }

         var shaderNode = browser .createShader ("PhysicalMaterialShader", "Default", "PBR", options);
      }
      else
      {
         options .push ("X3D_UNLIT_MATERIAL");

         var shaderNode = browser .createShader ("UnlitShader", "Default", "Unlit", options);

         browser .getShaders () .set (key .replace (/^(\d{1,2})\d*/, "$1") .replace (/\d$/, "0"), shaderNode);
      }

      browser .getShaders () .set (key, shaderNode);

      return shaderNode;
   },
   setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
   {
      Shape_X3DOneSidedMaterialNode.prototype.setShaderUniforms.call (this, gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping);

      gl .uniform3fv (shaderObject .x3d_BaseColor, this .baseColor);
      gl .uniform1f  (shaderObject .x3d_Metallic,  this .metallic);
      gl .uniform1f  (shaderObject .x3d_Roughness, this .roughness);

      if (+this .getTextureBits ())
      {
         // Base parameters

         if (this .baseTextureNode)
         {
            const baseTexture = shaderObject .x3d_BaseTexture;

            this .baseTextureNode .setShaderUniforms (gl, shaderObject, renderObject, baseTexture);

            gl .uniform1i (baseTexture .textureTransformMapping,  textureTransformMapping  .get (this ._baseTextureMapping .getValue ()) || 0);
            gl .uniform1i (baseTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._baseTextureMapping .getValue ()) || 0);
         }

         // Metallic roughness parameters

         if (this .metallicRoughnessTextureNode)
         {
            const metallicRoughnessTexture = shaderObject .x3d_MetallicRoughnessTexture;

            this .metallicRoughnessTextureNode .setShaderUniforms (gl, shaderObject, renderObject, metallicRoughnessTexture);

            gl .uniform1i (metallicRoughnessTexture .textureTransformMapping,  textureTransformMapping  .get (this ._metallicRoughnessTextureMapping .getValue ()) || 0);
            gl .uniform1i (metallicRoughnessTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._metallicRoughnessTextureMapping .getValue ()) || 0);
         }

         // Occlusion parameters

         if (this .occlusionTextureNode)
         {
            const occlusionTexture = shaderObject .x3d_OcclusionTexture;

            gl .uniform1f (shaderObject .x3d_OcclusionStrength, this .occlusionStrength);

            this .occlusionTextureNode .setShaderUniforms (gl, shaderObject, renderObject, occlusionTexture);

            gl .uniform1i (occlusionTexture .textureTransformMapping,  textureTransformMapping  .get (this ._occlusionTextureMapping .getValue ()) || 0);
            gl .uniform1i (occlusionTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._occlusionTextureMapping .getValue ()) || 0);
         }
      }
   },
});

/* harmony default export */ const Shape_PhysicalMaterial = (PhysicalMaterial);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/PointProperties.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function PointProperties (executionContext)
{
   Shape_X3DAppearanceChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PointProperties);

   this .pointSizeAttenuation = new Float32Array (3);
}

PointProperties .prototype = Object .assign (Object .create (Shape_X3DAppearanceChildNode.prototype),
{
   constructor: PointProperties,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pointSizeScaleFactor", new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pointSizeMinValue",    new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pointSizeMaxValue",    new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pointSizeAttenuation", new x_ite_Fields.MFFloat (1, 0, 0)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "markerType",           new x_ite_Fields.SFInt32 (1)),
   ]),
   getTypeName: function ()
   {
      return "PointProperties";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "pointProperties";
   },
   initialize: function ()
   {
      Shape_X3DAppearanceChildNode.prototype.initialize.call (this);

      const gl = this .getBrowser () .getContext ();

      this .pointSizeRange = gl .getParameter (gl .ALIASED_POINT_SIZE_RANGE);

      this ._pointSizeScaleFactor .addInterest ("set_pointSizeScaleFactor__", this);
      this ._pointSizeMinValue    .addInterest ("set_pointSizeMinValue__",    this);
      this ._pointSizeMaxValue    .addInterest ("set_pointSizeMaxValue__",    this);
      this ._pointSizeAttenuation .addInterest ("set_pointSizeAttenuation__", this);
      this ._markerType           .addInterest ("set_markerType__",           this);

      this .set_pointSizeScaleFactor__ ();
      this .set_pointSizeMinValue__ ();
      this .set_pointSizeMaxValue__ ();
      this .set_pointSizeAttenuation__ ();
      this .set_markerType__ ();
   },
   getPointSize: function (point)
   {
      const
         pointSizeAttenuation = this .pointSizeAttenuation,
         dL                   = point .magnitude ();

      let pointSize = this .pointSizeScaleFactor;

      pointSize /= pointSizeAttenuation [0] + pointSizeAttenuation [1] * dL + pointSizeAttenuation [2] * (dL * dL);
      pointSize  = Math_Algorithm.clamp (pointSize, this .pointSizeMinValue, this .pointSizeMaxValue);

      return pointSize;
   },
   set_pointSizeScaleFactor__: function ()
   {
      this .pointSizeScaleFactor = Math .max (this ._pointSizeScaleFactor .getValue (), 0);
   },
   set_pointSizeMinValue__: function ()
   {
      this .pointSizeMinValue = Math_Algorithm.clamp (this ._pointSizeMinValue .getValue (), 0, this .pointSizeRange [1]);
   },
   set_pointSizeMaxValue__: function ()
   {
      this .pointSizeMaxValue = Math_Algorithm.clamp (this ._pointSizeMaxValue .getValue (), 0, this .pointSizeRange [1]);
   },
   set_pointSizeAttenuation__: function ()
   {
      const length = this ._pointSizeAttenuation .length;

      this .pointSizeAttenuation [0] = length > 0 ? Math .max (0, this ._pointSizeAttenuation [0]) : 1;
      this .pointSizeAttenuation [1] = length > 1 ? Math .max (0, this ._pointSizeAttenuation [1]) : 0;
      this .pointSizeAttenuation [2] = length > 2 ? Math .max (0, this ._pointSizeAttenuation [2]) : 0;
   },
   set_markerType__: function ()
   {
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeScaleFactor, this .pointSizeScaleFactor);
      gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMinValue,    this .pointSizeMinValue);
      gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMaxValue,    this .pointSizeMaxValue);
      gl .uniform3fv (shaderObject .x3d_PointPropertiesPointSizeAttenuation, this .pointSizeAttenuation);
   },
});

/* harmony default export */ const Shape_PointProperties = (PointProperties);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape/TwoSidedMaterial.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function TwoSidedMaterial (executionContext)
{
   console .warn ("TwoSidedMaterial is depreciated, please use Appearance backMaterial field.");

   Shape_X3DMaterialNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TwoSidedMaterial);

   this .diffuseColor  = new Float32Array (3);
   this .specularColor = new Float32Array (3);
   this .emissiveColor = new Float32Array (3);

   this .backDiffuseColor  = new Float32Array (3);
   this .backSpecularColor = new Float32Array (3);
   this .backEmissiveColor = new Float32Array (3);
}

TwoSidedMaterial .prototype = Object .assign (Object .create (Shape_X3DMaterialNode.prototype),
{
   constructor: TwoSidedMaterial,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "separateBackColor",    new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "ambientIntensity",     new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "diffuseColor",         new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "specularColor",        new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "emissiveColor",        new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "shininess",            new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "transparency",         new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backAmbientIntensity", new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backDiffuseColor",     new x_ite_Fields.SFColor (0.8, 0.8, 0.8)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backSpecularColor",    new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backEmissiveColor",    new x_ite_Fields.SFColor ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backShininess",        new x_ite_Fields.SFFloat (0.2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "backTransparency",     new x_ite_Fields.SFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "TwoSidedMaterial";
   },
   getComponentName: function ()
   {
      return "Shape";
   },
   getContainerField: function ()
   {
      return "material";
   },
   initialize: function ()
   {
      Shape_X3DMaterialNode.prototype.initialize.call (this);

      this ._ambientIntensity .addInterest ("set_ambientIntensity__", this);
      this ._diffuseColor     .addInterest ("set_diffuseColor__",     this);
      this ._specularColor    .addInterest ("set_specularColor__",    this);
      this ._emissiveColor    .addInterest ("set_emissiveColor__",    this);
      this ._shininess        .addInterest ("set_shininess__",        this);
      this ._transparency     .addInterest ("set_transparency__",     this);

      this ._backAmbientIntensity .addInterest ("set_backAmbientIntensity__", this);
      this ._backDiffuseColor     .addInterest ("set_backDiffuseColor__",     this);
      this ._backSpecularColor    .addInterest ("set_backSpecularColor__",    this);
      this ._backEmissiveColor    .addInterest ("set_backEmissiveColor__",    this);
      this ._backShininess        .addInterest ("set_backShininess__",        this);
      this ._backTransparency     .addInterest ("set_backTransparency__",     this);

      this ._separateBackColor .addInterest ("set_transparent__", this);
      this ._transparency      .addInterest ("set_transparent__", this);
      this ._backTransparency  .addInterest ("set_transparent__", this);

      this .set_ambientIntensity__ ();
      this .set_diffuseColor__ ();
      this .set_specularColor__ ();
      this .set_emissiveColor__ ();
      this .set_shininess__ ();
      this .set_transparency__ ();

      this .set_backAmbientIntensity__ ();
      this .set_backDiffuseColor__ ();
      this .set_backSpecularColor__ ();
      this .set_backEmissiveColor__ ();
      this .set_backShininess__ ();
      this .set_backTransparency__ ();

      this .set_transparent__ ();
   },
   set_ambientIntensity__: function ()
   {
      this .ambientIntensity = Math .max (this ._ambientIntensity .getValue (), 0);
   },
   set_diffuseColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .diffuseColor .set (this ._diffuseColor .getValue ());

      const
         diffuseColor  = this .diffuseColor,
         diffuseColor_ = this ._diffuseColor .getValue ();

      diffuseColor [0] = diffuseColor_ .r;
      diffuseColor [1] = diffuseColor_ .g;
      diffuseColor [2] = diffuseColor_ .b;
   },
   set_specularColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .specularColor .set (this ._specularColor .getValue ());

      const
         specularColor  = this .specularColor,
         specularColor_ = this ._specularColor .getValue ();

      specularColor [0] = specularColor_ .r;
      specularColor [1] = specularColor_ .g;
      specularColor [2] = specularColor_ .b;
   },
   set_emissiveColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .emissiveColor .set (this ._emissiveColor .getValue ());

      const
         emissiveColor  = this .emissiveColor,
         emissiveColor_ = this ._emissiveColor .getValue ();

      emissiveColor [0] = emissiveColor_ .r;
      emissiveColor [1] = emissiveColor_ .g;
      emissiveColor [2] = emissiveColor_ .b;
   },
   set_shininess__: function ()
   {
      this .shininess = Math_Algorithm.clamp (this ._shininess .getValue (), 0, 1);
   },
   set_transparency__: function ()
   {
      this .transparency = Math_Algorithm.clamp (this ._transparency .getValue (), 0, 1);
   },
   /*
    * Back Material
    */
   set_backAmbientIntensity__: function ()
   {
      this .backAmbientIntensity = Math .max (this ._backAmbientIntensity .getValue (), 0);
   },
   set_backDiffuseColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .backDiffuseColor .set (this ._backDiffuseColor .getValue ());

      const
         backDiffuseColor  = this .backDiffuseColor,
         backDiffuseColor_ = this ._backDiffuseColor .getValue ();

      backDiffuseColor [0] = backDiffuseColor_ .r;
      backDiffuseColor [1] = backDiffuseColor_ .g;
      backDiffuseColor [2] = backDiffuseColor_ .b;
   },
   set_backSpecularColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .backSpecularColor .set (this ._backSpecularColor .getValue ());

      const
         backSpecularColor  = this .backSpecularColor,
         backSpecularColor_ = this ._backSpecularColor .getValue ();

      backSpecularColor [0] = backSpecularColor_ .r;
      backSpecularColor [1] = backSpecularColor_ .g;
      backSpecularColor [2] = backSpecularColor_ .b;
   },
   set_backEmissiveColor__: function ()
   {
      //We cannot use this in Windows Edge:
      //this .backEmissiveColor .set (this ._backEmissiveColor .getValue ());

      const
         backEmissiveColor  = this .backEmissiveColor,
         backEmissiveColor_ = this ._backEmissiveColor .getValue ();

      backEmissiveColor [0] = backEmissiveColor_ .r;
      backEmissiveColor [1] = backEmissiveColor_ .g;
      backEmissiveColor [2] = backEmissiveColor_ .b;
   },
   set_backShininess__: function ()
   {
      this .backShininess = Math_Algorithm.clamp (this ._backShininess .getValue (), 0, 1);
   },
   set_backTransparency__: function ()
   {
      this .backTransparency = Math_Algorithm.clamp (this ._backTransparency .getValue (), 0, 1);
   },
   set_transparent__: function ()
   {
      this .setTransparent (Boolean (this ._transparency .getValue () || (this ._separateBackColor .getValue () && this ._backTransparency .getValue ())));
   },
   getMaterialKey: Shape_Material.prototype.getMaterialKey,
   createShader: Shape_Material.prototype.createShader,
   setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping, front)
   {
      if (! front && this ._separateBackColor .getValue ())
      {
         gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .backAmbientIntensity);
         gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .backDiffuseColor);
         gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .backSpecularColor);
         gl .uniform3fv (shaderObject .x3d_EmissiveColor,    this .backEmissiveColor);
         gl .uniform1f  (shaderObject .x3d_Shininess,        this .backShininess);
         gl .uniform1f  (shaderObject .x3d_Transparency,     this .backTransparency);
      }
      else
      {
         gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .ambientIntensity);
         gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .diffuseColor);
         gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .specularColor);
         gl .uniform3fv (shaderObject .x3d_EmissiveColor,    this .emissiveColor);
         gl .uniform1f  (shaderObject .x3d_Shininess,        this .shininess);
         gl .uniform1f  (shaderObject .x3d_Transparency,     this .transparency);
      }
   },
});

/* harmony default export */ const Shape_TwoSidedMaterial = (TwoSidedMaterial);

;// CONCATENATED MODULE: ./src/x_ite/Components/Shape.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/



















const Shape_Types =
{
   AcousticProperties: Shape_AcousticProperties,
   Appearance:         Shape_Appearance,
   FillProperties:     Shape_FillProperties,
   LineProperties:     Shape_LineProperties,
   Material:           Shape_Material,
   PhysicalMaterial:   Shape_PhysicalMaterial,
   PointProperties:    Shape_PointProperties,
   Shape:              Shape_Shape,
   TwoSidedMaterial:   Shape_TwoSidedMaterial,
   UnlitMaterial:      Shape_UnlitMaterial,
};

const Shape_AbstractTypes =
{
   X3DAppearanceChildNode:  Shape_X3DAppearanceChildNode,
   X3DAppearanceNode:       Shape_X3DAppearanceNode,
   X3DMaterialNode:         Shape_X3DMaterialNode,
   X3DOneSidedMaterialNode: Shape_X3DOneSidedMaterialNode,
   X3DShapeNode:            Shape_X3DShapeNode,
};

for (const typeName in Shape_Types)
   Configuration_SupportedNodes.addType (typeName, Shape_Types [typeName]);

for (const typeName in Shape_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Shape_AbstractTypes [typeName]);

/* harmony default export */ const Components_Shape = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Sound/X3DSoundSourceNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function X3DSoundSourceNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);
   Time_X3DTimeDependentNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSoundSourceNode);

   this .volume = 0;
   this .media  = null;
}

X3DSoundSourceNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
   Time_X3DTimeDependentNode.prototype,
{
   constructor: X3DSoundSourceNode,
   initialize: function ()
   {
      Core_X3DChildNode.prototype.initialize.call (this);
      Time_X3DTimeDependentNode.prototype.initialize.call (this);
   },
   set_live__: function ()
   {
      Time_X3DTimeDependentNode.prototype.set_live__.call (this);

      if (this .getDisabled ())
      {
         this .getBrowser () ._volume .removeInterest ("set_volume__", this);
         this .getBrowser () ._mute   .removeInterest ("set_volume__", this);
      }
      else
      {
         this .getBrowser () ._volume .addInterest ("set_volume__", this);
         this .getBrowser () ._mute   .addInterest ("set_volume__", this);

         this .set_volume__ ();
      }
   },
   setMedia: function (value)
   {
      if (this .media)
      {
         const media = this .media [0];

         media .muted = true;
         media .pause ();
      }

      this .media = value;

      if (value)
      {
         const media = value [0];

         media .muted  = false;
         media .volume = 0;
         media .loop   = this ._loop .getValue ();

         this .setVolume (0);
         this ._duration_changed = media .duration;

         this .resetElapsedTime ();

         if (this ._isActive .getValue ())
         {
            if (this ._isPaused .getValue ())
            {
               this .set_pause ();
            }
            else
            {
               if (this .getLiveState ())
                  this .set_start ();
               else
                  this .set_pause ();
            }
         }
         else
         {
            this .set_stop ();
         }
      }
   },
   getMedia: function ()
   {
      return this .media;
   },
   setVolume: function (volume)
   {
      this .volume = Math_Algorithm.clamp (volume, 0, 1);

      this .set_volume__ ();
   },
   set_loop: function ()
   {
      if (this .media)
         this .media [0] .loop = this ._loop .getValue ();
   },
   set_volume__: function ()
   {
      if (! this .media)
         return;

      const
         mute      = this .getBrowser () ._mute .getValue (),
         intensity = Math_Algorithm.clamp (this .getBrowser () ._volume .getValue (), 0, 1),
         volume    = (! mute) * intensity * this .volume;

      this .media [0] .volume = volume;
   },
   set_speed: function ()
   { },
   set_pitch: function ()
   { },
   set_start: function ()
   {
      if (this .media)
      {
         if (this ._speed .getValue ())
         {
            this .media [0] .currentTime = 0;
            this .media [0] .play () .catch (Function .prototype);
         }
      }
   },
   set_pause: function ()
   {
      if (this .media)
         this .media [0] .pause ();
   },
   set_resume: function ()
   {
      if (this .media)
      {
         if (this ._speed .getValue ())
            this .media [0] .play () .catch (Function .prototype);
      }
   },
   set_stop: function ()
   {
      if (this .media)
         this .media [0] .pause ();
   },
   set_ended: function ()
   {
      if (this .media)
      {
         const media = this .media [0];

         if (media .currentTime < media .duration)
            return;

         if (!this ._loop .getValue ())
            this .stop ();
      }
   },
   set_time: function ()
   {
      if (this .media)
         this ._elapsedTime = this .getElapsedTime ();

      this .set_ended ();
   },
});

/* harmony default export */ const Sound_X3DSoundSourceNode = (X3DSoundSourceNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Sound/AudioClip.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function AudioClip (executionContext)
{
   Sound_X3DSoundSourceNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.AudioClip);

   this .addChildObjects ("speed", new x_ite_Fields.SFFloat (1));

   this .audio    = $("<audio></audio>");
   this .urlStack = new x_ite_Fields.MFString ();
}

AudioClip .prototype = Object .assign (Object .create (Sound_X3DSoundSourceNode.prototype),
   Networking_X3DUrlObject.prototype,
{
   constructor: AudioClip,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "enabled",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "gain",                 new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pitch",                new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "loop",                 new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "startTime",            new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "resumeTime",           new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "pauseTime",            new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "stopTime",             new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isPaused",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "isActive",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "elapsedTime",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,  "duration_changed",     new x_ite_Fields.SFTime (-1)),
   ]),
   getTypeName: function ()
   {
      return "AudioClip";
   },
   getComponentName: function ()
   {
      return "Sound";
   },
   getContainerField: function ()
   {
      return "source";
   },
   initialize: function ()
   {
      Sound_X3DSoundSourceNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      this .audio .on ("abort error",     this .setError   .bind (this));
      this .audio .on ("suspend stalled", this .setTimeout .bind (this));

      this .audio [0] .crossOrigin = "Anonymous";
      this .audio [0] .preload     = "auto";
      this .audio [0] .muted       = true;

      this .requestImmediateLoad ();
   },
   getElement: function ()
   {
      return this .audio [0];
   },
   set_live__: function ()
   {
      Sound_X3DSoundSourceNode.prototype.set_live__.call (this);
      Networking_X3DUrlObject.prototype.set_live__.call (this);
   },
   unLoadNow: function ()
   {
      this .setMedia (null);
   },
   loadNow: function ()
   {
      this .setMedia (null);
      this .urlStack .setValue (this ._url);
      this .audio .on ("canplaythrough", this .setAudio .bind (this));
      this .loadNext ();
   },
   loadNext: function ()
   {
      if (this .urlStack .length === 0)
      {
         this .audio .off ("canplaythrough");
         this ._duration_changed = -1;
         this .setLoadState (Base_X3DConstants.FAILED_STATE);
         return;
      }

      // Get URL.

      this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

      if (this .URL .protocol !== "data:")
      {
         if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
            this .URL .searchParams .set ("_", Date .now ());
      }

      this .audio .attr ("src", this .URL .href);
      this .audio .get (0) .load ();
   },
   setTimeout: function (event)
   {
      setTimeout (function ()
      {
         if (this .checkLoadState () === Base_X3DConstants.IN_PROGRESS_STATE)
            this .setError (event);
      }
      .bind (this), 3000);
   },
   setError: function (event)
   {
      if (this .URL .protocol !== "data:")
         console .warn ("Error loading audio:", decodeURI (this .URL .href), event .type);

      this .loadNext ();
   },
   setAudio: function ()
   {
      if (DEBUG)
      {
         if (this .URL .protocol !== "data:")
            console .info ("Done loading audio:", decodeURI (this .URL .href));
      }

      this .audio .unbind ("canplaythrough");
      this .setMedia (this .audio);
      this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
   },
});

/* harmony default export */ const Sound_AudioClip = (AudioClip);

;// CONCATENATED MODULE: ./src/x_ite/Components/Sound/X3DSoundNode.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function X3DSoundNode (executionContext)
{
   Core_X3DChildNode.call (this, executionContext);

   this .addType (Base_X3DConstants.X3DSoundNode);
}

X3DSoundNode .prototype = Object .assign (Object .create (Core_X3DChildNode.prototype),
{
   constructor: X3DSoundNode,
});

/* harmony default export */ const Sound_X3DSoundNode = (X3DSoundNode);

;// CONCATENATED MODULE: ./src/x_ite/Components/Sound/Sound.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/
















function Sound (executionContext)
{
   Sound_X3DSoundNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Sound);

   this .addChildObjects ("traversed", new x_ite_Fields.SFBool (true));

   this ._location .setUnit ("length");
   this ._minBack  .setUnit ("length");
   this ._minFront .setUnit ("length");
   this ._maxBack  .setUnit ("length");
   this ._maxFront .setUnit ("length");

   this .currentTraversed = true;
}

Sound .prototype = Object .assign (Object .create (Sound_X3DSoundNode.prototype),
{
   constructor: Sound,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "intensity",  new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "spatialize", new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "location",   new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "direction",  new x_ite_Fields.SFVec3f (0, 0, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "minBack",    new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "minFront",   new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "maxBack",    new x_ite_Fields.SFFloat (10)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "maxFront",   new x_ite_Fields.SFFloat (10)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "priority",   new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "source",     new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Sound";
   },
   getComponentName: function ()
   {
      return "Sound";
   },
   getContainerField: function ()
   {
      return "children";
   },
   initialize: function ()
   {
      Sound_X3DSoundNode.prototype.initialize.call (this);

      this .isLive ()  .addInterest ("set_live__", this);
      this ._traversed .addInterest ("set_live__", this);

      this ._source .addInterest ("set_source__", this);

      this .set_live__ ();
      this .set_source__ ();
   },
   setTraversed: function (value)
   {
      if (value)
      {
         if (this ._traversed .getValue () === false)
            this ._traversed = true;
      }
      else
      {
         if (this .currentTraversed !== this ._traversed .getValue ())
            this ._traversed = this .currentTraversed;
      }

      this .currentTraversed = value;
   },
   getTraversed: function ()
   {
      return this .currentTraversed;
   },
   set_live__: function ()
   {
      if (this .isLive () .getValue () && this ._traversed .getValue ())
      {
         this .getBrowser () .sensorEvents () .addInterest ("update", this);
      }
      else
      {
         this .getBrowser () .sensorEvents () .removeInterest ("update", this);
      }
   },
   set_source__: function ()
   {
      if (this .sourceNode)
         this .sourceNode .setVolume (0);

      this .sourceNode = X3DCast (Base_X3DConstants.X3DSoundSourceNode, this ._source);
   },
   update: function ()
   {
      if (! this .getTraversed ())
      {
         if (this .sourceNode)
            this .sourceNode .setVolume (0);
      }

      this .setTraversed (false);
   },
   traverse: (function ()
   {
      const
         min = { distance: 0, intersection: new Numbers_Vector3 (0, 0, 0) },
         max = { distance: 0, intersection: new Numbers_Vector3 (0, 0, 0) };

      return function (type, renderObject)
      {
         if (type !== Rendering_TraverseType.DISPLAY)
            return;

         if (! this .sourceNode)
            return;

         if (! this .sourceNode ._isActive .getValue () || this .sourceNode ._isPaused .getValue ())
            return;

         this .setTraversed (true);

         const modelViewMatrix = renderObject .getModelViewMatrix () .get ();

         this .getEllipsoidParameter (modelViewMatrix,
                                       Math .max (this ._maxBack  .getValue (), 0),
                                       Math .max (this ._maxFront .getValue (), 0),
                                       max);

         if (max .distance < 1) // Sphere radius is 1
         {
            this .getEllipsoidParameter (modelViewMatrix,
                                          Math .max (this ._minBack  .getValue (), 0),
                                          Math .max (this ._minFront .getValue (), 0),
                                          min);

            if (min .distance < 1) // Sphere radius is 1
            {
               this .sourceNode .setVolume (this ._intensity .getValue ());
            }
            else
            {
               const
                  d1        = max .intersection .magnitude (), // Viewer is here at (0, 0, 0)
                  d2        = max .intersection .distance (min .intersection),
                  d         = Math .min (d1 / d2, 1),
                  intensity = Math_Algorithm.clamp (this ._intensity .getValue (), 0, 1),
                  volume    = intensity * d;

               this .sourceNode .setVolume (volume);
            }
         }
         else
         {
            this .sourceNode .setVolume (0);
         }
      };
   })(),
   getEllipsoidParameter: (function ()
   {
      const
         location        = new Numbers_Vector3 (0, 0, 0),
         sphereMatrix    = new Numbers_Matrix4 (),
         invSphereMatrix = new Numbers_Matrix4 (),
         rotation        = new Numbers_Rotation4 (),
         scale           = new Numbers_Vector3 (1, 1, 1),
         sphere          = new Geometry_Sphere3 (1, Numbers_Vector3.Zero),
         normal          = new Numbers_Vector3 (0, 0, 0),
         line            = new Geometry_Line3 (Numbers_Vector3.Zero, Numbers_Vector3.zAxis),
         enterPoint      = new Numbers_Vector3 (0, 0, 0),
         exitPoint       = new Numbers_Vector3 (0, 0, 0);

      return function (modelViewMatrix, back, front, value)
      {
         /*
          * http://de.wikipedia.org/wiki/Ellipse
          *
          * The ellipsoid is transformed to a sphere for easier calculation and then the viewer position is
          * transformed into this coordinate system. The radius and distance can then be obtained.
          *
          * throws Error
          */

         if (back == 0 || front == 0)
         {
            sphereMatrix .multVecMatrix (value .intersection .assign (this ._location .getValue ()));
            value .distance = 1;
            return;
         }

         const
            a = (back + front) / 2,
            e = a - back,
            b = Math .sqrt (a * a - e * e);

         location .set (0, 0, e);
         scale    .set (b, b, a);
         rotation .setFromToVec (Numbers_Vector3.zAxis, this ._direction .getValue ());

         sphereMatrix
            .assign (modelViewMatrix)
            .translate (this ._location .getValue ())
            .rotate (rotation)
            .translate (location)
            .scale (scale);

         invSphereMatrix .assign (sphereMatrix) .inverse ();

         const viewer = invSphereMatrix .origin;
         location .negate () .divVec (scale);

         normal .assign (location) .subtract (viewer) .normalize ();
         line .set (viewer, normal);
         sphere .intersectsLine (line, enterPoint, exitPoint);

         value .intersection .assign (sphereMatrix .multVecMatrix (enterPoint));
         value .distance = viewer .magnitude ();
      };
   })(),
});

/* harmony default export */ const Sound_Sound = (Sound);

;// CONCATENATED MODULE: ./src/x_ite/Components/Sound.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








const Sound_Types =
{
   AudioClip: Sound_AudioClip,
   Sound:     Sound_Sound,
};

const Sound_AbstractTypes =
{
   X3DSoundNode:       Sound_X3DSoundNode,
   X3DSoundSourceNode: Sound_X3DSoundSourceNode,
};

for (const typeName in Sound_Types)
   Configuration_SupportedNodes.addType (typeName, Sound_Types [typeName]);

for (const typeName in Sound_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Sound_AbstractTypes [typeName]);

/* harmony default export */ const Components_Sound = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Text/Text.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function Text (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Text);

   this ._length     .setUnit ("length");
   this ._maxExtent  .setUnit ("length");
   this ._origin     .setUnit ("length");
   this ._textBounds .setUnit ("length");
   this ._lineBounds .setUnit ("length");
}

Text .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Text,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "string",     new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "length",     new x_ite_Fields.MFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "maxExtent",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",      new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "origin",     new x_ite_Fields.SFVec3f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "textBounds", new x_ite_Fields.SFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "lineBounds", new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "fontStyle",  new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "Text";
   },
   getComponentName: function ()
   {
      return "Text";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DGeometryNode.prototype.initialize.call (this);

      this ._fontStyle .addInterest ("set_fontStyle__", this);

      this .set_fontStyle__ ();
   },
   getMatrix: function ()
   {
      return this .textGeometry .getMatrix ();
   },
   getLength: function (index)
   {
      if (index < this ._length .length)
         return Math .max (0, this ._length [index]);

      return 0;
   },
   set_live__: function ()
   {
       Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getBrowserOptions () ._PrimitiveQuality .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getBrowserOptions () ._PrimitiveQuality .removeInterest ("requestRebuild", this);
   },
   set_fontStyle__: function ()
   {
      if (this .fontStyleNode)
         this .fontStyleNode .removeInterest ("requestRebuild", this);

      this .fontStyleNode = X3DCast (Base_X3DConstants.X3DFontStyleNode, this ._fontStyle);

      if (! this .fontStyleNode)
         this .fontStyleNode = this .getBrowser () .getDefaultFontStyle ();

      this .fontStyleNode .addInterest ("requestRebuild", this);

      this .textGeometry = this .fontStyleNode .getTextGeometry (this);

      this .setTransparent (this .textGeometry .getTransparent ());
   },
   build: function ()
   {
      this .textGeometry .update ();
      this .textGeometry .build ();

      this .setSolid (this ._solid .getValue ());
   },
   traverse: function (type, renderObject)
   {
      this .textGeometry .traverse (type, renderObject);

      Rendering_X3DGeometryNode.prototype.traverse.call (this, type, renderObject);
   },
   display: function (gl, renderContext)
   {
      this .textGeometry .display (gl, renderContext);

      Rendering_X3DGeometryNode.prototype.display.call (this, gl, renderContext);

      renderContext .textureNode = null;
   },
   transformLine: function (line)
   {
      // Apply sceen nodes transformation in place here.
      return this .textGeometry .transformLine (line);
   },
   transformMatrix: function (matrix)
   {
      // Apply sceen nodes transformation in place here.
      return this .textGeometry .transformMatrix (matrix);
   },
});

/* harmony default export */ const Text_Text = (Text);

;// CONCATENATED MODULE: ./src/x_ite/Components/Text.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







const Text_Types =
{
   FontStyle: Text_FontStyle,
   Text: Text_Text,
};

const Text_AbstractTypes =
{
   X3DFontStyleNode: Text_X3DFontStyleNode,
};

for (const typeName in Text_Types)
   Configuration_SupportedNodes.addType (typeName, Text_Types [typeName]);

for (const typeName in Text_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Text_AbstractTypes [typeName]);

/* harmony default export */ const Components_Text = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/MovieTexture.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function MovieTexture (executionContext)
{
   Texturing_X3DTexture2DNode.call (this, executionContext);
   Sound_X3DSoundSourceNode.call (this, executionContext);
   Networking_X3DUrlObject.call (this, executionContext);

   this .addType (Base_X3DConstants.MovieTexture);

   this .canvas   = $("<canvas></canvas>");
   this .video    = $("<video></video>");
   this .urlStack = new x_ite_Fields.MFString ();
}

MovieTexture .prototype = Object .assign (Object .create (Texturing_X3DTexture2DNode.prototype),
   Sound_X3DSoundSourceNode.prototype,
   Networking_X3DUrlObject.prototype,
{
   constructor: MovieTexture,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",             new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "description",          new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "enabled",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "load",                 new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "url",                  new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefresh",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "autoRefreshTimeLimit", new x_ite_Fields.SFTime (3600)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "gain",                 new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "speed",                new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "pitch",                new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "loop",                 new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "startTime",            new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "resumeTime",           new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "pauseTime",            new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "stopTime",             new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isPaused",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "isActive",             new x_ite_Fields.SFBool ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "elapsedTime",          new x_ite_Fields.SFTime ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.outputOnly,     "duration_changed",     new x_ite_Fields.SFTime (-1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatS",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatT",              new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "textureProperties",    new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "MovieTexture";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texture";
   },
   initialize: function ()
   {
      Texturing_X3DTexture2DNode.prototype.initialize.call (this);
      Sound_X3DSoundSourceNode.prototype.initialize.call (this);
      Networking_X3DUrlObject.prototype.initialize.call (this);

      this .video .on ("abort error",     this .setError   .bind (this));
      this .video .on ("suspend stalled", this .setTimeout .bind (this));

      this .video [0] .crossOrigin = "Anonymous";
      this .video [0] .preload     = "auto";
      this .video [0] .muted       = true;

      this .requestImmediateLoad ();
   },
   getElement: function ()
   {
      return this .video [0];
   },
   set_live__: function ()
   {
      Sound_X3DSoundSourceNode.prototype.set_live__.call (this);
      Networking_X3DUrlObject.prototype.set_live__.call (this);
   },
   unLoadNow: function ()
   {
      this .clearTexture ();
   },
   loadNow: function ()
   {
      this .setMedia (null);
      this .urlStack .setValue (this ._url);
      this .video .on ("canplaythrough", this .setVideo .bind (this));
      this .loadNext ();
   },
   loadNext: function ()
   {
      if (this .urlStack .length === 0)
      {
         this .video .off ("canplaythrough");
         this ._duration_changed = -1;
         this .clearTexture ();
         this .setLoadState (Base_X3DConstants.FAILED_STATE);
         return;
      }

      // Get URL.

      this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

      if (this .URL .protocol !== "data:")
      {
         if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
            this .URL .searchParams .set ("_", Date .now ());
      }

      this .video .attr ("src", this .URL .href);
      this .video .get (0) .load ();
   },
   setTimeout: function (event)
   {
      setTimeout (function ()
      {
         if (this .checkLoadState () === Base_X3DConstants.IN_PROGRESS_STATE)
            this .setError (event);
      }
      .bind (this), 3000);
   },
   setError: function (event)
   {
      if (this .URL .protocol !== "data:")
         console .warn ("Error loading movie:", decodeURI (this .URL .href), event .type);

      this .loadNext ();
   },
   setVideo: function ()
   {
      if (DEBUG)
      {
         if (this .URL .protocol !== "data:")
            console .info ("Done loading movie:", decodeURI (this .URL .href));
      }

      try
      {
         this .video .unbind ("canplaythrough");

         const
            video  = this .video [0],
            width  = video .videoWidth,
            height = video .videoHeight,
            canvas = this .canvas [0],
            cx     = canvas .getContext ("2d", { willReadFrequently: true });

         if (! Math_Algorithm.isPowerOfTwo (width) || ! Math_Algorithm.isPowerOfTwo (height))
            throw new Error ("The movie texture is a non power-of-two texture.");

         canvas .width  = width;
         canvas .height = height;

         cx .drawImage (video, 0, 0);

         const data = cx .getImageData (0, 0, width, height) .data;

         this .setMedia (this .video);
         this .setTexture (width, height, false, new Uint8Array (data .buffer), true);
         this .setLoadState (Base_X3DConstants.COMPLETE_STATE);
      }
      catch (error)
      {
         // Catch security error from cross origin requests.
         console .log (error .message);
         this .setError ();
      }
   },
   set_time: function ()
   {
      Sound_X3DSoundSourceNode.prototype.set_time.call (this);

      if (this .checkLoadState () === Base_X3DConstants.COMPLETE_STATE)
         this .updateTexture (this .getMedia () [0], true);
   },
   traverse: Texturing_X3DTexture2DNode.prototype.traverse,
});

/* harmony default export */ const Texturing_MovieTexture = (MovieTexture);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/MultiTexture.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/












function MultiTexture (executionContext)
{
   Texturing_X3DTextureNode.call (this, executionContext);

   this .addType (Base_X3DConstants.MultiTexture);

   this .addChildObjects ("loadState", new x_ite_Fields.SFInt32 (Base_X3DConstants.NOT_STARTED_STATE));

   this .color        = new Float32Array (4);
   this .modes        = [ ];
   this .alphaModes   = [ ];
   this .sources      = [ ];
   this .functions    = [ ];
   this .textureNodes = [ ];
}

MultiTexture .prototype = Object .assign (Object .create (Texturing_X3DTextureNode.prototype),
{
   constructor: MultiTexture,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "description", new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "color",       new x_ite_Fields.SFColor (1, 1, 1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "alpha",       new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "mode",        new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "source",      new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "function",    new x_ite_Fields.MFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "texture",     new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "MultiTexture";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texture";
   },
   initialize: function ()
   {
      Texturing_X3DTextureNode.prototype.initialize.call (this);

      this ._color    .addInterest ("set_color__",    this);
      this ._alpha    .addInterest ("set_alpha__",    this);
      this ._mode     .addInterest ("set_mode__",     this);
      this ._source   .addInterest ("set_source__",   this);
      this ._function .addInterest ("set_function__", this);
      this ._texture  .addInterest ("set_texture__",  this);

      this .set_color__ ();
      this .set_alpha__ ();
      this .set_mode__ ();
      this .set_source__ ();
      this .set_function__ ();
      this .set_texture__ ();

      this ._loadState = Base_X3DConstants.COMPLETE_STATE;
   },
   getCount: function ()
   {
      return Math .min (this .getBrowser () .getMaxTextures (), this .textureNodes .length);
   },
   getMode: function (index)
   {
      if (index < this .modes .length)
         return this .modes [index];

      return Texturing_ModeType.MODULATE;
   },
   getAlphaMode: function (index)
   {
      if (index < this .alphaModes .length)
         return this .alphaModes [index];

      return Texturing_ModeType.MODULATE;
   },
   getSource: function (index)
   {
      if (index < this .sources .length)
         return this .sources [index];

      return Texturing_SourceType.DEFAULT;
   },
   getFunction: function (index)
   {
      if (index < this .functions .length)
         return this .functions [index];

      return Texturing_FunctionType.DEFAULT;
   },
   set_color__: function ()
   {
      this .color [0] = this ._color .r;
      this .color [1] = this ._color .g;
      this .color [2] = this ._color .b;
   },
   set_alpha__: function ()
   {
      this .color [3] = this ._alpha;
   },
   set_mode__: (function ()
   {
      const modeTypes = new Map ([
         ["REPLACE",                   Texturing_ModeType.REPLACE],
         ["MODULATE",                  Texturing_ModeType.MODULATE],
         ["MODULATE2X",                Texturing_ModeType.MODULATE2X],
         ["MODULATE4X",                Texturing_ModeType.MODULATE4X],
         ["ADD",                       Texturing_ModeType.ADD],
         ["ADDSIGNED",                 Texturing_ModeType.ADDSIGNED],
         ["ADDSIGNED2X",               Texturing_ModeType.ADDSIGNED2X],
         ["ADDSMOOTH",                 Texturing_ModeType.ADDSMOOTH],
         ["SUBTRACT",                  Texturing_ModeType.SUBTRACT],
         ["BLENDDIFFUSEALPHA",         Texturing_ModeType.BLENDDIFFUSEALPHA],
         ["BLENDTEXTUREALPHA",         Texturing_ModeType.BLENDTEXTUREALPHA],
         ["BLENDFACTORALPHA",          Texturing_ModeType.BLENDFACTORALPHA],
         ["BLENDCURRENTALPHA",         Texturing_ModeType.BLENDCURRENTALPHA],
         ["MODULATEALPHA_ADDCOLOR",    Texturing_ModeType.MODULATEALPHA_ADDCOLOR],
         ["MODULATEINVALPHA_ADDCOLOR", Texturing_ModeType.MODULATEINVALPHA_ADDCOLOR],
         ["MODULATEINVCOLOR_ADDALPHA", Texturing_ModeType.MODULATEINVCOLOR_ADDALPHA],
         ["DOTPRODUCT3",               Texturing_ModeType.DOTPRODUCT3],
         ["SELECTARG1",                Texturing_ModeType.SELECTARG1],
         ["SELECTARG2",                Texturing_ModeType.SELECTARG2],
         ["OFF",                       Texturing_ModeType.OFF],
      ]);

      return function ()
      {
         this .modes      .length = 0;
         this .alphaModes .length = 0;

         for (const modes of this ._mode)
         {
            const mode = modes .split (",");

            for (let m = 0, l = mode .length; m < l; ++ m)
               mode [m] = mode [m] .trim ();

            if (mode .length === 0)
               mode .push ("MODULATE");

            if (mode .length < 2)
               mode .push (mode [0]);

            // RGB

            const modeType = modeTypes .get (mode [0]);

            if (modeType !== undefined)
               this .modes .push (modeType);
            else
               this .modes .push (Texturing_ModeType.MODULATE);

            // Alpha

            const alphaModeType = modeTypes .get (mode [1]);

            if (alphaModeType !== undefined)
               this .alphaModes .push (alphaModeType);
            else
               this .alphaModes .push (Texturing_ModeType.MODULATE);
         }
      };
   })(),
   set_source__: (function ()
   {
      const sourceTypes = new Map ([
         ["DIFFUSE",  Texturing_SourceType.DIFFUSE],
         ["SPECULAR", Texturing_SourceType.SPECULAR],
         ["FACTOR",   Texturing_SourceType.FACTOR],
      ]);

      return function ()
      {
         this .sources .length = 0;

         for (const source of this ._source)
         {
            const sourceType = sourceTypes .get (source);

            if (sourceType !== undefined)
               this .sources .push (sourceType);
            else
               this .sources .push (Texturing_SourceType.DEFAULT);
         }
      };
   })(),
   set_function__: (function ()
   {
      const functionsTypes = new Map ([
         ["COMPLEMENT",     Texturing_FunctionType.COMPLEMENT],
         ["ALPHAREPLICATE", Texturing_FunctionType.ALPHAREPLICATE],
      ]);

      return function ()
      {
         this .functions .length = 0;

         for (const func of this ._function)
         {
            const functionsType = functionsTypes .get (func);

            if (functionsType !== undefined)
               this .functions .push (functionsType);
            else
               this .functions .push (Texturing_FunctionType.DEFAULT);
         }
      };
   })(),
   set_texture__: function ()
   {
      this .textureNodes .length = 0;

      for (const node of this ._texture)
      {
         const textureNode = X3DCast (Base_X3DConstants.X3DSingleTextureNode, node);

         if (textureNode)
            this .textureNodes .push (textureNode);
      }
   },
   updateTextureBits: function (textureBits)
   {
      const
         maxTextures  = this .getBrowser () .getMaxTextures (),
         textureNodes = this .textureNodes,
         channels     = Math .min (maxTextures, textureNodes .length);

      for (let i = 0; i < channels; ++ i)
         textureNodes [i] .updateTextureBits (textureBits, i);

      textureBits .set (maxTextures * 2, 1);
   },
   getShaderOptions: function (options)
   {
      const
         textureNodes = this .textureNodes,
         channels     = Math .min (this .getBrowser () .getMaxTextures (), textureNodes .length);

      for (let i = 0; i < channels; ++ i)
         textureNodes [i] .getShaderOptions (options, i);
   },
   traverse: function (type, renderObject)
   {
      for (const textureNode of this .textureNodes)
         textureNode .traverse (type, renderObject);
   },
   setShaderUniforms: function (gl, shaderObject, renderObject)
   {
      const
         textureNodes = this .textureNodes,
         channels     = Math .min (this .getBrowser () .getMaxTextures (), textureNodes .length);

      gl .uniform4fv (shaderObject .x3d_MultiTextureColor, this .color);

      for (let i = 0; i < channels; ++ i)
      {
         textureNodes [i] .setShaderUniforms (gl, shaderObject, renderObject, shaderObject .x3d_Texture [i]);

         gl .uniform1i  (shaderObject .x3d_MultiTextureMode [i],      this .getMode (i));
         gl .uniform1i  (shaderObject .x3d_MultiTextureAlphaMode [i], this .getAlphaMode (i));
         gl .uniform1i  (shaderObject .x3d_MultiTextureSource [i],    this .getSource (i));
         gl .uniform1i  (shaderObject .x3d_MultiTextureFunction [i],  this .getFunction (i));
      }
   },
});

/* harmony default export */ const Texturing_MultiTexture = (MultiTexture);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/MultiTextureCoordinate.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function MultiTextureCoordinate (executionContext)
{
   Texturing_X3DTextureCoordinateNode.call (this, executionContext);

   this .addType (Base_X3DConstants.MultiTextureCoordinate);

   this .textureCoordinateNodes = [ ];
}

MultiTextureCoordinate .prototype = Object .assign (Object .create (Texturing_X3DTextureCoordinateNode.prototype),
{
   constructor: MultiTextureCoordinate,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "texCoord", new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "MultiTextureCoordinate";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texCoord";
   },
   initialize: function ()
   {
      Texturing_X3DTextureCoordinateNode.prototype.initialize.call (this);

      this ._texCoord .addInterest ("set_texCoord__", this);

      this .set_texCoord__ ();
   },
   set_texCoord__: function ()
   {
      const textureCoordinateNodes = this .textureCoordinateNodes;

      for (const textureCoordinateNode of textureCoordinateNodes)
         textureCoordinateNode .removeInterest ("addNodeEvent", this);

      textureCoordinateNodes .length = 0;

      for (const node of this ._texCoord)
      {
         const textureCoordinateNode = X3DCast (Base_X3DConstants.X3DSingleTextureCoordinateNode, node);

         if (textureCoordinateNode)
            textureCoordinateNodes .push (textureCoordinateNode);
      }

      for (const textureCoordinateNode of textureCoordinateNodes)
         textureCoordinateNode .addInterest ("addNodeEvent", this);
   },
   getCount: function ()
   {
      return Math .min (this .getBrowser () .getMaxTextures (), this .textureCoordinateNodes .length);
   },
   isEmpty: function ()
   {
      return true;
   },
   getSize: function ()
   {
      return 0;
   },
   get1Point: function (index, vector)
   {
      for (const textureCoordinateNode of this .textureCoordinateNodes)
         return textureCoordinateNode .get1Point (index, vector);

      return vector .set (0, 0, 0, 1);
   },
   init: function (multiArray)
   {
      for (const textureCoordinateNode of this .textureCoordinateNodes)
         textureCoordinateNode .init (multiArray);
   },
   addTexCoord: function (index, multiArray)
   {
      const textureCoordinateNodes = this .textureCoordinateNodes;

      for (let i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
         textureCoordinateNodes [i] .addTexCoordToChannel (index, multiArray [i]);
   },
   addTexCoordToChannel: function (index, array)
   { },
   getTexCoord: function (array)
   {
      for (const textureCoordinateNode of this .textureCoordinateNodes)
         return textureCoordinateNode .getTexCoord (array);

      return array;
   },
   getTextureCoordinateMapping: function (textureCoordinateMapping)
   {
      const
         textureCoordinateNodes = this .textureCoordinateNodes,
         length                 = Math .min (this .getBrowser () .getMaxTextures (), textureCoordinateNodes .length);

      for (let i = 0; i < length; ++ i)
         textureCoordinateNodes [i] .getTextureCoordinateMapping (textureCoordinateMapping, i);
   },
   setShaderUniforms: function (gl, shaderObject)
   {
      const
         textureCoordinateNodes = this .textureCoordinateNodes,
         length                 = Math .min (shaderObject .x3d_MaxTextures, textureCoordinateNodes .length);

      for (let i = 0; i < length; ++ i)
         textureCoordinateNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

      if (length)
      {
         const last = textureCoordinateNodes .at (-1);

         for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
            last .setShaderUniformsToChannel (gl, shaderObject, i);
      }
      else
      {
         for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
            gl .uniform1i (shaderObject .x3d_TextureCoordinateGeneratorMode [i], 0);
      }
   },
});

/* harmony default export */ const Texturing_MultiTextureCoordinate = (MultiTextureCoordinate);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/MultiTextureTransform.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function MultiTextureTransform (executionContext)
{
   Texturing_X3DTextureTransformNode.call (this, executionContext);

   this .addType (Base_X3DConstants.MultiTextureTransform);

   this .textureTransformNodes = [ ];
}

MultiTextureTransform .prototype = Object .assign (Object .create (Texturing_X3DTextureTransformNode.prototype),
{
   constructor: MultiTextureTransform,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",         new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "textureTransform", new x_ite_Fields.MFNode ()),
   ]),
   getTypeName: function ()
   {
      return "MultiTextureTransform";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "textureTransform";
   },
   initialize: function ()
   {
      Texturing_X3DTextureTransformNode.prototype.initialize.call (this);

      this ._textureTransform .addInterest ("set_textureTransform__", this);

      this .set_textureTransform__ ();
   },
   set_textureTransform__: function ()
   {
      const textureTransformNodes = this .textureTransformNodes;

      textureTransformNodes .length = 0;

      for (const node of this ._textureTransform)
      {
         const textureTransformNode = X3DCast (Base_X3DConstants.X3DSingleTextureTransformNode, node);

         if (textureTransformNode)
            textureTransformNodes .push (textureTransformNode);
      }
   },
   getCount: function ()
   {
      return Math .min (this .getBrowser () .getMaxTextures (), this .textureTransformNodes .length);
   },
   getTextureTransformMapping: function (textureTransformMapping)
   {
      const
         textureTransformNodes = this .textureTransformNodes,
         length                = Math .min (this .getBrowser () .getMaxTextures (), textureTransformNodes .length);

      for (let i = 0; i < length; ++ i)
         textureTransformNodes [i] .getTextureTransformMapping (textureTransformMapping, i);
   },
   setShaderUniforms: (function ()
   {
      const matrixArray = new Float32Array (Numbers_Matrix4.Identity);

      return function (gl, shaderObject)
      {
         const
            textureTransformNodes = this .textureTransformNodes,
            length                = Math .min (shaderObject .x3d_MaxTextures, textureTransformNodes .length);

         for (let i = 0; i < length; ++ i)
            textureTransformNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

         if (length)
         {
            const last = textureTransformNodes .at (-1);

            for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
               last .setShaderUniformsToChannel (gl, shaderObject, i);
         }
         else
         {
            for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
               gl .uniformMatrix4fv (shaderObject .x3d_TextureMatrix [i], false, matrixArray);
         }
      };
   })(),
});

/* harmony default export */ const Texturing_MultiTextureTransform = (MultiTextureTransform);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/PixelTexture.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/











function PixelTexture (executionContext)
{
   Texturing_X3DTexture2DNode.call (this, executionContext);

   this .addType (Base_X3DConstants.PixelTexture);

   this .addChildObjects ("loadState", new x_ite_Fields.SFInt32 (Base_X3DConstants.NOT_STARTED_STATE));
}

PixelTexture .prototype = Object .assign (Object .create (Texturing_X3DTexture2DNode.prototype),
{
   constructor: PixelTexture,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",          new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "description",       new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "image",             new x_ite_Fields.SFImage (0, 0, 0, new x_ite_Fields.MFInt32 ())),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatS",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "repeatT",           new x_ite_Fields.SFBool (true)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "textureProperties", new x_ite_Fields.SFNode ()),
   ]),
   getTypeName: function ()
   {
      return "PixelTexture";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texture";
   },
   initialize: function ()
   {
      Texturing_X3DTexture2DNode.prototype.initialize.call (this);

      this ._image .addInterest ("set_image__", this);

      this .canvas1 = $("<canvas></canvas>");
      this .canvas2 = $("<canvas></canvas>");

      this .set_image__ ();
   },
   checkLoadState: function ()
   {
      return this ._loadState .getValue ();
   },
   convert: function (data, comp, array, length)
   {
      switch (comp)
      {
         case 1:
         {
            for (let i = 0, index = 0; i < length; ++ i, index += 4)
            {
               const pixel = array [i];

               data [index]     =
               data [index + 1] =
               data [index + 2] = pixel & 255;
               data [index + 3] = 255;
            }

            break;
         }
         case 2:
         {
            for (let i = 0, index = 0; i < length; ++ i, index += 4)
            {
               const pixel = array [i];

               data [index]     =
               data [index + 1] =
               data [index + 2] = (pixel >>> 8) & 255;
               data [index + 3] = pixel & 255;
            }

            break;
         }
         case 3:
         {
            for (let i = 0, index = 0; i < length; ++ i, index += 4)
            {
               const pixel = array [i];

               data [index]     = (pixel >>> 16) & 255;
               data [index + 1] = (pixel >>>  8) & 255;
               data [index + 2] = pixel & 255;
               data [index + 3] = 255;
            }

            break;
         }
         case 4:
         {
            for (let i = 0, index = 0; i < length; ++ i, index += 4)
            {
               const pixel = array [i];

               data [index]     = (pixel >>> 24);
               data [index + 1] = (pixel >>> 16) & 255;
               data [index + 2] = (pixel >>>  8) & 255;
               data [index + 3] = pixel & 255;
            }

            break;
         }
      }
   },
   resize: function (input, inputWidth, inputHeight, outputWidth, outputHeight)
   {
      // Nearest neighbor scaling algorithm for very small images.

      const
         output = new Uint8Array (outputWidth * outputHeight * 4),
         scaleX = outputWidth / inputWidth,
         scaleY = outputHeight / inputHeight;

      for (let y = 0; y < outputHeight; ++ y)
      {
         const
            inputW  = Math .floor (y / scaleY) * inputWidth,
            outputW = y * outputWidth;

         for (let x = 0; x < outputWidth; ++ x)
         {
            const
               index       = (inputW + Math.floor (x / scaleX)) * 4,
               indexScaled = (outputW + x) * 4;

            output [indexScaled]     = input [index];
            output [indexScaled + 1] = input [index + 1];
            output [indexScaled + 2] = input [index + 2];
            output [indexScaled + 3] = input [index + 3];
         }
      }

      return output;
   },
   set_image__: function ()
   {
      const
         gl          = this .getBrowser () .getContext (),
         comp        = this ._image .comp,
         array       = this ._image .array,
         transparent = !(comp % 2);

      let
         width  = this ._image .width,
         height = this ._image .height,
         data   = null;

      if (width > 0 && height > 0 && comp > 0 && comp < 5)
      {
         if (gl .getVersion () >= 2 || (Math_Algorithm.isPowerOfTwo (width) && Math_Algorithm.isPowerOfTwo (height)))
         {
            data = new Uint8Array (width * height * 4);

            this .convert (data, comp, array .getValue (), array .length);
         }
         else if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! this ._textureProperties .getValue ())
         {
            data = new Uint8Array (width * height * 4);

            this .convert (data, comp, array .getValue (), array .length);

            const
               inputWidth  = width,
               inputHeight = height;

            width  = Math_Algorithm.nextPowerOfTwo (inputWidth)  * 4;
            height = Math_Algorithm.nextPowerOfTwo (inputHeight) * 4;
            data   = this .resize (data, inputWidth, inputHeight, width, height);
         }
         else
         {
            const
               canvas1   = this .canvas1 [0],
               canvas2   = this .canvas2 [0],
               cx1       = canvas1 .getContext ("2d", { willReadFrequently: true }),
               cx2       = canvas2 .getContext ("2d", { willReadFrequently: true }),
               imageData = cx1 .createImageData (width, height);

            canvas1 .width  = width;
            canvas1 .height = height;

            this .convert (imageData .data, comp, array, array .length);
            cx1 .putImageData (imageData, 0, 0);

            width  = Math_Algorithm.nextPowerOfTwo (width);
            height = Math_Algorithm.nextPowerOfTwo (height);

            canvas2 .width  = width;
            canvas2 .height = height;

            cx2 .clearRect (0, 0, width, height);
            cx2 .drawImage (canvas1, 0, 0, canvas1 .width, canvas1 .height, 0, 0, width, height);

            data = cx2 .getImageData (0, 0, width, height) .data;
         }

         this .setTexture (width, height, transparent, new Uint8Array (data .buffer), false);
         this ._loadState = Base_X3DConstants.COMPLETE_STATE;
      }
      else
      {
         this .clearTexture ();
         this ._loadState = Base_X3DConstants.FAILED_STATE;
      }
   },
});

/* harmony default export */ const Texturing_PixelTexture = (PixelTexture);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing/TextureCoordinateGenerator.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function TextureCoordinateGenerator (executionContext)
{
   Texturing_X3DSingleTextureCoordinateNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TextureCoordinateGenerator);

   this .mode      = TextureCoordinateGeneratorModeType.SPHERE;
   this .parameter = new Float32Array (6);
}

TextureCoordinateGenerator .prototype = Object .assign (Object .create (Texturing_X3DSingleTextureCoordinateNode.prototype),
{
   constructor: TextureCoordinateGenerator,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata",  new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "mapping",   new x_ite_Fields.SFString ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "mode",      new x_ite_Fields.SFString ("SPHERE")),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "parameter", new x_ite_Fields.MFFloat ()),
   ]),
   getTypeName: function ()
   {
      return "TextureCoordinateGenerator";
   },
   getComponentName: function ()
   {
      return "Texturing";
   },
   getContainerField: function ()
   {
      return "texCoord";
   },
   initialize: function ()
   {
      Texturing_X3DSingleTextureCoordinateNode.prototype.initialize.call (this);

      this ._mode      .addInterest ("set_mode__",      this);
      this ._parameter .addInterest ("set_parameter__", this);

      this .set_mode__ ();
      this .set_parameter__ ();
   },
   set_mode__: (function ()
   {
      const modes = new Map ([
         ["SPHERE",                      TextureCoordinateGeneratorModeType.SPHERE],
         ["CAMERASPACENORMAL",           TextureCoordinateGeneratorModeType.CAMERASPACENORMAL],
         ["CAMERASPACEPOSITION",         TextureCoordinateGeneratorModeType.CAMERASPACEPOSITION],
         ["CAMERASPACEREFLECTIONVECTOR", TextureCoordinateGeneratorModeType.CAMERASPACEREFLECTIONVECTOR],
         ["SPHERE-LOCAL",                TextureCoordinateGeneratorModeType.SPHERE_LOCAL],
         ["COORD",                       TextureCoordinateGeneratorModeType.COORD],
         ["COORD-EYE",                   TextureCoordinateGeneratorModeType.COORD_EYE],
         ["NOISE",                       TextureCoordinateGeneratorModeType.NOISE],
         ["NOISE-EYE",                   TextureCoordinateGeneratorModeType.NOISE_EYE],
         ["SPHERE-REFLECT",              TextureCoordinateGeneratorModeType.SPHERE_REFLECT],
         ["SPHERE-REFLECT-LOCAL",        TextureCoordinateGeneratorModeType.SPHERE_REFLECT_LOCAL],
      ]);

      return function ()
      {
         this .mode = modes .get (this ._mode .getValue ());

         if (this .mode === undefined)
            this .mode = TextureCoordinateGeneratorModeType.SPHERE;
      };
   })(),
   set_parameter__: function ()
   {
      const length = Math .min (this .parameter .length, this ._parameter .length)

      for (let i = 0; i < length; ++ i)
         this .parameter [i] = this ._parameter [i];

      this .parameter .fill (0, length);
   },
   get1Point: function (index, vector)
   {
      return vector;
   },
   addTexCoordToChannel: function (index, array)
   {
      array .push (0, 0, 0, 1);
   },
   getTexCoord: function (array)
   {
      return array;
   },
   setShaderUniformsToChannel: function (gl, shaderObject, channel = 0)
   {
      gl .uniform1i  (shaderObject .x3d_TextureCoordinateGeneratorMode [channel],      this .mode);
      gl .uniform1fv (shaderObject .x3d_TextureCoordinateGeneratorParameter [channel], this .parameter);
   },
});

/* harmony default export */ const Texturing_TextureCoordinateGenerator = (TextureCoordinateGenerator);

;// CONCATENATED MODULE: ./src/x_ite/Components/Texturing.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





















const Texturing_Types =
{
   ImageTexture:               Texturing_ImageTexture,
   MovieTexture:               Texturing_MovieTexture,
   MultiTexture:               Texturing_MultiTexture,
   MultiTextureCoordinate:     Texturing_MultiTextureCoordinate,
   MultiTextureTransform:      Texturing_MultiTextureTransform,
   PixelTexture:               Texturing_PixelTexture,
   TextureCoordinate:          Texturing_TextureCoordinate,
   TextureCoordinateGenerator: Texturing_TextureCoordinateGenerator,
   TextureProperties:          Texturing_TextureProperties,
   TextureTransform:           Texturing_TextureTransform,
};

const Texturing_AbstractTypes =
{
   X3DSingleTextureCoordinateNode: Texturing_X3DSingleTextureCoordinateNode,
   X3DSingleTextureNode:           Texturing_X3DSingleTextureNode,
   X3DSingleTextureTransformNode:  Texturing_X3DSingleTextureTransformNode,
   X3DTexture2DNode:               Texturing_X3DTexture2DNode,
   X3DTextureCoordinateNode:       Texturing_X3DTextureCoordinateNode,
   X3DTextureNode:                 Texturing_X3DTextureNode,
   X3DTextureTransformNode:        Texturing_X3DTextureTransformNode,
};

for (const typeName in Texturing_Types)
   Configuration_SupportedNodes.addType (typeName, Texturing_Types [typeName]);

for (const typeName in Texturing_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Texturing_AbstractTypes [typeName]);

/* harmony default export */ const Texturing = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components/Time.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/






const Time_Types =
{
   TimeSensor: Time_TimeSensor,
};

const Time_AbstractTypes =
{
   X3DTimeDependentNode: Time_X3DTimeDependentNode,
};

for (const typeName in Time_Types)
   Configuration_SupportedNodes.addType (typeName, Time_Types [typeName]);

for (const typeName in Time_AbstractTypes)
   Configuration_SupportedNodes.addAbstractType (typeName, Time_AbstractTypes [typeName]);

/* harmony default export */ const Time = ((/* unused pure expression or super */ null && (undefined)));

;// CONCATENATED MODULE: ./src/x_ite/Components.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

























function Components () { }

Components .prototype =
{
   addComponent: function (component)
   {
      if (component .types)
      {
         for (const typeName in component .types)
            Configuration_SupportedNodes.addType (typeName, component .types [typeName]);
      }

      if (component .abstractTypes)
      {
         for (const typeName in component .abstractTypes)
            Configuration_SupportedNodes.addAbstractType (typeName, component .abstractTypes [typeName]);
      }

      if (component .browserContext)
         Browser_X3DBrowserContext.addBrowserContext (component .browserContext);

      if (component .name)
      {
         if (DEBUG)
            console .info ("Done loading external component '" + component .name + "'.");
      }
   },
};

/* harmony default export */ const x_ite_Components = (new Components ());

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/Arc2DOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function ArcClose2DOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("dimension", new x_ite_Fields.SFInt32 (40))
}

ArcClose2DOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: ArcClose2DOptions,
   getTypeName: function ()
   {
      return "ArcClose2DOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "arcClose2DOptions";
   },
});

/* harmony default export */ const Arc2DOptions = (ArcClose2DOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/ArcClose2DOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/





function ArcClose2DOptions_Arc2DOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("dimension", new x_ite_Fields.SFInt32 (40))
}

ArcClose2DOptions_Arc2DOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: ArcClose2DOptions_Arc2DOptions,
   getTypeName: function ()
   {
      return "Arc2DOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "arc2DOptions";
   },
});

/* harmony default export */ const Geometry2D_ArcClose2DOptions = (ArcClose2DOptions_Arc2DOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/Circle2DOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/







function Circle2DOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("dimension", new x_ite_Fields.SFInt32 (40))

   this .vertices = Rendering_X3DGeometryNode.createArray ();
}

Circle2DOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: Circle2DOptions,
   getTypeName: function ()
   {
      return "Circle2DOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "circle2DOptions";
   },
   initialize: function ()
   {
      this .addInterest ("build", this);

      this .build ();
   },
   getVertices: function ()
   {
      return this .vertices;
   },
   build: function ()
   {
      const
         dimension = this ._dimension .getValue (),
         angle     = Math .PI * 2 / dimension,
         vertices  = this .vertices;

      vertices .length = 0;

      for (let n = 0; n < dimension; ++ n)
      {
         const
            point1 = Numbers_Complex.Polar (1, angle * n),
            point2 = Numbers_Complex.Polar (1, angle * (n + 1));

         vertices .push (point1 .real, point1 .imag, 0, 1);
         vertices .push (point2 .real, point2 .imag, 0, 1);
      }

      vertices .shrinkToFit ();
   },
});

/* harmony default export */ const Geometry2D_Circle2DOptions = (Circle2DOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/Disk2DOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Disk2DOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);

   this .addChildObjects ("dimension", new x_ite_Fields.SFInt32 (40))

   this .circleVertices = Rendering_X3DGeometryNode.createArray ();
   this .diskTexCoords  = Rendering_X3DGeometryNode.createArray ();
   this .diskNormals    = Rendering_X3DGeometryNode.createArray ();
   this .diskVertices   = Rendering_X3DGeometryNode.createArray ();
}

Disk2DOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: Disk2DOptions,
   getTypeName: function ()
   {
      return "Disk2DOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "circle2DOptions";
   },
   initialize: function ()
   {
      this .addInterest ("build", this);

      this .build ();
   },
   getCircleVertices: function ()
   {
      return this .circleVertices;
   },
   getDiskTexCoords: function ()
   {
      return this .diskTexCoords;
   },
   getDiskNormals: function ()
   {
      return this .diskNormals;
   },
   getDiskVertices: function ()
   {
      return this .diskVertices;
   },
   build: (function ()
   {
      const
         half      = new Numbers_Complex (0.5, 0.5),
         texCoord1 = new Numbers_Complex (0, 0),
         texCoord2 = new Numbers_Complex (0, 0),
         point1    = new Numbers_Complex (0, 0),
         point2    = new Numbers_Complex (0, 0);

      return function ()
      {
         const
            dimension      = this ._dimension .getValue (),
            angle          = Math .PI * 2 / dimension,
            circleVertices = this .circleVertices,
            diskTexCoords  = this .diskTexCoords,
            diskNormals    = this .diskNormals,
            diskVertices   = this .diskVertices;

         circleVertices .length = 0;
         diskTexCoords  .length = 0;
         diskNormals    .length = 0;
         diskVertices   .length = 0;

         for (let n = 0; n < dimension; ++ n)
         {
            const
               theta1 = angle * n,
               theta2 = angle * (n + 1);

            texCoord1 .setPolar (0.5, theta1) .add (half);
            texCoord2 .setPolar (0.5, theta2) .add (half);
            point1    .setPolar (1, theta1);
            point2    .setPolar (1, theta2);

            // Circle

            circleVertices .push (point1 .real, point1 .imag, 0, 1);
            circleVertices .push (point2 .real, point2 .imag, 0, 1);

            // Disk

            diskTexCoords .push (0.5, 0.5, 0, 1,
                                 texCoord1 .real, texCoord1 .imag, 0, 1,
                                 texCoord2 .real, texCoord2 .imag, 0, 1);

            diskNormals .push (0, 0, 1,  0, 0, 1,  0, 0, 1);

            diskVertices .push (0, 0, 0, 1,
                                point1 .real, point1 .imag, 0, 1,
                                point2 .real, point2 .imag, 0, 1);
         }

         circleVertices .shrinkToFit ();
         diskTexCoords  .shrinkToFit ();
         diskNormals    .shrinkToFit ();
         diskVertices   .shrinkToFit ();
      };
   })(),
});

/* harmony default export */ const Geometry2D_Disk2DOptions = (Disk2DOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/Rectangle2DOptions.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Rectangle2DOptions (executionContext)
{
   Base_X3DBaseNode.call (this, executionContext);
}

Rectangle2DOptions .prototype = Object .assign (Object .create (Base_X3DBaseNode.prototype),
{
   constructor: Rectangle2DOptions,
   getTypeName: function ()
   {
      return "Rectangle2DOptions";
   },
   getComponentName: function ()
   {
      return "X_ITE";
   },
   getContainerField: function ()
   {
      return "rectangle2DOptions";
   },
   initialize: function ()
   {
      Base_X3DBaseNode.prototype.initialize.call (this);
   },
   getGeometry: function ()
   {
      if (this .geometry)
         return this .geometry;

      this .geometry            = new Geometry3D_IndexedFaceSet (this .getExecutionContext ());
      this .geometry ._texCoord = new Texturing_TextureCoordinate (this .getExecutionContext ());
      this .geometry ._coord    = new Rendering_Coordinate (this .getExecutionContext ());

      const
         geometry = this .geometry,
         texCoord = this .geometry ._texCoord .getValue (),
         coord    = this .geometry ._coord .getValue ();

      geometry ._texCoordIndex = new x_ite_Fields.MFInt32 (
         0, 1, 2, 3, -1
      );

      geometry ._coordIndex = new x_ite_Fields.MFInt32 (
         0, 1, 2, 3, -1
      );

      texCoord ._point = new x_ite_Fields.MFVec2f (
         new x_ite_Fields.SFVec2f (1, 1), new x_ite_Fields.SFVec2f (0, 1), new x_ite_Fields.SFVec2f (0, 0), new x_ite_Fields.SFVec2f (1, 0)
      );

      coord ._point = new x_ite_Fields.MFVec3f (
         new x_ite_Fields.SFVec3f (1, 1, 0), new x_ite_Fields.SFVec3f (-1, 1, 0), new x_ite_Fields.SFVec3f (-1, -1, 0), new x_ite_Fields.SFVec3f (1, -1, 0)
      );

      texCoord .setup ();
      coord    .setup ();
      geometry .setup ();

      return this .geometry;
   },
});

/* harmony default export */ const Geometry2D_Rectangle2DOptions = (Rectangle2DOptions);

;// CONCATENATED MODULE: ./src/x_ite/Browser/Geometry2D/X3DGeometry2DContext.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/









function X3DGeometry2DContext () { }

X3DGeometry2DContext .prototype =
{
   initialize: function ()
   {
      this .setPrimitiveQuality2D (this .getBrowserOptions () .getPrimitiveQuality ());
   },
   getArc2DOptions: function ()
   {
      return X3DGeometry2DContext_getOptionNode .call (this, "getArc2DOptions", Arc2DOptions);
   },
   getArcClose2DOptions: function ()
   {
      return X3DGeometry2DContext_getOptionNode .call (this, "getArcClose2DOptions", Geometry2D_ArcClose2DOptions);
   },
   getCircle2DOptions: function ()
   {
      return X3DGeometry2DContext_getOptionNode .call (this, "getCircle2DOptions", Geometry2D_Circle2DOptions);
   },
   getDisk2DOptions: function ()
   {
      return X3DGeometry2DContext_getOptionNode .call (this, "getDisk2DOptions", Geometry2D_Disk2DOptions);
   },
   getRectangle2DOptions: function ()
   {
      return X3DGeometry2DContext_getOptionNode .call (this, "getRectangle2DOptions", Geometry2D_Rectangle2DOptions);
   },
   setPrimitiveQuality2D: function (primitiveQuality)
   {
      const
         arc      = this .getArc2DOptions (),
         arcClose = this .getArcClose2DOptions (),
         circle   = this .getCircle2DOptions (),
         disk     = this .getDisk2DOptions ();

      switch (primitiveQuality)
      {
         case Core_PrimitiveQuality.LOW:
         {
            arc      ._dimension = 20;
            arcClose ._dimension = 20;
            circle   ._dimension = 20;
            disk     ._dimension = 20;
            break;
         }
         case Core_PrimitiveQuality.MEDIUM:
         {
            arc      ._dimension = 40;
            arcClose ._dimension = 40;
            circle   ._dimension = 40;
            disk     ._dimension = 40;
            break;
         }
         case Core_PrimitiveQuality.HIGH:
         {
            arc      ._dimension = 80;
            arcClose ._dimension = 80;
            circle   ._dimension = 80;
            disk     ._dimension = 80;
            break;
         }
      }
   },
};

function X3DGeometry2DContext_getOptionNode (key, OptionNode)
{
   const optionNode = new OptionNode (this .getPrivateScene ());

   optionNode .setup ();

   this [key] = function () { return optionNode; };

   Object .defineProperty (this, key, { enumerable: false });

   return optionNode;
}

/* harmony default export */ const Geometry2D_X3DGeometry2DContext = (X3DGeometry2DContext);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Arc2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function Arc2D (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Arc2D);

   this ._startAngle .setUnit ("angle");
   this ._endAngle   .setUnit ("angle");
   this ._radius     .setUnit ("length");
}

Arc2D .prototype = Object .assign (Object .create (Rendering_X3DLineGeometryNode.prototype),
{
   constructor: Arc2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",   new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "startAngle", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "endAngle",   new x_ite_Fields.SFFloat (1.5708)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "radius",     new x_ite_Fields.SFFloat (1)),
   ]),
   getTypeName: function ()
   {
      return "Arc2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DLineGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getArc2DOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getArc2DOptions () .removeInterest ("requestRebuild", this);
   },
   getSweepAngle: function ()
   {
      const
         start = Math_Algorithm.interval (this ._startAngle .getValue (), 0, Math .PI * 2),
         end   = Math_Algorithm.interval (this ._endAngle   .getValue (), 0, Math .PI * 2);

      if (start === end)
         return Math .PI * 2;

      const sweepAngle = Math .abs (end - start);

      if (start > end)
         return (Math .PI * 2) - sweepAngle;

      if (! isNaN (sweepAngle))
         return sweepAngle;

      // We must test for NAN, as NAN to int is undefined.
      return 0;
   },
   build: function ()
   {
      const
         options     = this .getBrowser () .getArc2DOptions (),
         dimension   = options ._dimension .getValue (),
         startAngle  = this ._startAngle .getValue  (),
         radius      = Math .abs (this ._radius .getValue ()),
         sweepAngle  = this .getSweepAngle (),
         steps       = Math .max (3, Math .floor (sweepAngle * dimension / (Math .PI * 2))),
         vertexArray = this .getVertices ();

      for (let n = 0; n < steps; ++ n)
      {
         const
            t1     = n / steps,
            theta1 = startAngle + (sweepAngle * t1),
            point1 = Numbers_Complex.Polar (radius, theta1),
            t2     = (n + 1) / steps,
            theta2 = startAngle + (sweepAngle * t2),
            point2 = Numbers_Complex.Polar (radius, theta2);

         vertexArray .push (point1 .real, point1 .imag, 0, 1);
         vertexArray .push (point2 .real, point2 .imag, 0, 1);
      }

      this .getMin () .set (-radius, -radius, 0);
      this .getMax () .set ( radius,  radius, 0);
   },
});

/* harmony default export */ const Geometry2D_Arc2D = (Arc2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/ArcClose2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function ArcClose2D (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.ArcClose2D);

   this .setGeometryType (2);

   this ._startAngle .setUnit ("angle");
   this ._endAngle   .setUnit ("angle");
   this ._radius     .setUnit ("length");
}

ArcClose2D .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: ArcClose2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "closureType", new x_ite_Fields.SFString ("PIE")),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "startAngle",  new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "endAngle",    new x_ite_Fields.SFFloat (1.5708)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "radius",      new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",       new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "ArcClose2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getArcClose2DOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getArcClose2DOptions () .removeInterest ("requestRebuild", this);
   },
   getSweepAngle: function ()
   {
      const
         start = Math_Algorithm.interval (this ._startAngle .getValue (), 0, Math .PI * 2),
         end   = Math_Algorithm.interval (this ._endAngle   .getValue (), 0, Math .PI * 2);

      if (start === end)
         return Math .PI * 2;

      const sweepAngle = Math .abs (end - start);

      if (start > end)
         return (Math .PI * 2) - sweepAngle;

      if (! isNaN (sweepAngle))
         return sweepAngle;

      // We must test for NAN, as NAN to int is undefined.
      return 0;
   },
   build: (function ()
   {
      const half = new Numbers_Complex (0.5, 0.5);

      return function ()
      {
         const
            options       = this .getBrowser () .getArcClose2DOptions (),
            chord         = this ._closureType .getValue () === "CHORD",
            dimension     = options ._dimension .getValue (),
            startAngle    = this ._startAngle .getValue  (),
            radius        = Math .abs (this ._radius .getValue ()),
            sweepAngle    = this .getSweepAngle (),
            steps         = Math .max (4, Math .floor (sweepAngle * dimension / (Math .PI * 2))),
            texCoordArray = this .getTexCoords (),
            normalArray   = this .getNormals (),
            vertexArray   = this .getVertices (),
            texCoords     = [ ],
            points        = [ ];

         this .getMultiTexCoords () .push (texCoordArray);

         const steps_1 = steps - 1;

         for (let n = 0; n < steps; ++ n)
         {
            const
               t     = n / steps_1,
               theta = startAngle + (sweepAngle * t);

            texCoords .push (Numbers_Complex.Polar (0.5, theta) .add (half));
            points    .push (Numbers_Complex.Polar (radius, theta));
         }

         if (chord)
         {
            const
               t0 = texCoords [0],
               p0 = points [0];

            for (let i = 1; i < steps_1; ++ i)
            {
               const
                  t1 = texCoords [i],
                  t2 = texCoords [i + 1],
                  p1 = points [i],
                  p2 = points [i + 1];

               texCoordArray .push (t0 .real, t0 .imag, 0, 1,
                                    t1 .real, t1 .imag, 0, 1,
                                    t2 .real, t2 .imag, 0, 1);

               normalArray .push (0, 0, 1,
                                  0, 0, 1,
                                  0, 0, 1);

               vertexArray .push (p0 .real, p0 .imag, 0, 1,
                                  p1 .real, p1 .imag, 0, 1,
                                  p2 .real, p2 .imag, 0, 1);
            }
         }
         else
         {
            for (let i = 0; i < steps_1; ++ i)
            {
               const
                  t1 = texCoords [i],
                  t2 = texCoords [i + 1],
                  p1 = points [i],
                  p2 = points [i + 1];

               texCoordArray .push (0.5, 0.5, 0, 1,
                                    t1 .real, t1 .imag, 0, 1,
                                    t2 .real, t2 .imag, 0, 1);

               normalArray .push (0, 0, 1,  0, 0, 1,  0, 0, 1);

               vertexArray .push (0, 0, 0, 1,
                                  p1 .real, p1 .imag, 0, 1,
                                  p2 .real, p2 .imag, 0, 1);
            }
         }

         this .getMin () .set (-radius, -radius, 0);
         this .getMax () .set ( radius,  radius, 0);

         this .setSolid (this ._solid .getValue ());
      };
   })(),
});

/* harmony default export */ const Geometry2D_ArcClose2D = (ArcClose2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Circle2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Circle2D (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Circle2D);

   this ._radius .setUnit ("length");
}

Circle2D .prototype = Object .assign (Object .create (Rendering_X3DLineGeometryNode.prototype),
{
   constructor: Circle2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "radius",   new x_ite_Fields.SFFloat (1)),
   ]),
   getTypeName: function ()
   {
      return "Circle2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   set_live__: function ()
   {
      Rendering_X3DLineGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getCircle2DOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getCircle2DOptions () .removeInterest ("requestRebuild", this);
   },
   build: function ()
   {
      const
         options     = this .getBrowser () .getCircle2DOptions (),
         vertexArray = this .getVertices (),
         radius      = this ._radius .getValue ();

      if (radius === 1)
      {
         this .setVertices (options .getVertices ());
      }
      else
      {
         const defaultVertices = options .getVertices () .getValue ();

         for (let i = 0, length = defaultVertices .length; i < length; i += 4)
            vertexArray .push (defaultVertices [i] * radius, defaultVertices [i + 1] * radius, 0, 1);
      }

      this .getMin () .set (-radius, -radius, 0);
      this .getMax () .set ( radius,  radius, 0);
   },
});

/* harmony default export */ const Geometry2D_Circle2D = (Circle2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Disk2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function Disk2D (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Disk2D);

   this ._innerRadius .setUnit ("length");
   this ._outerRadius .setUnit ("length");
}

Disk2D .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Disk2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",    new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "innerRadius", new x_ite_Fields.SFFloat ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "outerRadius", new x_ite_Fields.SFFloat (1)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",       new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "Disk2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   initialize: function ()
   {
      Rendering_X3DGeometryNode.prototype.initialize.call (this);
   },
   set_live__: function ()
   {
      Rendering_X3DGeometryNode.prototype.set_live__.call (this);

      if (this .isLive () .getValue ())
         this .getBrowser () .getDisk2DOptions () .addInterest ("requestRebuild", this);
      else
         this .getBrowser () .getDisk2DOptions () .removeInterest ("requestRebuild", this);
   },
   build: function ()
   {
      const
         browser     = this .getBrowser (),
         gl          = browser .getContext (),
         options     = browser .getDisk2DOptions (),
         innerRadius = Math .min (Math .abs (this ._innerRadius .getValue ()), Math .abs (this ._outerRadius .getValue ())),
         outerRadius = Math .max (Math .abs (this ._innerRadius .getValue ()), Math .abs (this ._outerRadius .getValue ()));

      if (innerRadius === outerRadius)
      {
         const vertexArray = this .getVertices ();

         // Point

         if (outerRadius === 0)
         {
            vertexArray .push (0, 0, 0, 1);

            this .getMin () .set (0, 0, 0);
            this .getMax () .set (0, 0, 0);

            this .setGeometryType (0);
            this .setPrimitiveMode (gl .POINTS);
            this .setTransparent (true);
            this .setBase (X3DPointGeometryNode);
            return;
         }

         // Circle

         if (outerRadius === 1)
         {
            this .setVertices (options .getCircleVertices ());
         }
         else
         {
            const defaultVertices = options .getCircleVertices () .getValue ();

            for (let i = 0, length = defaultVertices .length; i < length; i += 4)
               vertexArray .push (defaultVertices [i] * outerRadius, defaultVertices [i + 1] * outerRadius, 0, 1);
         }

         this .getMin () .set (-outerRadius, -outerRadius, 0);
         this .getMax () .set ( outerRadius,  outerRadius, 0);

         this .setGeometryType (1);
         this .setPrimitiveMode (gl .LINES);
         this .setTransparent (false);
         this .setBase (Rendering_X3DLineGeometryNode);
         return;
      }

      if (innerRadius === 0)
      {
         // Disk

         this .getMultiTexCoords () .push (options .getDiskTexCoords ());
         this .setNormals (options .getDiskNormals ());

         if (outerRadius === 1)
         {
            this .setVertices (options .getDiskVertices ());
         }
         else
         {
            const
               defaultVertices = options .getDiskVertices () .getValue (),
               vertexArray     = this .getVertices ();

            for (let i = 0, length = defaultVertices .length; i < length; i += 4)
               vertexArray .push (defaultVertices [i] * outerRadius, defaultVertices [i + 1] * outerRadius, 0, 1);
         }

         this .getMin () .set (-outerRadius, -outerRadius, 0);
         this .getMax () .set ( outerRadius,  outerRadius, 0);

         this .setGeometryType (2);
         this .setPrimitiveMode (gl .TRIANGLES);
         this .setTransparent (false);
         this .setSolid (this ._solid .getValue ());
         this .setBase (Rendering_X3DGeometryNode);
         return;
      }

      // Disk with hole

      const
         scale            = innerRadius / outerRadius,
         offset           = (1 - scale) / 2,
         defaultTexCoords = options .getDiskTexCoords () .getValue (),
         defaultVertices  = options .getDiskVertices () .getValue (),
         texCoordArray    = this .getTexCoords (),
         normalArray      = this .getNormals (),
         vertexArray      = this .getVertices ();

      this .getMultiTexCoords () .push (texCoordArray);

      for (let i = 0, length = defaultVertices .length; i < length; i += 12)
      {
         texCoordArray .push (defaultTexCoords [i + 4] * scale + offset, defaultTexCoords [i + 5] * scale + offset, 0, 1,
                              defaultTexCoords [i + 4], defaultTexCoords [i + 5], 0, 1,
                              defaultTexCoords [i + 8], defaultTexCoords [i + 9], 0, 1,

                              defaultTexCoords [i + 4] * scale + offset, defaultTexCoords [i + 5] * scale + offset, 0, 1,
                              defaultTexCoords [i + 8], defaultTexCoords [i + 9], 0, 1,
                              defaultTexCoords [i + 8] * scale + offset, defaultTexCoords [i + 9] * scale + offset, 0, 1);

         normalArray .push (0, 0, 1,  0, 0, 1,  0, 0, 1,
                            0, 0, 1,  0, 0, 1,  0, 0, 1);

         vertexArray .push (defaultVertices [i + 4] * innerRadius, defaultVertices [i + 5] * innerRadius, 0, 1,
                            defaultVertices [i + 4] * outerRadius, defaultVertices [i + 5] * outerRadius, 0, 1,
                            defaultVertices [i + 8] * outerRadius, defaultVertices [i + 9] * outerRadius, 0, 1,

                            defaultVertices [i + 4] * innerRadius, defaultVertices [i + 5] * innerRadius, 0, 1,
                            defaultVertices [i + 8] * outerRadius, defaultVertices [i + 9] * outerRadius, 0, 1,
                            defaultVertices [i + 8] * innerRadius, defaultVertices [i + 9] * innerRadius, 0, 1);
      }

      this .getMin () .set (-outerRadius, -outerRadius, 0);
      this .getMax () .set ( outerRadius,  outerRadius, 0);

      this .setGeometryType (2);
      this .setPrimitiveMode (gl .TRIANGLES);
      this .setTransparent (false);
      this .setSolid (this ._solid .getValue ());
      this .setBase (Rendering_X3DGeometryNode);
   },
   setBase: function (base)
   {
      this .intersectsLine   = base .prototype .intersectsLine;
      this .intersectsBox    = base .prototype .intersectsBox;
      this .display          = base .prototype .display;
      this .displayParticles = base .prototype .displayParticles;
   },
   updateRenderFunctions: function ()
   { },
});

/* harmony default export */ const Geometry2D_Disk2D = (Disk2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Polyline2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Polyline2D (executionContext)
{
   Rendering_X3DLineGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Polyline2D);

   this ._lineSegments .setUnit ("length");
}

Polyline2D .prototype = Object .assign (Object .create (Rendering_X3DLineGeometryNode.prototype),
{
   constructor: Polyline2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata",     new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "lineSegments", new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "Polyline2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: function ()
   {
      const
         lineSegments = this ._lineSegments .getValue (),
         vertexArray  = this .getVertices ();

      for (let i = 0, length = (this ._lineSegments .length - 1) * 2; i < length; i += 2)
      {
         vertexArray .push (lineSegments [i + 0], lineSegments [i + 1], 0, 1);
         vertexArray .push (lineSegments [i + 2], lineSegments [i + 3], 0, 1);
      }
   },
});

/* harmony default export */ const Geometry2D_Polyline2D = (Polyline2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Polypoint2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function Polypoint2D (executionContext)
{
   X3DPointGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Polypoint2D);

   this ._point .setUnit ("length");
}

Polypoint2D .prototype = Object .assign (Object .create (X3DPointGeometryNode.prototype),
{
   constructor: Polypoint2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput, "point",    new x_ite_Fields.MFVec2f ()),
   ]),
   getTypeName: function ()
   {
      return "Polypoint2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: function ()
   {
      const
         point       = this ._point .getValue (),
         vertexArray = this .getVertices ();

      for (let i = 0, length = this ._point .length * 2; i < length; i += 2)
      {
         vertexArray .push (point [i], point [i + 1], 0, 1);
      }
   },
});

/* harmony default export */ const Geometry2D_Polypoint2D = (Polypoint2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/Rectangle2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/










function Rectangle2D (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.Rectangle2D);

   this .setGeometryType (2);

   this ._size .setUnit ("length");
}

Rectangle2D .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: Rectangle2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "size",     new x_ite_Fields.SFVec2f (2, 2)),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",    new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "Rectangle2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: (function ()
   {
      const defaultSize = new Numbers_Vector2 (2, 2);

      return function ()
      {
         const
            options  = this .getBrowser () .getRectangle2DOptions (),
            geometry = options .getGeometry (),
            size     = this ._size .getValue ();

         this .setMultiTexCoords (geometry .getMultiTexCoords ());
         this .setNormals        (geometry .getNormals ());

         if (size .equals (defaultSize))
         {
            this .setVertices (geometry .getVertices ());

            this .getMin () .assign (geometry .getMin ());
            this .getMax () .assign (geometry .getMax ());
         }
         else
         {
            const
               scale           = Numbers_Vector3.divide (size, 2),
               x               = scale .x,
               y               = scale .y,
               defaultVertices = geometry .getVertices () .getValue (),
               vertexArray     = this .getVertices ();

            for (let i = 0; i < defaultVertices .length; i += 4)
            {
               vertexArray .push (x * defaultVertices [i],
                                  y * defaultVertices [i + 1],
                                  0,
                                  1);
            }

            this .getMin () .set (-x, -y, 0);
            this .getMax () .set ( x,  y, 0);
         }

         this .setSolid (this ._solid .getValue ());
      };
   })(),
});

/* harmony default export */ const Geometry2D_Rectangle2D = (Rectangle2D);

;// CONCATENATED MODULE: ./src/x_ite/Components/Geometry2D/TriangleSet2D.js
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/








function TriangleSet2D (executionContext)
{
   Rendering_X3DGeometryNode.call (this, executionContext);

   this .addType (Base_X3DConstants.TriangleSet2D);

   this .setGeometryType (2);

   this ._vertices .setUnit ("length");
}

TriangleSet2D .prototype = Object .assign (Object .create (Rendering_X3DGeometryNode.prototype),
{
   constructor: TriangleSet2D,
   [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new Base_FieldDefinitionArray ([
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "metadata", new x_ite_Fields.SFNode ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.inputOutput,    "vertices", new x_ite_Fields.MFVec2f ()),
      new Base_X3DFieldDefinition (Base_X3DConstants.initializeOnly, "solid",    new x_ite_Fields.SFBool ()),
   ]),
   getTypeName: function ()
   {
      return "TriangleSet2D";
   },
   getComponentName: function ()
   {
      return "Geometry2D";
   },
   getContainerField: function ()
   {
      return "geometry";
   },
   build: function ()
   {
      const
         vertices    = this ._vertices .getValue (),
         normalArray = this .getNormals (),
         vertexArray = this .getVertices ();

      for (let i = 0, length = this ._vertices .length * 2; i < length; i += 2)
      {
         normalArray .push (0, 0, 1);
         vertexArray .push (vertices [i], vertices [i + 1], 0, 1);
      }

      this .setSolid (this ._solid .getValue ());
   },
   buildTexCoords: function ()
   {
      const texCoordArray = this .getTexCoords ();

      if (texCoordArray .length === 0)
      {
         const
            p             = this .getTexCoordParams (),
            min           = p .min,
            Ssize         = p .Ssize,
            vertexArray   = this .getVertices () .getValue ();

         for (let i = 0, length = vertexArray .length; i < length; i += 4)
         {
            texCoordArray .push ((vertexArray [i]     - min [0]) / Ssize,
                                 (vertexArray [i + 1] - min [1]) / Ssize,
                                 0,
                                 1);
         }

         texCoordArray .shrinkToFit ();
      }

      this .getMultiTexCoords () .push (texCoordArray);
   },
});

/* harmony default export */ const Geometry2D_TriangleSet2D = (TriangleSet2D);

;// CONCATENATED MODULE: ./src/assets/components/Geometry2D.js
/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/













x_ite_Components.addComponent ({
   name: "Geometry2D",
   types:
   {
      Arc2D:         Geometry2D_Arc2D,
      ArcClose2D:    Geometry2D_ArcClose2D,
      Circle2D:      Geometry2D_Circle2D,
      Disk2D:        Geometry2D_Disk2D,
      Polyline2D:    Geometry2D_Polyline2D,
      Polypoint2D:   Geometry2D_Polypoint2D,
      Rectangle2D:   Geometry2D_Rectangle2D,
      TriangleSet2D: Geometry2D_TriangleSet2D,
   },
   abstractTypes:
   {
   },
   browserContext: Geometry2D_X3DGeometry2DContext,
});

/* harmony default export */ const Geometry2D = ((/* unused pure expression or super */ null && (undefined)));

/******/ })()
;