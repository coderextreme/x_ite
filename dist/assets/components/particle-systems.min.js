!function(){const e=window[Symbol.for("X_ITE.X3D-6.1.0")],t=e.define,n=e.require;t("x_ite/Browser/ParticleSystems/GeometryTypes",[],(function(){"use strict";let e=0;return{POINT:e++,LINE:e++,TRIANGLE:e++,QUAD:e++,SPRITE:e++,GEOMETRY:e++}})),t("text!x_ite/Browser/ParticleSystems/Line3.glsl",[],(function(){return"struct Line3 {\n   vec3 point;\n   vec3 direction;\n};\n\n// Line3\n// line3 (const in vec3 point1, const in vec3 point2)\n// {\n//    return Line3 (point1, normalize (point2 - point1));\n// }\n\n/* Line intersect triangle */\n\nbool\nintersects (const in Line3 line, const in vec3 a, const in vec3 b, const in vec3 c, out vec3 r)\n{\n   // find vectors for two edges sharing vert0\n   vec3 edge1 = b - a;\n   vec3 edge2 = c - a;\n\n   // begin calculating determinant - also used to calculate U parameter\n   vec3 pvec = cross (line .direction, edge2);\n\n   // if determinant is near zero, ray lies in plane of triangle\n   float det = dot (edge1, pvec);\n\n   // Non culling intersection\n\n   if (det == 0.0)\n      return false;\n\n   float inv_det = 1.0 / det;\n\n   // calculate distance from vert0 to ray point\n   vec3 tvec = line .point - a;\n\n   // calculate U parameter and test bounds\n   float u = dot (tvec, pvec) * inv_det;\n\n   if (u < 0.0 || u > 1.0)\n      return false;\n\n   // prepare to test V parameter\n   vec3 qvec = cross (tvec, edge1);\n\n   // calculate V parameter and test bounds\n   float v = dot (line .direction, qvec) * inv_det;\n\n   if (v < 0.0 || u + v > 1.0)\n      return false;\n\n   r = vec3 (u, v, 1.0 - u - v);\n\n   return true;\n}\n"})),t("text!x_ite/Browser/ParticleSystems/Plane3.glsl",[],(function(){return"struct Plane3\n{\n   vec3  normal;\n   float distanceFromOrigin;\n};\n\nPlane3\nplane3 (const in vec3 point, const in vec3 normal)\n{\n   return Plane3 (normal, dot (normal, point));\n}\n\nfloat\nplane_distance (const in Plane3 plane, const in vec3 point)\n{\n   return dot (point, plane .normal) - plane .distanceFromOrigin;\n}\n\n/* Plane intersect line */\nbool\nintersects (const in Plane3 plane, const in Line3 line, out vec3 point)\n{\n   // Check if the line is parallel to the plane.\n   float theta = dot (line .direction, plane .normal);\n\n   // Plane and line are parallel.\n   if (theta == 0.0)\n      return false;\n\n   // Plane and line are not parallel. The intersection point can be calculated now.\n   float t = (plane .distanceFromOrigin - dot (plane .normal, line .point)) / theta;\n\n   point = line .point + line .direction * t;\n\n   return true;\n}\n\n/* Find find the first point that is farther to the plane than value. */\n// int\n// upper_bound (const in vec4 points [ARRAY_SIZE], in int count, const in float value, const in Plane3 plane)\n// {\n//    int first = 0;\n//    int step  = 0;\n\n//    while (count > 0)\n//    {\n//       int index = first;\n\n//       step = count >> 1;\n\n//       index += step;\n\n//       if (value < plane_distance (plane, points [index] .xyz))\n//       {\n//          count = step;\n//       }\n//       else\n//       {\n//          first  = ++ index;\n//          count -= step + 1;\n//       }\n//    }\n\n//    return first;\n// }\n\n/* CombSort: sort points in distance to a plane. */\nvoid\nsort (inout vec4 points [ARRAY_SIZE], const in int count, const in Plane3 plane)\n{\n   const float shrink = 1.0 / 1.3;\n\n   int  gap       = count;\n   bool exchanged = true;\n\n   while (exchanged)\n   {\n      gap = int (float (gap) * shrink);\n\n      if (gap <= 1)\n      {\n         exchanged = false;\n         gap       = 1;\n      }\n\n      for (int i = 0, l = count - gap; i < l; ++ i)\n      {\n         int j = gap + i;\n\n         if (plane_distance (plane, points [i] .xyz) > plane_distance (plane, points [j] .xyz))\n         {\n            vec4 tmp1 = points [i];\n            points [i] = points [j];\n            points [j] = tmp1;\n\n            exchanged = true;\n         }\n      }\n   }\n}\n\n\n// /* CombSort: sort points and normals in distance to a plane. */\n// void\n// sort (inout vec4 points [ARRAY_SIZE], inout vec3 normals [ARRAY_SIZE], const in int count, const in Plane3 plane)\n// {\n//    const float shrink = 1.0 / 1.3;\n\n//    int  gap       = count;\n//    bool exchanged = true;\n\n//    while (exchanged)\n//    {\n//       gap = int (float (gap) * shrink);\n\n//       if (gap <= 1)\n//       {\n//          exchanged = false;\n//          gap       = 1;\n//       }\n\n//       for (int i = 0, l = count - gap; i < l; ++ i)\n//       {\n//          int j = gap + i;\n\n//          if (plane_distance (plane, points [i] .xyz) > plane_distance (plane, points [j] .xyz))\n//          {\n//             vec4 tmp1 = points [i];\n//             points [i] = points [j];\n//             points [j] = tmp1;\n\n//             vec3 tmp2   = normals [i];\n//             normals [i] = normals [j];\n//             normals [j] = tmp2;\n\n//             exchanged = true;\n//          }\n//       }\n//    }\n// }\n\nint\nmin_index (const in vec4 points [ARRAY_SIZE], const in int count, const in float value, const in Plane3 plane)\n{\n   int   index = -1;\n   float dist  = 1000000.0;\n\n   for (int i = 0; i < count; ++ i)\n   {\n      float d = plane_distance (plane, points [i] .xyz);\n\n      if (d >= value && d < dist)\n      {\n         dist  = d;\n         index = i;\n      }\n   }\n\n   return index;\n}\n"})),t("text!x_ite/Browser/ParticleSystems/Box3.glsl",[],(function(){return"bool\nintersects (const in vec3 min, const in vec3 max, const in Line3 line)\n{\n   vec3 intersection;\n\n   // front\n\n   if (intersects (plane3 (max, vec3 (0.0, 0.0, 1.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xy, max .xy), vec4 (min .xy, intersection .xy))))\n         return true;\n   }\n\n   // back\n\n   if (intersects (plane3 (min, vec3 (0.0, 0.0, -1.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xy, max .xy), vec4 (min .xy, intersection .xy))))\n         return true;\n   }\n\n   // top\n\n   if (intersects (plane3 (max, vec3 (0.0, 1.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xz, max .xz), vec4 (min .xz, intersection .xz))))\n         return true;\n   }\n\n   // bottom\n\n   if (intersects (plane3 (min, vec3 (0.0, -1.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xz, max .xz), vec4 (min .xz, intersection .xz))))\n         return true;\n   }\n\n   // right\n\n   if (intersects (plane3 (max, vec3 (1.0, 0.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .yz, max .yz), vec4 (min .yz, intersection .yz))))\n         return true;\n   }\n\n   return false;\n}\n"})),t("text!x_ite/Browser/ParticleSystems/BVH.glsl",[],(function(){return"#define BVH_NODE        0\n#define BVH_TRIANGLE    1\n#define BVH_STACK_SIZE  32\n\nint bvhNodeIndex = 0;\n\nvoid\nsetBVHIndex (const in int index)\n{\n   bvhNodeIndex = index;\n}\n\nint\ngetBVHRoot (const in sampler2D volume, const in int hierarchyIndex, const in int rootIndex)\n{\n   return int (texelFetch (volume, rootIndex, 0) .x) + hierarchyIndex;\n}\n\nint\ngetBVHType (const in sampler2D volume)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .x);\n}\n\nvec3\ngetBVHMin (const in sampler2D volume)\n{\n   return texelFetch (volume, bvhNodeIndex + 1, 0) .xyz;\n}\n\nvec3\ngetBVHMax (const in sampler2D volume)\n{\n   return texelFetch (volume, bvhNodeIndex + 2, 0) .xyz;\n}\n\nint\ngetBVHLeft (const in sampler2D volume, const in int hierarchyIndex)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .y) + hierarchyIndex;\n}\n\nint\ngetBVHRight (const in sampler2D volume, const in int hierarchyIndex)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .z) + hierarchyIndex;\n}\n\nint\ngetBVHTriangle (const in sampler2D volume)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .y);\n}\n\n/* Ray triangle intersection test */\n\nint\ngetIntersections (const in sampler2D volume, const in int verticesIndex, const in int hierarchyIndex, const in int rootIndex, const in Line3 line, out vec4 points [ARRAY_SIZE])\n{\n   int current    = getBVHRoot (volume, hierarchyIndex, rootIndex);\n   int count      = 0;\n   int stackIndex = -1;\n   int stack [BVH_STACK_SIZE];\n\n   while (stackIndex >= 0 || current >= 0)\n   {\n      if (current >= 0)\n      {\n         setBVHIndex (current);\n\n         if (getBVHType (volume) == BVH_NODE)\n         {\n            // Node\n\n            if (intersects (getBVHMin (volume), getBVHMax (volume), line))\n            {\n               stack [++ stackIndex] = current;\n\n               current = getBVHLeft (volume, hierarchyIndex);\n            }\n            else\n            {\n               current = -1;\n            }\n         }\n         else\n         {\n            // Triangle\n\n            int  t = getBVHTriangle (volume);\n            int  v = verticesIndex + t;\n            vec3 r = vec3 (0.0);\n\n            vec3 a = texelFetch (volume, v,     0) .xyz;\n            vec3 b = texelFetch (volume, v + 1, 0) .xyz;\n            vec3 c = texelFetch (volume, v + 2, 0) .xyz;\n\n            if (intersects (line, a, b, c, r))\n               points [count ++] = vec4 (r .z * a + r .x * b + r .y * c, 1.0);\n\n            current = -1;\n         }\n      }\n      else\n      {\n         setBVHIndex (stack [stackIndex --]);\n\n         current = getBVHRight (volume, hierarchyIndex);\n      }\n   }\n\n   return count;\n}\n\nint\ngetIntersections (const in sampler2D volume, const in int verticesIndex, const in int normalsIndex, const in int hierarchyIndex, const in int rootIndex, const in Line3 line, out vec4 points [ARRAY_SIZE], out vec3 normals [ARRAY_SIZE])\n{\n   int current    = getBVHRoot (volume, hierarchyIndex, rootIndex);\n   int count      = 0;\n   int stackIndex = -1;\n   int stack [BVH_STACK_SIZE];\n\n   while (stackIndex >= 0 || current >= 0)\n   {\n      if (current >= 0)\n      {\n         setBVHIndex (current);\n\n         if (getBVHType (volume) == BVH_NODE)\n         {\n            // Node\n\n            if (intersects (getBVHMin (volume), getBVHMax (volume), line))\n            {\n               stack [++ stackIndex] = current;\n\n               current = getBVHLeft (volume, hierarchyIndex);\n            }\n            else\n            {\n               current = -1;\n            }\n         }\n         else\n         {\n            // Triangle\n\n            int  t = getBVHTriangle (volume);\n            int  v = verticesIndex + t;\n            vec3 r = vec3 (0.0);\n\n            vec3 a = texelFetch (volume, v,     0) .xyz;\n            vec3 b = texelFetch (volume, v + 1, 0) .xyz;\n            vec3 c = texelFetch (volume, v + 2, 0) .xyz;\n\n            if (intersects (line, a, b, c, r))\n            {\n               points [count] = vec4 (r .z * a + r .x * b + r .y * c, 1.0);\n\n               int n = normalsIndex + t;\n\n               vec3 n0 = texelFetch (volume, n,     0) .xyz;\n               vec3 n1 = texelFetch (volume, n + 1, 0) .xyz;\n               vec3 n2 = texelFetch (volume, n + 2, 0) .xyz;\n\n               normals [count] = save_normalize (r .z * n0 + r .x * n1 + r .y * n2);\n\n               ++ count;\n            }\n\n            current = -1;\n         }\n      }\n      else\n      {\n         setBVHIndex (stack [stackIndex --]);\n\n         current = getBVHRight (volume, hierarchyIndex);\n      }\n   }\n\n   return count;\n}\n"})),t("x_ite/Components/ParticleSystems/X3DParticleEmitterNode",["x_ite/Components/Core/X3DNode","x_ite/Browser/ParticleSystems/GeometryTypes","x_ite/Base/X3DConstants","text!x_ite/Browser/ParticleSystems/Line3.glsl","text!x_ite/Browser/ParticleSystems/Plane3.glsl","text!x_ite/Browser/ParticleSystems/Box3.glsl","text!x_ite/Browser/ParticleSystems/BVH.glsl"],(function(e,t,n,i,o,r,s){"use strict";function a(t){e.call(this,t),this.addType(n.X3DParticleEmitterNode),this._speed.setUnit("speed"),this._mass.setUnit("mass"),this._surfaceArea.setUnit("area"),this.samplers=[],this.uniforms={},this.functions=[],this.program=null,this.addSampler("forces"),this.addSampler("boundedVolume"),this.addSampler("colorRamp"),this.addSampler("texCoordRamp"),this.addUniform("speed","uniform float speed;"),this.addUniform("variation","uniform float variation;"),this.addFunction(i),this.addFunction(o),this.addFunction(r),this.addFunction(s)}return a.prototype=Object.assign(Object.create(e.prototype),{constructor:a,initialize:function(){e.prototype.initialize.call(this);const t=this.getBrowser().getContext();t.getVersion()<2||(this.program=this.createProgram(),this.transformFeedback=t.createTransformFeedback(),this._on.addInterest("set_on__",this),this._speed.addInterest("set_speed__",this),this._variation.addInterest("set_variation__",this),this._mass.addInterest("set_mass__",this),this.set_on__(),this.set_speed__(),this.set_variation__(),this.set_mass__())},isExplosive:function(){return!1},getMass:function(){return this.mass},set_on__:function(){this.on=this._on.getValue()},set_speed__:function(){this.setUniform("uniform1f","speed",this._speed.getValue())},set_variation__:function(){this.setUniform("uniform1f","variation",this._variation.getValue())},set_mass__:function(){this.mass=this._mass.getValue()},getRandomValue:function(e,t){return Math.random()*(t-e)+e},getRandomNormal:function(e){const t=this.getRandomValue(-1,1)*Math.PI,n=this.getRandomValue(-1,1),i=Math.acos(n),o=Math.sin(i);return e.set(Math.sin(t)*o,Math.cos(t)*o,n)},animate:function(e,t){const n=this.getBrowser().getContext(),i=e.inputParticles,o=e.particleStride,r=e.particleOffsets,s=this.program;if(n.useProgram(s),n.uniform1i(s.randomSeed,4294967295*Math.random()),n.uniform1i(s.geometryType,e.geometryType),n.uniform1i(s.createParticles,e.createParticles&&this.on),n.uniform1f(s.particleLifetime,e.particleLifetime),n.uniform1f(s.lifetimeVariation,e.lifetimeVariation),n.uniform1f(s.deltaTime,t),n.uniform2f(s.particleSize,e._particleSize.x,e._particleSize.y),n.uniform1i(s.numForces,e.numForces),e.numForces&&(n.activeTexture(n.TEXTURE0+s.forcesTextureUnit),n.bindTexture(n.TEXTURE_2D,e.forcesTexture)),e.boundedHierarchyRoot<0?n.uniform1i(s.boundedHierarchyRoot,-1):(n.uniform1i(s.boundedVerticesIndex,e.boundedVerticesIndex),n.uniform1i(s.boundedNormalsIndex,e.boundedNormalsIndex),n.uniform1i(s.boundedHierarchyIndex,e.boundedHierarchyIndex),n.uniform1i(s.boundedHierarchyRoot,e.boundedHierarchyRoot),n.activeTexture(n.TEXTURE0+s.boundedVolumeTextureUnit),n.bindTexture(n.TEXTURE_2D,e.boundedTexture)),n.uniform1i(s.numColors,e.numColors),e.numColors&&(n.activeTexture(n.TEXTURE0+s.colorRampTextureUnit),n.bindTexture(n.TEXTURE_2D,e.colorRampTexture)),n.uniform1i(s.numTexCoords,e.numTexCoords),e.numTexCoords&&(n.uniform1i(s.texCoordCount,e.texCoordCount),n.activeTexture(n.TEXTURE0+s.texCoordRampTextureUnit),n.bindTexture(n.TEXTURE_2D,e.texCoordRampTexture)),this.activateTextures(n,s),i.emitterArrayObject.enable(n,s)){for(const[e,t]of s.inputs)n.bindBuffer(n.ARRAY_BUFFER,i),n.enableVertexAttribArray(t),n.vertexAttribPointer(t,4,n.FLOAT,!1,o,r[e]);n.bindBuffer(n.ARRAY_BUFFER,null)}n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.transformFeedback),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,e.outputParticles),n.enable(n.RASTERIZER_DISCARD),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,e.numParticles),n.endTransformFeedback(),n.disable(n.RASTERIZER_DISCARD),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null)},addSampler:function(e){this.samplers.push(e)},addUniform:function(e,t){this.uniforms[e]=t},setUniform:function(e,t,n,i,o){const r=this.getBrowser().getContext(),s=this.program;r.useProgram(s),r[e](s[t],n,i,o)},addFunction:function(e){this.functions.push(e)},createProgram:function(){const e=this.getBrowser(),n=e.getContext(),i=`#version 300 es\n\n         precision highp float;\n         precision highp int;\n         precision highp sampler2D;\n\n         uniform int   randomSeed;\n         uniform int   geometryType;\n         uniform bool  createParticles;\n         uniform float particleLifetime;\n         uniform float lifetimeVariation;\n         uniform float deltaTime;\n         uniform vec2  particleSize;\n\n         uniform int       numForces;\n         uniform sampler2D forces;\n\n         uniform int       boundedVerticesIndex;\n         uniform int       boundedNormalsIndex;\n         uniform int       boundedHierarchyIndex;\n         uniform int       boundedHierarchyRoot;\n         uniform sampler2D boundedVolume;\n\n         uniform int       numColors;\n         uniform sampler2D colorRamp;\n\n         uniform int       texCoordCount;\n         uniform int       numTexCoords;\n         uniform sampler2D texCoordRamp;\n\n         ${Object.values(this.uniforms).join("\n")}\n\n         in vec4 input0;\n         in vec4 input2;\n         in vec4 input6;\n\n         out vec4 output0;\n         out vec4 output1;\n         out vec4 output2;\n\n         out vec4 output3;\n         out vec4 output4;\n         out vec4 output5;\n         out vec4 output6;\n\n         // Constants\n\n         ${Object.entries(t).map((([e,t])=>`#define ${e} ${t}`)).join("\n")}\n\n         const int   ARRAY_SIZE = 32;\n         const float M_PI       = 3.14159265359;\n\n         uniform float NaN;\n\n         // Texture\n\n         vec4\n         texelFetch (const in sampler2D sampler, const in int index, const in int lod)\n         {\n            int   x = textureSize (sampler, lod) .x;\n            ivec2 p = ivec2 (index % x, index / x);\n            vec4  t = texelFetch (sampler, p, lod);\n\n            return t;\n         }\n\n         // Math\n\n         // Save normalize, that will not divide by zero.\n         vec3\n         save_normalize (const in vec3 vector)\n         {\n            float l = length (vector);\n\n            if (l == 0.0)\n               return vec3 (0.0);\n\n            return vector / l;\n         }\n\n         // Quaternion\n\n         vec4\n         Quaternion (const in vec3 fromVector, const in vec3 toVector)\n         {\n            vec3 from = save_normalize (fromVector);\n            vec3 to   = save_normalize (toVector);\n\n            float cos_angle = dot (from, to);\n            vec3  cross_vec = cross (from, to);\n            float cross_len = length (cross_vec);\n\n            if (cross_len == 0.0)\n            {\n               if (cos_angle > 0.0)\n               {\n                  return vec4 (0.0, 0.0, 0.0, 1.0);\n               }\n               else\n               {\n                  vec3 t = cross (from, vec3 (1.0, 0.0, 0.0));\n\n                  if (dot (t, t) == 0.0)\n                     t = cross (from, vec3 (0.0, 1.0, 0.0));\n\n                  t = save_normalize (t);\n\n                  return vec4 (t, 0.0);\n               }\n            }\n            else\n            {\n               float s = sqrt (abs (1.0 - cos_angle) * 0.5);\n\n               cross_vec = save_normalize (cross_vec);\n\n               return vec4 (cross_vec * s, sqrt (abs (1.0 + cos_angle) * 0.5));\n            }\n         }\n\n         vec3\n         multVecQuat (const in vec3 v, const in vec4 q)\n         {\n            float a = q .w * q .w - q .x * q .x - q .y * q .y - q .z * q .z;\n            float b = 2.0 * (v .x * q .x + v .y * q .y + v .z * q .z);\n            float c = 2.0 * q .w;\n            vec3  r = a * v .xyz + b * q .xyz + c * (q .yzx * v .zxy - q .zxy * v .yzx);\n\n            return r;\n         }\n\n         mat3\n         Matrix3 (const in vec4 quaternion)\n         {\n            float x = quaternion .x;\n            float y = quaternion .y;\n            float z = quaternion .z;\n            float w = quaternion .w;\n            float A = y * y;\n            float B = z * z;\n            float C = x * y;\n            float D = z * w;\n            float E = z * x;\n            float F = y * w;\n            float G = x * x;\n            float H = y * z;\n            float I = x * w;\n\n            return mat3 (1.0 - 2.0 * (A + B),\n                         2.0 * (C + D),\n                         2.0 * (E - F),\n                         2.0 * (C - D),\n                         1.0 - 2.0 * (B + G),\n                         2.0 * (H + I),\n                         2.0 * (E + F),\n                         2.0 * (H - I),\n                         1.0 - 2.0 * (A + G));\n         }\n\n         /* Random number generation */\n\n         uint seed = 1u;\n\n         void\n         srand (const in int value)\n         {\n            seed = uint (value);\n         }\n\n         // Return a uniform distributed random floating point number in the interval [0, 1].\n         float\n         random ()\n         {\n            seed = seed * 1103515245u + 12345u;\n\n            return float (seed) / 4294967295.0;\n         }\n\n         float\n         getRandomValue (const in float min, const in float max)\n         {\n            return min + random () * (max - min);\n         }\n\n         float\n         getRandomLifetime ()\n         {\n            float v    = particleLifetime * lifetimeVariation;\n            float min_ = max (0.0, particleLifetime - v);\n            float max_ = particleLifetime + v;\n\n            return getRandomValue (min_, max_);\n         }\n\n         float\n         getRandomSpeed ()\n         {\n            float v    = speed * variation;\n            float min_ = max (0.0, speed - v);\n            float max_ = speed + v;\n\n            return getRandomValue (min_, max_);\n         }\n\n         vec3\n         getRandomNormal ()\n         {\n            float theta = getRandomValue (-M_PI, M_PI);\n            float cphi  = getRandomValue (-1.0, 1.0);\n            float r     = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n\n            return vec3 (sin (theta) * r, cos (theta) * r, cphi);\n         }\n\n         vec3\n         getRandomNormalWithAngle (const in float angle)\n         {\n            float theta = getRandomValue (-M_PI, M_PI);\n            float cphi  = getRandomValue (cos (angle), 1.0);\n            float r     = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n\n            return vec3 (sin (theta) * r, cos (theta) * r, cphi);\n         }\n\n         vec3\n         getRandomNormalWithDirectionAndAngle (const in vec3 direction, const in float angle)\n         {\n            vec4 rotation = Quaternion (vec3 (0.0, 0.0, 1.0), direction);\n            vec3 normal   = getRandomNormalWithAngle (angle);\n\n            return multVecQuat (normal, rotation);\n         }\n\n         vec3\n         getRandomSurfaceNormal (const in vec3 direction)\n         {\n            float theta    = getRandomValue (-M_PI, M_PI);\n            float cphi     = pow (random (), 1.0 / 3.0);\n            float r        = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n            vec3  normal   = vec3 (sin (theta) * r, cos (theta) * r, cphi);\n            vec4  rotation = Quaternion (vec3 (0.0, 0.0, 1.0), direction);\n\n            return multVecQuat (normal, rotation);\n         }\n\n         vec3\n         getRandomSphericalVelocity ()\n         {\n            vec3  normal = getRandomNormal ();\n            float speed  = getRandomSpeed ();\n\n            return normal * speed;\n         }\n\n         // Algorithms\n\n         int\n         upperBound (const in sampler2D sampler, in int count, const in float value)\n         {\n            int first = 0;\n            int step  = 0;\n\n            while (count > 0)\n            {\n               int index = first;\n\n               step = count >> 1;\n\n               index += step;\n\n               if (value < texelFetch (sampler, index, 0) .x)\n               {\n                  count = step;\n               }\n               else\n               {\n                  first  = ++ index;\n                  count -= step + 1;\n               }\n            }\n\n            return first;\n         }\n\n         void\n         interpolate (const in sampler2D sampler, const in int count, const in float fraction, out int index0, out int index1, out float weight)\n         {\n            // Determine index0, index1 and weight.\n\n            if (count == 1 || fraction <= texelFetch (sampler, 0, 0) .x)\n            {\n               index0 = 0;\n               index1 = 0;\n               weight = 0.0;\n            }\n            else if (fraction >= texelFetch (sampler, count - 1, 0) .x)\n            {\n               index0 = count - 2;\n               index1 = count - 1;\n               weight = 1.0;\n            }\n            else\n            {\n               int index = upperBound (sampler, count, fraction);\n\n               if (index < count)\n               {\n                  index1 = index;\n                  index0 = index - 1;\n\n                  float key0 = texelFetch (sampler, index0, 0) .x;\n                  float key1 = texelFetch (sampler, index1, 0) .x;\n\n                  weight = clamp ((fraction - key0) / (key1 - key0), 0.0, 1.0);\n               }\n               else\n               {\n                  index0 = 0;\n                  index1 = 0;\n                  weight = 0.0;\n               }\n            }\n         }\n\n         void\n         interpolate (const in sampler2D sampler, const in int count, const in float fraction, out int index0)\n         {\n            // Determine index0.\n\n            if (count == 1 || fraction <= texelFetch (sampler, 0, 0) .x)\n            {\n               index0 = 0;\n            }\n            else if (fraction >= texelFetch (sampler, count - 1, 0) .x)\n            {\n               index0 = count - 2;\n            }\n            else\n            {\n               int index = upperBound (sampler, count, fraction);\n\n               if (index < count)\n                  index0 = index - 1;\n               else\n                  index0 = 0;\n            }\n         }\n\n         vec3\n         getRandomBarycentricCoord ()\n         {\n            // Random barycentric coordinates.\n\n            float u = random ();\n            float v = random ();\n\n            if (u + v > 1.0)\n            {\n               u = 1.0 - u;\n               v = 1.0 - v;\n            }\n\n            float t = 1.0 - u - v;\n\n            return vec3 (t, u, v);\n         }\n\n         void\n         getRandomPointOnSurface (const in sampler2D surface, const in int verticesIndex, const in int normalsIndex, out vec4 position, out vec3 normal)\n         {\n            // Determine index0, index1 and weight.\n\n            float lastAreaSoFar = texelFetch (surface, verticesIndex - 1, 0) .x;\n            float fraction      = random () * lastAreaSoFar;\n\n            int   index0;\n            int   index1;\n            int   index2;\n            float weight;\n\n            interpolate (surface, verticesIndex, fraction, index0, index1, weight);\n\n            // Interpolate and return position.\n\n            index0 *= 3;\n            index1  = index0 + 1;\n            index2  = index0 + 2;\n\n            vec4 vertex0 = texelFetch (surface, verticesIndex + index0, 0);\n            vec4 vertex1 = texelFetch (surface, verticesIndex + index1, 0);\n            vec4 vertex2 = texelFetch (surface, verticesIndex + index2, 0);\n\n            vec3 normal0 = texelFetch (surface, normalsIndex + index0, 0) .xyz;\n            vec3 normal1 = texelFetch (surface, normalsIndex + index1, 0) .xyz;\n            vec3 normal2 = texelFetch (surface, normalsIndex + index2, 0) .xyz;\n\n            // Random barycentric coordinates.\n\n            vec3 r = getRandomBarycentricCoord ();\n\n            // Calculate position and direction.\n\n            position = r .z * vertex0 + r .x * vertex1 + r .y * vertex2;\n            normal   = save_normalize (r .z * normal0 + r .x * normal1 + r .y * normal2);\n         }\n\n         // Functions\n\n         ${this.functions.join("\n")}\n\n         // Current values\n\n         vec4\n         getColor (const in float lifetime, const in float elapsedTime)\n         {\n            if (numColors > 0)\n            {\n               // Determine index0, index1 and weight.\n\n               float fraction = elapsedTime / lifetime;\n\n               int   index0;\n               int   index1;\n               float weight;\n\n               interpolate (colorRamp, numColors, fraction, index0, index1, weight);\n\n               // Interpolate and return color.\n\n               vec4 color0 = texelFetch (colorRamp, numColors + index0, 0);\n               vec4 color1 = texelFetch (colorRamp, numColors + index1, 0);\n\n               return mix (color0, color1, weight);\n            }\n            else\n            {\n               return vec4 (1.0);\n            }\n         }\n\n         void\n         bounce (const in vec4 fromPosition, inout vec4 toPosition, inout vec3 velocity)\n         {\n            if (boundedHierarchyRoot < 0)\n               return;\n\n            Line3 line = Line3 (fromPosition .xyz, save_normalize (velocity));\n\n            vec4 points  [ARRAY_SIZE];\n            vec3 normals [ARRAY_SIZE];\n\n            int numIntersections = getIntersections (boundedVolume, boundedVerticesIndex, boundedNormalsIndex, boundedHierarchyIndex, boundedHierarchyRoot, line, points, normals);\n\n            if (numIntersections == 0)\n               return;\n\n            Plane3 plane1 = plane3 (line .point, line .direction);\n\n            int index = min_index (points, numIntersections, 0.0, plane1);\n\n            if (index == -1)\n               return;\n\n            Plane3 plane2 = plane3 (points [index] .xyz, normals [index]);\n\n            if (sign (plane_distance (plane2, fromPosition .xyz)) == sign (plane_distance (plane2, toPosition .xyz)))\n               return;\n\n            velocity   = reflect (velocity, normals [index]);\n            toPosition = vec4 (points [index] .xyz + reflect (points [index] .xyz - fromPosition .xyz, normals [index]), 1.0);\n         }\n\n         int\n         getTexCoordIndex0 (const in float lifetime, const in float elapsedTime)\n         {\n            if (numTexCoords == 0)\n            {\n               return -1;\n            }\n            else\n            {\n               float fraction = elapsedTime / lifetime;\n               int   index0   = 0;\n\n               interpolate (texCoordRamp, numTexCoords, fraction, index0);\n\n               return numTexCoords + index0 * texCoordCount;\n            }\n         }\n\n         void\n         main ()\n         {\n            int   life        = int (input0 [0]);\n            float lifetime    = input0 [1];\n            float elapsedTime = input0 [2] + deltaTime;\n\n            srand ((gl_VertexID + randomSeed) * randomSeed);\n\n            if (elapsedTime > lifetime)\n            {\n               // Create new particle or hide particle.\n\n               lifetime    = getRandomLifetime ();\n               elapsedTime = 0.0;\n\n               output0 = vec4 (max (life + 1, 1), lifetime, elapsedTime, getTexCoordIndex0 (lifetime, elapsedTime));\n\n               if (createParticles)\n               {\n                  output1 = getColor (lifetime, elapsedTime);\n                  output2 = vec4 (getRandomVelocity (), 0.0);\n                  output6 = getRandomPosition ();\n               }\n               else\n               {\n                  output1 = vec4 (0.0);\n                  output2 = vec4 (0.0);\n                  output6 = vec4 (NaN);\n               }\n            }\n            else\n            {\n               // Animate particle.\n\n               vec3 velocity = input2 .xyz;\n               vec4 position = input6;\n\n               for (int i = 0; i < numForces; ++ i)\n               {\n                  vec4  force      = texelFetch (forces, i, 0);\n                  float turbulence = force .w;\n                  vec3  normal     = getRandomNormalWithDirectionAndAngle (force .xyz, turbulence);\n                  float speed      = length (force .xyz);\n\n                  velocity += normal * speed;\n               }\n\n               position .xyz += velocity * deltaTime;\n\n               bounce (input6, position, velocity);\n\n               output0 = vec4 (life, lifetime, elapsedTime, getTexCoordIndex0 (lifetime, elapsedTime));\n               output1 = getColor (lifetime, elapsedTime);\n               output2 = vec4 (velocity, 0.0);\n               output6 = position;\n            }\n\n            switch (geometryType)\n            {\n               case POINT:\n               case SPRITE:\n               case GEOMETRY:\n               {\n                  output3 = vec4 (1.0, 0.0, 0.0, 0.0);\n                  output4 = vec4 (0.0, 1.0, 0.0, 0.0);\n                  output5 = vec4 (0.0, 0.0, 1.0, 0.0);\n                  break;\n               }\n               case LINE:\n               {\n                  mat3 r = Matrix3 (Quaternion (vec3 (0.0, 0.0, 1.0), output2 .xyz));\n                  mat3 s = mat3 (1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, particleSize .y);\n                  mat3 m = r * s;\n\n                  output3 = vec4 (m [0], 0.0);\n                  output4 = vec4 (m [1], 0.0);\n                  output5 = vec4 (m [2], 0.0);\n                  break;\n               }\n               default: // QUAD, TRIANGLE\n               {\n                  output3 = vec4 (particleSize .x, 0.0, 0.0, 0.0);\n                  output4 = vec4 (0.0, particleSize .y, 0.0, 0.0);\n                  output5 = vec4 (0.0, 0.0, 1.0, 0.0);\n                  break;\n               }\n            }\n         }\n         `,o=n.createShader(n.VERTEX_SHADER);n.shaderSource(o,i),n.compileShader(o);const r=n.createShader(n.FRAGMENT_SHADER);n.shaderSource(r,"#version 300 es\n\n         precision highp float;\n\n         void\n         main () { }\n         "),n.compileShader(r);const s=n.createProgram();n.attachShader(s,o),n.attachShader(s,r),n.transformFeedbackVaryings(s,Array.from({length:7},((e,t)=>"output"+t)),n.INTERLEAVED_ATTRIBS),n.linkProgram(s),n.getProgramParameter(s,n.LINK_STATUS)||console.error("Couldn't initialize particle shader: "+n.getProgramInfoLog(s)),s.inputs=[[0,n.getAttribLocation(s,"input0")],[2,n.getAttribLocation(s,"input2")],[6,n.getAttribLocation(s,"input6")]],s.randomSeed=n.getUniformLocation(s,"randomSeed"),s.geometryType=n.getUniformLocation(s,"geometryType"),s.createParticles=n.getUniformLocation(s,"createParticles"),s.particleLifetime=n.getUniformLocation(s,"particleLifetime"),s.lifetimeVariation=n.getUniformLocation(s,"lifetimeVariation"),s.deltaTime=n.getUniformLocation(s,"deltaTime"),s.particleSize=n.getUniformLocation(s,"particleSize"),s.numForces=n.getUniformLocation(s,"numForces"),s.forces=n.getUniformLocation(s,"forces"),s.boundedVerticesIndex=n.getUniformLocation(s,"boundedVerticesIndex"),s.boundedNormalsIndex=n.getUniformLocation(s,"boundedNormalsIndex"),s.boundedHierarchyIndex=n.getUniformLocation(s,"boundedHierarchyIndex"),s.boundedHierarchyRoot=n.getUniformLocation(s,"boundedHierarchyRoot"),s.boundedVolume=n.getUniformLocation(s,"boundedVolume"),s.numColors=n.getUniformLocation(s,"numColors"),s.colorRamp=n.getUniformLocation(s,"colorRamp"),s.texCoordCount=n.getUniformLocation(s,"texCoordCount"),s.numTexCoords=n.getUniformLocation(s,"numTexCoords"),s.texCoordRamp=n.getUniformLocation(s,"texCoordRamp");for(const e of Object.keys(this.uniforms))s[e]=n.getUniformLocation(s,e);s.NaN=n.getUniformLocation(s,"NaN"),n.useProgram(s);for(const t of this.samplers){const i=n.getUniformLocation(s,t);n.uniform1i(i,s[t+"TextureUnit"]=e.getTexture2DUnit())}return n.uniform1f(s.NaN,NaN),e.resetTextureUnits(),s},activateTextures:function(){},createTexture:function(){const e=this.getBrowser().getContext(),t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,1,1,0,e.RGBA,e.FLOAT,new Float32Array(4)),t},getTexture2DUnit:function(e,t,n){const i=t[n];return void 0===i?t[n]=e.getTexture2DUnit():i}}),a})),t("x_ite/Components/ParticleSystems/PointEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Base/X3DConstants","standard/Math/Numbers/Vector3"],(function(e,t,n,i,o,r){"use strict";function s(e){i.call(this,e),this.addType(o.PointEmitter),this._position.setUnit("length"),this.addUniform("position","uniform vec3 position;"),this.addUniform("direction","uniform vec3 direction;"),this.addFunction("vec3 getRandomVelocity ()\n      {\n         if (direction == vec3 (0.0))\n            return getRandomSphericalVelocity ();\n\n         else\n            return direction * getRandomSpeed ();\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         return vec4 (position, 1.0);\n      }")}return s.prototype=Object.assign(Object.create(i.prototype),{constructor:s,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"on",new e.SFBool(!0)),new t(o.inputOutput,"position",new e.SFVec3f),new t(o.inputOutput,"direction",new e.SFVec3f(0,1,0)),new t(o.inputOutput,"speed",new e.SFFloat),new t(o.inputOutput,"variation",new e.SFFloat(.25)),new t(o.inputOutput,"mass",new e.SFFloat),new t(o.inputOutput,"surfaceArea",new e.SFFloat)]),getTypeName:function(){return"PointEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this._direction.addInterest("set_direction__",this),this.set_position__(),this.set_direction__())},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)},set_direction__:function(){const e=new r(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}()}),s})),t("x_ite/Browser/ParticleSystems/X3DParticleSystemsContext",["x_ite/Components/ParticleSystems/PointEmitter"],(function(e){"use strict";const t=Symbol();function n(){}return n.prototype={getDefaultEmitter:function(){return this[t]=new e(this.getPrivateScene()),this[t].setup(),this.getDefaultEmitter=function(){return this[t]},Object.defineProperty(this,"getDefaultEmitter",{enumerable:!1}),v,this[t]}},n})),t("x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode",["x_ite/Components/Core/X3DNode","x_ite/Base/X3DConstants"],(function(e,t){"use strict";function n(n){e.call(this,n),this.addType(t.X3DParticlePhysicsModelNode)}return n.prototype=Object.assign(Object.create(e.prototype),{constructor:n,addForce:function(){}}),n})),t("x_ite/Components/ParticleSystems/BoundedPhysicsModel",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode","x_ite/Base/X3DConstants","x_ite/Base/X3DCast"],(function(e,t,n,i,o,r){"use strict";function s(e){i.call(this,e),this.addType(o.BoundedPhysicsModel)}return s.prototype=Object.assign(Object.create(i.prototype),{constructor:s,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"enabled",new e.SFBool(!0)),new t(o.inputOutput,"geometry",new e.SFNode)]),getTypeName:function(){return"BoundedPhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},initialize:function(){i.prototype.initialize.call(this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},set_geometry__:function(){this.geometryNode&&this.geometryNode._rebuild.removeInterest("addNodeEvent",this),this.geometryNode=r(o.X3DGeometryNode,this._geometry),this.geometryNode&&this.geometryNode._rebuild.addInterest("addNodeEvent",this)},addGeometry:function(e,t){if(this.geometryNode&&this._enabled.getValue()){const n=this.geometryNode.getNormals().getValue(),i=this.geometryNode.getVertices().getValue();for(const t of n)e.push(t);for(const e of i)t.push(e)}}}),s})),t("x_ite/Components/ParticleSystems/ConeEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Base/X3DConstants"],(function(e,t,n,i,o){"use strict";function r(e){i.call(this,e),this.addType(o.ConeEmitter),this._position.setUnit("length"),this._angle.setUnit("angle"),this.addUniform("position","uniform vec3  position;"),this.addUniform("direction","uniform vec3  direction;"),this.addUniform("angle","uniform float angle;"),this.addFunction("vec3 getRandomVelocity ()\n      {\n         if (direction == vec3 (0.0))\n         {\n            return getRandomSphericalVelocity ();\n         }\n         else\n         {\n            vec3  normal = getRandomNormalWithDirectionAndAngle (direction, angle);\n            float speed  = getRandomSpeed ();\n\n            return normal * speed;\n         }\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         return vec4 (position, 1.0);\n      }")}return r.prototype=Object.assign(Object.create(i.prototype),{constructor:r,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"on",new e.SFBool(!0)),new t(o.inputOutput,"position",new e.SFVec3f),new t(o.inputOutput,"direction",new e.SFVec3f(0,1,0)),new t(o.inputOutput,"angle",new e.SFFloat(.7854)),new t(o.inputOutput,"speed",new e.SFFloat),new t(o.inputOutput,"variation",new e.SFFloat(.25)),new t(o.inputOutput,"mass",new e.SFFloat),new t(o.inputOutput,"surfaceArea",new e.SFFloat)]),getTypeName:function(){return"ConeEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this._direction.addInterest("set_direction__",this),this._angle.addInterest("set_angle__",this),this.set_position__(),this.set_direction__(),this.set_angle__())},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)},set_direction__:function(){const e=this._direction.getValue();this.setUniform("uniform3f","direction",e.x,e.y,e.z)},set_angle__:function(){this.setUniform("uniform1f","angle",this._angle.getValue())}}),r})),t("x_ite/Components/ParticleSystems/ExplosionEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Base/X3DConstants"],(function(e,t,n,i,o){"use strict";function r(e){i.call(this,e),this.addType(o.ExplosionEmitter),this._position.setUnit("length"),this.addUniform("position","uniform vec3 position;"),this.addFunction("vec3 getRandomVelocity ()\n      {\n         return getRandomSphericalVelocity ();\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         return vec4 (position, 1.0);\n      }")}return r.prototype=Object.assign(Object.create(i.prototype),{constructor:r,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"on",new e.SFBool(!0)),new t(o.inputOutput,"position",new e.SFVec3f),new t(o.inputOutput,"speed",new e.SFFloat),new t(o.inputOutput,"variation",new e.SFFloat(.25)),new t(o.inputOutput,"mass",new e.SFFloat),new t(o.inputOutput,"surfaceArea",new e.SFFloat)]),getTypeName:function(){return"ExplosionEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this.set_position__())},isExplosive:function(){return!0},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)}}),r})),t("x_ite/Components/ParticleSystems/ForcePhysicsModel",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode","x_ite/Base/X3DConstants","standard/Math/Numbers/Vector3"],(function(e,t,n,i,o,r){"use strict";function s(e){i.call(this,e),this.addType(o.ForcePhysicsModel),this._force.setUnit("force")}return s.prototype=Object.assign(Object.create(i.prototype),{constructor:s,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"enabled",new e.SFBool(!0)),new t(o.inputOutput,"force",new e.SFVec3f(0,-9.8,0))]),getTypeName:function(){return"ForcePhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},addForce:function(){const e=new r(0,0,0);return function(t,n,i,o){return!!this._enabled.getValue()&&(o.set(e.assign(this._force.getValue()).multiply(i),4*t),o[4*t+3]=0,!0)}}()}),s})),t("standard/Math/Utility/BVH",["standard/Math/Numbers/Vector3","standard/Math/Geometry/Plane3","standard/Math/Algorithms/QuickSort"],(function(e,t,n){"use strict";const i=new e(0,0,0),o=new e(0,0,0),r=new e(0,0,0),s={u:0,v:0,t:0},a=[new e(0,0,1),new e(0,0,-1),new e(0,1,0),new e(0,-1,0),new e(1,0,0)];function c(e,t){this.vertices=e.vertices,this.normals=e.normals,this.triangle=t,this.i4=12*t,this.i3=9*t}function l(n,s,u,d){this.min=new e(0,0,0),this.max=new e(0,0,0),this.planes=[],this.intersection=new e(0,0,0);const m=n.vertices,h=this.min,p=this.max,f=u+d;let x=12*s[u];h.set(m[x],m[x+1],m[x+2]),p.assign(h);for(let e=u;e<f;++e)x=12*s[e],i.set(m[x],m[x+1],m[x+2]),o.set(m[x+4],m[x+5],m[x+6]),r.set(m[x+8],m[x+9],m[x+10]),h.min(i,o,r),p.max(i,o,r);for(let e=0;e<5;++e)this.planes[e]=new t(e%2?h:p,a[e]);if(d>2){n.sorter.compare.axis=this.getLongestAxis(h,p),n.sorter.sort(u,f);var _=d>>>1}else _=1;const y=d-_;this.left=_>1?new l(n,s,u,_):new c(n,s[u]),this.right=y>1?new l(n,s,u+_,y):new c(n,s[u+_])}function u(e,t){const i=e.length/12;switch(this.vertices=e,this.normals=t,i){case 0:this.root=null;break;case 1:this.root=new c(this,0);break;default:{const t=[];for(let e=0;e<i;++e)t.push(e);this.sorter=new n(t,function(e,t){return function(n,i){return Math.min(e[n+t],e[n+4+t],e[n+8+t])<Math.min(e[i+t],e[i+4+t],e[i+8+t])}}(e,0)),this.root=new l(this,t,0,i);break}}}return c.prototype={intersectsLine:function(t,n,a){const c=this.vertices,l=this.normals,u=this.i4,d=this.i3;if(i.x=c[u],i.y=c[u+1],i.z=c[u+2],o.x=c[u+4],o.y=c[u+5],o.z=c[u+6],r.x=c[u+8],r.y=c[u+9],r.z=c[u+10],t.intersectsTriangle(i,o,r,s)){const t=s.u,i=s.v,o=1-t-i,r=n.size++;r>=n.length&&n.push(new e(0,0,0)),n[r].set(o*c[u]+t*c[u+4]+i*c[u+8],o*c[u+1]+t*c[u+5]+i*c[u+9],o*c[u+2]+t*c[u+6]+i*c[u+10]),a&&(r>=a.length&&a.push(new e(0,0,0)),a[r].set(o*l[d]+t*l[d+3]+i*l[d+6],o*l[d+1]+t*l[d+4]+i*l[d+7],o*l[d+2]+t*l[d+5]+i*l[d+8]))}},toArray:function(e){const t=e.length/4;return e.push(1,3*this.triangle,0,0),t}},l.prototype={intersectsLine:function(e,t,n){this.intersectsBBox(e)&&(this.left.intersectsLine(e,t,n),this.right.intersectsLine(e,t,n))},intersectsBBox:function(e){const t=this.planes,n=this.min,i=this.max,o=n.x,r=i.x,s=n.y,a=i.y,c=n.z,l=i.z,u=this.intersection;return!!(t[0].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.y>=s&&u.y<=a)||(!!(t[1].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.y>=s&&u.y<=a)||(!!(t[2].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.z>=c&&u.z<=l)||(!!(t[3].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.z>=c&&u.z<=l)||!!(t[4].intersectsLine(e,u)&&u.y>=s&&u.y<=a&&u.z>=c&&u.z<=l))))},getLongestAxis:function(e,t){const n=t.x-e.x,i=t.y-e.y,o=t.z-e.z;return n<i?i<o?2:1:n<o?2:0},toArray:function(e){const t=this.left.toArray(e),n=this.right.toArray(e),i=this.min,o=this.max,r=e.length/4;return e.push(0,t,n,0,i.x,i.y,i.z,0,o.x,o.y,o.z,0),r}},u.prototype={constructor:u,intersectsLine:function(e,t,n){return t.size=0,this.root?(this.root.intersectsLine(e,t,n),t.size):0},toArray:function(e){if(this.root){const t=this.root.toArray(e);e.push(t,0,0,0)}return e}},u})),t("x_ite/Components/ParticleSystems/ParticleSystem",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/Shape/X3DShapeNode","x_ite/Browser/ParticleSystems/GeometryTypes","x_ite/Rendering/VertexArray","x_ite/Rendering/TraverseType","x_ite/Base/X3DConstants","x_ite/Base/X3DCast","x_ite/Browser/Shape/AlphaMode","standard/Math/Numbers/Vector3","standard/Math/Numbers/Matrix4","standard/Math/Numbers/Matrix3","standard/Math/Utility/BVH"],(function(e,t,n,i,o,r,s,a,c,l,u,d,m,h){"use strict";const p=new Float32Array([0,0,0,1]),f=new Float32Array([0,0,0,1,1,0,0,1,0,0,-.5,1,0,0,.5,1]),x=new Float32Array([0,0,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,-.5,-.5,0,1,.5,-.5,0,1,.5,.5,0,1,-.5,-.5,0,1,.5,.5,0,1,-.5,.5,0,1]);function _(e){i.call(this,e),this.addType(a.ParticleSystem),this._particleSize.setUnit("length"),this.maxParticles=0,this.numParticles=0,this.forcePhysicsModelNodes=[],this.forces=new Float32Array(4),this.boundedPhysicsModelNodes=[],this.boundedNormals=[],this.boundedVertices=[],this.colorRamp=new Float32Array,this.texCoordRamp=new Float32Array,this.geometryContext={},this.creationTime=0,this.pauseTime=0,this.deltaTime=0,this.particleStride=7*Float32Array.BYTES_PER_ELEMENT*4,this.particleOffsets=Array.from({length:7},((e,t)=>4*Float32Array.BYTES_PER_ELEMENT*t)),this.particleOffset=this.particleOffsets[0],this.colorOffset=this.particleOffsets[1],this.matrixOffset=this.particleOffsets[3],this.texCoordOffset=0}return _.prototype=Object.assign(Object.create(i.prototype),{constructor:_,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(a.inputOutput,"metadata",new e.SFNode),new t(a.inputOutput,"enabled",new e.SFBool(!0)),new t(a.inputOutput,"createParticles",new e.SFBool(!0)),new t(a.initializeOnly,"geometryType",new e.SFString("QUAD")),new t(a.inputOutput,"maxParticles",new e.SFInt32(200)),new t(a.inputOutput,"particleLifetime",new e.SFFloat(5)),new t(a.inputOutput,"lifetimeVariation",new e.SFFloat(.25)),new t(a.inputOutput,"particleSize",new e.SFVec2f(.02,.02)),new t(a.initializeOnly,"emitter",new e.SFNode),new t(a.initializeOnly,"physics",new e.MFNode),new t(a.initializeOnly,"colorKey",new e.MFFloat),new t(a.initializeOnly,"colorRamp",new e.SFNode),new t(a.initializeOnly,"texCoordKey",new e.MFFloat),new t(a.initializeOnly,"texCoordRamp",new e.SFNode),new t(a.outputOnly,"isActive",new e.SFBool),new t(a.inputOutput,"visible",new e.SFBool(!0)),new t(a.inputOutput,"castShadow",new e.SFBool(!0)),new t(a.inputOutput,"bboxDisplay",new e.SFBool),new t(a.initializeOnly,"bboxSize",new e.SFVec3f(-1,-1,-1)),new t(a.initializeOnly,"bboxCenter",new e.SFVec3f),new t(a.inputOutput,"appearance",new e.SFNode),new t(a.inputOutput,"geometry",new e.SFNode)]),getTypeName:function(){return"ParticleSystem"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"children"},initialize:function(){i.prototype.initialize.call(this);const e=this.getBrowser();e.getContext();e.getContext().getVersion()<2||(this.isLive().addInterest("set_live__",this),e.getBrowserOptions()._Shading.addInterest("set_shader__",this),this._enabled.addInterest("set_enabled__",this),this._createParticles.addInterest("set_createParticles__",this),this._geometryType.addInterest("set_geometryType__",this),this._geometryType.addInterest("set_texCoord__",this),this._maxParticles.addInterest("set_enabled__",this),this._particleLifetime.addInterest("set_particleLifetime__",this),this._lifetimeVariation.addInterest("set_lifetimeVariation__",this),this._emitter.addInterest("set_emitter__",this),this._physics.addInterest("set_physics__",this),this._colorKey.addInterest("set_color__",this),this._colorRamp.addInterest("set_colorRamp__",this),this._texCoordKey.addInterest("set_texCoord__",this),this._texCoordRamp.addInterest("set_texCoordRamp__",this),this.inputParticles=this.createBuffer(),this.outputParticles=this.createBuffer(),this.inputParticles.emitterArrayObject=new r,this.inputParticles.vertexArrayObject=new r,this.inputParticles.shadowArrayObject=new r,this.outputParticles.emitterArrayObject=new r,this.outputParticles.vertexArrayObject=new r,this.outputParticles.shadowArrayObject=new r,this.forcesTexture=this.createTexture(),this.boundedTexture=this.createTexture(),this.colorRampTexture=this.createTexture(),this.texCoordRampTexture=this.createTexture(),this.geometryBuffer=this.createBuffer(),this.texCoordBuffers=new Array(e.getMaxTextures()).fill(this.geometryBuffer),this.geometryContext.fogCoords=!1,this.geometryContext.textureCoordinateNode=e.getDefaultTextureCoordinate(),this.geometryContext.textureCoordinateMapping=new Map,this.set_emitter__(),this.set_enabled__(),this.set_geometryType__(),this.set_createParticles__(),this.set_particleLifetime__(),this.set_lifetimeVariation__(),this.set_physics__(),this.set_colorRamp__(),this.set_texCoordRamp__())},set_bbox__:function(){this._bboxSize.getValue().equals(this.getDefaultBBoxSize())?this.bbox.set():this.bbox.set(this._bboxSize.getValue(),this._bboxCenter.getValue()),this.bboxSize.assign(this.bbox.size),this.bboxCenter.assign(this.bbox.center)},set_transparent__:function(){if(this.getAppearance().getAlphaMode()===l.AUTO)if(this.geometryType===o.POINT)this.setTransparent(!0);else this.setTransparent(this.getAppearance().getTransparent()||this.colorRampNode&&this.colorRampNode.getTransparent()||this.geometryType===o.GEOMETRY&&this.geometryNode&&this.geometryNode.getTransparent());else this.setTransparent(this.getAppearance().getTransparent())},set_live__:function(){this.isLive().getValue()?this._isActive.getValue()&&this._maxParticles.getValue()&&(this.getBrowser().sensorEvents().addInterest("animateParticles",this),this.pauseTime&&(this.creationTime+=performance.now()/1e3-this.pauseTime,this.pauseTime=0)):this._isActive.getValue()&&this._maxParticles.getValue()&&(this.getBrowser().sensorEvents().removeInterest("animateParticles",this),0===this.pauseTime&&(this.pauseTime=performance.now()/1e3))},set_enabled__:function(){this._enabled.getValue()&&this._maxParticles.getValue()?this._isActive.getValue()||(this.isLive().getValue()?(this.getBrowser().sensorEvents().addInterest("animateParticles",this),this.pauseTime=0):this.pauseTime=performance.now()/1e3,this._isActive=!0,delete this.traverse):this._isActive.getValue()&&(this.isLive().getValue()&&this.getBrowser().sensorEvents().removeInterest("animateParticles",this),this._isActive=!1,this.numParticles=0,this.traverse=Function.prototype),this.set_maxParticles__()},set_createParticles__:function(){this.createParticles=this._createParticles.getValue()},set_geometryType__:function(){const e=this.getBrowser().getContext();switch(this.geometryType=o.hasOwnProperty(this._geometryType.getValue())?o[this._geometryType.getValue()]:o.QUAD,this.geometryType){case o.POINT:this.geometryContext.geometryType=0,this.texCoordCount=0,this.vertexCount=1,this.hasNormals=!1,this.primitiveMode=e.POINTS,this.verticesOffset=0,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,p,e.DYNAMIC_DRAW);break;case o.LINE:this.geometryContext.geometryType=1,this.texCoordCount=2,this.vertexCount=2,this.hasNormals=!1,this.primitiveMode=e.LINES,this.texCoordsOffset=0,this.verticesOffset=8*Float32Array.BYTES_PER_ELEMENT,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,f,e.DYNAMIC_DRAW);break;case o.TRIANGLE:case o.QUAD:case o.SPRITE:this.geometryContext.geometryType=2,this.texCoordCount=4,this.vertexCount=6,this.hasNormals=!0,this.primitiveMode=e.TRIANGLES,this.texCoordsOffset=0,this.normalOffset=24*Float32Array.BYTES_PER_ELEMENT,this.verticesOffset=27*Float32Array.BYTES_PER_ELEMENT,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,x,e.DYNAMIC_DRAW);break;case o.GEOMETRY:this.texCoordCount=0,this.vertexCount=0}this.updateVertexArrays(),this.set_shader__(),this.set_transparent__()},set_shader__:function(){switch(this.geometryType){case o.POINT:this.shaderNode=this.getBrowser().getPointShader();break;case o.LINE:this.shaderNode=this.getBrowser().getLineShader();break;default:this.shaderNode=null}},set_maxParticles__:function(){const e=this.numParticles,t=Math.max(0,this._maxParticles.getValue());this.maxParticles=t,this.numParticles=Math.min(e,t),this.emitterNode.isExplosive()||(this.creationTime=performance.now()/1e3),this.resizeBuffers(e),this.updateVertexArrays()},set_particleLifetime__:function(){this.particleLifetime=this._particleLifetime.getValue()},set_lifetimeVariation__:function(){this.lifetimeVariation=this._lifetimeVariation.getValue()},set_emitter__:function(){this.emitterNode=c(a.X3DParticleEmitterNode,this._emitter),this.emitterNode||(this.emitterNode=this.getBrowser().getDefaultEmitter()),this.createParticles=this._createParticles.getValue()},set_physics__:function(){const e=this._physics.getValue(),t=this.forcePhysicsModelNodes,n=this.boundedPhysicsModelNodes;for(let e=0,t=n.length;e<t;++e)n[e].removeInterest("set_boundedPhysics__",this);t.length=0,n.length=0;for(let i=0,o=e.length;i<o;++i)try{const o=e[i].getValue().getInnerNode(),r=o.getType();for(let e=r.length-1;e>=0;--e){switch(r[e]){case a.ForcePhysicsModel:case a.WindPhysicsModel:t.push(o);break;case a.BoundedPhysicsModel:o.addInterest("set_boundedPhysics__",this),n.push(o);break;default:continue}break}}catch(e){}this.set_boundedPhysics__()},set_boundedPhysics__:function(){const e=this.getBrowser().getContext(),t=this.boundedPhysicsModelNodes,n=this.boundedNormals,i=this.boundedVertices;n.length=0,i.length=0;for(let e=0,o=t.length;e<o;++e)t[e].addGeometry(n,i);const o=new h(i,n).toArray([]),r=i.length/4,s=n.length/3,a=o.length/4,c=Math.ceil(Math.sqrt(r+s+a)),l=new Float32Array(c*c*4);this.boundedVerticesIndex=0,this.boundedNormalsIndex=r,this.boundedHierarchyIndex=this.boundedNormalsIndex+s,this.boundedHierarchyRoot=this.boundedHierarchyIndex+a-1,l.set(i);for(let e=4*this.boundedNormalsIndex,t=0,i=n.length;t<i;e+=4,t+=3)l[e+0]=n[t+0],l[e+1]=n[t+1],l[e+2]=n[t+2];l.set(o,4*this.boundedHierarchyIndex),c&&(e.bindTexture(e.TEXTURE_2D,this.boundedTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,c,c,0,e.RGBA,e.FLOAT,l))},set_colorRamp__:function(){this.colorRampNode&&this.colorRampNode.removeInterest("set_color__",this),this.colorRampNode=c(a.X3DColorNode,this._colorRamp),this.colorRampNode&&this.colorRampNode.addInterest("set_color__",this),this.set_color__(),this.set_transparent__()},set_color__:function(){const e=this.getBrowser().getContext(),t=this._colorKey,n=t.length,i=Math.ceil(Math.sqrt(2*n));let o=this.colorRamp;i*i*4>o.length&&(o=this.colorRamp=new Float32Array(i*i*4));for(let e=0;e<n;++e)o[4*e]=t[e];this.colorRampNode?o.set(this.colorRampNode.addColors([],n).slice(0,4*n),4*n):o.fill(1,4*n),i&&(e.bindTexture(e.TEXTURE_2D,this.colorRampTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,i,i,0,e.RGBA,e.FLOAT,o)),this.numColors=n,this.geometryContext.colorMaterial=!(!n||!this.colorRampNode),this.updateVertexArrays()},set_texCoordRamp__:function(){this.texCoordRampNode&&this.texCoordRampNode.removeInterest("set_texCoord__",this),this.texCoordRampNode=c(a.X3DTextureCoordinateNode,this._texCoordRamp),this.texCoordRampNode&&this.texCoordRampNode.addInterest("set_texCoord__",this),this.set_texCoord__()},set_texCoord__:function(){const e=this.getBrowser().getContext(),t=this._texCoordKey,n=t.length,i=Math.ceil(Math.sqrt(n+n*this.texCoordCount));let o=this.texCoordRamp;i*i*4>o.length?o=this.texCoordRamp=new Float32Array(i*i*4):o.fill(0);for(let e=0;e<n;++e)o[4*e]=t[e];this.texCoordRampNode&&o.set(this.texCoordRampNode.getTexCoord([]).slice(0,n*this.texCoordCount*4),4*n),i&&(e.bindTexture(e.TEXTURE_2D,this.texCoordRampTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,i,i,0,e.RGBA,e.FLOAT,o)),this.numTexCoords=this.texCoordRampNode?n:0,this.updateVertexArrays()},updateVertexArrays:function(){this.inputParticles.vertexArrayObject.update(),this.inputParticles.shadowArrayObject.update(),this.inputParticles.emitterArrayObject.update(),this.outputParticles.vertexArrayObject.update(),this.outputParticles.shadowArrayObject.update(),this.outputParticles.emitterArrayObject.update()},createTexture:function(){const e=this.getBrowser().getContext(),t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,1,1,0,e.RGBA,e.FLOAT,new Float32Array(4)),t},createBuffer:function(){const e=this.getBrowser().getContext(),t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Uint32Array,e.DYNAMIC_DRAW),t},resizeBuffers:function(e){const t=this.getBrowser().getContext(),n=this.maxParticles,i=this.particleStride,o=Object.assign(t.createBuffer(),this.outputParticles),r=new Uint8Array(n*i);t.bindBuffer(t.ARRAY_BUFFER,this.inputParticles),t.bufferData(t.ARRAY_BUFFER,r,t.DYNAMIC_DRAW),t.bindBuffer(t.COPY_READ_BUFFER,this.outputParticles),t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,r,t.DYNAMIC_DRAW),t.copyBufferSubData(t.COPY_READ_BUFFER,t.ARRAY_BUFFER,0,0,Math.min(n*i,e*i)),t.deleteBuffer(this.outputParticles),this.outputParticles=o},animateParticles:function(){const e=this.getBrowser(),t=e.getContext(),n=this.emitterNode,i=1/Math.max(10,this.getBrowser().getCurrentFrameRate());let o=this.deltaTime=(14*this.deltaTime+i)/15;if(n.isExplosive()){const e=performance.now()/1e3,t=this.particleLifetime+this.particleLifetime*this.lifetimeVariation;0===this.numParticles||e-this.creationTime>t?(this.creationTime=e,this.numParticles=this.maxParticles,this.createParticles=this._createParticles.getValue(),o=Number.POSITIVE_INFINITY):this.createParticles=!1}else if(this.numParticles<this.maxParticles){const e=performance.now()/1e3,t=Math.max(0,Math.floor((e-this.creationTime)*this.maxParticles/this.particleLifetime));t&&(this.creationTime=e),this.numParticles=Math.floor(Math.min(this.maxParticles,this.numParticles+t))}if(n.getMass()){const e=this.forcePhysicsModelNodes;let i=e.length,r=this.forces,s=o/n.getMass();4*i>r.length&&(r=this.forces=new Float32Array(4*i));let a=0;for(let t=0;t<i;++t)a+=!e[t].addForce(t-a,n,s,r);this.numForces=i-=a,i&&(t.bindTexture(t.TEXTURE_2D,this.forcesTexture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA32F,i,1,0,t.RGBA,t.FLOAT,r))}else this.numForces=0;const r=this.outputParticles;this.outputParticles=this.inputParticles,this.inputParticles=r,n.animate(this,o),e.addBrowserEvent()},updateSprite:function(){const e=new Float32Array(x),t=[new u(-.5,-.5,0),new u(.5,-.5,0),new u(.5,.5,0),new u(-.5,-.5,0),new u(.5,.5,0),new u(-.5,.5,0)],n=new u(0,0,0),i=new u(0,0,0);return function(o,r){for(let t=0;t<3;++t)e[24+t]=r[6+t];i.set(this._particleSize.x,this._particleSize.y,1);for(let o=0;o<6;++o){const s=27+4*o;r.multVecMatrix(n.assign(t[o]).multVec(i)),e[s+0]=n.x,e[s+1]=n.y,e[s+2]=n.z}o.bindBuffer(o.ARRAY_BUFFER,this.geometryBuffer),o.bufferData(o.ARRAY_BUFFER,e,o.DYNAMIC_DRAW)}}(),intersectsBox:function(e,t){},traverse:function(e,t){if(0!==this.numParticles){switch(e){case s.POINTER:case s.PICKING:case s.COLLISION:break;case s.SHADOW:this._castShadow.getValue()&&t.addDepthShape(this);break;case s.DISPLAY:t.addDisplayShape(this)&&this.getAppearance().traverse(e,t)}this.geometryType===o.GEOMETRY&&this.getGeometry()&&this.getGeometry().traverse(e,t)}},depth:function(e,t,n){switch(this.geometryType){case o.GEOMETRY:{const i=this.getGeometry();i&&i.displayParticlesDepth(e,t,n,this);break}case o.SPRITE:this.updateSprite(e,this.getScreenAlignedRotation(t.modelViewMatrix));default:{const t=this.outputParticles;if(t.shadowArrayObject.enable(e,n)){const i=this.particleStride;n.enableParticleAttribute(e,t,i,this.particleOffset,1),n.enableParticleMatrixAttribute(e,t,i,this.matrixOffset,1),n.enableVertexAttribute(e,this.geometryBuffer,0,this.verticesOffset)}e.drawArraysInstanced(this.primitiveMode,0,this.vertexCount,this.numParticles);break}}},display:function(e,t){switch(this.geometryType){case o.GEOMETRY:{const n=this.getGeometry();n&&n.displayParticles(e,t,this);break}case o.SPRITE:this.updateSprite(e,this.getScreenAlignedRotation(t.modelViewMatrix));case o.QUAD:case o.TRIANGLE:{const n=d.prototype.determinant3.call(t.modelViewMatrix)>0;e.frontFace(n?e.CCW:e.CW),e.enable(e.CULL_FACE),e.cullFace(e.BACK)}default:{const n=this.getAppearance(),i=n.shaderNode||this.shaderNode||n.materialNode.getShader(t.browser,t.shadow),o=i.getPrimitiveMode(this.primitiveMode);if(i.isValid()){t.geometryContext=this.geometryContext;const r=n.blendModeNode;if(r&&r.enable(e),i.enable(e),i.setLocalUniforms(e,t),this.numTexCoords){const n=t.browser.getTexture2DUnit();e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,this.texCoordRampTexture),e.uniform1i(i.x3d_TexCoordRamp,n)}const s=this.outputParticles;if(s.vertexArrayObject.enable(e,i)){const t=this.particleStride;i.enableParticleAttribute(e,s,t,this.particleOffset,1),i.enableParticleMatrixAttribute(e,s,t,this.matrixOffset,1),this.geometryContext.colorMaterial&&(i.enableColorAttribute(e,s,t,this.colorOffset),i.colorAttributeDivisor(e,1)),this.texCoordCount&&i.enableTexCoordAttribute(e,this.texCoordBuffers,0,this.texCoordOffset),this.hasNormals&&(i.enableNormalAttribute(e,this.geometryBuffer,0,this.normalOffset),i.normalAttributeDivisor(e,this.maxParticles)),i.enableVertexAttribute(e,this.geometryBuffer,0,this.verticesOffset)}e.drawArraysInstanced(o,0,this.vertexCount,this.numParticles),r&&r.disable(e),delete t.geometryContext}break}}},getScreenAlignedRotation:function(){const e=new d,t=new u(0,0,0),n=new u(0,0,0),i=new u(0,0,0),o=new m(9);return function(r){e.assign(r).inverse(),e.multDirMatrix(t.assign(u.zAxis)),e.multDirMatrix(n.assign(u.yAxis));const s=n.cross(t);i.assign(t).cross(s);const a=t;return s.normalize(),i.normalize(),a.normalize(),o.set(s.x,s.y,s.z,i.x,i.y,i.z,a.x,a.y,a.z),o}}()}),_})),t("x_ite/Components/ParticleSystems/PolylineEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Components/Rendering/IndexedLineSet","x_ite/Base/X3DConstants","standard/Math/Numbers/Vector3"],(function(e,t,n,i,o,r,s){"use strict";function a(e){i.call(this,e),this.addType(r.PolylineEmitter),this.polylinesNode=new o(e),this.polylinesArray=new Float32Array,this.addSampler("polylines"),this.addUniform("direction","uniform vec3 direction;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("polylines","uniform sampler2D polylines;"),this.addFunction("vec3 getRandomVelocity ()\n      {\n         if (direction == vec3 (0.0))\n            return getRandomSphericalVelocity ();\n\n         else\n            return direction * getRandomSpeed ();\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         if (verticesIndex < 0)\n         {\n            return vec4 (NaN);\n         }\n         else\n         {\n            // Determine index0, index1 and weight.\n\n            float lastLengthSoFar = texelFetch (polylines, verticesIndex - 1, 0) .x;\n            float fraction        = random () * lastLengthSoFar;\n\n            int   index0 = 0;\n            int   index1 = 0;\n            float weight = 0.0;\n\n            interpolate (polylines, verticesIndex, fraction, index0, index1, weight);\n\n            // Interpolate and return position.\n\n            index0 *= 2;\n            index1  = index0 + 1;\n\n            vec4 vertex0 = texelFetch (polylines, verticesIndex + index0, 0);\n            vec4 vertex1 = texelFetch (polylines, verticesIndex + index1, 0);\n\n            return mix (vertex0, vertex1, weight);\n         }\n      }")}return a.prototype=Object.assign(Object.create(i.prototype),{constructor:a,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(r.inputOutput,"metadata",new e.SFNode),new t(r.inputOutput,"on",new e.SFBool(!0)),new t(r.inputOutput,"direction",new e.SFVec3f(0,1,0)),new t(r.inputOutput,"speed",new e.SFFloat),new t(r.inputOutput,"variation",new e.SFFloat(.25)),new t(r.inputOutput,"mass",new e.SFFloat),new t(r.inputOutput,"surfaceArea",new e.SFFloat),new t(r.inputOutput,"coordIndex",new e.MFInt32(-1)),new t(r.inputOutput,"coord",new e.SFNode)]),getTypeName:function(){return"PolylineEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.polylinesTexture=this.createTexture(),this._direction.addInterest("set_direction__",this),this._coordIndex.addFieldInterest(this.polylinesNode._coordIndex),this._coord.addFieldInterest(this.polylinesNode._coord),this.polylinesNode._coordIndex=this._coordIndex,this.polylinesNode._coord=this._coord,this.polylinesNode._rebuild.addInterest("set_polyline",this),this.polylinesNode.setPrivate(!0),this.polylinesNode.setup(),this.set_direction__(),this.set_polyline())},set_direction__:function(){const e=new s(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}(),set_polyline:function(){const e=new s(0,0,0),t=new s(0,0,0);return function(){const n=this.getBrowser().getContext(),i=this.polylinesNode.getVertices().getValue(),o=i.length/4,r=o/2+1,s=Math.ceil(Math.sqrt(r+o)),a=r;let c=this.polylinesArray;c.length<s*s*4&&(c=this.polylinesArray=new Float32Array(s*s*4));let l=0;for(let n=0,o=i.length;n<o;n+=8)e.set(i[n],i[n+1],i[n+2]),t.set(i[n+4],i[n+5],i[n+6]),c[n/2+4]=l+=t.subtract(e).magnitude();c.set(i,4*a),this.setUniform("uniform1i","verticesIndex",o?a:-1),s&&(n.bindTexture(n.TEXTURE_2D,this.polylinesTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,s,s,0,n.RGBA,n.FLOAT,c))}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.polylinesTextureUnit),e.bindTexture(e.TEXTURE_2D,this.polylinesTexture)}}),a})),t("x_ite/Components/ParticleSystems/SurfaceEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Base/X3DConstants","x_ite/Base/X3DCast","standard/Math/Geometry/Triangle3","standard/Math/Numbers/Vector3"],(function(e,t,n,i,o,r,s,a){"use strict";function c(e){i.call(this,e),this.addType(o.SurfaceEmitter),this.surfaceNode=null,this.surfaceArray=new Float32Array,this.addSampler("surface"),this.addUniform("solid","uniform bool solid;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("normalsIndex","uniform int normalsIndex;"),this.addUniform("surface","uniform sampler2D surface;"),this.addFunction("vec4 position; vec3 getRandomVelocity ()\n      {\n         if (verticesIndex < 0)\n         {\n            return vec3 (0.0);\n         }\n         else\n         {\n            vec3 normal;\n\n            getRandomPointOnSurface (surface, verticesIndex, normalsIndex, position, normal);\n\n            if (solid == false && random () > 0.5)\n               normal = -normal;\n\n            return normal * getRandomSpeed ();\n         }\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         return verticesIndex < 0 ? vec4 (NaN) : position;\n      }")}return c.prototype=Object.assign(Object.create(i.prototype),{constructor:c,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"on",new e.SFBool(!0)),new t(o.inputOutput,"speed",new e.SFFloat),new t(o.inputOutput,"variation",new e.SFFloat(.25)),new t(o.inputOutput,"mass",new e.SFFloat),new t(o.inputOutput,"surfaceArea",new e.SFFloat),new t(o.inputOutput,"surface",new e.SFNode)]),getTypeName:function(){return"SurfaceEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.surfaceTexture=this.createTexture(),this._surface.addInterest("set_surface__",this),this.set_surface__())},set_surface__:function(){this.surfaceNode&&(this.surfaceNode._solid.removeInterest("set_solid__",this),this.surfaceNode._rebuild.removeInterest("set_geometry__",this)),this.surfaceNode=r(o.X3DGeometryNode,this._surface),this.surfaceNode&&(this.surfaceNode._solid.addInterest("set_solid__",this),this.surfaceNode._rebuild.addInterest("set_geometry__",this)),this.set_solid__(),this.set_geometry__()},set_solid__:function(){this.surfaceNode&&this.setUniform("uniform1i","solid",this.surfaceNode._solid.getValue())},set_geometry__:function(){const e=new a(0,0,0),t=new a(0,0,0),n=new a(0,0,0);return function(){const i=this.getBrowser().getContext();if(this.surfaceNode){const o=this.surfaceNode.getVertices().getValue(),r=this.surfaceNode.getNormals().getValue(),a=o.length/4,c=a/3+1,l=Math.ceil(Math.sqrt(c+a+a)),u=c,d=u+a;let m=this.surfaceArray;m.length<l*l*4&&(m=this.surfaceArray=new Float32Array(l*l*4));let h=0;for(let i=0,r=o.length;i<r;i+=12)e.set(o[i],o[i+1],o[i+2]),t.set(o[i+4],o[i+5],o[i+6]),n.set(o[i+8],o[i+9],o[i+10]),m[i/3+4]=h+=s.area(e,t,n);m.set(o,4*u);for(let e=4*d,t=0,n=r.length;t<n;e+=4,t+=3)m[e+0]=r[t+0],m[e+1]=r[t+1],m[e+2]=r[t+2];this.setUniform("uniform1i","verticesIndex",a?u:-1),this.setUniform("uniform1i","normalsIndex",a?d:-1),l&&(i.bindTexture(i.TEXTURE_2D,this.surfaceTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA32F,l,l,0,i.RGBA,i.FLOAT,m))}else this.setUniform("uniform1i","verticesIndex",-1),this.setUniform("uniform1i","normalsIndex",-1)}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.surfaceTextureUnit),e.bindTexture(e.TEXTURE_2D,this.surfaceTexture)}}),c})),t("x_ite/Components/ParticleSystems/VolumeEmitter",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Components/Geometry3D/IndexedFaceSet","x_ite/Base/X3DConstants","standard/Math/Numbers/Vector3","standard/Math/Geometry/Triangle3","standard/Math/Utility/BVH"],(function(e,t,n,i,o,r,s,a,c){"use strict";function l(e){i.call(this,e),this.addType(r.VolumeEmitter),this.volumeNode=new o(e),this.volumeArray=new Float32Array,this.addSampler("volume"),this.addUniform("direction","uniform vec3 direction;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("normalsIndex","uniform int normalsIndex;"),this.addUniform("hierarchyIndex","uniform int hierarchyIndex;"),this.addUniform("hierarchyRoot","uniform int hierarchyRoot;"),this.addUniform("volume","uniform sampler2D volume;"),this.addFunction("vec3 getRandomVelocity ()\n      {\n         if (hierarchyRoot < 0)\n         {\n            return vec3 (0.0);\n         }\n         else\n         {\n            if (direction == vec3 (0.0))\n               return getRandomSphericalVelocity ();\n\n            else\n               return direction * getRandomSpeed ();\n         }\n      }"),this.addFunction("vec4 getRandomPosition ()\n      {\n         if (hierarchyRoot < 0)\n         {\n            return vec4 (NaN);\n         }\n         else\n         {\n            vec4 point;\n            vec3 normal;\n\n            getRandomPointOnSurface (volume, verticesIndex, normalsIndex, point, normal);\n\n            Line3 line = Line3 (point .xyz, getRandomSurfaceNormal (normal));\n\n            vec4 points [ARRAY_SIZE];\n\n            int numIntersections = getIntersections (volume, verticesIndex, hierarchyIndex, hierarchyRoot, line, points);\n\n            numIntersections -= numIntersections % 2; // We need an even count of intersections.\n\n            switch (numIntersections)\n            {\n               case 0:\n                  return vec4 (0.0);\n               case 2:\n                  break;\n               default:\n                  sort (points, numIntersections, plane3 (line .point, line .direction));\n                  break;\n            }\n\n            int index = int (fract (random ()) * float (numIntersections / 2)) * 2; // Select random intersection.\n\n            return mix (points [index], points [index + 1], random ());\n         }\n      }")}return l.prototype=Object.assign(Object.create(i.prototype),{constructor:l,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(r.inputOutput,"metadata",new e.SFNode),new t(r.inputOutput,"on",new e.SFBool(!0)),new t(r.inputOutput,"internal",new e.SFBool(!0)),new t(r.inputOutput,"direction",new e.SFVec3f(0,1,0)),new t(r.inputOutput,"speed",new e.SFFloat),new t(r.inputOutput,"variation",new e.SFFloat(.25)),new t(r.inputOutput,"mass",new e.SFFloat),new t(r.inputOutput,"surfaceArea",new e.SFFloat),new t(r.inputOutput,"coordIndex",new e.MFInt32(-1)),new t(r.inputOutput,"coord",new e.SFNode)]),getTypeName:function(){return"VolumeEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){i.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.volumeTexture=this.createTexture(),this._direction.addInterest("set_direction__",this),this._coordIndex.addFieldInterest(this.volumeNode._coordIndex),this._coord.addFieldInterest(this.volumeNode._coord),this.volumeNode._creaseAngle=Math.PI,this.volumeNode._convex=!1,this.volumeNode._coordIndex=this._coordIndex,this.volumeNode._coord=this._coord,this.volumeNode._rebuild.addInterest("set_geometry__",this),this.volumeNode.setPrivate(!0),this.volumeNode.setup(),this.set_direction__(),this.set_geometry__())},set_direction__:function(){const e=new s(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}(),set_geometry__:function(){const e=new s(0,0,0),t=new s(0,0,0),n=new s(0,0,0);return function(){const i=this.getBrowser().getContext(),o=this.volumeNode.getVertices().getValue(),r=this.volumeNode.getNormals().getValue(),s=new c(o,r).toArray([]),l=o.length/4,u=r.length/3,d=l/3+1,m=s.length/4,h=Math.ceil(Math.sqrt(d+l+l+m)),p=d,f=p+l,x=f+u;let _=this.volumeArray;_.length<h*h*4&&(_=this.volumeArray=new Float32Array(h*h*4));let y=0;for(let i=0,r=o.length;i<r;i+=12)e.set(o[i],o[i+1],o[i+2]),t.set(o[i+4],o[i+5],o[i+6]),n.set(o[i+8],o[i+9],o[i+10]),_[i/3+4]=y+=a.area(e,t,n);_.set(o,4*p);for(let e=4*f,t=0,n=r.length;t<n;e+=4,t+=3)_[e+0]=r[t+0],_[e+1]=r[t+1],_[e+2]=r[t+2];_.set(s,4*x),this.setUniform("uniform1i","verticesIndex",p),this.setUniform("uniform1i","normalsIndex",f),this.setUniform("uniform1i","hierarchyIndex",x),this.setUniform("uniform1i","hierarchyRoot",x+m-1),h&&(i.bindTexture(i.TEXTURE_2D,this.volumeTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA32F,h,h,0,i.RGBA,i.FLOAT,_))}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.volumeTextureUnit),e.bindTexture(e.TEXTURE_2D,this.volumeTexture)}}),l})),t("x_ite/Components/ParticleSystems/WindPhysicsModel",["x_ite/Fields","x_ite/Base/X3DFieldDefinition","x_ite/Base/FieldDefinitionArray","x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode","x_ite/Base/X3DConstants","standard/Math/Numbers/Vector3","standard/Math/Algorithm"],(function(e,t,n,i,o,r,s){"use strict";function a(e){i.call(this,e),this.addType(o.WindPhysicsModel),this._speed.setUnit("speed")}return a.prototype=Object.assign(Object.create(i.prototype),{constructor:a,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new n([new t(o.inputOutput,"metadata",new e.SFNode),new t(o.inputOutput,"enabled",new e.SFBool(!0)),new t(o.inputOutput,"direction",new e.SFVec3f),new t(o.inputOutput,"speed",new e.SFFloat(.1)),new t(o.inputOutput,"gustiness",new e.SFFloat(.1)),new t(o.inputOutput,"turbulence",new e.SFFloat)]),getTypeName:function(){return"WindPhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},getRandomSpeed:function(e){const t=Math.max(0,this._speed.getValue()),n=t*Math.max(0,this._gustiness.getValue());return e.getRandomValue(Math.max(0,t-n),t+n)},addForce:function(){const e=new r(0,0,0);return function(t,n,i,o){if(this._enabled.getValue()){const a=n._surfaceArea.getValue(),c=this.getRandomSpeed(n),l=.64615*Math.pow(10,2*Math.log(c));return this._direction.getValue().equals(r.Zero)?n.getRandomNormal(e):e.assign(this._direction.getValue()).normalize(),o.set(e.multiply(a*l*i),4*t),o[4*t+3]=Math.PI*s.clamp(this._turbulence.getValue(),0,1),!0}return!1}}()}),a})),t(n.getComponentUrl("particle-systems"),["x_ite/Components","x_ite/Browser/ParticleSystems/X3DParticleSystemsContext","x_ite/Components/ParticleSystems/BoundedPhysicsModel","x_ite/Components/ParticleSystems/ConeEmitter","x_ite/Components/ParticleSystems/ExplosionEmitter","x_ite/Components/ParticleSystems/ForcePhysicsModel","x_ite/Components/ParticleSystems/ParticleSystem","x_ite/Components/ParticleSystems/PointEmitter","x_ite/Components/ParticleSystems/PolylineEmitter","x_ite/Components/ParticleSystems/SurfaceEmitter","x_ite/Components/ParticleSystems/VolumeEmitter","x_ite/Components/ParticleSystems/WindPhysicsModel","x_ite/Components/ParticleSystems/X3DParticleEmitterNode","x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode"],(function(e,t,n,i,o,r,s,a,c,l,u,d,m,h){"use strict";e.addComponent({name:"ParticleSystems",types:{BoundedPhysicsModel:n,ConeEmitter:i,ExplosionEmitter:o,ForcePhysicsModel:r,ParticleSystem:s,PointEmitter:a,PolylineEmitter:c,SurfaceEmitter:l,VolumeEmitter:u,WindPhysicsModel:d},abstractTypes:{X3DParticleEmitterNode:m,X3DParticlePhysicsModelNode:h},context:t})}))}();
