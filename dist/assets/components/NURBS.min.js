<<<<<<< HEAD
/* X_ITE v8.7.9 */(()=>{"use strict";var t={n:e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return t.d(n,{a:n}),n},d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const e=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components");var n=t.n(e);const i=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Fields");var o=t.n(i);const s=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Base/X3DFieldDefinition");var r=t.n(s);const u=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Base/FieldDefinitionArray");var l=t.n(u);const a=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Core/X3DNode");var h=t.n(a);const c=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Base/X3DConstants");var d=t.n(c);const g=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Base/X3DCast");var f=t.n(g);const p=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Namespace");var _=t.n(p);function m(t){h().call(this,t),this.addType(d().Contour2D),this.childNodes=[]}function w(t,e,n,i,o,s){const r=new Set;for(let t=o;t<s;++t)r.add(i[t]);return t.remove(e,n,(t=>r.has(t)))}m.prototype=Object.assign(Object.create(h().prototype),{constructor:m,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"addChildren",new(o().MFNode)),new(r())(d().inputOnly,"removeChildren",new(o().MFNode)),new(r())(d().inputOutput,"children",new(o().MFNode))]),getTypeName:function(){return"Contour2D"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"trimmingContour"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){h().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__:function(){this._addChildren.setTainted(!0),this._addChildren.erase(w(this._addChildren,0,this._addChildren.length,this._children,0,this._children.length),this._addChildren.length);for(const t of this._addChildren)this._children.push(t);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__:function(){this._removeChildren.setTainted(!0),this._children.erase(w(this._children,0,this._children.length,this._removeChildren,0,this._removeChildren.length),this._children.length),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__:function(){const t=this.childNodes;t.length=0;for(const e of this._children){const n=f()(d().NurbsCurve2D,e);if(n)t.push(n);else{const n=f()(d().ContourPolyline2D,e);if(n){t.push(n);continue}}}},addTrimmingContour:function(t){for(const e of this.childNodes)t.push(e.tessellate(2))}});const y=m;_().set("x_ite/Components/NURBS/Contour2D",y);const v=y;function b(t){h().call(this,t),this.addType(d().X3DNurbsControlCurveNode)}b.prototype=Object.assign(Object.create(h().prototype),{constructor:b});const C=b;_().set("x_ite/Components/NURBS/X3DNurbsControlCurveNode",C);const N=C,S=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Numbers/Vector3");var O=t.n(S);function D(t){N.call(this,t),this.addType(d().ContourPolyline2D),this.controlPoints=[]}D.prototype=Object.assign(Object.create(N.prototype),{constructor:D,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2d))]),getTypeName:function(){return"ContourPolyline2D"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},tessellate:function(t){switch(t){case 0:{const t=this._controlPoint.getValue(),e=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i;e[n+0]=t[n+0],e[n+1]=t[n+1]}return e.length=2*n,e}case 1:{const t=this._controlPoint.getValue(),e=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i,o=3*i;e[o+0]=t[n+0],e[o+1]=0,e[o+2]=t[n+1]}return e.length=3*n,e}case 3:{const t=this._controlPoint.getValue(),e=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i;e[i]=new(O())(t[n+0],t[n+1],0)}return e.length=n,e}}}});const P=D;_().set("x_ite/Components/NURBS/ContourPolyline2D",P);const T=P,F=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Rendering/X3DCoordinateNode");var I=t.n(F);function R(t){I().call(this,t),this.addType(d().CoordinateDouble)}R.prototype=Object.assign(Object.create(I().prototype),{constructor:R,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"point",new(o().MFVec3d))]),getTypeName:function(){return"CoordinateDouble"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"coord"},getSpecificationRange:function(){return["3.0","Infinity"]}});const V=R;_().set("x_ite/Components/NURBS/CoordinateDouble",V);const x=V,z=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Rendering/X3DGeometryNode");var j=t.n(z);const k=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Numbers/Vector2");var A=t.n(k);const X=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Numbers/Vector4");var B=t.n(X);const E={getTessellation:function(t,e){return t>0?t+1:t<0?-t*e+1:2*e+1},getClosed2D:function(t,e,n,i){const o=i.length;return(!(n.length===o)||n[0]===n[o-1])&&(!!i[0].equals(i[o-1])&&!!this.isPeriodic(t,o,e))},getClosed:function(){const t=new(O())(0,0,0),e=new(O())(0,0,0);return function(n,i,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&(!!s.get1Point(0,t).equals(s.get1Point(r-1,e))&&!!this.isPeriodic(n,r,i))}}(),getUClosed:function(){const t=new(O())(0,0,0),e=new(O())(0,0,0);return function(n,i,o,s,r,u){const l=r.length===u.getSize();for(let n=0,s=o;n<s;++n){const o=n*i,s=n*i+i-1;if(l&&r[o]!==r[s])return!1;if(!u.get1Point(o,t).equals(u.get1Point(s,e)))return!1}return!!this.isPeriodic(n,i,s)}}(),getVClosed:function(){const t=new(O())(0,0,0),e=new(O())(0,0,0);return function(n,i,o,s,r,u){const l=r.length===u.getSize();for(let n=0,s=i;n<s;++n){const s=n,a=(o-1)*i+n;if(l&&r[s]!==r[a])return!1;if(!u.get1Point(s,t).equals(u.get1Point(a,e)))return!1}return!!this.isPeriodic(n,o,s)}}(),isPeriodic:function(t,e,n){if(n.length===e+t){{let e=1;for(let i=1,o=t;i<o;++i)e+=n[i]===n[0];if(e===t)return!1}{let e=1;for(let i=n.length-t,o=n.length-1;i<o;++i)e+=n[i]===n[o];if(e===t)return!1}}return!0},getKnots:function(t,e,n,i,o){const s=t||[];for(let t=0,e=o.length;t<e;++t)s[t]=o[t];s.length=o.length;let r=!0;if(s.length===i+n){r=!1;let t=0;for(let e=1,i=s.length;e<i;++e)s[e]==s[e-1]?++t:t=0,t>n-1&&(r=!0),s[e-1]>s[e]&&(r=!0)}if(r)for(let t=0,e=i+n;t<e;++t)s[t]=t/(e-1);if(e)for(let t=1,e=n-1;t<e;++t)s.push(s.at(-1)+(s[t]-s[t-1]));return s},getWeights:function(t,e,n){if(n.length!==e)return;const i=t||[];for(let t=0;t<e;++t)i[t]=n[t];return i.length=e,i},getUVWeights:function(t,e,n,i){const o=e*n;if(i.length!==o)return;const s=t||[];for(let t=0,o=0;t<e;++t)for(let t=0;t<n;++t,++o)s[o]=i[o];return s.length=o,s},getControlPoints2D:function(t,e,n,i,o){const s=t||[],r=o.getValue(),u=o.length,l=!!i,a=l?O():A();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let t=0;t<u;++t){const e=2*t,n=s[t]||new a(0,0,0);s[t]=n.set(r[e+0],r[e+1],l?i[t]:0)}if(s.length=u,e)for(let t=1,e=n-1;t<e;++t)s.push(s[t]);return s},getControlPoints:function(t,e,n,i,o){const s=t||[],r=o.getSize(),u=!!i,l=u?B():O();s.haveWeights!==u&&(s.haveWeights=u,s.length=0);for(let t=0;t<r;++t){const e=s[t]=o.get1Point(t,s[t]||new l(0,0,0,0));u&&(e.w=i[t])}if(s.length=r,e)for(let t=1,e=n-1;t<e;++t)s.push(s[t]);return s},getUVControlPoints:function(t,e,n,i,o,s,r,u,l){const a=t||[],h=!!u,c=h?B():O();a.haveWeights!==h&&(a.haveWeights=h,a.length=0);for(let t=0;t<s;++t){let e=a[t];e||(e=a[t]=[]);for(let n=0;n<r;++n){const i=n*s+t;e[n]=l.get1Point(i,e[n]||new c(0,0,0,0)),h&&(e[n].w=u[i])}if(e.length=r,n)for(let t=1,n=o-1;t<n;++t)e.push(e[t])}if(a.length=s,e)for(let t=1,e=i-1;t<e;++t)a.push(a[t]);return a},getTexControlPoints:function(t,e,n,i,o,s,r,u){const l=t||[];for(let t=0;t<s;++t){let e=l[t];e||(e=l[t]=[]);for(let n=0;n<r;++n){const i=n*s+t;e[n]=u.get1Point(i,e[n]||new(B())(0,0,0,0))}if(e.length=r,n)for(let t=1,n=o-1;t<n;++t)e.push(e[t])}if(l.length=s,e)for(let t=1,e=i-1;t<e;++t)l.push(l[t]);return l}};_().set("x_ite/Browser/NURBS/NURBS",E);const q=E;function K(t){j().call(this,t),this.addType(d().X3DParametricGeometryNode)}K.prototype=Object.assign(Object.create(j().prototype),{constructor:K,getKnots:function(t,e,n,i,o){return q.getKnots(t,e,n,i,o)}});const M=K;_().set("x_ite/Components/NURBS/X3DParametricGeometryNode",M);const U=M,G=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Rendering/X3DLineGeometryNode");var W=t.n(G);const Y=function(t){return!!t&&(!!t.dtype&&new RegExp("function View[0-9]+d(:?"+t.dtype+")+").test(String(t.constructor)))};_().set("lib/nurbs/src/utils/is-ndarray",Y);const J=Y,L=function(t){return!!t&&(void 0!==t.data&&Array.isArray(t.shape)&&void 0!==t.offset&&void 0!==t.stride)};_().set("lib/nurbs/src/utils/is-ndarray-like",L);const Z=L,H=function(t){return Array.isArray(t)||ArrayBuffer.isView(t)||void 0!==t.length};_().set("lib/nurbs/src/utils/is-array-like",H);const Q=H;function $(t){if(t){if(J(t)||Z(t))return"generic"===t.dtype?$.GENERIC_NDARRAY:$.NDARRAY;if(Q(t)){for(var e=t;Q(e[0]);e=e[0]);return"x"in e?$.ARRAY_OF_OBJECTS:$.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof t)}}$.ARRAY_OF_OBJECTS="Obj",$.ARRAY_OF_ARRAYS="Arr",$.NDARRAY="Nd",$.GENERIC_NDARRAY="GenNd",$.PACKED="PackArr";const tt=$;_().set("lib/nurbs/src/utils/infer-type",tt);const et=tt;const nt=function(t,e,n,i,o,s){var r,u,l=[],a=!1;for(r=0;r<t.splineDimension;r++){var h=Q(t.knots)&&Q(t.knots[r]);h&&(a=!0),l.push("Deg"+t.degree[r]+(h?"":"Uniform")+((u=t.boundary[r])[0].toUpperCase()+u.slice(1)))}var c=[[a?"NU":"",t.weights?"RBS":"BS"].join("")+t.dimension+"D",l.join("_")];return i&&c.push(i+"Pts"),o&&c.push(o+"Wts"),s&&c.push(s+"Kts"),e&&c.push("debug"),n&&c.push("chk"),c.join("_")};_().set("lib/nurbs/src/utils/cache-key",nt);const it=nt;var ot=function t(e,n){return function(n,i){void 0===n||Array.isArray(n)||(n=[n]);for(var o=[],s=0;s<n.length;s++)o.push(t.sum(n[s]));if(i)for(n=0;n<o.length;n++)void 0!==i[n]&&(o[n]="("+o[n]+" + "+i[n]+") % "+i[n]);return e+o.join("_")}};ot.sum=function(t){return 0===(t=(t=Array.isArray(t)?t:[t]).filter((function(t){return void 0!==t&&0!==t}))).length&&t.push(0),t.join(" + ")};const st=ot;_().set("lib/nurbs/src/utils/variable",st);const rt=st;var ut=[".x",".y",".z",".w"];function lt(t){return function(e,n){void 0===e||Array.isArray(e)||(e=[e]);for(var i=[],o=0;o<e.length;o++)i.push(rt.sum(e[o]));if(n)for(e=0;e<i.length;e++)void 0!==n[e]&&(i[e]="("+i[e]+" + "+n[e]+") % "+n[e]);return t(i)}}function at(t,e){if(e)switch(et(e)){case et.ARRAY_OF_OBJECTS:return lt((function(e){var n=e.pop();return t+"["+e.join("][")+"]"+ut[n]}));case et.ARRAY_OF_ARRAYS:return lt((function(e){return t+"["+e.join("][")+"]"}));case et.GENERIC_NDARRAY:return lt((function(e){return t+".get("+e.join(",")+")"}));case et.NDARRAY:return lt((function(e){for(var n=[t+"Offset"],i=0;i<e.length;i++)n.push(t+"Stride"+i+" * ("+e[i]+")");return t+"["+n.join(" + ")+"]"}));case et.PACKED:default:return}}const ht=function(t){var e,n={};return(e=at("x",t.points))&&(n.point=e),(e=at("w",t.weights))&&(n.weight=e),(e=at("k",t.knots))&&(n.knot=e),n};_().set("lib/nurbs/src/utils/create-accessors",ht);const ct=ht;var dt=[],gt=[];const ft=function(t,e,n){if(1!==e)throw new Error("Numerical derivative not implemented for order n = "+e+".");var i,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(dt.length=this.splineDimension,i=0;i<this.splineDimension;i++)dt[i+1]=arguments[i+3];var s,r,u,l=this.domain,a=l[n][0],h=l[n][1],c=dt[n+1],d=(h-a)*o;for("closed"===this.boundary[n]?(s=a+(c-a-d+(u=h-a))%u,r=a+(c-a+d+u)%u,d*=2):(s=Math.min(h,Math.max(a,c-d)),d=(r=Math.min(h,Math.max(a,c+d)))-s),dt[n+1]=s,dt[0]=gt,this.evaluate.apply(null,dt),dt[n+1]=r,dt[0]=t,this.evaluate.apply(null,dt),i=0;i<this.dimension;i++)t[i]=(t[i]-gt[i])/d;return t};_().set("lib/nurbs/src/numerical-derivative",ft);const pt=ft,_t=function(t,e){for(var n=1,i=0,o=[];i<t.length;i++)n*=Array.isArray(t[i])?t[i][1]-t[i][0]:t[i],o[i]=Array.isArray(t[i])?t[i][0]:0;for(var s=0;s<n;s++)for(e(o.slice()),i=t.length-1;i>=0;i--){if(o[i]!==(Array.isArray(t[i])?t[i][1]:t[i])-1){o[i]++;break}o[i]=Array.isArray(t[i])?t[i][0]:0}};_().set("lib/nurbs/src/utils/ndloop",_t);const mt=_t,wt=function(t,e,n,i){var o=[];switch(et(i)){case et.NDARRAY:o.push("  var "+e+" = "+n+".data;"),o.push("  var "+e+"Offset = "+n+".offset;");for(var s=0;s<i.dimension;s++)o.push("  var "+e+"Stride"+s+" = "+n+".stride["+s+"];");break;case et.ARRAY_OF_OBJECTS:case et.ARRAY_OF_ARRAYS:o.push("  var "+e+" = "+n+";")}return o.join("\n")};_().set("lib/nurbs/src/utils/accessor-preamble",wt);const yt=wt,vt=function(t,e,n){if(t){if(Z(t))return e+".shape["+n+"]";for(var i=e,o=0;o<n;o++)i+="[0]";return i+".length"}return"this.size["+n+"]"};_().set("lib/nurbs/src/utils/size-getter",vt);const bt=vt;var Ct={},Nt={};const St=function(t,e,n,i,o,s,r){var u,l,a,h,c,d,g=e.splineDimension,f=e.points,p=e.degree,_=e.weights,m=void 0!==_,w=e.knots,y=e.dimension,v=e.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var b=0;for(u=0;u<g;u++)void 0===r[u]&&(r[u]=0),b+=r[u];if(m&&b>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+b+".")}s&&(t="Basis"+t),r&&(t="Der"+r.join("_")+"_"+t);var C=Ct[t];if(i)var N="function"==typeof i?i:console.log;if(C)return i&&N(Nt[t]),C.bind(e);var S=[],O="evaluate"+t,D=n.point;s&&(D=function(t,e){for(var n=[],i=0;i<t.length;i++){for(var o=t[i],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),e[i]&&(o="("+o+" + "+e[i]+") % "+e[i]),n.push(o+" === "+V(i))}return"(("+n.join(" && ")+") ? 1 : 0)"});var P=n.weight,T=n.knot,F=rt("k"),I=rt("x"),R=rt("w"),V=rt("i"),x=rt("t"),z=i?"domain":"d",j=rt(i?"size":"s"),k=rt(i?"knotIndex":"j"),A=!0;for(c=0;c<g;c++)Q(w)&&Q(w[c])&&(A=!1);function X(t){S.push("  "+(t||""))}function B(t){i&&X(t)}if(s)var E=[];var q=[];for(u=0;u<g;u++)s&&E.push(V([u])),q.push(x([u]));for(S.push("function "+O+" ("+(s?"":"out, ")+q.join(", ")+(s?", "+E.join(", "):"")+") {"),X("var h, m, a, b;"),o&&(X("var "+z+" = this.domain;"),X("for (var i = 0; i < this.splineDimension; i++) {"),X("  a = arguments[i + 1];"),X("  if (a < "+z+"[i][0] || a > "+z+"[i][1] || a === undefined || isNaN(a)) {"),X('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+z+'[i][0]+", "+'+z+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),X("  }"),X("}")),c=0;c<g;c++)X("var "+j(c)+" = "+bt(f,"this.points",c)+";");function K(t,e,n){return"("+t+") ? ("+e+") : ("+n+")"}S.push(yt(e,"x","this.points",f)),m&&S.push(yt(e,"w","this.weights",_)),A||S.push(yt(e,"k","this.knots",w));var M=[];for(c=0;c<g;c++)switch(et(w)){case et.NDARRAY:M[c]=!0;break;case et.ARRAY_OF_ARRAYS:M[c]=Q(w[c])}for(c=0;c<g;c++)if(M[c])for(B("\n  // Bisect to locate the knot interval in dimension "+c+"\n"),X("var "+k(c)+" = 0;"),X("h = "+j(c)+";"),X("while(h > "+k(c)+" + 1) {"),X("  m = 0.5 * (h + "+k(c)+") | 0;"),X("  if ("+T([c,"m"])+" > "+x(c)+") h = m;"),X("  else "+k(c)+" = m;"),X("}"),B("\n  // Fetch knots for dimension "+c+"\n"),u=1-p[c];u<=p[c];u++)"closed"===v[c]?X(u<0?"var "+F([c,u+p[c]-1])+" = "+K(k(c)+" < "+-u,T([c,0])+" + "+T([c,[j(c),k(c),u]])+" - "+T([c,[j(c)]]),T([c,[k(c),u]]))+";":u>0?"var "+F([c,u+p[c]-1])+" = "+K(k(c)+" + "+u+" > "+j(c),T([c,j(c)])+" + "+T([c,u+" + "+k(c)+" - "+j(c)])+" - "+T([c,0]),T([c,[k(c),u]]))+";":"var "+F([c,u+p[c]-1])+" = "+T([c,[k(c),u]])+";"):X("var "+F([c,u+p[c]-1])+" = "+T([c,[k(c),u]])+";");else{for(B("\n  // Directly compute knot interval for dimension "+c+"\n"),"closed"===v[c]?X(k(c)+" = ("+x(c)+" | 0) % "+j(c)+";"):(X(k(c)+" = ("+x(c)+" | 0);"),X("if ("+k(c)+" < "+p[c]+") "+k(c)+" = "+p[c]+";"),X("if ("+k(c)+" > "+j(c)+" - 1) "+k(c)+" = "+j(c)+" - 1;")),B("\n  // Compute and clamp knots for dimension "+c+"\n"),u=1-p[c];u<=p[c];u++)X("var "+(d=F([c,u+p[c]-1]))+" = "+k(c)+" + "+u+";");if("clamped"===v[c])for(u=1-p[c];u<=p[c];u++)d=F([c,u+p[c]-1]),u<0&&X("if ("+d+" < "+p[c]+") "+d+" = "+p[c]+";"),u>0&&X("if ("+d+" > "+j(c)+") "+d+" = "+j(c)+";");"closed"===v[c]&&(B("\n  // Wrap the B-Spline parameter for closed boundary"),X(x(c)+" %= "+j(c)+";"))}for(c=0,a=[];c<g;c++)a[c]=p[c]+1;for(m&&(B("\n  // Fetch weights\n"),mt(a,(function(t){for(var e=[],n=[],i=0;i<g;i++)e[i]=[k(i),t[i]-p[i]],"closed"===v[i]&&t[i]-p[i]<0&&(n[i]=j(i));X("var "+R(t)+" = "+P(e,n)+";")}))),i&&X(m?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),mt(a,(function(t){for(var e=[],n=[],i=0;i<g;i++)e[i]=[k(i),t[i]-p[i]],"closed"===v[i]&&t[i]-p[i]<0&&(n[i]=j(i));if(s)X(m?"var "+I(t)+" = "+D(e,n)+" * "+R(t)+";":"var "+I(t)+" = "+D(e,n)+";");else for(i=0;i<y;i++){var o=t.concat(i);e[g]=i,X(m?"var "+I(o)+" = "+D(e,n)+" * "+R(t)+";":"var "+I(o)+" = "+D(e,n)+";")}})),B("\n"),B('// Perform De Boor"s algorithm'),c=a.length-1;c>=0;c--)for(a[c]=[p[c],p[c]+1],u=0;u<p[c];u++)for(B("\n  // Degree "+p[c]+" evaluation in dimension "+c+", step "+(u+1)+"\n"),l=p[c];l>u;l--){var U=r&&p[c]-u-r[c]<=0;U?(X("m = 1 / ("+F([c,l-u+p[c]-1])+" - "+F([c,l-1])+");"),m&&(X("a = ("+x(c)+" - "+F([c,l-1])+") * m;"),X("b = 1 - a;"))):(X("a = ("+x(c)+" - "+F([c,l-1])+") / ("+F([c,l-u+p[c]-1])+" - "+F([c,l-1])+");"),X("b = 1 - a;")),m&&mt(a,(function(t){var e=t.slice(),n=t.slice();e[c]=l,n[c]=l-1,U&&m&&X("h = "+R(e)+";"),X(R(e)+" = b * "+R(n)+" + a * "+R(e)+";")})),mt(a,(function(t){var e,n,i,o=t.slice(),r=t.slice();if(o[c]=l,r[c]=l-1,U){var a=u+1;if(s)e=m?"h * "+R(r)+" / "+R(o)+" * ":"",n=I(o)+(m?" / h":""),i=I(r)+(m?" / "+R(r):""),X(I(o)+" = "+a+" * "+e+"("+n+" - "+i+") * m;");else{var d=o.slice(),f=r.slice();for(h=0;h<y;h++)d[g]=f[g]=h,e=m?"h * "+R(r)+" / "+R(o)+" * ":"",n=I(d)+(m?" / h":""),i=I(f)+(m?" / "+R(r):""),X(I(d)+" = "+a+" * "+e+"("+n+" - "+i+") * m;")}}else if(s)X(I(o)+" = b * "+I(r)+" + a * "+I(o)+";");else for(h=0;h<y;h++)o[g]=r[g]=h,X(I(o)+" = b * "+I(r)+" + a * "+I(o)+";")})),B("\n")}if(i&&X(m?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)X(m?"return "+I(p)+" / "+R(p)+";":"return "+I(p)+";");else for(c=0;c<y;c++)X(m?"out["+c+"] = "+I(p.concat([c]))+" / "+R(p)+";":"out["+c+"] = "+I(p.concat([c]))+";");if(s||X("return out;"),S.push("}"),i){var G=S.join("\n");N(G),Nt[t]=G}var W=new Function([S.join("\n"),"; return ",O].join(""))();return Ct[t]=W,W.bind(e)};_().set("lib/nurbs/src/evaluate",St);const Ot=St;var Dt={};const Pt=function(t,e,n,i){var o,s,r,u,l,a,h,c,d=Dt[t];if(d)return d.bind(e);var g=[],f="transform"+t;g.push("function "+f+"(m) {"),g.push("var i, w;"),g.push(yt(e,"x","this.points",e.points));var p=rt(i?"size":"s");for(o=0;o<e.splineDimension;o++)g.push("var "+p(o)+" = "+bt(e.points,"this.points",o)+";");for(u=[],o=0;o<e.splineDimension;o++)r="i"+o,u.push(r),g.push("for ("+r+" = "+p(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<e.dimension;o++)g.push("x"+o+" = "+n.point(u.concat([o])));for(l=[],o=0;o<e.dimension;o++)l.push("m["+((e.dimension+1)*(o+1)-1)+"] * x"+o);for(l.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),g.push("var w = ("+l.join(" + ")+") || 1.0;"),o=0;o<e.dimension;o++){for(l=[],a=e.dimension,s=0;s<a;s++)l.push("m["+(s*(a+1)+o)+"] * x"+s);l.push("m["+(s*(a+1)+o)+"]"),c=n.point(u.concat([o])),h="("+l.join(" + ")+") / w",g.push(c+" = "+h+";")}for(o=e.splineDimension-1;o>=0;o--)g.push("}");g.push("return this;"),g.push("}");var _=new Function([g.join("\n"),"; return ",f].join(""))();return i&&console.log(g.join("\n")),Dt[t]=_,_.bind(e)};_().set("lib/nurbs/src/transform",Pt);const Tt=Pt;var Ft={};const It=function(t,e,n,i,o){var s=Ft[t];if(s)return s.bind(e);var r,u,l,a=e.degree,h=e.knots,c=e.splineDimension,d=e.boundary,g=[],f="support"+t,p=n.knot,_=rt("t"),m=i?"domain":"d",w=rt(i?"size":"s"),y=rt(i?"knotIndex":"i"),v=!0;for(l=0;l<c;l++)Q(h)&&Q(h[l])&&(v=!1);function b(t){g.push("  "+(t||""))}var C=[];for(r=0;r<c;r++)C.push(_([r]));g.push("function "+f+" (out, "+C.join(", ")+") {");var N=0;function S(t,e){b(void 0===e?"out["+N+++"] = "+t.join(" + ")+";":"out["+N+++"] = ("+t.join(" + ")+" + "+e+") % "+e+";")}for(b("var h, m;"),b("var c = 0;"),o&&(b("var "+m+" = this.domain;"),b("for (var i = 0; i < this.splineDimension; i++) {"),b("  a = arguments[i + 1];"),b("  if (a < "+m+"[i][0] || a > "+m+"[i][1] || a === undefined || isNaN(a)) {"),b('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+m+'[i][0]+", "+'+m+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),b("  }"),b("}")),l=0;l<c;l++)b("var "+w(l)+" = "+bt(e.points,"this.points",l)+";");v||g.push(yt(e,"k","this.knots",h));var O=[];for(l=0;l<c;l++)switch(et(h)){case et.NDARRAY:O[l]=!0;break;case et.ARRAY_OF_ARRAYS:O[l]=Q(h[l])}for(l=0;l<c;l++)O[l]?(b("var "+y(l)+" = 0;"),b("h = "+w(l)+";"),b("while(h > "+y(l)+" + 1) {"),b("  m = 0.5 * (h + "+y(l)+") | 0;"),b("  if ("+p([l,"m"])+" > "+_(l)+") h = m;"),b("  else "+y(l)+" = m;"),b("}")):"closed"===d[l]?b(y(l)+" = ("+_(l)+" | 0) % "+w(l)+";"):(b(y(l)+" = ("+_(l)+" | 0);"),b("if ("+y(l)+" < "+a[l]+") "+y(l)+" = "+a[l]+";"),b("if ("+y(l)+" > "+w(l)+" - 1) "+y(l)+" = "+w(l)+" - 1;"));for(l=0,u=[];l<c;l++)u[l]=a[l]+1;mt(u,(function(t){for(var e=[],n=[],i=0;i<c;i++)e[i]=[y(i),t[i]-a[i]],"closed"===d[i]&&t[i]-a[i]<0&&(n[i]=w(i));for(i=0;i<c;i++)S(e[i],n[i])})),b("out.length = "+N+";"),b("return out;"),g.push("}"),i&&console.log(g.join("\n"));var D=new Function([g.join("\n"),"; return ",f].join(""))();return Ft[t]=D,D.bind(e)};_().set("lib/nurbs/src/support",It);const Rt=It,Vt=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Geometry/Triangle3");var xt=t.n(Vt),zt=[];const jt=function(t,e,n){n=n||{};var i=(t=t||{}).points=t.points||[],o=t.faces=t.faces||[],s=n.haveWeights,r=e.dimension-s;if(Array.isArray(n.resolution))var u=n.resolution;else{var l=void 0===n.resolution?31:n.resolution;u=new Array(e.splineDimension).fill(l)}switch(e.splineDimension){case 1:for(var a=(_=(w=u[0])+!(v="closed"===e.boundary[0]))*r,h=(C=(m=n.domain||e.domain)[0])[1]-C[0],c=0;c<_;++c){var d=C[0]+h*c/w,g=c*r;if(e.evaluate(zt,d),s)for(var f=zt[r],p=0;p<r;++p)i[g+p]=zt[p]/f;else for(p=0;p<r;++p)i[g+p]=zt[p]}i.length=a;break;case 2:var _,m,w=u[0],y=u[1],v="closed"===e.boundary[0],b=y+!(P="closed"===e.boundary[1]),C=(a=(_=w+!v)*b*r,(m=n.domain||e.domain)[0]),N=m[1],S=(h=C[1]-C[0],N[1]-N[0]);for(c=0;c<_;++c){d=C[0]+h*c/w;for(var O=0;O<b;++O){var D=N[0]+S*O/y;g=(c+_*O)*r;if(e.evaluate(zt,d,D),s)for(f=zt[r],p=0;p<r;++p)i[g+p]=zt[p]/f;else for(p=0;p<r;++p)i[g+p]=zt[p]}}i.length=a;v=n.closed[0];var P=n.closed[1],T=0;for(c=0;c<w;++c){var F=c,I=c+1;v&&(I%=w);for(O=0;O<y;++O){var R=O,V=O+1;P&&(V%=y),o[T++]=F+_*R,o[T++]=I+_*R,o[T++]=I+_*V,o[T++]=F+_*R,o[T++]=I+_*V,o[T++]=F+_*V}}o.length=T;break;default:throw new Error("Can only sample contours and surfaces")}return t};_().set("lib/nurbs/extras/sample",jt);const kt=jt;var At={open:"open",closed:"closed",clamped:"clamped"};function Xt(t){return null==t}function Bt(t,e,n,i,o,s){var r,u;!t||Q(t)||J(t)?(s=s||{},this.weights=i,this.knots=n,this.degree=e,this.points=t,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=t,this.debug=t.debug,this.checkBounds=!!t.checkBounds,this.weights=t.weights,this.knots=t.knots,this.degree=t.degree,this.boundary=t.boundary,this.points=t.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var l=et(this.points),a=et(this.weights),h=et(this.knots);if(this.points)switch(l){case et.GENERIC_NDARRAY:case et.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case et.ARRAY_OF_OBJECTS:case et.ARRAY_OF_ARRAYS:var c=0,d=this.size||[];d.length=0;for(var g=this.points;Q(g[0]);g=g[0])c++,d.push(g.length);if(0===c)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:c,writable:!1,configurable:!0},dimension:{value:g.length,writable:!1,configurable:!0},size:{get:function(){var t=[];t.length=0;for(var e=0,n=this.points;e<this.splineDimension;e++,n=n[0])t[e]=n.length;return t},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case et.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(Q(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(Q(this.degree)){for(r=0;r<this.splineDimension;r++)if(Xt(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var f=!Xt(this.degree),p=Xt(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=p){if(f)throw new Error("Expected at least "+(p+1)+" points for degree "+p+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=p}if(u="string"!=typeof this.boundary?"open":this.boundary,!At[u])throw new Error("Boundary type must be one of "+Object.keys(At)+". Got "+u);for(this.boundary=Q(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=Xt(this.boundary[r])?u:this.boundary[r],!At[u])throw new Error("Boundary type must be one of "+Object.keys(At)+". Got "+u+" for dimension "+(r+1));switch(h){case et.ARRAY_OF_ARRAYS:for(Q(this.knots)&&this.knots.length>0&&!Q(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(Q(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case et.NDARRAY:}var _=it(this,this.debug,this.checkBounds,l,a,h);if(_!==this.__cacheKey){this.__cacheKey=_;var m=ct(this);this.evaluate=Ot(this.__cacheKey,this,m,this.debug,this.checkBounds,!1),this.transform=Tt(this.__cacheKey,this,m,this.debug),this.support=Rt(this.__cacheKey,this,m,this.debug,this.checkBounds),this.evaluator=function(t,e){return Ot(this.__cacheKey,this,m,this.debug,this.checkBounds,e,t)}}return this.numericalDerivative=pt.bind(this),this}function Et(){var t,e=[],n=this.points;n?Z(n)&&(t=n.shape):t=this.size;for(var i=0;i<this.splineDimension;i++){var o=t?t[i]:n.length,s=this.degree[i],r="closed"===this.boundary[i];if(this.knots&&this.knots[i]){var u=this.knots[i];e[i]=[u[r?0:s],u[o]]}else e[i]=[r?0:s,o];n&&(n=n[0])}return e}function qt(t,e,n,i,o,s){var r=function(t,e,n,i,o,s){return u(t,e,n,i,o,s),r},u=Bt.bind(r);return Object.defineProperty(r,"domain",{get:Et}),u(t,e,n,i,o,s),r}qt.sample=kt;const Kt=qt;_().set("lib/nurbs/nurbs",Kt);const Mt=Kt;function Ut(t){U.call(this,t),W().call(this,t),this.addType(d().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Ut.prototype=Object.assign(Object.create(U.prototype),W().prototype,{constructor:Ut,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"closed",new(o().SFBool)),new(r())(d().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode))]),getTypeName:function(){return"NurbsCurve"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"geometry"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){U.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=f()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},getTessellation:function(t){return q.getTessellation(this._tessellation.getValue(),t-this._order.getValue())},getClosed:function(t,e,n,i){return!!this._closed.getValue()&&q.getClosed(t,e,n,i)},getWeights:function(t,e,n){return q.getWeights(t,e,n)},getControlPoints:function(t,e,n,i,o){return q.getControlPoints(t,e,n,i,o)},tessellate:function(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const t=this.getVertices(),e=[];if(t.length){const n=t.length;for(let i=0;i<n;i+=8)e.push(t[i],t[i+1],t[i+2]);e.push(t[n-4],t[n-3],t[n-2])}return e},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),i=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(i.at(-1),i[0],this._order.getValue()-1),s=this.surface=(this.surface||Mt)({boundary:["open"],degree:[o],knots:[i],points:n,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(i.length),this.sampleOptions.haveWeights=!!e;const r=Mt.sample(this.mesh,s,this.sampleOptions).points,u=this.getVertices();for(let t=3,e=r.length;t<e;t+=3){const e=t-3;u.push(r[e],r[e+1],r[e+2],1),u.push(r[t],r[t+1],r[t+2],1)}},dispose:function(){U.prototype.dispose.call(this)}});const Gt=Ut;_().set("x_ite/Components/NURBS/NurbsCurve",Gt);const Wt=Gt;function Yt(t){N.call(this,t),this.addType(d().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Yt.prototype=Object.assign(Object.create(N.prototype),{constructor:Yt,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"closed",new(o().SFBool)),new(r())(d().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2d))]),getTypeName:function(){return"NurbsCurve2D"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},getTessellation:function(t){return q.getTessellation(this._tessellation.getValue(),t-this._order.getValue())},getClosed:function(t,e,n,i){return!!this._closed.getValue()&&q.getClosed2D(t,e,n,i)},getKnots:function(t,e,n,i,o){return q.getKnots(t,e,n,i,o)},getWeights:function(t,e,n){return q.getWeights(t,e,n)},getControlPoints:function(t,e,n,i,o){return q.getControlPoints2D(t,e,n,i,o)},tessellate:function(t){const e=this.array;if(e.length=0,this._order.getValue()<2)return e;if(this._controlPoint.length<this._order.getValue())return e;const n=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),i=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,n,this._order.getValue(),i,this._controlPoint),s=this.getKnots(this.knots,n,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1),u=this.surface=(this.surface||Mt)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(s.length),this.sampleOptions.haveWeights=!!i;const l=Mt.sample(this.mesh,u,this.sampleOptions).points;switch(t){case 0:for(let t=0,n=l.length;t<n;t+=2)e.push(l[t],l[t+1]);break;case 1:for(let t=0,n=l.length;t<n;t+=2)e.push(l[t],0,l[t+1]);break;case 2:for(let t=0,n=l.length;t<n;t+=2)e.push(new(O())(l[t],l[t+1],0))}return e}});const Jt=Yt;_().set("x_ite/Components/NURBS/NurbsCurve2D",Jt);const Lt=Jt,Zt=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Core/X3DChildNode");var Ht=t.n(Zt);const Qt=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Interpolation/OrientationInterpolator");var $t=t.n(Qt);const te=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Numbers/Rotation4");var ee=t.n(te);function ne(t){Ht().call(this,t),this.addType(d().NurbsOrientationInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new($t())(t),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}ne.prototype=Object.assign(Object.create(Ht().prototype),{constructor:ne,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(d().inputOutput,"order",new(o().SFInt32)(3)),new(r())(d().inputOutput,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"value_changed",new(o().SFRotation))]),getTypeName:function(){return"NurbsOrientationInterpolator"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){Ht().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=f()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:function(t,e,n,i){return!1},getKnots:function(t,e,n,i,o){return q.getKnots(t,e,n,i,o)},getWeights:function(t,e,n){return q.getWeights(t,e,n)},getControlPoints:function(t,e,n,i,o){return q.getControlPoints(t,e,n,i,o)},requestRebuild:function(){this._rebuild.addEvent()},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),i=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=i.at(-1)-i[0],s=this._order.getValue()-1,r=this.surface=(this.surface||Mt)({boundary:["open"],degree:[s],knots:[i],points:n,debug:!1});this.sampleOptions.haveWeights=!!e;const u=Mt.sample(this.mesh,r,this.sampleOptions).points,l=this.interpolator;l._key.length=0,l._keyValue.length=0;for(let e=0,n=u.length-3;e<n;e+=3){const s=new(O())(u[e+3]-u[e+0],u[e+4]-u[e+1],u[e+5]-u[e+2]);l._key.push(i[0]+e/(n-3+3*t)*o),l._keyValue.push(new(ee())(O().zAxis,s))}t&&(l._key.push(i[0]+o),l._keyValue.push(l._keyValue[0]))}});const ie=ne;_().set("x_ite/Components/NURBS/NurbsOrientationInterpolator",ie);const oe=ie,se=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Algorithm");var re=t.n(se);function ue(t){U.call(this,t),this.addType(d().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}ue.prototype=Object.assign(Object.create(U.prototype),{constructor:ue,initialize:function(){U.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__:function(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=f()(d().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=f()(d().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=f()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},setTessellationScale:function(t){this.tessellationScale=t,this.requestRebuild()},getUTessellation:function(t){return Math.floor(q.getTessellation(this._uTessellation.getValue(),t-this._uOrder.getValue())*this.tessellationScale)},getVTessellation:function(t){return Math.floor(q.getTessellation(this._vTessellation.getValue(),t-this._vOrder.getValue())*this.tessellationScale)},getUClosed:function(t,e,n,i,o,s){return!!this._uClosed.getValue()&&q.getUClosed(t,e,n,i,o,s)},getVClosed:function(t,e,n,i,o,s){return!!this._vClosed.getValue()&&q.getVClosed(t,e,n,i,o,s)},getUVWeights:function(t,e,n,i){return q.getUVWeights(t,e,n,i)},getTexControlPoints:function(t,e,n,i,o,s,r,u){return q.getTexControlPoints(t,e,n,i,o,s,r,u)},getUVControlPoints:function(t,e,n,i,o,s,r,u,l){return q.getUVControlPoints(t,e,n,i,o,s,r,u,l)},getTrimmingContours:function(){},build:function(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()!==this._uDimension.getValue()*this._vDimension.getValue())return;const t=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),e=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),n=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),i=this.getUVControlPoints(this.controlPoints,t,e,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),n,this.controlPointNode),o=this.getKnots(this.uKnots,t,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,e,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),u=this._vOrder.getValue()-1,l=this.surface=(this.surface||Mt)({boundary:["open","open"],degree:[r,u],knots:[o,s],points:i,debug:!1}),a=this.sampleOptions;a.resolution[0]=this.getUTessellation(o.length),a.resolution[1]=this.getVTessellation(s.length),a.closed[0]=t,a.closed[1]=e,a.domain=void 0,a.haveWeights=!!n,a.trimmingContours=this.getTrimmingContours();const h=Mt.sample(this.mesh,l,a),c=h.faces,d=h.points,g=this.getVertices();for(let t=0,e=c.length;t<e;++t){const e=3*c[t];g.push(d[e],d[e+1],d[e+2],1)}this.buildNurbsTexCoords(t,e,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue(),l.domain),this.buildNormals(c,d),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords:function(){const t=[],e=[],n=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];function i(t,e){return t[0]=t[1]=e[0],t[2]=t[3]=e.at(-1),t}return function(o,s,r,u,l,a,h,c,d){const g=this.sampleOptions;if(this.texCoordNode&&this.texCoordNode.getSize()===h*c)var f=r-1,p=u-1,_=l,m=a,w=this.getTexControlPoints(this.texControlPoints,o,s,r,u,h,c,this.texCoordNode);else if(this.nurbsTexCoordNode&&this.nurbsTexCoordNode.isValid()){var y=this.nurbsTexCoordNode,v=(f=y._uOrder.getValue()-1,p=y._vOrder.getValue()-1,_=this.getKnots(this.texUKnots,!1,y._uOrder.getValue(),y._uDimension.getValue(),y._uKnot),m=this.getKnots(this.texVKnots,!1,y._vOrder.getValue(),y._vDimension.getValue(),y._vKnot),this.getUVWeights(this.texWeights,y._uDimension.getValue(),y._vDimension.getValue(),y._weight));w=y.getControlPoints(v)}else{f=1,p=1,_=i(t,l),m=i(e,a),w=n;g.domain=d}const b=this.texSurface=(this.texSurface||Mt)({boundary:["open","open"],degree:[f,p],knots:[_,m],points:w});g.closed[0]=!1,g.closed[1]=!1,g.haveWeights=!1;const C=Mt.sample(this.texMesh,b,g),N=C.faces,S=C.points,O=this.getTexCoords();for(let t=0,e=N.length;t<e;++t){const e=4*N[t];O.push(S[e],S[e+1],S[e+2],S[e+3])}this.getMultiTexCoords().push(this.getTexCoords())}}(),buildNormals:function(t,e){const n=this.createNormals(t,e),i=this.getNormals();for(const t of n)i.push(t.x,t.y,t.z)},createNormals:function(t,e){const n=this.createFaceNormals(t,e),i=[];for(let e=0,n=t.length;e<n;++e){const n=t[e];let o=i[n];o||(o=i[n]=[]),o.push(e)}return this.refineNormals(i,n,re().radians(85))},createFaceNormals:function(){const t=new(O())(0,0,0),e=new(O())(0,0,0),n=new(O())(0,0,0);return function(i,o){const s=this.faceNormals||[],r=i.length;for(let u=0;u<r;u+=3){const r=3*i[u],l=3*i[u+1],a=3*i[u+2];t.set(o[r],o[r+1],o[r+2]),e.set(o[l],o[l+1],o[l+2]),n.set(o[a],o[a+1],o[a+2]);const h=xt().normal(t,e,n,s[u]||new(O())(0,0,0));s[u]=h,s[u+1]=h,s[u+2]=h}return s.length=r,s}}()});const le=ue;_().set("x_ite/Components/NURBS/X3DNurbsSurfaceGeometryNode",le);const ae=le;function he(t){ae.call(this,t),this.addType(d().NurbsPatchSurface)}he.prototype=Object.assign(Object.create(ae.prototype),{constructor:he,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(d().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"uClosed",new(o().SFBool)),new(r())(d().initializeOnly,"vClosed",new(o().SFBool)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"texCoord",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode))]),getTypeName:function(){return"NurbsPatchSurface"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"geometry"},getSpecificationRange:function(){return["3.0","Infinity"]}});const ce=he;_().set("x_ite/Components/NURBS/NurbsPatchSurface",ce);const de=ce,ge=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Interpolation/PositionInterpolator");var fe=t.n(ge);function pe(t){Ht().call(this,t),this.addType(d().NurbsPositionInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new(fe())(t),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}pe.prototype=Object.assign(Object.create(Ht().prototype),{constructor:pe,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(d().inputOutput,"order",new(o().SFInt32)(3)),new(r())(d().inputOutput,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"value_changed",new(o().SFVec3f))]),getTypeName:function(){return"NurbsPositionInterpolator"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){Ht().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=f()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:function(t,e,n,i){return!1},getKnots:function(t,e,n,i,o){return q.getKnots(t,e,n,i,o)},getWeights:function(t,e,n){return q.getWeights(t,e,n)},getControlPoints:function(t,e,n,i,o){return q.getControlPoints(t,e,n,i,o)},requestRebuild:function(){this._rebuild.addEvent()},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),i=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),s=i.at(-1)-i[0],r=this._order.getValue()-1,u=this.surface=(this.surface||Mt)({boundary:["open"],degree:[r],knots:[i],points:n,debug:!1});this.sampleOptions.haveWeights=!!e;const l=Mt.sample(this.mesh,u,this.sampleOptions).points,a=this.interpolator;a._key.length=0,a._keyValue.length=0;for(let t=0,e=l.length;t<e;t+=3)a._key.push(i[0]+t/(e-3)*s),a._keyValue.push(new(o().SFVec3f)(l[t],l[t+1],l[t+2]))}});const _e=pe;_().set("x_ite/Components/NURBS/NurbsPositionInterpolator",_e);const me=_e,we=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Grouping/X3DBoundedObject");var ye=t.n(we);function ve(t){Ht().call(this,t),ye().call(this,t),this.addType(d().NurbsSet),this.geometryNodes=[]}function be(t,e,n,i,o,s){const r=new Set;for(let t=o;t<s;++t)r.add(i[t]);return t.remove(e,n,(t=>r.has(t)))}ve.prototype=Object.assign(Object.create(Ht().prototype),ye().prototype,{constructor:ve,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellationScale",new(o().SFFloat)(1)),new(r())(d().inputOutput,"visible",new(o().SFBool)(!0)),new(r())(d().inputOutput,"bboxDisplay",new(o().SFBool)),new(r())(d().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(r())(d().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(r())(d().inputOnly,"addGeometry",new(o().MFNode)),new(r())(d().inputOnly,"removeGeometry",new(o().MFNode)),new(r())(d().inputOutput,"geometry",new(o().MFNode))]),getTypeName:function(){return"NurbsSet"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){Ht().prototype.initialize.call(this),ye().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox:function(t,e){for(const e of this.geometryNodes)t.add(e.getBBox());return t},set_tessellationScale__:function(){const t=Math.max(0,this._tessellationScale.getValue());for(const e of this.geometryNodes)e.setTessellationScale(t)},set_addGeometry__:function(){this._addGeometry.setTainted(!0),this._addGeometry.erase(be(this._addGeometry,0,this._addGeometry.length,this._geometry,0,this._geometry.length),this._addGeometry.length);for(const t of this._addGeometry)this._geometry.push(t);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__:function(){this._removeGeometry.setTainted(!0),this._geometry.erase(be(this._geometry,0,this._geometry.length,this._removeGeometry,0,this._removeGeometry.length),this._geometry.length),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__:function(){for(const t of this.geometryNodes)t.setTessellationScale(1);this.geometryNodes.length=0;for(const t of this._geometry){const e=f()(d().X3DNurbsSurfaceGeometryNode,t);e&&this.geometryNodes.push(e)}this.set_tessellationScale__()},dispose:function(){ye().prototype.dispose.call(this),Ht().prototype.dispose.call(this)}});const Ce=ve;_().set("x_ite/Components/NURBS/NurbsSet",Ce);const Ne=Ce,Se=window[Symbol.for("X_ITE.X3D-8.7.9")].require("standard/Math/Geometry/Line3");var Oe=t.n(Se);const De={isPointInTriangle:function(t,e,n,i){const o=(e.y-n.y)*(t.x-n.x)+(n.x-e.x)*(t.y-n.y);if(0==o)return!1;const s=((e.y-n.y)*(i.x-n.x)+(n.x-e.x)*(i.y-n.y))/o;if(s<0||s>1)return!1;const r=((n.y-t.y)*(i.x-n.x)+(t.x-n.x)*(i.y-n.y))/o;if(r<0||r>1)return!1;const u=1-s-r;return!(u<0||u>1)}};_().set("standard/Math/Geometry/Triangle2",De);const Pe=De;function Te(t){Ht().call(this,t),this.addType(d().NurbsSurfaceInterpolator),this.geometry=new de(t)}Te.prototype=Object.assign(Object.create(Ht().prototype),{constructor:Te,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFVec2f)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"normal_changed",new(o().SFVec3f)),new(r())(d().outputOnly,"position_changed",new(o().SFVec3f))]),getTypeName:function(){return"NurbsSurfaceInterpolator"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"children"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=128,this.geometry._vTessellation=128,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry.setup()},set_fraction__:function(){const t=new(O())(0,0,0),e=new(O())(0,0,0),n=new(O())(0,0,0),i=new(O())(0,0,0),o=new(Oe())(O().Zero,O().zAxis),s={};return function(){const r=this._set_fraction.getValue(),u=this.geometry.getTexCoords(),l=this.geometry.getNormals(),a=this.geometry.getVertices();for(let h=0,c=0,d=u.length;h<d;h+=12,c+=9)if(t.set(u[h+0],u[h+1],0),e.set(u[h+4],u[h+5],0),n.set(u[h+7],u[h+9],0),Pe.isPointInTriangle(t,e,n,r)&&(o.set(i.set(r.x,r.y,0),O().zAxis),o.intersectsTriangle(t,e,n,s))){const t=s.u,e=s.v,n=s.t,i=new(O())(n*l[c+0]+t*l[c+3]+e*l[c+6],n*l[c+1]+t*l[c+4]+e*l[c+7],n*l[c+2]+t*l[c+5]+e*l[c+8]),o=new(O())(n*a[h+0]+t*a[h+4]+e*a[h+8],n*a[h+1]+t*a[h+5]+e*a[h+9],n*a[h+2]+t*a[h+6]+e*a[h+10]);this._normal_changed=i,this._position_changed=o}}}()});const Fe=Te;_().set("x_ite/Components/NURBS/NurbsSurfaceInterpolator",Fe);const Ie=Fe,Re=window[Symbol.for("X_ITE.X3D-8.7.9")].require("x_ite/Components/Geometry3D/Extrusion");var Ve=t.n(Re);function xe(t){U.call(this,t),this.addType(d().NurbsSweptSurface),this.extrusion=new(Ve())(t)}xe.prototype=Object.assign(Object.create(U.prototype),{constructor:xe,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(d().inputOutput,"crossSectionCurve",new(o().SFNode)),new(r())(d().inputOutput,"trajectoryCurve",new(o().SFNode))]),getTypeName:function(){return"NurbsSweptSurface"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"geometry"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){U.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},set_crossSectionCurve__:function(){this.crossSectionCurveNode&&this.crossSectionCurveNode.removeInterest("requestRebuild",this),this.crossSectionCurveNode=f()(d().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode&&this.crossSectionCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__:function(){this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(d().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.addInterest("requestRebuild",this)},build:function(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.crossSectionCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(0),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals();for(let e=0,n=t.length;e<n;++e)t[e]=-t[e]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}});const ze=xe;_().set("x_ite/Components/NURBS/NurbsSweptSurface",ze);const je=ze;function ke(t){U.call(this,t),this.addType(d().NurbsSwungSurface),this.extrusion=new(Ve())(t)}ke.prototype=Object.assign(Object.create(U.prototype),{constructor:ke,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(d().inputOutput,"profileCurve",new(o().SFNode)),new(r())(d().inputOutput,"trajectoryCurve",new(o().SFNode))]),getTypeName:function(){return"NurbsSwungSurface"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"geometry"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){U.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},set_profileCurve__:function(){this.profileCurveNode&&this.profileCurveNode.removeInterest("requestRebuild",this),this.profileCurveNode=f()(d().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode&&this.profileCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__:function(){this.trajectoryCurveNode&&this.trajectoryCurveNode.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(d().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode.addInterest("requestRebuild",this)},build:function(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.profileCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(1),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals();for(let e=0,n=t.length;e<n;++e)t[e]=-t[e]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}});const Ae=ke;_().set("x_ite/Components/NURBS/NurbsSwungSurface",Ae);const Xe=Ae;function Be(t){h().call(this,t),this.addType(d().NurbsTextureCoordinate),this.controlPoints=[]}Be.prototype=Object.assign(Object.create(h().prototype),{constructor:Be,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2f))]),getTypeName:function(){return"NurbsTextureCoordinate"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"texCoord"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){h().prototype.initialize.call(this)},getControlPoints:function(t){const e=this._controlPoint.getValue(),n=this.controlPoints;for(let i=0,o=this._uDimension.getValue();i<o;++i){let s=n[i];s||(s=n[i]=[]);for(let n=0,r=this._vDimension.getValue();n<r;++n){const r=n*o+i,u=s[n]||new(B()),l=2*r;s[n]=u.set(e[l],e[l+1],0,t?t[r]:1)}}return n},isValid:function(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&this._controlPoint.length===this._uDimension.getValue()*this._vDimension.getValue())))}});const Ee=Be;_().set("x_ite/Components/NURBS/NurbsTextureCoordinate",Ee);const qe=Ee;function Ke(t){ae.call(this,t),this.addType(d().NurbsTrimmedSurface),this.trimmingContourNodes=[]}function Me(t,e,n,i,o,s){const r=new Set;for(let t=o;t<s;++t)r.add(i[t]);return t.remove(e,n,(t=>r.has(t)))}Ke.prototype=Object.assign(Object.create(ae.prototype),{constructor:Ke,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(l())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(d().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"uClosed",new(o().SFBool)),new(r())(d().initializeOnly,"vClosed",new(o().SFBool)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"texCoord",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().inputOnly,"addTrimmingContour",new(o().MFNode)),new(r())(d().inputOnly,"removeTrimmingContour",new(o().MFNode)),new(r())(d().inputOutput,"trimmingContour",new(o().MFNode))]),getTypeName:function(){return"NurbsTrimmedSurface"},getComponentName:function(){return"NURBS"},getContainerField:function(){return"geometry"},getSpecificationRange:function(){return["3.0","Infinity"]},initialize:function(){ae.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__:function(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.erase(Me(this._addTrimmingContour,0,this._addTrimmingContour.length,this._trimmingContour,0,this._trimmingContour.length),this._addTrimmingContour.length);for(const t of this._addTrimmingContour)this._trimmingContour.push(t);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__:function(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.erase(Me(this._trimmingContour,0,this._trimmingContour.length,this._removeTrimmingContour,0,this._removeTrimmingContour.length),this._trimmingContour.length),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__:function(){const t=this.trimmingContourNodes;t.length=0;for(const e of this._trimmingContour){const n=f()(d().Contour2D,e);n&&t.push(n)}},getTrimmingContours:function(){const t=this.trimmingContourNodes,e=[];for(const n of t)n.addTrimmingContour(e);return e}});const Ue=Ke;_().set("x_ite/Components/NURBS/NurbsTrimmedSurface",Ue);const Ge=Ue;n().addComponent({name:"NURBS",types:{Contour2D:v,ContourPolyline2D:T,CoordinateDouble:x,NurbsCurve:Wt,NurbsCurve2D:Lt,NurbsOrientationInterpolator:oe,NurbsPatchSurface:de,NurbsPositionInterpolator:me,NurbsSet:Ne,NurbsSurfaceInterpolator:Ie,NurbsSweptSurface:je,NurbsSwungSurface:Xe,NurbsTextureCoordinate:qe,NurbsTrimmedSurface:Ge},abstractTypes:{X3DNurbsControlCurveNode:N,X3DNurbsSurfaceGeometryNode:ae,X3DParametricGeometryNode:U}});const We=void 0;_().set("assets/components/NURBS",We)})();
=======
/* X_ITE v8.7.8 */(()=>{"use strict";var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components");var i=e.n(t);const n=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Fields");var o=e.n(n);const s=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DFieldDefinition");var r=e.n(s);const l=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/FieldDefinitionArray");var a=e.n(l);const u=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Core/X3DNode");var h=e.n(u);const d=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DConstants");var c=e.n(d);const p=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DCast");var g=e.n(p);const m=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Namespace");var f=e.n(m);function _(e){h().call(this,e),this.addType(c().Contour2D),this.childNodes=[]}function b(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(_.prototype,h().prototype),{initialize(){h().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__(){this._addChildren.setTainted(!0),this._addChildren.assign(b(this._addChildren,this._children));for(const e of this._addChildren)this._children.push(e);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__(){this._removeChildren.setTainted(!0),this._children.assign(b(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__(){const e=this.childNodes;e.length=0;for(const t of this._children){const i=g()(c().NurbsCurve2D,t);if(i)e.push(i);else{const i=g()(c().ContourPolyline2D,t);if(i){e.push(i);continue}}}},addTrimmingContour(e){for(const t of this.childNodes)e.push(t.tessellate(2))}}),Object.defineProperties(_,{typeName:{value:"Contour2D",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"trimmingContour",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"addChildren",new(o().MFNode)),new(r())(c().inputOnly,"removeChildren",new(o().MFNode)),new(r())(c().inputOutput,"children",new(o().MFNode))]),enumerable:!0}});const w=_;f().set("x_ite/Components/NURBS/Contour2D",w);const v=w;function y(e){h().call(this,e),this.addType(c().X3DNurbsControlCurveNode)}Object.setPrototypeOf(y.prototype,h().prototype),Object.defineProperties(y,{typeName:{value:"X3DNurbsControlCurveNode",enumerable:!0},componentName:{value:"NURBS",enumerable:!0}});const N=y;f().set("x_ite/Components/NURBS/X3DNurbsControlCurveNode",N);const C=N,O=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector3");var S=e.n(O);function P(e){C.call(this,e),this.addType(c().ContourPolyline2D),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(P.prototype,C.prototype),{tessellate(e){switch(e){case 0:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;t[i+0]=e[i+0],t[i+1]=e[i+1]}return t.length=2*i,t}case 1:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n,o=3*n;t[o+0]=e[i+0],t[o+1]=0,t[o+2]=e[i+1]}return t.length=3*i,t}case 3:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;t[n]=new(S())(e[i+0],e[i+1],0)}return t.length=i,t}}}}),Object.defineProperties(P,{typeName:{value:"ContourPolyline2D",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerable:!0}});const D=P;f().set("x_ite/Components/NURBS/ContourPolyline2D",D);const F=D,R=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DCoordinateNode");var V=e.n(R);function I(e){V().call(this,e),this.addType(c().CoordinateDouble)}Object.setPrototypeOf(I.prototype,V().prototype),Object.defineProperties(I,{typeName:{value:"CoordinateDouble",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"coord",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"point",new(o().MFVec3d))]),enumerable:!0}});const T=I;f().set("x_ite/Components/NURBS/CoordinateDouble",T);const x=T,j=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DGeometryNode");var z=e.n(j);const k=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector2");var A=e.n(k);const B=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector4");var X=e.n(B);const E={getTessellation:(e,t)=>e>0?e+1:e<0?-e*t+1:2*t+1,getClosed2D(e,t,i,n){const o=n.length;return(!(i.length===o)||i[0]===i[o-1])&&(!!n[0].equals(n[o-1])&&!!this.isPeriodic(e,o,t))},getClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(i,n,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&(!!s.get1Point(0,e).equals(s.get1Point(r-1,t))&&!!this.isPeriodic(i,r,n))}}(),getUClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0,s=o;i<s;++i){const o=i*n,s=i*n+n-1;if(a&&r[o]!==r[s])return!1;if(!l.get1Point(o,e).equals(l.get1Point(s,t)))return!1}return!!this.isPeriodic(i,n,s)}}(),getVClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0,s=n;i<s;++i){const s=i,u=(o-1)*n+i;if(a&&r[s]!==r[u])return!1;if(!l.get1Point(s,e).equals(l.get1Point(u,t)))return!1}return!!this.isPeriodic(i,o,s)}}(),isPeriodic(e,t,i){if(i.length===t+e){{let t=1;for(let n=1,o=e;n<o;++n)t+=i[n]===i[0];if(t===e)return!1}{let t=1;for(let n=i.length-e,o=i.length-1;n<o;++n)t+=i[n]===i[o];if(t===e)return!1}}return!0},getKnots(e,t,i,n,o){const s=e||[];for(let e=0,t=o.length;e<t;++e)s[e]=o[e];s.length=o.length;let r=!0;if(s.length===n+i){r=!1;let e=0;for(let t=1,n=s.length;t<n;++t)s[t]==s[t-1]?++e:e=0,e>i-1&&(r=!0),s[t-1]>s[t]&&(r=!0)}if(r)for(let e=0,t=n+i;e<t;++e)s[e]=e/(t-1);if(t)for(let e=1,t=i-1;e<t;++e)s.push(s.at(-1)+(s[e]-s[e-1]));return s},getWeights(e,t,i){if(i.length!==t)return;const n=e||[];for(let e=0;e<t;++e)n[e]=i[e];return n.length=t,n},getUVWeights(e,t,i,n){const o=t*i;if(n.length!==o)return;const s=e||[];for(let e=0,o=0;e<t;++e)for(let e=0;e<i;++e,++o)s[o]=n[o];return s.length=o,s},getControlPoints2D(e,t,i,n,o){const s=e||[],r=o.getValue(),l=o.length,a=!!n,u=a?S():A();s.haveWeights!==a&&(s.haveWeights=a,s.length=0);for(let e=0;e<l;++e){const t=2*e,i=s[e]||new u(0,0,0);s[e]=i.set(r[t+0],r[t+1],a?n[e]:0)}if(s.length=l,t)for(let e=1,t=i-1;e<t;++e)s.push(s[e]);return s},getControlPoints(e,t,i,n,o){const s=e||[],r=o.getSize(),l=!!n,a=l?X():S();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let e=0;e<r;++e){const t=s[e]=o.get1Point(e,s[e]||new a(0,0,0,0));l&&(t.w=n[e])}if(s.length=r,t)for(let e=1,t=i-1;e<t;++e)s.push(s[e]);return s},getUVControlPoints(e,t,i,n,o,s,r,l,a){const u=e||[],h=!!l,d=h?X():S();u.haveWeights!==h&&(u.haveWeights=h,u.length=0);for(let e=0;e<s;++e){let t=u[e];t||(t=u[e]=[]);for(let i=0;i<r;++i){const n=i*s+e;t[i]=a.get1Point(n,t[i]||new d(0,0,0,0)),h&&(t[i].w=l[n])}if(t.length=r,i)for(let e=1,i=o-1;e<i;++e)t.push(t[e])}if(u.length=s,t)for(let e=1,t=n-1;e<t;++e)u.push(u[e]);return u},getTexControlPoints(e,t,i,n,o,s,r,l){const a=e||[];for(let e=0;e<s;++e){let t=a[e];t||(t=a[e]=[]);for(let i=0;i<r;++i){const n=i*s+e;t[i]=l.get1Point(n,t[i]||new(X())(0,0,0,0))}if(t.length=r,i)for(let e=1,i=o-1;e<i;++e)t.push(t[e])}if(a.length=s,t)for(let e=1,t=n-1;e<t;++e)a.push(a[e]);return a}};f().set("x_ite/Browser/NURBS/NURBS",E);const U=E;function q(e){z().call(this,e),this.addType(c().X3DParametricGeometryNode)}Object.assign(Object.setPrototypeOf(q.prototype,z().prototype),{getKnots:(e,t,i,n,o)=>U.getKnots(e,t,i,n,o)}),Object.defineProperties(q,{typeName:{value:"X3DParametricGeometryNode",enumerable:!0},componentName:{value:"NURBS",enumerable:!0}});const K=q;f().set("x_ite/Components/NURBS/X3DParametricGeometryNode",K);const M=K,G=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DLineGeometryNode");var W=e.n(G);const Y=function(e){return!!e&&(!!e.dtype&&new RegExp("function View[0-9]+d(:?"+e.dtype+")+").test(String(e.constructor)))};f().set("lib/nurbs/src/utils/is-ndarray",Y);const J=Y,L=function(e){return!!e&&(void 0!==e.data&&Array.isArray(e.shape)&&void 0!==e.offset&&void 0!==e.stride)};f().set("lib/nurbs/src/utils/is-ndarray-like",L);const Z=L,H=function(e){return Array.isArray(e)||ArrayBuffer.isView(e)||void 0!==e.length};f().set("lib/nurbs/src/utils/is-array-like",H);const Q=H;function $(e){if(e){if(J(e)||Z(e))return"generic"===e.dtype?$.GENERIC_NDARRAY:$.NDARRAY;if(Q(e)){for(var t=e;Q(t[0]);t=t[0]);return"x"in t?$.ARRAY_OF_OBJECTS:$.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof e)}}$.ARRAY_OF_OBJECTS="Obj",$.ARRAY_OF_ARRAYS="Arr",$.NDARRAY="Nd",$.GENERIC_NDARRAY="GenNd",$.PACKED="PackArr";const ee=$;f().set("lib/nurbs/src/utils/infer-type",ee);const te=ee;const ie=function(e,t,i,n,o,s){var r,l,a=[],u=!1;for(r=0;r<e.splineDimension;r++){var h=Q(e.knots)&&Q(e.knots[r]);h&&(u=!0),a.push("Deg"+e.degree[r]+(h?"":"Uniform")+((l=e.boundary[r])[0].toUpperCase()+l.slice(1)))}var d=[[u?"NU":"",e.weights?"RBS":"BS"].join("")+e.dimension+"D",a.join("_")];return n&&d.push(n+"Pts"),o&&d.push(o+"Wts"),s&&d.push(s+"Kts"),t&&d.push("debug"),i&&d.push("chk"),d.join("_")};f().set("lib/nurbs/src/utils/cache-key",ie);const ne=ie;var oe=function e(t,i){return function(i,n){void 0===i||Array.isArray(i)||(i=[i]);for(var o=[],s=0;s<i.length;s++)o.push(e.sum(i[s]));if(n)for(i=0;i<o.length;i++)void 0!==n[i]&&(o[i]="("+o[i]+" + "+n[i]+") % "+n[i]);return t+o.join("_")}};oe.sum=function(e){return 0===(e=(e=Array.isArray(e)?e:[e]).filter((function(e){return void 0!==e&&0!==e}))).length&&e.push(0),e.join(" + ")};const se=oe;f().set("lib/nurbs/src/utils/variable",se);const re=se;var le=[".x",".y",".z",".w"];function ae(e){return function(t,i){void 0===t||Array.isArray(t)||(t=[t]);for(var n=[],o=0;o<t.length;o++)n.push(re.sum(t[o]));if(i)for(t=0;t<n.length;t++)void 0!==i[t]&&(n[t]="("+n[t]+" + "+i[t]+") % "+i[t]);return e(n)}}function ue(e,t){if(t)switch(te(t)){case te.ARRAY_OF_OBJECTS:return ae((function(t){var i=t.pop();return e+"["+t.join("][")+"]"+le[i]}));case te.ARRAY_OF_ARRAYS:return ae((function(t){return e+"["+t.join("][")+"]"}));case te.GENERIC_NDARRAY:return ae((function(t){return e+".get("+t.join(",")+")"}));case te.NDARRAY:return ae((function(t){for(var i=[e+"Offset"],n=0;n<t.length;n++)i.push(e+"Stride"+n+" * ("+t[n]+")");return e+"["+i.join(" + ")+"]"}));case te.PACKED:default:return}}const he=function(e){var t,i={};return(t=ue("x",e.points))&&(i.point=t),(t=ue("w",e.weights))&&(i.weight=t),(t=ue("k",e.knots))&&(i.knot=t),i};f().set("lib/nurbs/src/utils/create-accessors",he);const de=he;var ce=[],pe=[];const ge=function(e,t,i){if(1!==t)throw new Error("Numerical derivative not implemented for order n = "+t+".");var n,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(ce.length=this.splineDimension,n=0;n<this.splineDimension;n++)ce[n+1]=arguments[n+3];var s,r,l,a=this.domain,u=a[i][0],h=a[i][1],d=ce[i+1],c=(h-u)*o;for("closed"===this.boundary[i]?(s=u+(d-u-c+(l=h-u))%l,r=u+(d-u+c+l)%l,c*=2):(s=Math.min(h,Math.max(u,d-c)),c=(r=Math.min(h,Math.max(u,d+c)))-s),ce[i+1]=s,ce[0]=pe,this.evaluate.apply(null,ce),ce[i+1]=r,ce[0]=e,this.evaluate.apply(null,ce),n=0;n<this.dimension;n++)e[n]=(e[n]-pe[n])/c;return e};f().set("lib/nurbs/src/numerical-derivative",ge);const me=ge,fe=function(e,t){for(var i=1,n=0,o=[];n<e.length;n++)i*=Array.isArray(e[n])?e[n][1]-e[n][0]:e[n],o[n]=Array.isArray(e[n])?e[n][0]:0;for(var s=0;s<i;s++)for(t(o.slice()),n=e.length-1;n>=0;n--){if(o[n]!==(Array.isArray(e[n])?e[n][1]:e[n])-1){o[n]++;break}o[n]=Array.isArray(e[n])?e[n][0]:0}};f().set("lib/nurbs/src/utils/ndloop",fe);const _e=fe,be=function(e,t,i,n){var o=[];switch(te(n)){case te.NDARRAY:o.push("  var "+t+" = "+i+".data;"),o.push("  var "+t+"Offset = "+i+".offset;");for(var s=0;s<n.dimension;s++)o.push("  var "+t+"Stride"+s+" = "+i+".stride["+s+"];");break;case te.ARRAY_OF_OBJECTS:case te.ARRAY_OF_ARRAYS:o.push("  var "+t+" = "+i+";")}return o.join("\n")};f().set("lib/nurbs/src/utils/accessor-preamble",be);const we=be,ve=function(e,t,i){if(e){if(Z(e))return t+".shape["+i+"]";for(var n=t,o=0;o<i;o++)n+="[0]";return n+".length"}return"this.size["+i+"]"};f().set("lib/nurbs/src/utils/size-getter",ve);const ye=ve;var Ne={},Ce={};const Oe=function(e,t,i,n,o,s,r){var l,a,u,h,d,c,p=t.splineDimension,g=t.points,m=t.degree,f=t.weights,_=void 0!==f,b=t.knots,w=t.dimension,v=t.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var y=0;for(l=0;l<p;l++)void 0===r[l]&&(r[l]=0),y+=r[l];if(_&&y>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+y+".")}s&&(e="Basis"+e),r&&(e="Der"+r.join("_")+"_"+e);var N=Ne[e];if(n)var C="function"==typeof n?n:console.log;if(N)return n&&C(Ce[e]),N.bind(t);var O=[],S="evaluate"+e,P=i.point;s&&(P=function(e,t){for(var i=[],n=0;n<e.length;n++){for(var o=e[n],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),t[n]&&(o="("+o+" + "+t[n]+") % "+t[n]),i.push(o+" === "+T(n))}return"(("+i.join(" && ")+") ? 1 : 0)"});var D=i.weight,F=i.knot,R=re("k"),V=re("x"),I=re("w"),T=re("i"),x=re("t"),j=n?"domain":"d",z=re(n?"size":"s"),k=re(n?"knotIndex":"j"),A=!0;for(d=0;d<p;d++)Q(b)&&Q(b[d])&&(A=!1);function B(e){O.push("  "+(e||""))}function X(e){n&&B(e)}if(s)var E=[];var U=[];for(l=0;l<p;l++)s&&E.push(T([l])),U.push(x([l]));for(O.push("function "+S+" ("+(s?"":"out, ")+U.join(", ")+(s?", "+E.join(", "):"")+") {"),B("var h, m, a, b;"),o&&(B("var "+j+" = this.domain;"),B("for (var i = 0; i < this.splineDimension; i++) {"),B("  a = arguments[i + 1];"),B("  if (a < "+j+"[i][0] || a > "+j+"[i][1] || a === undefined || isNaN(a)) {"),B('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+j+'[i][0]+", "+'+j+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),B("  }"),B("}")),d=0;d<p;d++)B("var "+z(d)+" = "+ye(g,"this.points",d)+";");function q(e,t,i){return"("+e+") ? ("+t+") : ("+i+")"}O.push(we(t,"x","this.points",g)),_&&O.push(we(t,"w","this.weights",f)),A||O.push(we(t,"k","this.knots",b));var K=[];for(d=0;d<p;d++)switch(te(b)){case te.NDARRAY:K[d]=!0;break;case te.ARRAY_OF_ARRAYS:K[d]=Q(b[d])}for(d=0;d<p;d++)if(K[d])for(X("\n  // Bisect to locate the knot interval in dimension "+d+"\n"),B("var "+k(d)+" = 0;"),B("h = "+z(d)+";"),B("while(h > "+k(d)+" + 1) {"),B("  m = 0.5 * (h + "+k(d)+") | 0;"),B("  if ("+F([d,"m"])+" > "+x(d)+") h = m;"),B("  else "+k(d)+" = m;"),B("}"),X("\n  // Fetch knots for dimension "+d+"\n"),l=1-m[d];l<=m[d];l++)"closed"===v[d]?B(l<0?"var "+R([d,l+m[d]-1])+" = "+q(k(d)+" < "+-l,F([d,0])+" + "+F([d,[z(d),k(d),l]])+" - "+F([d,[z(d)]]),F([d,[k(d),l]]))+";":l>0?"var "+R([d,l+m[d]-1])+" = "+q(k(d)+" + "+l+" > "+z(d),F([d,z(d)])+" + "+F([d,l+" + "+k(d)+" - "+z(d)])+" - "+F([d,0]),F([d,[k(d),l]]))+";":"var "+R([d,l+m[d]-1])+" = "+F([d,[k(d),l]])+";"):B("var "+R([d,l+m[d]-1])+" = "+F([d,[k(d),l]])+";");else{for(X("\n  // Directly compute knot interval for dimension "+d+"\n"),"closed"===v[d]?B(k(d)+" = ("+x(d)+" | 0) % "+z(d)+";"):(B(k(d)+" = ("+x(d)+" | 0);"),B("if ("+k(d)+" < "+m[d]+") "+k(d)+" = "+m[d]+";"),B("if ("+k(d)+" > "+z(d)+" - 1) "+k(d)+" = "+z(d)+" - 1;")),X("\n  // Compute and clamp knots for dimension "+d+"\n"),l=1-m[d];l<=m[d];l++)B("var "+(c=R([d,l+m[d]-1]))+" = "+k(d)+" + "+l+";");if("clamped"===v[d])for(l=1-m[d];l<=m[d];l++)c=R([d,l+m[d]-1]),l<0&&B("if ("+c+" < "+m[d]+") "+c+" = "+m[d]+";"),l>0&&B("if ("+c+" > "+z(d)+") "+c+" = "+z(d)+";");"closed"===v[d]&&(X("\n  // Wrap the B-Spline parameter for closed boundary"),B(x(d)+" %= "+z(d)+";"))}for(d=0,u=[];d<p;d++)u[d]=m[d]+1;for(_&&(X("\n  // Fetch weights\n"),_e(u,(function(e){for(var t=[],i=[],n=0;n<p;n++)t[n]=[k(n),e[n]-m[n]],"closed"===v[n]&&e[n]-m[n]<0&&(i[n]=z(n));B("var "+I(e)+" = "+D(t,i)+";")}))),n&&B(_?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),_e(u,(function(e){for(var t=[],i=[],n=0;n<p;n++)t[n]=[k(n),e[n]-m[n]],"closed"===v[n]&&e[n]-m[n]<0&&(i[n]=z(n));if(s)B(_?"var "+V(e)+" = "+P(t,i)+" * "+I(e)+";":"var "+V(e)+" = "+P(t,i)+";");else for(n=0;n<w;n++){var o=e.concat(n);t[p]=n,B(_?"var "+V(o)+" = "+P(t,i)+" * "+I(e)+";":"var "+V(o)+" = "+P(t,i)+";")}})),X("\n"),X('// Perform De Boor"s algorithm'),d=u.length-1;d>=0;d--)for(u[d]=[m[d],m[d]+1],l=0;l<m[d];l++)for(X("\n  // Degree "+m[d]+" evaluation in dimension "+d+", step "+(l+1)+"\n"),a=m[d];a>l;a--){var M=r&&m[d]-l-r[d]<=0;M?(B("m = 1 / ("+R([d,a-l+m[d]-1])+" - "+R([d,a-1])+");"),_&&(B("a = ("+x(d)+" - "+R([d,a-1])+") * m;"),B("b = 1 - a;"))):(B("a = ("+x(d)+" - "+R([d,a-1])+") / ("+R([d,a-l+m[d]-1])+" - "+R([d,a-1])+");"),B("b = 1 - a;")),_&&_e(u,(function(e){var t=e.slice(),i=e.slice();t[d]=a,i[d]=a-1,M&&_&&B("h = "+I(t)+";"),B(I(t)+" = b * "+I(i)+" + a * "+I(t)+";")})),_e(u,(function(e){var t,i,n,o=e.slice(),r=e.slice();if(o[d]=a,r[d]=a-1,M){var u=l+1;if(s)t=_?"h * "+I(r)+" / "+I(o)+" * ":"",i=V(o)+(_?" / h":""),n=V(r)+(_?" / "+I(r):""),B(V(o)+" = "+u+" * "+t+"("+i+" - "+n+") * m;");else{var c=o.slice(),g=r.slice();for(h=0;h<w;h++)c[p]=g[p]=h,t=_?"h * "+I(r)+" / "+I(o)+" * ":"",i=V(c)+(_?" / h":""),n=V(g)+(_?" / "+I(r):""),B(V(c)+" = "+u+" * "+t+"("+i+" - "+n+") * m;")}}else if(s)B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";");else for(h=0;h<w;h++)o[p]=r[p]=h,B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";")})),X("\n")}if(n&&B(_?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)B(_?"return "+V(m)+" / "+I(m)+";":"return "+V(m)+";");else for(d=0;d<w;d++)B(_?"out["+d+"] = "+V(m.concat([d]))+" / "+I(m)+";":"out["+d+"] = "+V(m.concat([d]))+";");if(s||B("return out;"),O.push("}"),n){var G=O.join("\n");C(G),Ce[e]=G}var W=new Function([O.join("\n"),"; return ",S].join(""))();return Ne[e]=W,W.bind(t)};f().set("lib/nurbs/src/evaluate",Oe);const Se=Oe;var Pe={};const De=function(e,t,i,n){var o,s,r,l,a,u,h,d,c=Pe[e];if(c)return c.bind(t);var p=[],g="transform"+e;p.push("function "+g+"(m) {"),p.push("var i, w;"),p.push(we(t,"x","this.points",t.points));var m=re(n?"size":"s");for(o=0;o<t.splineDimension;o++)p.push("var "+m(o)+" = "+ye(t.points,"this.points",o)+";");for(l=[],o=0;o<t.splineDimension;o++)r="i"+o,l.push(r),p.push("for ("+r+" = "+m(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<t.dimension;o++)p.push("x"+o+" = "+i.point(l.concat([o])));for(a=[],o=0;o<t.dimension;o++)a.push("m["+((t.dimension+1)*(o+1)-1)+"] * x"+o);for(a.push("m["+((t.dimension+1)*(t.dimension+1)-1)+"]"),p.push("var w = ("+a.join(" + ")+") || 1.0;"),o=0;o<t.dimension;o++){for(a=[],u=t.dimension,s=0;s<u;s++)a.push("m["+(s*(u+1)+o)+"] * x"+s);a.push("m["+(s*(u+1)+o)+"]"),d=i.point(l.concat([o])),h="("+a.join(" + ")+") / w",p.push(d+" = "+h+";")}for(o=t.splineDimension-1;o>=0;o--)p.push("}");p.push("return this;"),p.push("}");var f=new Function([p.join("\n"),"; return ",g].join(""))();return n&&console.log(p.join("\n")),Pe[e]=f,f.bind(t)};f().set("lib/nurbs/src/transform",De);const Fe=De;var Re={};const Ve=function(e,t,i,n,o){var s=Re[e];if(s)return s.bind(t);var r,l,a,u=t.degree,h=t.knots,d=t.splineDimension,c=t.boundary,p=[],g="support"+e,m=i.knot,f=re("t"),_=n?"domain":"d",b=re(n?"size":"s"),w=re(n?"knotIndex":"i"),v=!0;for(a=0;a<d;a++)Q(h)&&Q(h[a])&&(v=!1);function y(e){p.push("  "+(e||""))}var N=[];for(r=0;r<d;r++)N.push(f([r]));p.push("function "+g+" (out, "+N.join(", ")+") {");var C=0;function O(e,t){y(void 0===t?"out["+C+++"] = "+e.join(" + ")+";":"out["+C+++"] = ("+e.join(" + ")+" + "+t+") % "+t+";")}for(y("var h, m;"),y("var c = 0;"),o&&(y("var "+_+" = this.domain;"),y("for (var i = 0; i < this.splineDimension; i++) {"),y("  a = arguments[i + 1];"),y("  if (a < "+_+"[i][0] || a > "+_+"[i][1] || a === undefined || isNaN(a)) {"),y('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+_+'[i][0]+", "+'+_+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),y("  }"),y("}")),a=0;a<d;a++)y("var "+b(a)+" = "+ye(t.points,"this.points",a)+";");v||p.push(we(t,"k","this.knots",h));var S=[];for(a=0;a<d;a++)switch(te(h)){case te.NDARRAY:S[a]=!0;break;case te.ARRAY_OF_ARRAYS:S[a]=Q(h[a])}for(a=0;a<d;a++)S[a]?(y("var "+w(a)+" = 0;"),y("h = "+b(a)+";"),y("while(h > "+w(a)+" + 1) {"),y("  m = 0.5 * (h + "+w(a)+") | 0;"),y("  if ("+m([a,"m"])+" > "+f(a)+") h = m;"),y("  else "+w(a)+" = m;"),y("}")):"closed"===c[a]?y(w(a)+" = ("+f(a)+" | 0) % "+b(a)+";"):(y(w(a)+" = ("+f(a)+" | 0);"),y("if ("+w(a)+" < "+u[a]+") "+w(a)+" = "+u[a]+";"),y("if ("+w(a)+" > "+b(a)+" - 1) "+w(a)+" = "+b(a)+" - 1;"));for(a=0,l=[];a<d;a++)l[a]=u[a]+1;_e(l,(function(e){for(var t=[],i=[],n=0;n<d;n++)t[n]=[w(n),e[n]-u[n]],"closed"===c[n]&&e[n]-u[n]<0&&(i[n]=b(n));for(n=0;n<d;n++)O(t[n],i[n])})),y("out.length = "+C+";"),y("return out;"),p.push("}"),n&&console.log(p.join("\n"));var P=new Function([p.join("\n"),"; return ",g].join(""))();return Re[e]=P,P.bind(t)};f().set("lib/nurbs/src/support",Ve);const Ie=Ve,Te=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Geometry/Triangle3");var xe=e.n(Te),je=[];const ze=function(e,t,i){i=i||{};var n=(e=e||{}).points=e.points||[],o=e.faces=e.faces||[],s=i.haveWeights,r=t.dimension-s;if(Array.isArray(i.resolution))var l=i.resolution;else{var a=void 0===i.resolution?31:i.resolution;l=new Array(t.splineDimension).fill(a)}switch(t.splineDimension){case 1:for(var u=(f=(b=l[0])+!(v="closed"===t.boundary[0]))*r,h=(N=(_=i.domain||t.domain)[0])[1]-N[0],d=0;d<f;++d){var c=N[0]+h*d/b,p=d*r;if(t.evaluate(je,c),s)for(var g=je[r],m=0;m<r;++m)n[p+m]=je[m]/g;else for(m=0;m<r;++m)n[p+m]=je[m]}n.length=u;break;case 2:var f,_,b=l[0],w=l[1],v="closed"===t.boundary[0],y=w+!(D="closed"===t.boundary[1]),N=(u=(f=b+!v)*y*r,(_=i.domain||t.domain)[0]),C=_[1],O=(h=N[1]-N[0],C[1]-C[0]);for(d=0;d<f;++d){c=N[0]+h*d/b;for(var S=0;S<y;++S){var P=C[0]+O*S/w;p=(d+f*S)*r;if(t.evaluate(je,c,P),s)for(g=je[r],m=0;m<r;++m)n[p+m]=je[m]/g;else for(m=0;m<r;++m)n[p+m]=je[m]}}n.length=u;v=i.closed[0];var D=i.closed[1],F=0;for(d=0;d<b;++d){var R=d,V=d+1;v&&(V%=b);for(S=0;S<w;++S){var I=S,T=S+1;D&&(T%=w),o[F++]=R+f*I,o[F++]=V+f*I,o[F++]=V+f*T,o[F++]=R+f*I,o[F++]=V+f*T,o[F++]=R+f*T}}o.length=F;break;default:throw new Error("Can only sample contours and surfaces")}return e};f().set("lib/nurbs/extras/sample",ze);const ke=ze;var Ae={open:"open",closed:"closed",clamped:"clamped"};function Be(e){return null==e}function Xe(e,t,i,n,o,s){var r,l;!e||Q(e)||J(e)?(s=s||{},this.weights=n,this.knots=i,this.degree=t,this.points=e,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=e,this.debug=e.debug,this.checkBounds=!!e.checkBounds,this.weights=e.weights,this.knots=e.knots,this.degree=e.degree,this.boundary=e.boundary,this.points=e.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var a=te(this.points),u=te(this.weights),h=te(this.knots);if(this.points)switch(a){case te.GENERIC_NDARRAY:case te.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case te.ARRAY_OF_OBJECTS:case te.ARRAY_OF_ARRAYS:var d=0,c=this.size||[];c.length=0;for(var p=this.points;Q(p[0]);p=p[0])d++,c.push(p.length);if(0===d)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:d,writable:!1,configurable:!0},dimension:{value:p.length,writable:!1,configurable:!0},size:{get:function(){var e=[];e.length=0;for(var t=0,i=this.points;t<this.splineDimension;t++,i=i[0])e[t]=i.length;return e},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case te.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(Q(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(Q(this.degree)){for(r=0;r<this.splineDimension;r++)if(Be(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var g=!Be(this.degree),m=Be(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=m){if(g)throw new Error("Expected at least "+(m+1)+" points for degree "+m+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=m}if(l="string"!=typeof this.boundary?"open":this.boundary,!Ae[l])throw new Error("Boundary type must be one of "+Object.keys(Ae)+". Got "+l);for(this.boundary=Q(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=Be(this.boundary[r])?l:this.boundary[r],!Ae[l])throw new Error("Boundary type must be one of "+Object.keys(Ae)+". Got "+l+" for dimension "+(r+1));switch(h){case te.ARRAY_OF_ARRAYS:for(Q(this.knots)&&this.knots.length>0&&!Q(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(Q(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case te.NDARRAY:}var f=ne(this,this.debug,this.checkBounds,a,u,h);if(f!==this.__cacheKey){this.__cacheKey=f;var _=de(this);this.evaluate=Se(this.__cacheKey,this,_,this.debug,this.checkBounds,!1),this.transform=Fe(this.__cacheKey,this,_,this.debug),this.support=Ie(this.__cacheKey,this,_,this.debug,this.checkBounds),this.evaluator=function(e,t){return Se(this.__cacheKey,this,_,this.debug,this.checkBounds,t,e)}}return this.numericalDerivative=me.bind(this),this}function Ee(){var e,t=[],i=this.points;i?Z(i)&&(e=i.shape):e=this.size;for(var n=0;n<this.splineDimension;n++){var o=e?e[n]:i.length,s=this.degree[n],r="closed"===this.boundary[n];if(this.knots&&this.knots[n]){var l=this.knots[n];t[n]=[l[r?0:s],l[o]]}else t[n]=[r?0:s,o];i&&(i=i[0])}return t}function Ue(e,t,i,n,o,s){var r=function(e,t,i,n,o,s){return l(e,t,i,n,o,s),r},l=Xe.bind(r);return Object.defineProperty(r,"domain",{get:Ee}),l(e,t,i,n,o,s),r}Ue.sample=ke;const qe=Ue;f().set("lib/nurbs/nurbs",qe);const Ke=qe;function Me(e){M.call(this,e),W().call(this,e),this.addType(c().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Object.assign(Object.setPrototypeOf(Me.prototype,M.prototype),W().prototype,{initialize(){M.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=g()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},getTessellation(e){return U.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed(e,t,i,n){return!!this._closed.getValue()&&U.getClosed(e,t,i,n)},getWeights:(e,t,i)=>U.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>U.getControlPoints(e,t,i,n,o),tessellate(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const e=this.getVertices(),t=[];if(e.length){const i=e.length;for(let n=0;n<i;n+=8)t.push(e[n],e[n+1],e[n+2]);t.push(e[i-4],e[i-3],e[i-2])}return t},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(n.at(-1),n[0],this._order.getValue()-1),s=this.surface=(this.surface||Ke)({boundary:["open"],degree:[o],knots:[n],points:i,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(n.length),this.sampleOptions.haveWeights=!!t;const r=Ke.sample(this.mesh,s,this.sampleOptions).points,l=this.getVertices();for(let e=3,t=r.length;e<t;e+=3){const t=e-3;l.push(r[t],r[t+1],r[t+2],1),l.push(r[e],r[e+1],r[e+2],1)}},dispose(){M.prototype.dispose.call(this)}}),Object.defineProperties(Me,{typeName:{value:"NurbsCurve",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"closed",new(o().SFBool)),new(r())(c().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode))]),enumerable:!0}});const Ge=Me;f().set("x_ite/Components/NURBS/NurbsCurve",Ge);const We=Ge;function Ye(e){C.call(this,e),this.addType(c().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Object.assign(Object.setPrototypeOf(Ye.prototype,C.prototype),{getTessellation(e){return U.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed(e,t,i,n){return!!this._closed.getValue()&&U.getClosed2D(e,t,i,n)},getKnots:(e,t,i,n,o)=>U.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>U.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>U.getControlPoints2D(e,t,i,n,o),tessellate(e){const t=this.array;if(t.length=0,this._order.getValue()<2)return t;if(this._controlPoint.length<this._order.getValue())return t;const i=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),n=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,i,this._order.getValue(),n,this._controlPoint),s=this.getKnots(this.knots,i,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1),l=this.surface=(this.surface||Ke)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(s.length),this.sampleOptions.haveWeights=!!n;const a=Ke.sample(this.mesh,l,this.sampleOptions).points;switch(e){case 0:for(let e=0,i=a.length;e<i;e+=2)t.push(a[e],a[e+1]);break;case 1:for(let e=0,i=a.length;e<i;e+=2)t.push(a[e],0,a[e+1]);break;case 2:for(let e=0,i=a.length;e<i;e+=2)t.push(new(S())(a[e],a[e+1],0))}return t}}),Object.defineProperties(Ye,{typeName:{value:"NurbsCurve2D",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"closed",new(o().SFBool)),new(r())(c().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerable:!0}});const Je=Ye;f().set("x_ite/Components/NURBS/NurbsCurve2D",Je);const Le=Je,Ze=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Core/X3DChildNode");var He=e.n(Ze);const Qe=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Interpolation/OrientationInterpolator");var $e=e.n(Qe);const et=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Rotation4");var tt=e.n(et);function it(e){He().call(this,e),this.addType(c().NurbsOrientationInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new($e())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(it.prototype,He().prototype),{initialize(){He().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=g()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(e,t,i,n)=>!1,getKnots:(e,t,i,n,o)=>U.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>U.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>U.getControlPoints(e,t,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=n.at(-1)-n[0],s=this._order.getValue()-1,r=this.surface=(this.surface||Ke)({boundary:["open"],degree:[s],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!t;const l=Ke.sample(this.mesh,r,this.sampleOptions).points,a=this.interpolator;a._key.length=0,a._keyValue.length=0;for(let t=0,i=l.length-3;t<i;t+=3){const s=new(S())(l[t+3]-l[t+0],l[t+4]-l[t+1],l[t+5]-l[t+2]);a._key.push(n[0]+t/(i-3+3*e)*o),a._keyValue.push(new(tt())(S().zAxis,s))}e&&(a._key.push(n[0]+o),a._keyValue.push(a._keyValue[0]))}}),Object.defineProperties(it,{typeName:{value:"NurbsOrientationInterpolator",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(c().inputOutput,"order",new(o().SFInt32)(3)),new(r())(c().inputOutput,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"value_changed",new(o().SFRotation))]),enumerable:!0}});const nt=it;f().set("x_ite/Components/NURBS/NurbsOrientationInterpolator",nt);const ot=nt,st=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Algorithm");var rt=e.n(st);function lt(e){M.call(this,e),this.addType(c().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}Object.assign(Object.setPrototypeOf(lt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=g()(c().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=g()(c().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=g()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},setTessellationScale(e){this.tessellationScale=e,this.requestRebuild()},getUTessellation(e){return Math.floor(U.getTessellation(this._uTessellation.getValue(),e-this._uOrder.getValue())*this.tessellationScale)},getVTessellation(e){return Math.floor(U.getTessellation(this._vTessellation.getValue(),e-this._vOrder.getValue())*this.tessellationScale)},getUClosed(e,t,i,n,o,s){return!!this._uClosed.getValue()&&U.getUClosed(e,t,i,n,o,s)},getVClosed(e,t,i,n,o,s){return!!this._vClosed.getValue()&&U.getVClosed(e,t,i,n,o,s)},getUVWeights:(e,t,i,n)=>U.getUVWeights(e,t,i,n),getTexControlPoints:(e,t,i,n,o,s,r,l)=>U.getTexControlPoints(e,t,i,n,o,s,r,l),getUVControlPoints:(e,t,i,n,o,s,r,l,a)=>U.getUVControlPoints(e,t,i,n,o,s,r,l,a),getTrimmingContours(){},build(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()!==this._uDimension.getValue()*this._vDimension.getValue())return;const e=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),t=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),i=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),n=this.getUVControlPoints(this.controlPoints,e,t,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),i,this.controlPointNode),o=this.getKnots(this.uKnots,e,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,t,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),l=this._vOrder.getValue()-1,a=this.surface=(this.surface||Ke)({boundary:["open","open"],degree:[r,l],knots:[o,s],points:n,debug:!1}),u=this.sampleOptions;u.resolution[0]=this.getUTessellation(o.length),u.resolution[1]=this.getVTessellation(s.length),u.closed[0]=e,u.closed[1]=t,u.domain=void 0,u.haveWeights=!!i,u.trimmingContours=this.getTrimmingContours();const h=Ke.sample(this.mesh,a,u),d=h.faces,c=h.points,p=this.getVertices();for(let e=0,t=d.length;e<t;++e){const t=3*d[e];p.push(c[t],c[t+1],c[t+2],1)}this.buildNurbsTexCoords(e,t,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue(),a.domain),this.buildNormals(d,c),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords:function(){const e=[],t=[],i=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];function n(e,t){return e[0]=e[1]=t[0],e[2]=e[3]=t.at(-1),e}return function(o,s,r,l,a,u,h,d,c){const p=this.sampleOptions;if(this.texCoordNode&&this.texCoordNode.getSize()===h*d)var g=r-1,m=l-1,f=a,_=u,b=this.getTexControlPoints(this.texControlPoints,o,s,r,l,h,d,this.texCoordNode);else if(this.nurbsTexCoordNode&&this.nurbsTexCoordNode.isValid()){var w=this.nurbsTexCoordNode,v=(g=w._uOrder.getValue()-1,m=w._vOrder.getValue()-1,f=this.getKnots(this.texUKnots,!1,w._uOrder.getValue(),w._uDimension.getValue(),w._uKnot),_=this.getKnots(this.texVKnots,!1,w._vOrder.getValue(),w._vDimension.getValue(),w._vKnot),this.getUVWeights(this.texWeights,w._uDimension.getValue(),w._vDimension.getValue(),w._weight));b=w.getControlPoints(v)}else{g=1,m=1,f=n(e,a),_=n(t,u),b=i;p.domain=c}const y=this.texSurface=(this.texSurface||Ke)({boundary:["open","open"],degree:[g,m],knots:[f,_],points:b});p.closed[0]=!1,p.closed[1]=!1,p.haveWeights=!1;const N=Ke.sample(this.texMesh,y,p),C=N.faces,O=N.points,S=this.getTexCoords();for(let e=0,t=C.length;e<t;++e){const t=4*C[e];S.push(O[t],O[t+1],O[t+2],O[t+3])}this.getMultiTexCoords().push(this.getTexCoords())}}(),buildNormals(e,t){const i=this.createNormals(e,t),n=this.getNormals();for(const e of i)n.push(e.x,e.y,e.z)},createNormals(e,t){const i=this.createFaceNormals(e,t),n=[];for(let t=0,i=e.length;t<i;++t){const i=e[t];let o=n[i];o||(o=n[i]=[]),o.push(t)}return this.refineNormals(n,i,rt().radians(85))},createFaceNormals:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0),i=new(S())(0,0,0);return function(n,o){const s=this.faceNormals||[],r=n.length;for(let l=0;l<r;l+=3){const r=3*n[l],a=3*n[l+1],u=3*n[l+2];e.set(o[r],o[r+1],o[r+2]),t.set(o[a],o[a+1],o[a+2]),i.set(o[u],o[u+1],o[u+2]);const h=xe().normal(e,t,i,s[l]||new(S())(0,0,0));s[l]=h,s[l+1]=h,s[l+2]=h}return s.length=r,s}}()}),Object.defineProperties(lt,{typeName:{value:"X3DNurbsSurfaceGeometryNode",enumerable:!0},componentName:{value:"NURBS",enumerable:!0}});const at=lt;f().set("x_ite/Components/NURBS/X3DNurbsSurfaceGeometryNode",at);const ut=at;function ht(e){ut.call(this,e),this.addType(c().NurbsPatchSurface)}Object.setPrototypeOf(ht.prototype,ut.prototype),Object.defineProperties(ht,{typeName:{value:"NurbsPatchSurface",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(c().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"uClosed",new(o().SFBool)),new(r())(c().initializeOnly,"vClosed",new(o().SFBool)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"texCoord",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode))]),enumerable:!0}});const dt=ht;f().set("x_ite/Components/NURBS/NurbsPatchSurface",dt);const ct=dt,pt=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Interpolation/PositionInterpolator");var gt=e.n(pt);function mt(e){He().call(this,e),this.addType(c().NurbsPositionInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new(gt())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(mt.prototype,He().prototype),{initialize(){He().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=g()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(e,t,i,n)=>!1,getKnots:(e,t,i,n,o)=>U.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>U.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>U.getControlPoints(e,t,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),s=n.at(-1)-n[0],r=this._order.getValue()-1,l=this.surface=(this.surface||Ke)({boundary:["open"],degree:[r],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!t;const a=Ke.sample(this.mesh,l,this.sampleOptions).points,u=this.interpolator;u._key.length=0,u._keyValue.length=0;for(let e=0,t=a.length;e<t;e+=3)u._key.push(n[0]+e/(t-3)*s),u._keyValue.push(new(o().SFVec3f)(a[e],a[e+1],a[e+2]))}}),Object.defineProperties(mt,{typeName:{value:"NurbsPositionInterpolator",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(c().inputOutput,"order",new(o().SFInt32)(3)),new(r())(c().inputOutput,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"value_changed",new(o().SFVec3f))]),enumerable:!0}});const ft=mt;f().set("x_ite/Components/NURBS/NurbsPositionInterpolator",ft);const _t=ft,bt=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Grouping/X3DBoundedObject");var wt=e.n(bt);function vt(e){He().call(this,e),wt().call(this,e),this.addType(c().NurbsSet),this.geometryNodes=[]}function yt(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(vt.prototype,He().prototype),wt().prototype,{initialize(){He().prototype.initialize.call(this),wt().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox(e,t){for(const t of this.geometryNodes)e.add(t.getBBox());return e},set_tessellationScale__(){const e=Math.max(0,this._tessellationScale.getValue());for(const t of this.geometryNodes)t.setTessellationScale(e)},set_addGeometry__(){this._addGeometry.setTainted(!0),this._addGeometry.assign(yt(this._addGeometry,this._geometry));for(const e of this._addGeometry)this._geometry.push(e);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__(){this._removeGeometry.setTainted(!0),this._geometry.assign(yt(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__(){for(const e of this.geometryNodes)e.setTessellationScale(1);this.geometryNodes.length=0;for(const e of this._geometry){const t=g()(c().X3DNurbsSurfaceGeometryNode,e);t&&this.geometryNodes.push(t)}this.set_tessellationScale__()},dispose(){wt().prototype.dispose.call(this),He().prototype.dispose.call(this)}}),Object.defineProperties(vt,{typeName:{value:"NurbsSet",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellationScale",new(o().SFFloat)(1)),new(r())(c().inputOutput,"visible",new(o().SFBool)(!0)),new(r())(c().inputOutput,"bboxDisplay",new(o().SFBool)),new(r())(c().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(r())(c().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(r())(c().inputOnly,"addGeometry",new(o().MFNode)),new(r())(c().inputOnly,"removeGeometry",new(o().MFNode)),new(r())(c().inputOutput,"geometry",new(o().MFNode))]),enumerable:!0}});const Nt=vt;f().set("x_ite/Components/NURBS/NurbsSet",Nt);const Ct=Nt,Ot=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Geometry/Line3");var St=e.n(Ot);const Pt={isPointInTriangle(e,t,i,n){const o=(t.y-i.y)*(e.x-i.x)+(i.x-t.x)*(e.y-i.y);if(0==o)return!1;const s=((t.y-i.y)*(n.x-i.x)+(i.x-t.x)*(n.y-i.y))/o;if(s<0||s>1)return!1;const r=((i.y-e.y)*(n.x-i.x)+(e.x-i.x)*(n.y-i.y))/o;if(r<0||r>1)return!1;const l=1-s-r;return!(l<0||l>1)}};f().set("standard/Math/Geometry/Triangle2",Pt);const Dt=Pt;function Ft(e){He().call(this,e),this.addType(c().NurbsSurfaceInterpolator),this.geometry=new ct(e)}Object.assign(Object.setPrototypeOf(Ft.prototype,He().prototype),{initialize(){this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=128,this.geometry._vTessellation=128,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry.setup()},set_fraction__:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0),i=new(S())(0,0,0),n=new(S())(0,0,0),o=new(St())(S().Zero,S().zAxis),s={};return function(){const r=this._set_fraction.getValue(),l=this.geometry.getTexCoords(),a=this.geometry.getNormals(),u=this.geometry.getVertices();for(let h=0,d=0,c=l.length;h<c;h+=12,d+=9)if(e.set(l[h+0],l[h+1],0),t.set(l[h+4],l[h+5],0),i.set(l[h+7],l[h+9],0),Dt.isPointInTriangle(e,t,i,r)&&(o.set(n.set(r.x,r.y,0),S().zAxis),o.intersectsTriangle(e,t,i,s))){const e=s.u,t=s.v,i=s.t,n=new(S())(i*a[d+0]+e*a[d+3]+t*a[d+6],i*a[d+1]+e*a[d+4]+t*a[d+7],i*a[d+2]+e*a[d+5]+t*a[d+8]),o=new(S())(i*u[h+0]+e*u[h+4]+t*u[h+8],i*u[h+1]+e*u[h+5]+t*u[h+9],i*u[h+2]+e*u[h+6]+t*u[h+10]);this._normal_changed=n,this._position_changed=o}}}()}),Object.defineProperties(Ft,{typeName:{value:"NurbsSurfaceInterpolator",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFVec2f)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"normal_changed",new(o().SFVec3f)),new(r())(c().outputOnly,"position_changed",new(o().SFVec3f))]),enumerable:!0}});const Rt=Ft;f().set("x_ite/Components/NURBS/NurbsSurfaceInterpolator",Rt);const Vt=Rt,It=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Geometry3D/Extrusion");var Tt=e.n(It);function xt(e){M.call(this,e),this.addType(c().NurbsSweptSurface),this.extrusion=new(Tt())(e)}Object.assign(Object.setPrototypeOf(xt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},set_crossSectionCurve__(){this.crossSectionCurveNode&&this.crossSectionCurveNode.removeInterest("requestRebuild",this),this.crossSectionCurveNode=g()(c().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode&&this.crossSectionCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=g()(c().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.addInterest("requestRebuild",this)},build(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.crossSectionCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(0),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,i=e.length;t<i;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(xt,{typeName:{value:"NurbsSweptSurface",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(c().inputOutput,"crossSectionCurve",new(o().SFNode)),new(r())(c().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerable:!0}});const jt=xt;f().set("x_ite/Components/NURBS/NurbsSweptSurface",jt);const zt=jt;function kt(e){M.call(this,e),this.addType(c().NurbsSwungSurface),this.extrusion=new(Tt())(e)}Object.assign(Object.setPrototypeOf(kt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},set_profileCurve__(){this.profileCurveNode&&this.profileCurveNode.removeInterest("requestRebuild",this),this.profileCurveNode=g()(c().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode&&this.profileCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode&&this.trajectoryCurveNode.removeInterest("requestRebuild",this),this.trajectoryCurveNode=g()(c().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode.addInterest("requestRebuild",this)},build(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.profileCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(1),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,i=e.length;t<i;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(kt,{typeName:{value:"NurbsSwungSurface",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(c().inputOutput,"profileCurve",new(o().SFNode)),new(r())(c().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerable:!0}});const At=kt;f().set("x_ite/Components/NURBS/NurbsSwungSurface",At);const Bt=At;function Xt(e){h().call(this,e),this.addType(c().NurbsTextureCoordinate),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(Xt.prototype,h().prototype),{initialize(){h().prototype.initialize.call(this)},getControlPoints(e){const t=this._controlPoint.getValue(),i=this.controlPoints;for(let n=0,o=this._uDimension.getValue();n<o;++n){let s=i[n];s||(s=i[n]=[]);for(let i=0,r=this._vDimension.getValue();i<r;++i){const r=i*o+n,l=s[i]||new(X()),a=2*r;s[i]=l.set(t[a],t[a+1],0,e?e[r]:1)}}return i},isValid(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&this._controlPoint.length===this._uDimension.getValue()*this._vDimension.getValue())))}}),Object.defineProperties(Xt,{typeName:{value:"NurbsTextureCoordinate",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"texCoord",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2f))]),enumerable:!0}});const Et=Xt;f().set("x_ite/Components/NURBS/NurbsTextureCoordinate",Et);const Ut=Et;function qt(e){ut.call(this,e),this.addType(c().NurbsTrimmedSurface),this.trimmingContourNodes=[]}function Kt(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(qt.prototype,ut.prototype),{initialize(){ut.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Kt(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const e of this._addTrimmingContour)this._trimmingContour.push(e);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Kt(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__(){const e=this.trimmingContourNodes;e.length=0;for(const t of this._trimmingContour){const i=g()(c().Contour2D,t);i&&e.push(i)}},getTrimmingContours(){const e=this.trimmingContourNodes,t=[];for(const i of e)i.addTrimmingContour(t);return t}}),Object.defineProperties(qt,{typeName:{value:"NurbsTrimmedSurface",enumerable:!0},componentName:{value:"NURBS",enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(c().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"uClosed",new(o().SFBool)),new(r())(c().initializeOnly,"vClosed",new(o().SFBool)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"texCoord",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().inputOnly,"addTrimmingContour",new(o().MFNode)),new(r())(c().inputOnly,"removeTrimmingContour",new(o().MFNode)),new(r())(c().inputOutput,"trimmingContour",new(o().MFNode))]),enumerable:!0}});const Mt=qt;f().set("x_ite/Components/NURBS/NurbsTrimmedSurface",Mt);const Gt=Mt;i().add({name:"NURBS",concreteNodes:[v,F,x,We,Le,ot,ct,_t,Ct,Vt,zt,Bt,Ut,Gt],abstractNodes:[C,ut,M]});const Wt=void 0;f().set("assets/components/NURBS",Wt)})();
>>>>>>> development
