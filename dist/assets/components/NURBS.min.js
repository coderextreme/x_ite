/* X_ITE v8.7.8 */(()=>{"use strict";var e={n:t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return e.d(n,{a:n}),n},d:(t,n)=>{for(var i in n)e.o(n,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:n[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components");var n=e.n(t);const i=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Fields");var o=e.n(i);const s=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DFieldDefinition");var r=e.n(s);const u=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/FieldDefinitionArray");var a=e.n(u);const l=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Core/X3DNode");var h=e.n(l);const c=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DConstants");var d=e.n(c);const g=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Base/X3DCast");var p=e.n(g);const f=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Namespace");var m=e.n(f);function _(e){h().call(this,e),this.addType(d().Contour2D),this.childNodes=[]}function w(e,t){const n=new Set(t);return e.filter((e=>!n.has(e)))}_.prototype=Object.assign(Object.create(h().prototype),{constructor:_,initialize:function(){h().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__:function(){this._addChildren.setTainted(!0),this._addChildren.assign(w(this._addChildren,this._children));for(const e of this._addChildren)this._children.push(e);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__:function(){this._removeChildren.setTainted(!0),this._children.assign(w(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__:function(){const e=this.childNodes;e.length=0;for(const t of this._children){const n=p()(d().NurbsCurve2D,t);if(n)e.push(n);else{const n=p()(d().ContourPolyline2D,t);if(n){e.push(n);continue}}}},addTrimmingContour:function(e){for(const t of this.childNodes)e.push(t.tessellate(2))}}),Object.defineProperties(_,{typeName:{value:"Contour2D",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"trimmingContour",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"addChildren",new(o().MFNode)),new(r())(d().inputOnly,"removeChildren",new(o().MFNode)),new(r())(d().inputOutput,"children",new(o().MFNode))]),enumerate:!0}});const v=_;m().set("x_ite/Components/NURBS/Contour2D",v);const y=v;function b(e){h().call(this,e),this.addType(d().X3DNurbsControlCurveNode)}b.prototype=Object.assign(Object.create(h().prototype),{constructor:b}),Object.defineProperties(b,{typeName:{value:"X3DNurbsControlCurveNode",enumerate:!0},componentName:{value:"NURBS",enumerate:!0}});const N=b;m().set("x_ite/Components/NURBS/X3DNurbsControlCurveNode",N);const C=N,O=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector3");var S=e.n(O);function P(e){C.call(this,e),this.addType(d().ContourPolyline2D),this.controlPoints=[]}P.prototype=Object.assign(Object.create(C.prototype),{constructor:P,tessellate:function(e){switch(e){case 0:{const e=this._controlPoint.getValue(),t=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i;t[n+0]=e[n+0],t[n+1]=e[n+1]}return t.length=2*n,t}case 1:{const e=this._controlPoint.getValue(),t=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i,o=3*i;t[o+0]=e[n+0],t[o+1]=0,t[o+2]=e[n+1]}return t.length=3*n,t}case 3:{const e=this._controlPoint.getValue(),t=this.controlPoints,n=this._controlPoint.length;for(let i=0;i<n;++i){const n=2*i;t[i]=new(S())(e[n+0],e[n+1],0)}return t.length=n,t}}}}),Object.defineProperties(P,{typeName:{value:"ContourPolyline2D",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerate:!0}});const D=P;m().set("x_ite/Components/NURBS/ContourPolyline2D",D);const F=D,R=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DCoordinateNode");var V=e.n(R);function I(e){V().call(this,e),this.addType(d().CoordinateDouble)}I.prototype=Object.assign(Object.create(V().prototype),{constructor:I}),Object.defineProperties(I,{typeName:{value:"CoordinateDouble",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"coord",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"point",new(o().MFVec3d))]),enumerate:!0}});const T=I;m().set("x_ite/Components/NURBS/CoordinateDouble",T);const x=T,j=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DGeometryNode");var z=e.n(j);const k=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector2");var A=e.n(k);const B=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Vector4");var X=e.n(B);const E={getTessellation:function(e,t){return e>0?e+1:e<0?-e*t+1:2*t+1},getClosed2D:function(e,t,n,i){const o=i.length;return(!(n.length===o)||n[0]===n[o-1])&&(!!i[0].equals(i[o-1])&&!!this.isPeriodic(e,o,t))},getClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(n,i,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&(!!s.get1Point(0,e).equals(s.get1Point(r-1,t))&&!!this.isPeriodic(n,r,i))}}(),getUClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(n,i,o,s,r,u){const a=r.length===u.getSize();for(let n=0,s=o;n<s;++n){const o=n*i,s=n*i+i-1;if(a&&r[o]!==r[s])return!1;if(!u.get1Point(o,e).equals(u.get1Point(s,t)))return!1}return!!this.isPeriodic(n,i,s)}}(),getVClosed:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0);return function(n,i,o,s,r,u){const a=r.length===u.getSize();for(let n=0,s=i;n<s;++n){const s=n,l=(o-1)*i+n;if(a&&r[s]!==r[l])return!1;if(!u.get1Point(s,e).equals(u.get1Point(l,t)))return!1}return!!this.isPeriodic(n,o,s)}}(),isPeriodic:function(e,t,n){if(n.length===t+e){{let t=1;for(let i=1,o=e;i<o;++i)t+=n[i]===n[0];if(t===e)return!1}{let t=1;for(let i=n.length-e,o=n.length-1;i<o;++i)t+=n[i]===n[o];if(t===e)return!1}}return!0},getKnots:function(e,t,n,i,o){const s=e||[];for(let e=0,t=o.length;e<t;++e)s[e]=o[e];s.length=o.length;let r=!0;if(s.length===i+n){r=!1;let e=0;for(let t=1,i=s.length;t<i;++t)s[t]==s[t-1]?++e:e=0,e>n-1&&(r=!0),s[t-1]>s[t]&&(r=!0)}if(r)for(let e=0,t=i+n;e<t;++e)s[e]=e/(t-1);if(t)for(let e=1,t=n-1;e<t;++e)s.push(s.at(-1)+(s[e]-s[e-1]));return s},getWeights:function(e,t,n){if(n.length!==t)return;const i=e||[];for(let e=0;e<t;++e)i[e]=n[e];return i.length=t,i},getUVWeights:function(e,t,n,i){const o=t*n;if(i.length!==o)return;const s=e||[];for(let e=0,o=0;e<t;++e)for(let e=0;e<n;++e,++o)s[o]=i[o];return s.length=o,s},getControlPoints2D:function(e,t,n,i,o){const s=e||[],r=o.getValue(),u=o.length,a=!!i,l=a?S():A();s.haveWeights!==a&&(s.haveWeights=a,s.length=0);for(let e=0;e<u;++e){const t=2*e,n=s[e]||new l(0,0,0);s[e]=n.set(r[t+0],r[t+1],a?i[e]:0)}if(s.length=u,t)for(let e=1,t=n-1;e<t;++e)s.push(s[e]);return s},getControlPoints:function(e,t,n,i,o){const s=e||[],r=o.getSize(),u=!!i,a=u?X():S();s.haveWeights!==u&&(s.haveWeights=u,s.length=0);for(let e=0;e<r;++e){const t=s[e]=o.get1Point(e,s[e]||new a(0,0,0,0));u&&(t.w=i[e])}if(s.length=r,t)for(let e=1,t=n-1;e<t;++e)s.push(s[e]);return s},getUVControlPoints:function(e,t,n,i,o,s,r,u,a){const l=e||[],h=!!u,c=h?X():S();l.haveWeights!==h&&(l.haveWeights=h,l.length=0);for(let e=0;e<s;++e){let t=l[e];t||(t=l[e]=[]);for(let n=0;n<r;++n){const i=n*s+e;t[n]=a.get1Point(i,t[n]||new c(0,0,0,0)),h&&(t[n].w=u[i])}if(t.length=r,n)for(let e=1,n=o-1;e<n;++e)t.push(t[e])}if(l.length=s,t)for(let e=1,t=i-1;e<t;++e)l.push(l[e]);return l},getTexControlPoints:function(e,t,n,i,o,s,r,u){const a=e||[];for(let e=0;e<s;++e){let t=a[e];t||(t=a[e]=[]);for(let n=0;n<r;++n){const i=n*s+e;t[n]=u.get1Point(i,t[n]||new(X())(0,0,0,0))}if(t.length=r,n)for(let e=1,n=o-1;e<n;++e)t.push(t[e])}if(a.length=s,t)for(let e=1,t=i-1;e<t;++e)a.push(a[e]);return a}};m().set("x_ite/Browser/NURBS/NURBS",E);const U=E;function q(e){z().call(this,e),this.addType(d().X3DParametricGeometryNode)}q.prototype=Object.assign(Object.create(z().prototype),{constructor:q,getKnots:function(e,t,n,i,o){return U.getKnots(e,t,n,i,o)}}),Object.defineProperties(q,{typeName:{value:"X3DParametricGeometryNode",enumerate:!0},componentName:{value:"NURBS",enumerate:!0}});const K=q;m().set("x_ite/Components/NURBS/X3DParametricGeometryNode",K);const M=K,G=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Rendering/X3DLineGeometryNode");var W=e.n(G);const Y=function(e){return!!e&&(!!e.dtype&&new RegExp("function View[0-9]+d(:?"+e.dtype+")+").test(String(e.constructor)))};m().set("lib/nurbs/src/utils/is-ndarray",Y);const J=Y,L=function(e){return!!e&&(void 0!==e.data&&Array.isArray(e.shape)&&void 0!==e.offset&&void 0!==e.stride)};m().set("lib/nurbs/src/utils/is-ndarray-like",L);const Z=L,H=function(e){return Array.isArray(e)||ArrayBuffer.isView(e)||void 0!==e.length};m().set("lib/nurbs/src/utils/is-array-like",H);const Q=H;function $(e){if(e){if(J(e)||Z(e))return"generic"===e.dtype?$.GENERIC_NDARRAY:$.NDARRAY;if(Q(e)){for(var t=e;Q(t[0]);t=t[0]);return"x"in t?$.ARRAY_OF_OBJECTS:$.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof e)}}$.ARRAY_OF_OBJECTS="Obj",$.ARRAY_OF_ARRAYS="Arr",$.NDARRAY="Nd",$.GENERIC_NDARRAY="GenNd",$.PACKED="PackArr";const ee=$;m().set("lib/nurbs/src/utils/infer-type",ee);const te=ee;const ne=function(e,t,n,i,o,s){var r,u,a=[],l=!1;for(r=0;r<e.splineDimension;r++){var h=Q(e.knots)&&Q(e.knots[r]);h&&(l=!0),a.push("Deg"+e.degree[r]+(h?"":"Uniform")+((u=e.boundary[r])[0].toUpperCase()+u.slice(1)))}var c=[[l?"NU":"",e.weights?"RBS":"BS"].join("")+e.dimension+"D",a.join("_")];return i&&c.push(i+"Pts"),o&&c.push(o+"Wts"),s&&c.push(s+"Kts"),t&&c.push("debug"),n&&c.push("chk"),c.join("_")};m().set("lib/nurbs/src/utils/cache-key",ne);const ie=ne;var oe=function e(t,n){return function(n,i){void 0===n||Array.isArray(n)||(n=[n]);for(var o=[],s=0;s<n.length;s++)o.push(e.sum(n[s]));if(i)for(n=0;n<o.length;n++)void 0!==i[n]&&(o[n]="("+o[n]+" + "+i[n]+") % "+i[n]);return t+o.join("_")}};oe.sum=function(e){return 0===(e=(e=Array.isArray(e)?e:[e]).filter((function(e){return void 0!==e&&0!==e}))).length&&e.push(0),e.join(" + ")};const se=oe;m().set("lib/nurbs/src/utils/variable",se);const re=se;var ue=[".x",".y",".z",".w"];function ae(e){return function(t,n){void 0===t||Array.isArray(t)||(t=[t]);for(var i=[],o=0;o<t.length;o++)i.push(re.sum(t[o]));if(n)for(t=0;t<i.length;t++)void 0!==n[t]&&(i[t]="("+i[t]+" + "+n[t]+") % "+n[t]);return e(i)}}function le(e,t){if(t)switch(te(t)){case te.ARRAY_OF_OBJECTS:return ae((function(t){var n=t.pop();return e+"["+t.join("][")+"]"+ue[n]}));case te.ARRAY_OF_ARRAYS:return ae((function(t){return e+"["+t.join("][")+"]"}));case te.GENERIC_NDARRAY:return ae((function(t){return e+".get("+t.join(",")+")"}));case te.NDARRAY:return ae((function(t){for(var n=[e+"Offset"],i=0;i<t.length;i++)n.push(e+"Stride"+i+" * ("+t[i]+")");return e+"["+n.join(" + ")+"]"}));case te.PACKED:default:return}}const he=function(e){var t,n={};return(t=le("x",e.points))&&(n.point=t),(t=le("w",e.weights))&&(n.weight=t),(t=le("k",e.knots))&&(n.knot=t),n};m().set("lib/nurbs/src/utils/create-accessors",he);const ce=he;var de=[],ge=[];const pe=function(e,t,n){if(1!==t)throw new Error("Numerical derivative not implemented for order n = "+t+".");var i,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(de.length=this.splineDimension,i=0;i<this.splineDimension;i++)de[i+1]=arguments[i+3];var s,r,u,a=this.domain,l=a[n][0],h=a[n][1],c=de[n+1],d=(h-l)*o;for("closed"===this.boundary[n]?(s=l+(c-l-d+(u=h-l))%u,r=l+(c-l+d+u)%u,d*=2):(s=Math.min(h,Math.max(l,c-d)),d=(r=Math.min(h,Math.max(l,c+d)))-s),de[n+1]=s,de[0]=ge,this.evaluate.apply(null,de),de[n+1]=r,de[0]=e,this.evaluate.apply(null,de),i=0;i<this.dimension;i++)e[i]=(e[i]-ge[i])/d;return e};m().set("lib/nurbs/src/numerical-derivative",pe);const fe=pe,me=function(e,t){for(var n=1,i=0,o=[];i<e.length;i++)n*=Array.isArray(e[i])?e[i][1]-e[i][0]:e[i],o[i]=Array.isArray(e[i])?e[i][0]:0;for(var s=0;s<n;s++)for(t(o.slice()),i=e.length-1;i>=0;i--){if(o[i]!==(Array.isArray(e[i])?e[i][1]:e[i])-1){o[i]++;break}o[i]=Array.isArray(e[i])?e[i][0]:0}};m().set("lib/nurbs/src/utils/ndloop",me);const _e=me,we=function(e,t,n,i){var o=[];switch(te(i)){case te.NDARRAY:o.push("  var "+t+" = "+n+".data;"),o.push("  var "+t+"Offset = "+n+".offset;");for(var s=0;s<i.dimension;s++)o.push("  var "+t+"Stride"+s+" = "+n+".stride["+s+"];");break;case te.ARRAY_OF_OBJECTS:case te.ARRAY_OF_ARRAYS:o.push("  var "+t+" = "+n+";")}return o.join("\n")};m().set("lib/nurbs/src/utils/accessor-preamble",we);const ve=we,ye=function(e,t,n){if(e){if(Z(e))return t+".shape["+n+"]";for(var i=t,o=0;o<n;o++)i+="[0]";return i+".length"}return"this.size["+n+"]"};m().set("lib/nurbs/src/utils/size-getter",ye);const be=ye;var Ne={},Ce={};const Oe=function(e,t,n,i,o,s,r){var u,a,l,h,c,d,g=t.splineDimension,p=t.points,f=t.degree,m=t.weights,_=void 0!==m,w=t.knots,v=t.dimension,y=t.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var b=0;for(u=0;u<g;u++)void 0===r[u]&&(r[u]=0),b+=r[u];if(_&&b>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+b+".")}s&&(e="Basis"+e),r&&(e="Der"+r.join("_")+"_"+e);var N=Ne[e];if(i)var C="function"==typeof i?i:console.log;if(N)return i&&C(Ce[e]),N.bind(t);var O=[],S="evaluate"+e,P=n.point;s&&(P=function(e,t){for(var n=[],i=0;i<e.length;i++){for(var o=e[i],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),t[i]&&(o="("+o+" + "+t[i]+") % "+t[i]),n.push(o+" === "+T(i))}return"(("+n.join(" && ")+") ? 1 : 0)"});var D=n.weight,F=n.knot,R=re("k"),V=re("x"),I=re("w"),T=re("i"),x=re("t"),j=i?"domain":"d",z=re(i?"size":"s"),k=re(i?"knotIndex":"j"),A=!0;for(c=0;c<g;c++)Q(w)&&Q(w[c])&&(A=!1);function B(e){O.push("  "+(e||""))}function X(e){i&&B(e)}if(s)var E=[];var U=[];for(u=0;u<g;u++)s&&E.push(T([u])),U.push(x([u]));for(O.push("function "+S+" ("+(s?"":"out, ")+U.join(", ")+(s?", "+E.join(", "):"")+") {"),B("var h, m, a, b;"),o&&(B("var "+j+" = this.domain;"),B("for (var i = 0; i < this.splineDimension; i++) {"),B("  a = arguments[i + 1];"),B("  if (a < "+j+"[i][0] || a > "+j+"[i][1] || a === undefined || isNaN(a)) {"),B('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+j+'[i][0]+", "+'+j+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),B("  }"),B("}")),c=0;c<g;c++)B("var "+z(c)+" = "+be(p,"this.points",c)+";");function q(e,t,n){return"("+e+") ? ("+t+") : ("+n+")"}O.push(ve(t,"x","this.points",p)),_&&O.push(ve(t,"w","this.weights",m)),A||O.push(ve(t,"k","this.knots",w));var K=[];for(c=0;c<g;c++)switch(te(w)){case te.NDARRAY:K[c]=!0;break;case te.ARRAY_OF_ARRAYS:K[c]=Q(w[c])}for(c=0;c<g;c++)if(K[c])for(X("\n  // Bisect to locate the knot interval in dimension "+c+"\n"),B("var "+k(c)+" = 0;"),B("h = "+z(c)+";"),B("while(h > "+k(c)+" + 1) {"),B("  m = 0.5 * (h + "+k(c)+") | 0;"),B("  if ("+F([c,"m"])+" > "+x(c)+") h = m;"),B("  else "+k(c)+" = m;"),B("}"),X("\n  // Fetch knots for dimension "+c+"\n"),u=1-f[c];u<=f[c];u++)"closed"===y[c]?B(u<0?"var "+R([c,u+f[c]-1])+" = "+q(k(c)+" < "+-u,F([c,0])+" + "+F([c,[z(c),k(c),u]])+" - "+F([c,[z(c)]]),F([c,[k(c),u]]))+";":u>0?"var "+R([c,u+f[c]-1])+" = "+q(k(c)+" + "+u+" > "+z(c),F([c,z(c)])+" + "+F([c,u+" + "+k(c)+" - "+z(c)])+" - "+F([c,0]),F([c,[k(c),u]]))+";":"var "+R([c,u+f[c]-1])+" = "+F([c,[k(c),u]])+";"):B("var "+R([c,u+f[c]-1])+" = "+F([c,[k(c),u]])+";");else{for(X("\n  // Directly compute knot interval for dimension "+c+"\n"),"closed"===y[c]?B(k(c)+" = ("+x(c)+" | 0) % "+z(c)+";"):(B(k(c)+" = ("+x(c)+" | 0);"),B("if ("+k(c)+" < "+f[c]+") "+k(c)+" = "+f[c]+";"),B("if ("+k(c)+" > "+z(c)+" - 1) "+k(c)+" = "+z(c)+" - 1;")),X("\n  // Compute and clamp knots for dimension "+c+"\n"),u=1-f[c];u<=f[c];u++)B("var "+(d=R([c,u+f[c]-1]))+" = "+k(c)+" + "+u+";");if("clamped"===y[c])for(u=1-f[c];u<=f[c];u++)d=R([c,u+f[c]-1]),u<0&&B("if ("+d+" < "+f[c]+") "+d+" = "+f[c]+";"),u>0&&B("if ("+d+" > "+z(c)+") "+d+" = "+z(c)+";");"closed"===y[c]&&(X("\n  // Wrap the B-Spline parameter for closed boundary"),B(x(c)+" %= "+z(c)+";"))}for(c=0,l=[];c<g;c++)l[c]=f[c]+1;for(_&&(X("\n  // Fetch weights\n"),_e(l,(function(e){for(var t=[],n=[],i=0;i<g;i++)t[i]=[k(i),e[i]-f[i]],"closed"===y[i]&&e[i]-f[i]<0&&(n[i]=z(i));B("var "+I(e)+" = "+D(t,n)+";")}))),i&&B(_?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),_e(l,(function(e){for(var t=[],n=[],i=0;i<g;i++)t[i]=[k(i),e[i]-f[i]],"closed"===y[i]&&e[i]-f[i]<0&&(n[i]=z(i));if(s)B(_?"var "+V(e)+" = "+P(t,n)+" * "+I(e)+";":"var "+V(e)+" = "+P(t,n)+";");else for(i=0;i<v;i++){var o=e.concat(i);t[g]=i,B(_?"var "+V(o)+" = "+P(t,n)+" * "+I(e)+";":"var "+V(o)+" = "+P(t,n)+";")}})),X("\n"),X('// Perform De Boor"s algorithm'),c=l.length-1;c>=0;c--)for(l[c]=[f[c],f[c]+1],u=0;u<f[c];u++)for(X("\n  // Degree "+f[c]+" evaluation in dimension "+c+", step "+(u+1)+"\n"),a=f[c];a>u;a--){var M=r&&f[c]-u-r[c]<=0;M?(B("m = 1 / ("+R([c,a-u+f[c]-1])+" - "+R([c,a-1])+");"),_&&(B("a = ("+x(c)+" - "+R([c,a-1])+") * m;"),B("b = 1 - a;"))):(B("a = ("+x(c)+" - "+R([c,a-1])+") / ("+R([c,a-u+f[c]-1])+" - "+R([c,a-1])+");"),B("b = 1 - a;")),_&&_e(l,(function(e){var t=e.slice(),n=e.slice();t[c]=a,n[c]=a-1,M&&_&&B("h = "+I(t)+";"),B(I(t)+" = b * "+I(n)+" + a * "+I(t)+";")})),_e(l,(function(e){var t,n,i,o=e.slice(),r=e.slice();if(o[c]=a,r[c]=a-1,M){var l=u+1;if(s)t=_?"h * "+I(r)+" / "+I(o)+" * ":"",n=V(o)+(_?" / h":""),i=V(r)+(_?" / "+I(r):""),B(V(o)+" = "+l+" * "+t+"("+n+" - "+i+") * m;");else{var d=o.slice(),p=r.slice();for(h=0;h<v;h++)d[g]=p[g]=h,t=_?"h * "+I(r)+" / "+I(o)+" * ":"",n=V(d)+(_?" / h":""),i=V(p)+(_?" / "+I(r):""),B(V(d)+" = "+l+" * "+t+"("+n+" - "+i+") * m;")}}else if(s)B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";");else for(h=0;h<v;h++)o[g]=r[g]=h,B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";")})),X("\n")}if(i&&B(_?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)B(_?"return "+V(f)+" / "+I(f)+";":"return "+V(f)+";");else for(c=0;c<v;c++)B(_?"out["+c+"] = "+V(f.concat([c]))+" / "+I(f)+";":"out["+c+"] = "+V(f.concat([c]))+";");if(s||B("return out;"),O.push("}"),i){var G=O.join("\n");C(G),Ce[e]=G}var W=new Function([O.join("\n"),"; return ",S].join(""))();return Ne[e]=W,W.bind(t)};m().set("lib/nurbs/src/evaluate",Oe);const Se=Oe;var Pe={};const De=function(e,t,n,i){var o,s,r,u,a,l,h,c,d=Pe[e];if(d)return d.bind(t);var g=[],p="transform"+e;g.push("function "+p+"(m) {"),g.push("var i, w;"),g.push(ve(t,"x","this.points",t.points));var f=re(i?"size":"s");for(o=0;o<t.splineDimension;o++)g.push("var "+f(o)+" = "+be(t.points,"this.points",o)+";");for(u=[],o=0;o<t.splineDimension;o++)r="i"+o,u.push(r),g.push("for ("+r+" = "+f(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<t.dimension;o++)g.push("x"+o+" = "+n.point(u.concat([o])));for(a=[],o=0;o<t.dimension;o++)a.push("m["+((t.dimension+1)*(o+1)-1)+"] * x"+o);for(a.push("m["+((t.dimension+1)*(t.dimension+1)-1)+"]"),g.push("var w = ("+a.join(" + ")+") || 1.0;"),o=0;o<t.dimension;o++){for(a=[],l=t.dimension,s=0;s<l;s++)a.push("m["+(s*(l+1)+o)+"] * x"+s);a.push("m["+(s*(l+1)+o)+"]"),c=n.point(u.concat([o])),h="("+a.join(" + ")+") / w",g.push(c+" = "+h+";")}for(o=t.splineDimension-1;o>=0;o--)g.push("}");g.push("return this;"),g.push("}");var m=new Function([g.join("\n"),"; return ",p].join(""))();return i&&console.log(g.join("\n")),Pe[e]=m,m.bind(t)};m().set("lib/nurbs/src/transform",De);const Fe=De;var Re={};const Ve=function(e,t,n,i,o){var s=Re[e];if(s)return s.bind(t);var r,u,a,l=t.degree,h=t.knots,c=t.splineDimension,d=t.boundary,g=[],p="support"+e,f=n.knot,m=re("t"),_=i?"domain":"d",w=re(i?"size":"s"),v=re(i?"knotIndex":"i"),y=!0;for(a=0;a<c;a++)Q(h)&&Q(h[a])&&(y=!1);function b(e){g.push("  "+(e||""))}var N=[];for(r=0;r<c;r++)N.push(m([r]));g.push("function "+p+" (out, "+N.join(", ")+") {");var C=0;function O(e,t){b(void 0===t?"out["+C+++"] = "+e.join(" + ")+";":"out["+C+++"] = ("+e.join(" + ")+" + "+t+") % "+t+";")}for(b("var h, m;"),b("var c = 0;"),o&&(b("var "+_+" = this.domain;"),b("for (var i = 0; i < this.splineDimension; i++) {"),b("  a = arguments[i + 1];"),b("  if (a < "+_+"[i][0] || a > "+_+"[i][1] || a === undefined || isNaN(a)) {"),b('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+_+'[i][0]+", "+'+_+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),b("  }"),b("}")),a=0;a<c;a++)b("var "+w(a)+" = "+be(t.points,"this.points",a)+";");y||g.push(ve(t,"k","this.knots",h));var S=[];for(a=0;a<c;a++)switch(te(h)){case te.NDARRAY:S[a]=!0;break;case te.ARRAY_OF_ARRAYS:S[a]=Q(h[a])}for(a=0;a<c;a++)S[a]?(b("var "+v(a)+" = 0;"),b("h = "+w(a)+";"),b("while(h > "+v(a)+" + 1) {"),b("  m = 0.5 * (h + "+v(a)+") | 0;"),b("  if ("+f([a,"m"])+" > "+m(a)+") h = m;"),b("  else "+v(a)+" = m;"),b("}")):"closed"===d[a]?b(v(a)+" = ("+m(a)+" | 0) % "+w(a)+";"):(b(v(a)+" = ("+m(a)+" | 0);"),b("if ("+v(a)+" < "+l[a]+") "+v(a)+" = "+l[a]+";"),b("if ("+v(a)+" > "+w(a)+" - 1) "+v(a)+" = "+w(a)+" - 1;"));for(a=0,u=[];a<c;a++)u[a]=l[a]+1;_e(u,(function(e){for(var t=[],n=[],i=0;i<c;i++)t[i]=[v(i),e[i]-l[i]],"closed"===d[i]&&e[i]-l[i]<0&&(n[i]=w(i));for(i=0;i<c;i++)O(t[i],n[i])})),b("out.length = "+C+";"),b("return out;"),g.push("}"),i&&console.log(g.join("\n"));var P=new Function([g.join("\n"),"; return ",p].join(""))();return Re[e]=P,P.bind(t)};m().set("lib/nurbs/src/support",Ve);const Ie=Ve,Te=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Geometry/Triangle3");var xe=e.n(Te),je=[];const ze=function(e,t,n){n=n||{};var i=(e=e||{}).points=e.points||[],o=e.faces=e.faces||[],s=n.haveWeights,r=t.dimension-s;if(Array.isArray(n.resolution))var u=n.resolution;else{var a=void 0===n.resolution?31:n.resolution;u=new Array(t.splineDimension).fill(a)}switch(t.splineDimension){case 1:for(var l=(m=(w=u[0])+!(y="closed"===t.boundary[0]))*r,h=(N=(_=n.domain||t.domain)[0])[1]-N[0],c=0;c<m;++c){var d=N[0]+h*c/w,g=c*r;if(t.evaluate(je,d),s)for(var p=je[r],f=0;f<r;++f)i[g+f]=je[f]/p;else for(f=0;f<r;++f)i[g+f]=je[f]}i.length=l;break;case 2:var m,_,w=u[0],v=u[1],y="closed"===t.boundary[0],b=v+!(D="closed"===t.boundary[1]),N=(l=(m=w+!y)*b*r,(_=n.domain||t.domain)[0]),C=_[1],O=(h=N[1]-N[0],C[1]-C[0]);for(c=0;c<m;++c){d=N[0]+h*c/w;for(var S=0;S<b;++S){var P=C[0]+O*S/v;g=(c+m*S)*r;if(t.evaluate(je,d,P),s)for(p=je[r],f=0;f<r;++f)i[g+f]=je[f]/p;else for(f=0;f<r;++f)i[g+f]=je[f]}}i.length=l;y=n.closed[0];var D=n.closed[1],F=0;for(c=0;c<w;++c){var R=c,V=c+1;y&&(V%=w);for(S=0;S<v;++S){var I=S,T=S+1;D&&(T%=v),o[F++]=R+m*I,o[F++]=V+m*I,o[F++]=V+m*T,o[F++]=R+m*I,o[F++]=V+m*T,o[F++]=R+m*T}}o.length=F;break;default:throw new Error("Can only sample contours and surfaces")}return e};m().set("lib/nurbs/extras/sample",ze);const ke=ze;var Ae={open:"open",closed:"closed",clamped:"clamped"};function Be(e){return null==e}function Xe(e,t,n,i,o,s){var r,u;!e||Q(e)||J(e)?(s=s||{},this.weights=i,this.knots=n,this.degree=t,this.points=e,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=e,this.debug=e.debug,this.checkBounds=!!e.checkBounds,this.weights=e.weights,this.knots=e.knots,this.degree=e.degree,this.boundary=e.boundary,this.points=e.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var a=te(this.points),l=te(this.weights),h=te(this.knots);if(this.points)switch(a){case te.GENERIC_NDARRAY:case te.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case te.ARRAY_OF_OBJECTS:case te.ARRAY_OF_ARRAYS:var c=0,d=this.size||[];d.length=0;for(var g=this.points;Q(g[0]);g=g[0])c++,d.push(g.length);if(0===c)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:c,writable:!1,configurable:!0},dimension:{value:g.length,writable:!1,configurable:!0},size:{get:function(){var e=[];e.length=0;for(var t=0,n=this.points;t<this.splineDimension;t++,n=n[0])e[t]=n.length;return e},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case te.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(Q(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(Q(this.degree)){for(r=0;r<this.splineDimension;r++)if(Be(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var p=!Be(this.degree),f=Be(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=f){if(p)throw new Error("Expected at least "+(f+1)+" points for degree "+f+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=f}if(u="string"!=typeof this.boundary?"open":this.boundary,!Ae[u])throw new Error("Boundary type must be one of "+Object.keys(Ae)+". Got "+u);for(this.boundary=Q(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=Be(this.boundary[r])?u:this.boundary[r],!Ae[u])throw new Error("Boundary type must be one of "+Object.keys(Ae)+". Got "+u+" for dimension "+(r+1));switch(h){case te.ARRAY_OF_ARRAYS:for(Q(this.knots)&&this.knots.length>0&&!Q(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(Q(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case te.NDARRAY:}var m=ie(this,this.debug,this.checkBounds,a,l,h);if(m!==this.__cacheKey){this.__cacheKey=m;var _=ce(this);this.evaluate=Se(this.__cacheKey,this,_,this.debug,this.checkBounds,!1),this.transform=Fe(this.__cacheKey,this,_,this.debug),this.support=Ie(this.__cacheKey,this,_,this.debug,this.checkBounds),this.evaluator=function(e,t){return Se(this.__cacheKey,this,_,this.debug,this.checkBounds,t,e)}}return this.numericalDerivative=fe.bind(this),this}function Ee(){var e,t=[],n=this.points;n?Z(n)&&(e=n.shape):e=this.size;for(var i=0;i<this.splineDimension;i++){var o=e?e[i]:n.length,s=this.degree[i],r="closed"===this.boundary[i];if(this.knots&&this.knots[i]){var u=this.knots[i];t[i]=[u[r?0:s],u[o]]}else t[i]=[r?0:s,o];n&&(n=n[0])}return t}function Ue(e,t,n,i,o,s){var r=function(e,t,n,i,o,s){return u(e,t,n,i,o,s),r},u=Xe.bind(r);return Object.defineProperty(r,"domain",{get:Ee}),u(e,t,n,i,o,s),r}Ue.sample=ke;const qe=Ue;m().set("lib/nurbs/nurbs",qe);const Ke=qe;function Me(e){M.call(this,e),W().call(this,e),this.addType(d().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Me.prototype=Object.assign(Object.create(M.prototype),W().prototype,{constructor:Me,initialize:function(){M.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=p()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},getTessellation:function(e){return U.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed:function(e,t,n,i){return!!this._closed.getValue()&&U.getClosed(e,t,n,i)},getWeights:function(e,t,n){return U.getWeights(e,t,n)},getControlPoints:function(e,t,n,i,o){return U.getControlPoints(e,t,n,i,o)},tessellate:function(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const e=this.getVertices(),t=[];if(e.length){const n=e.length;for(let i=0;i<n;i+=8)t.push(e[i],e[i+1],e[i+2]);t.push(e[n-4],e[n-3],e[n-2])}return t},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),i=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(i.at(-1),i[0],this._order.getValue()-1),s=this.surface=(this.surface||Ke)({boundary:["open"],degree:[o],knots:[i],points:n,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(i.length),this.sampleOptions.haveWeights=!!t;const r=Ke.sample(this.mesh,s,this.sampleOptions).points,u=this.getVertices();for(let e=3,t=r.length;e<t;e+=3){const t=e-3;u.push(r[t],r[t+1],r[t+2],1),u.push(r[e],r[e+1],r[e+2],1)}},dispose:function(){M.prototype.dispose.call(this)}}),Object.defineProperties(Me,{typeName:{value:"NurbsCurve",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"geometry",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"closed",new(o().SFBool)),new(r())(d().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode))]),enumerate:!0}});const Ge=Me;m().set("x_ite/Components/NURBS/NurbsCurve",Ge);const We=Ge;function Ye(e){C.call(this,e),this.addType(d().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Ye.prototype=Object.assign(Object.create(C.prototype),{constructor:Ye,getTessellation:function(e){return U.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed:function(e,t,n,i){return!!this._closed.getValue()&&U.getClosed2D(e,t,n,i)},getKnots:function(e,t,n,i,o){return U.getKnots(e,t,n,i,o)},getWeights:function(e,t,n){return U.getWeights(e,t,n)},getControlPoints:function(e,t,n,i,o){return U.getControlPoints2D(e,t,n,i,o)},tessellate:function(e){const t=this.array;if(t.length=0,this._order.getValue()<2)return t;if(this._controlPoint.length<this._order.getValue())return t;const n=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),i=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,n,this._order.getValue(),i,this._controlPoint),s=this.getKnots(this.knots,n,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1),u=this.surface=(this.surface||Ke)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(s.length),this.sampleOptions.haveWeights=!!i;const a=Ke.sample(this.mesh,u,this.sampleOptions).points;switch(e){case 0:for(let e=0,n=a.length;e<n;e+=2)t.push(a[e],a[e+1]);break;case 1:for(let e=0,n=a.length;e<n;e+=2)t.push(a[e],0,a[e+1]);break;case 2:for(let e=0,n=a.length;e<n;e+=2)t.push(new(S())(a[e],a[e+1],0))}return t}}),Object.defineProperties(Ye,{typeName:{value:"NurbsCurve2D",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"closed",new(o().SFBool)),new(r())(d().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerate:!0}});const Je=Ye;m().set("x_ite/Components/NURBS/NurbsCurve2D",Je);const Le=Je,Ze=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Core/X3DChildNode");var He=e.n(Ze);const Qe=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Interpolation/OrientationInterpolator");var $e=e.n(Qe);const et=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Numbers/Rotation4");var tt=e.n(et);function nt(e){He().call(this,e),this.addType(d().NurbsOrientationInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new($e())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}nt.prototype=Object.assign(Object.create(He().prototype),{constructor:nt,initialize:function(){He().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=p()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:function(e,t,n,i){return!1},getKnots:function(e,t,n,i,o){return U.getKnots(e,t,n,i,o)},getWeights:function(e,t,n){return U.getWeights(e,t,n)},getControlPoints:function(e,t,n,i,o){return U.getControlPoints(e,t,n,i,o)},requestRebuild:function(){this._rebuild.addEvent()},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),i=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=i.at(-1)-i[0],s=this._order.getValue()-1,r=this.surface=(this.surface||Ke)({boundary:["open"],degree:[s],knots:[i],points:n,debug:!1});this.sampleOptions.haveWeights=!!t;const u=Ke.sample(this.mesh,r,this.sampleOptions).points,a=this.interpolator;a._key.length=0,a._keyValue.length=0;for(let t=0,n=u.length-3;t<n;t+=3){const s=new(S())(u[t+3]-u[t+0],u[t+4]-u[t+1],u[t+5]-u[t+2]);a._key.push(i[0]+t/(n-3+3*e)*o),a._keyValue.push(new(tt())(S().zAxis,s))}e&&(a._key.push(i[0]+o),a._keyValue.push(a._keyValue[0]))}}),Object.defineProperties(nt,{typeName:{value:"NurbsOrientationInterpolator",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(d().inputOutput,"order",new(o().SFInt32)(3)),new(r())(d().inputOutput,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"value_changed",new(o().SFRotation))]),enumerate:!0}});const it=nt;m().set("x_ite/Components/NURBS/NurbsOrientationInterpolator",it);const ot=it,st=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Algorithm");var rt=e.n(st);function ut(e){M.call(this,e),this.addType(d().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}ut.prototype=Object.assign(Object.create(M.prototype),{constructor:ut,initialize:function(){M.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__:function(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=p()(d().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=p()(d().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=p()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},setTessellationScale:function(e){this.tessellationScale=e,this.requestRebuild()},getUTessellation:function(e){return Math.floor(U.getTessellation(this._uTessellation.getValue(),e-this._uOrder.getValue())*this.tessellationScale)},getVTessellation:function(e){return Math.floor(U.getTessellation(this._vTessellation.getValue(),e-this._vOrder.getValue())*this.tessellationScale)},getUClosed:function(e,t,n,i,o,s){return!!this._uClosed.getValue()&&U.getUClosed(e,t,n,i,o,s)},getVClosed:function(e,t,n,i,o,s){return!!this._vClosed.getValue()&&U.getVClosed(e,t,n,i,o,s)},getUVWeights:function(e,t,n,i){return U.getUVWeights(e,t,n,i)},getTexControlPoints:function(e,t,n,i,o,s,r,u){return U.getTexControlPoints(e,t,n,i,o,s,r,u)},getUVControlPoints:function(e,t,n,i,o,s,r,u,a){return U.getUVControlPoints(e,t,n,i,o,s,r,u,a)},getTrimmingContours:function(){},build:function(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()!==this._uDimension.getValue()*this._vDimension.getValue())return;const e=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),t=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),n=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),i=this.getUVControlPoints(this.controlPoints,e,t,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),n,this.controlPointNode),o=this.getKnots(this.uKnots,e,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,t,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),u=this._vOrder.getValue()-1,a=this.surface=(this.surface||Ke)({boundary:["open","open"],degree:[r,u],knots:[o,s],points:i,debug:!1}),l=this.sampleOptions;l.resolution[0]=this.getUTessellation(o.length),l.resolution[1]=this.getVTessellation(s.length),l.closed[0]=e,l.closed[1]=t,l.domain=void 0,l.haveWeights=!!n,l.trimmingContours=this.getTrimmingContours();const h=Ke.sample(this.mesh,a,l),c=h.faces,d=h.points,g=this.getVertices();for(let e=0,t=c.length;e<t;++e){const t=3*c[e];g.push(d[t],d[t+1],d[t+2],1)}this.buildNurbsTexCoords(e,t,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue(),a.domain),this.buildNormals(c,d),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords:function(){const e=[],t=[],n=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];function i(e,t){return e[0]=e[1]=t[0],e[2]=e[3]=t.at(-1),e}return function(o,s,r,u,a,l,h,c,d){const g=this.sampleOptions;if(this.texCoordNode&&this.texCoordNode.getSize()===h*c)var p=r-1,f=u-1,m=a,_=l,w=this.getTexControlPoints(this.texControlPoints,o,s,r,u,h,c,this.texCoordNode);else if(this.nurbsTexCoordNode&&this.nurbsTexCoordNode.isValid()){var v=this.nurbsTexCoordNode,y=(p=v._uOrder.getValue()-1,f=v._vOrder.getValue()-1,m=this.getKnots(this.texUKnots,!1,v._uOrder.getValue(),v._uDimension.getValue(),v._uKnot),_=this.getKnots(this.texVKnots,!1,v._vOrder.getValue(),v._vDimension.getValue(),v._vKnot),this.getUVWeights(this.texWeights,v._uDimension.getValue(),v._vDimension.getValue(),v._weight));w=v.getControlPoints(y)}else{p=1,f=1,m=i(e,a),_=i(t,l),w=n;g.domain=d}const b=this.texSurface=(this.texSurface||Ke)({boundary:["open","open"],degree:[p,f],knots:[m,_],points:w});g.closed[0]=!1,g.closed[1]=!1,g.haveWeights=!1;const N=Ke.sample(this.texMesh,b,g),C=N.faces,O=N.points,S=this.getTexCoords();for(let e=0,t=C.length;e<t;++e){const t=4*C[e];S.push(O[t],O[t+1],O[t+2],O[t+3])}this.getMultiTexCoords().push(this.getTexCoords())}}(),buildNormals:function(e,t){const n=this.createNormals(e,t),i=this.getNormals();for(const e of n)i.push(e.x,e.y,e.z)},createNormals:function(e,t){const n=this.createFaceNormals(e,t),i=[];for(let t=0,n=e.length;t<n;++t){const n=e[t];let o=i[n];o||(o=i[n]=[]),o.push(t)}return this.refineNormals(i,n,rt().radians(85))},createFaceNormals:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0),n=new(S())(0,0,0);return function(i,o){const s=this.faceNormals||[],r=i.length;for(let u=0;u<r;u+=3){const r=3*i[u],a=3*i[u+1],l=3*i[u+2];e.set(o[r],o[r+1],o[r+2]),t.set(o[a],o[a+1],o[a+2]),n.set(o[l],o[l+1],o[l+2]);const h=xe().normal(e,t,n,s[u]||new(S())(0,0,0));s[u]=h,s[u+1]=h,s[u+2]=h}return s.length=r,s}}()}),Object.defineProperties(ut,{typeName:{value:"X3DNurbsSurfaceGeometryNode",enumerate:!0},componentName:{value:"NURBS",enumerate:!0}});const at=ut;m().set("x_ite/Components/NURBS/X3DNurbsSurfaceGeometryNode",at);const lt=at;function ht(e){lt.call(this,e),this.addType(d().NurbsPatchSurface)}ht.prototype=Object.assign(Object.create(lt.prototype),{constructor:ht}),Object.defineProperties(ht,{typeName:{value:"NurbsPatchSurface",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"geometry",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(d().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"uClosed",new(o().SFBool)),new(r())(d().initializeOnly,"vClosed",new(o().SFBool)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"texCoord",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode))]),enumerate:!0}});const ct=ht;m().set("x_ite/Components/NURBS/NurbsPatchSurface",ct);const dt=ct,gt=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Interpolation/PositionInterpolator");var pt=e.n(gt);function ft(e){He().call(this,e),this.addType(d().NurbsPositionInterpolator),this.addChildObjects("rebuild",new(o().SFTime)),this.interpolator=new(pt())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}ft.prototype=Object.assign(Object.create(He().prototype),{constructor:ft,initialize:function(){He().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__:function(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=p()(d().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:function(e,t,n,i){return!1},getKnots:function(e,t,n,i,o){return U.getKnots(e,t,n,i,o)},getWeights:function(e,t,n){return U.getWeights(e,t,n)},getControlPoints:function(e,t,n,i,o){return U.getControlPoints(e,t,n,i,o)},requestRebuild:function(){this._rebuild.addEvent()},build:function(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),n=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),i=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),s=i.at(-1)-i[0],r=this._order.getValue()-1,u=this.surface=(this.surface||Ke)({boundary:["open"],degree:[r],knots:[i],points:n,debug:!1});this.sampleOptions.haveWeights=!!t;const a=Ke.sample(this.mesh,u,this.sampleOptions).points,l=this.interpolator;l._key.length=0,l._keyValue.length=0;for(let e=0,t=a.length;e<t;e+=3)l._key.push(i[0]+e/(t-3)*s),l._keyValue.push(new(o().SFVec3f)(a[e],a[e+1],a[e+2]))}}),Object.defineProperties(ft,{typeName:{value:"NurbsPositionInterpolator",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(d().inputOutput,"order",new(o().SFInt32)(3)),new(r())(d().inputOutput,"knot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"value_changed",new(o().SFVec3f))]),enumerate:!0}});const mt=ft;m().set("x_ite/Components/NURBS/NurbsPositionInterpolator",mt);const _t=mt,wt=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Grouping/X3DBoundedObject");var vt=e.n(wt);function yt(e){He().call(this,e),vt().call(this,e),this.addType(d().NurbsSet),this.geometryNodes=[]}function bt(e,t){const n=new Set(t);return e.filter((e=>!n.has(e)))}yt.prototype=Object.assign(Object.create(He().prototype),vt().prototype,{constructor:yt,initialize:function(){He().prototype.initialize.call(this),vt().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox:function(e,t){for(const t of this.geometryNodes)e.add(t.getBBox());return e},set_tessellationScale__:function(){const e=Math.max(0,this._tessellationScale.getValue());for(const t of this.geometryNodes)t.setTessellationScale(e)},set_addGeometry__:function(){this._addGeometry.setTainted(!0),this._addGeometry.assign(bt(this._addGeometry,this._geometry));for(const e of this._addGeometry)this._geometry.push(e);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__:function(){this._removeGeometry.setTainted(!0),this._geometry.assign(bt(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__:function(){for(const e of this.geometryNodes)e.setTessellationScale(1);this.geometryNodes.length=0;for(const e of this._geometry){const t=p()(d().X3DNurbsSurfaceGeometryNode,e);t&&this.geometryNodes.push(t)}this.set_tessellationScale__()},dispose:function(){vt().prototype.dispose.call(this),He().prototype.dispose.call(this)}}),Object.defineProperties(yt,{typeName:{value:"NurbsSet",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOutput,"tessellationScale",new(o().SFFloat)(1)),new(r())(d().inputOutput,"visible",new(o().SFBool)(!0)),new(r())(d().inputOutput,"bboxDisplay",new(o().SFBool)),new(r())(d().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(r())(d().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(r())(d().inputOnly,"addGeometry",new(o().MFNode)),new(r())(d().inputOnly,"removeGeometry",new(o().MFNode)),new(r())(d().inputOutput,"geometry",new(o().MFNode))]),enumerate:!0}});const Nt=yt;m().set("x_ite/Components/NURBS/NurbsSet",Nt);const Ct=Nt,Ot=window[Symbol.for("X_ITE.X3D-8.7.8")].require("standard/Math/Geometry/Line3");var St=e.n(Ot);const Pt={isPointInTriangle:function(e,t,n,i){const o=(t.y-n.y)*(e.x-n.x)+(n.x-t.x)*(e.y-n.y);if(0==o)return!1;const s=((t.y-n.y)*(i.x-n.x)+(n.x-t.x)*(i.y-n.y))/o;if(s<0||s>1)return!1;const r=((n.y-e.y)*(i.x-n.x)+(e.x-n.x)*(i.y-n.y))/o;if(r<0||r>1)return!1;const u=1-s-r;return!(u<0||u>1)}};m().set("standard/Math/Geometry/Triangle2",Pt);const Dt=Pt;function Ft(e){He().call(this,e),this.addType(d().NurbsSurfaceInterpolator),this.geometry=new dt(e)}Ft.prototype=Object.assign(Object.create(He().prototype),{constructor:Ft,initialize:function(){this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=128,this.geometry._vTessellation=128,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry.setup()},set_fraction__:function(){const e=new(S())(0,0,0),t=new(S())(0,0,0),n=new(S())(0,0,0),i=new(S())(0,0,0),o=new(St())(S().Zero,S().zAxis),s={};return function(){const r=this._set_fraction.getValue(),u=this.geometry.getTexCoords(),a=this.geometry.getNormals(),l=this.geometry.getVertices();for(let h=0,c=0,d=u.length;h<d;h+=12,c+=9)if(e.set(u[h+0],u[h+1],0),t.set(u[h+4],u[h+5],0),n.set(u[h+7],u[h+9],0),Dt.isPointInTriangle(e,t,n,r)&&(o.set(i.set(r.x,r.y,0),S().zAxis),o.intersectsTriangle(e,t,n,s))){const e=s.u,t=s.v,n=s.t,i=new(S())(n*a[c+0]+e*a[c+3]+t*a[c+6],n*a[c+1]+e*a[c+4]+t*a[c+7],n*a[c+2]+e*a[c+5]+t*a[c+8]),o=new(S())(n*l[h+0]+e*l[h+4]+t*l[h+8],n*l[h+1]+e*l[h+5]+t*l[h+9],n*l[h+2]+e*l[h+6]+t*l[h+10]);this._normal_changed=i,this._position_changed=o}}}()}),Object.defineProperties(Ft,{typeName:{value:"NurbsSurfaceInterpolator",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"children",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().inputOnly,"set_fraction",new(o().SFVec2f)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().outputOnly,"normal_changed",new(o().SFVec3f)),new(r())(d().outputOnly,"position_changed",new(o().SFVec3f))]),enumerate:!0}});const Rt=Ft;m().set("x_ite/Components/NURBS/NurbsSurfaceInterpolator",Rt);const Vt=Rt,It=window[Symbol.for("X_ITE.X3D-8.7.8")].require("x_ite/Components/Geometry3D/Extrusion");var Tt=e.n(It);function xt(e){M.call(this,e),this.addType(d().NurbsSweptSurface),this.extrusion=new(Tt())(e)}xt.prototype=Object.assign(Object.create(M.prototype),{constructor:xt,initialize:function(){M.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},set_crossSectionCurve__:function(){this.crossSectionCurveNode&&this.crossSectionCurveNode.removeInterest("requestRebuild",this),this.crossSectionCurveNode=p()(d().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode&&this.crossSectionCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__:function(){this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=p()(d().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode._rebuild.addInterest("requestRebuild",this)},build:function(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.crossSectionCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(0),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,n=e.length;t<n;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(xt,{typeName:{value:"NurbsSweptSurface",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"geometry",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(d().inputOutput,"crossSectionCurve",new(o().SFNode)),new(r())(d().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerate:!0}});const jt=xt;m().set("x_ite/Components/NURBS/NurbsSweptSurface",jt);const zt=jt;function kt(e){M.call(this,e),this.addType(d().NurbsSwungSurface),this.extrusion=new(Tt())(e)}kt.prototype=Object.assign(Object.create(M.prototype),{constructor:kt,initialize:function(){M.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},set_profileCurve__:function(){this.profileCurveNode&&this.profileCurveNode.removeInterest("requestRebuild",this),this.profileCurveNode=p()(d().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode&&this.profileCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__:function(){this.trajectoryCurveNode&&this.trajectoryCurveNode.removeInterest("requestRebuild",this),this.trajectoryCurveNode=p()(d().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode.addInterest("requestRebuild",this)},build:function(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.profileCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(1),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,n=e.length;t<n;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(kt,{typeName:{value:"NurbsSwungSurface",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"geometry",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(d().inputOutput,"profileCurve",new(o().SFNode)),new(r())(d().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerate:!0}});const At=kt;m().set("x_ite/Components/NURBS/NurbsSwungSurface",At);const Bt=At;function Xt(e){h().call(this,e),this.addType(d().NurbsTextureCoordinate),this.controlPoints=[]}Xt.prototype=Object.assign(Object.create(h().prototype),{constructor:Xt,initialize:function(){h().prototype.initialize.call(this)},getControlPoints:function(e){const t=this._controlPoint.getValue(),n=this.controlPoints;for(let i=0,o=this._uDimension.getValue();i<o;++i){let s=n[i];s||(s=n[i]=[]);for(let n=0,r=this._vDimension.getValue();n<r;++n){const r=n*o+i,u=s[n]||new(X()),a=2*r;s[n]=u.set(t[a],t[a+1],0,e?e[r]:1)}}return n},isValid:function(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&this._controlPoint.length===this._uDimension.getValue()*this._vDimension.getValue())))}}),Object.defineProperties(Xt,{typeName:{value:"NurbsTextureCoordinate",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"texCoord",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"controlPoint",new(o().MFVec2f))]),enumerate:!0}});const Et=Xt;m().set("x_ite/Components/NURBS/NurbsTextureCoordinate",Et);const Ut=Et;function qt(e){lt.call(this,e),this.addType(d().NurbsTrimmedSurface),this.trimmingContourNodes=[]}function Kt(e,t){const n=new Set(t);return e.filter((e=>!n.has(e)))}qt.prototype=Object.assign(Object.create(lt.prototype),{constructor:qt,initialize:function(){lt.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__:function(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Kt(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const e of this._addTrimmingContour)this._trimmingContour.push(e);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__:function(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Kt(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__:function(){const e=this.trimmingContourNodes;e.length=0;for(const t of this._trimmingContour){const n=p()(d().Contour2D,t);n&&e.push(n)}},getTrimmingContours:function(){const e=this.trimmingContourNodes,t=[];for(const n of e)n.addTrimmingContour(t);return t}}),Object.defineProperties(qt,{typeName:{value:"NurbsTrimmedSurface",enumerate:!0},componentName:{value:"NURBS",enumerate:!0},containerField:{value:"geometry",enumerate:!0},specificationRange:{value:Object.freeze(["3.0","Infinity"]),enumerate:!0},fieldDefinitions:{value:new(a())([new(r())(d().inputOutput,"metadata",new(o().SFNode)),new(r())(d().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(d().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(d().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(d().initializeOnly,"uClosed",new(o().SFBool)),new(r())(d().initializeOnly,"vClosed",new(o().SFBool)),new(r())(d().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(d().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(d().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(d().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(d().inputOutput,"weight",new(o().MFDouble)),new(r())(d().inputOutput,"texCoord",new(o().SFNode)),new(r())(d().inputOutput,"controlPoint",new(o().SFNode)),new(r())(d().inputOnly,"addTrimmingContour",new(o().MFNode)),new(r())(d().inputOnly,"removeTrimmingContour",new(o().MFNode)),new(r())(d().inputOutput,"trimmingContour",new(o().MFNode))]),enumerate:!0}});const Mt=qt;m().set("x_ite/Components/NURBS/NurbsTrimmedSurface",Mt);const Gt=Mt;n().add({name:"NURBS",concreteNodes:[y,F,x,We,Le,ot,dt,_t,Ct,Vt,zt,Bt,Ut,Gt],abstractNodes:[C,lt,M]});const Wt=void 0;m().set("assets/components/NURBS",Wt)})();