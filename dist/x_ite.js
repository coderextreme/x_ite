/* X_ITE v6.0.0-1155 */

(function (global, factory)
{
	typeof module === "object" && typeof require === "function" ? factory (module, require) : factory ();
}
(this, (function (__global_module__, __global_require__)
{
// Undefine global variables.
var module, exports, process;
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.6 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.6',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttps://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

define("../node_modules/requirejs/require.js", function(){});

/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.


var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur as it's already being fired
		// in leverageNative.
		_default: function() {
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

define("jquery/dist/jquery", function(){});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DConstants',[],function ()
{
"use strict";

   let
      browserEvent = 0,
      loadState    = 0,
      fieldType    = 0;

   const X3DConstants =
   {
      // Browser event

      CONNECTION_ERROR:  browserEvent ++,
      BROWSER_EVENT:     browserEvent ++,
      INITIALIZED_EVENT: browserEvent ++,
      SHUTDOWN_EVENT:    browserEvent ++,
      INITIALIZED_ERROR: browserEvent ++,

      // Load state

      NOT_STARTED_STATE: loadState ++,
      IN_PROGRESS_STATE: loadState ++,
      COMPLETE_STATE:    loadState ++,
      FAILED_STATE:      loadState ++,

      // Access type

      initializeOnly: 0b001,
      inputOnly:      0b010,
      outputOnly:     0b100,
      inputOutput:    0b111,

      // X3DField

      SFBool:      fieldType ++,
      SFColor:     fieldType ++,
      SFColorRGBA: fieldType ++,
      SFDouble:    fieldType ++,
      SFFloat:     fieldType ++,
      SFImage:     fieldType ++,
      SFInt32:     fieldType ++,
      SFMatrix3d:  fieldType ++,
      SFMatrix3f:  fieldType ++,
      SFMatrix4d:  fieldType ++,
      SFMatrix4f:  fieldType ++,
      SFNode:      fieldType ++,
      SFRotation:  fieldType ++,
      SFString:    fieldType ++,
      SFTime:      fieldType ++,
      SFVec2d:     fieldType ++,
      SFVec2f:     fieldType ++,
      SFVec3d:     fieldType ++,
      SFVec3f:     fieldType ++,
      SFVec4d:     fieldType ++,
      SFVec4f:     fieldType ++,

      VrmlMatrix:  fieldType ++,

      // X3DArrayField

      MFBool:      fieldType ++,
      MFColor:     fieldType ++,
      MFColorRGBA: fieldType ++,
      MFDouble:    fieldType ++,
      MFFloat:     fieldType ++,
      MFImage:     fieldType ++,
      MFInt32:     fieldType ++,
      MFMatrix3d:  fieldType ++,
      MFMatrix3f:  fieldType ++,
      MFMatrix4d:  fieldType ++,
      MFMatrix4f:  fieldType ++,
      MFNode:      fieldType ++,
      MFRotation:  fieldType ++,
      MFString:    fieldType ++,
      MFTime:      fieldType ++,
      MFVec2d:     fieldType ++,
      MFVec2f:     fieldType ++,
      MFVec3d:     fieldType ++,
      MFVec3f:     fieldType ++,
      MFVec4d:     fieldType ++,
      MFVec4f:     fieldType ++,

      // Abstract node

      X3DBaseNode: 0,
   };

   return X3DConstants;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/InputOutput/Generator',[
   "x_ite/Base/X3DConstants",
],
function (X3DConstants)
{
"use strict";

   function Generator ()
   {
      this .indent              = "";
      this .indentChar          = "  ";
      this .precision           = 6;
      this .doublePrecision     = 14;
      this .removeTrailingZeros = /\.?0*(?=$|[eE])/;

      this .executionContextStack = [ null ];
      this .importedNodesIndex    = new Map ();
      this .exportedNodesIndex    = new Map ();
      this .nodes                 = new Set ();
      this .names                 = new Map ();
      this .namesByNode           = new Map ();
      this .importedNames         = new Map ();
      this .routeNodes            = new Set ();
      this .level                 = 0;
      this .newName               = 0;
      this .containerFields       = [ ];
      this .units                 = true;
      this .unitCategories        = [ ];

      this .names .set (null, new Map ());
   }

   Generator .prototype =
   {
      constructor: Generator,
      Indent: function ()
      {
         return this .indent;
      },
      IncIndent: function ()
      {
         this .indent += this .indentChar;
      },
      DecIndent: function ()
      {
         this .indent = this .indent .substr (0, this .indent .length - this .indentChar .length);
      },
      PadRight: function (string, pad)
      {
         for (let i = 0, length = pad - string .length; i < length; ++ i)
            string += " ";

         return string;
      },
      Precision: function (value)
      {
         return Math .fround (value) .toPrecision (this .precision) .replace (this .removeTrailingZeros, "");
      },
      DoublePrecision: function (value)
      {
         return value .toPrecision (this .doublePrecision) .replace (this .removeTrailingZeros, "");
      },
      PushExecutionContext: function (executionContext)
      {
         this .executionContextStack .push (executionContext);

         if (! this .names .has (executionContext))
            this .names .set (executionContext, new Map ());

         if (! this .importedNodesIndex .has (executionContext))
            this .importedNodesIndex .set (executionContext, new Set ());

         if (! this .exportedNodesIndex .has (executionContext))
            this .exportedNodesIndex .set (executionContext, new Set ());
      },
      PopExecutionContext: function ()
      {
         this .executionContextStack .pop ();

         if (this .ExecutionContext ())
            return;

         this .importedNodesIndex .clear ();
         this .exportedNodesIndex .clear ();
      },
      ExecutionContext: function ()
      {
         return this .executionContextStack .at (-1);
      },
      EnterScope: function ()
      {
         if (this .level === 0)
            this .newName = 0;

         ++ this .level;
      },
      LeaveScope: function ()
      {
         -- this .level;

         if (this .level === 0)
         {
            this .nodes         .clear ();
            this .namesByNode   .clear ();
            this .importedNames .clear ();
         }
      },
      ExportedNodes: function (exportedNodes)
      {
         const index = this .exportedNodesIndex .get (this .ExecutionContext ());

         exportedNodes .forEach (function (exportedNode)
         {
            try
            {
               index .add (exportedNode .getLocalNode ())
            }
            catch (error)
            { }
         });
      },
      ImportedNodes: function (importedNodes)
      {
         const index = this .importedNodesIndex .get (this .ExecutionContext ());

         importedNodes .forEach (function (importedNode)
         {
            try
            {
               index .add (importedNode .getInlineNode ());
            }
            catch (error)
            { }
         });
      },
      AddImportedNode: function (exportedNode, importedName)
      {
         this .importedNames .set (exportedNode, importedName);
      },
      AddRouteNode: function (routeNode)
      {
         this .routeNodes .add (routeNode);
      },
      ExistsRouteNode: function (routeNode)
      {
         return this .routeNodes .has (routeNode);
      },
      IsSharedNode: function (baseNode)
      {
         return this .ExecutionContext () !== baseNode .getExecutionContext ();
      },
      AddNode: function (baseNode)
      {
         this .nodes .add (baseNode);

         this .AddRouteNode (baseNode);
      },
      ExistsNode: function (baseNode)
      {
         return this .nodes .has (baseNode);
      },
      Name: (function ()
      {
         const _TrailingNumbers = /_\d+$/;

         return function (baseNode)
         {
            // Is the node already in index

            const name = this .namesByNode .get (baseNode);

            if (name !== undefined)
            {
               return name;
            }
            else
            {
               const names = this .names .get (this .ExecutionContext ());

               // The node has no name

               if (baseNode .getName () .length === 0)
               {
                  if (this .NeedsName (baseNode))
                  {
                     const name = this .UniqueName ();

                     names .set (name, baseNode);
                     this .namesByNode .set (baseNode, name);

                     return name;
                  }

                  // The node doesn't need a name

                  return baseNode .getName ();
               }

               // The node has a name

               let   name      = baseNode .getName ();
               const hasNumber = name .match (_TrailingNumbers) !== null;

               name = name .replace (_TrailingNumbers, "");

               if (name .length === 0)
               {
                  if (this .NeedsName (baseNode))
                     name = this .UniqueName ();

                  else
                     return "";
               }
               else
               {
                  let
                     i       = 0,
                     newName = hasNumber ? name + '_' + (++ i) : name;

                  while (names .has (newName))
                  {
                     newName = name + '_' + (++ i);
                  }

                  name = newName;
               }

               names .set (name, baseNode);
               this .namesByNode .set (baseNode, name);

               return name;
            }
         };
      })(),
      NeedsName: function (baseNode)
      {
         if (baseNode .getCloneCount () > 1)
            return true;

         if (baseNode .hasRoutes ())
            return true;

         const
            executionContext = baseNode .getExecutionContext (),
            index            = this .importedNodesIndex .get (executionContext);

         if (index)
         {
            if (index .has (baseNode))
               return true;
         }
         else
         {
            const index = this .exportedNodesIndex .get (executionContext);

            if (index)
            {
               if (index .has (baseNode))
                  return true;
            }

            return false;
         }
      },
      UniqueName: function ()
      {
         const names = this .names .get (this .ExecutionContext ());

         for (; ;)
         {
            const name = '_' + (++ this .newName);

            if (names .has (name))
               continue;

            return name;
         }
      },
      LocalName: function (baseNode)
      {
         const importedName = this .importedNames .get (baseNode);

         if (importedName !== undefined)
            return importedName;

         if (this .ExistsNode (baseNode))
            return this .Name (baseNode);

         throw new Error ("Couldn't get local name for node '" + baseNode .getTypeName () + "'.");
      },
      PushContainerField: function (field)
      {
         this .containerFields .push (field);
      },
      PopContainerField: function ()
      {
         this .containerFields .pop ();
      },
      ContainerField: function ()
      {
         if (this .containerFields .length)
            return this .containerFields [this .containerFields .length - 1];

         return null;
      },
      AccessType: function (accessType)
      {
         switch (accessType)
         {
            case X3DConstants .initializeOnly:
               return "initializeOnly";
            case X3DConstants .inputOnly:
               return "inputOnly";
            case X3DConstants .outputOnly:
               return "outputOnly";
            case X3DConstants .inputOutput:
               return "inputOutput";
         }
      },
      SetUnits: function (value)
      {
         this .units = value;
      },
      GetUnits: function ()
      {
         return this .units;
      },
      PushUnitCategory: function (category)
      {
         this .unitCategories .push (category);
      },
      PopUnitCategory: function ()
      {
         this .unitCategories .pop ();
      },
      Unit: function (category)
      {
         if (this .unitCategories .length == 0)
            return category;

         return this .unitCategories .at (-1);
      },
      ToUnit: function (category, value)
      {
         if (this .units)
         {
            const executionContext = this .ExecutionContext ();

            if (executionContext)
               return executionContext .toUnit (category, value);
         }

         return value;
      },
      XMLEncode: function (string)
      {
         return string
            .replace (/&/g, "&amp;")
            .replace (/\\/g, "&#92;")
            .replace (/\t/g, "&#x9;")
            .replace (/\n/g, "&#xA;")
            .replace (/\r/g, "&#xD;")
            .replace (/</g, "&lt;")
            .replace (/>/g, "&gt;")
            .replace (/'/g, "&apos;")
            .replace (/"/g, "\\\"");
      },
      escapeCDATA: function (string)
      {
         return string .replace (/\]\]\>/g, "\\]\\]\\>");
      },
   };

   for (const key of Reflect .ownKeys (Generator .prototype))
      Object .defineProperty (Generator .prototype, key, { enumerable: false });

   Generator .Get = function (stream)
   {
      if (! stream .generator)
         stream .generator = new Generator ();

      return stream .generator;
   };

   return Generator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/MapUtilities',['require'],function ($)
{
"use strict";

   const MapUtilities = {
      assign: function (m1, m2)
      {
         m1 .clear ();

         m2 .forEach (function (value, key)
         {
            m1 .set (key, value);
         });

         return m1;
      },
      values: function (a, m)
      {
         let i = 0;

         m .forEach (function (value)
         {
            a [i ++] = value;
         });

         a .length = m .size;

         return a;
      },
   };

   return MapUtilities;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DObject',[
   "x_ite/InputOutput/Generator",
   "standard/Utility/MapUtilities",
],
function (Generator,
          MapUtilities)
{
"use strict";

   const
      _name      = Symbol (),
      _interests = Symbol (),
      _values    = Symbol ();

   function X3DObject () { }

   X3DObject .prototype =
   {
      constructor: X3DObject,
      [_name]: "",
      [_interests]: new Map (),
      [_values]: [ ],
      getId: function ()
      {
         return X3DObject .getId (this);
      },
      getTypeName: function ()
      {
         return "X3DObject";
      },
      setName: function (value)
      {
         this [_name] = value;
      },
      getName: function ()
      {
         return this [_name];
      },
      getDisplayName: function ()
      {
         return this [_name];
      },
      getInterestId: function (callbackName, object)
      {
         return X3DObject .getId (object) + "." + String (callbackName);
      },
      hasInterest: function (callbackName, object)
      {
         return this [_interests] .has (this .getInterestId (callbackName, object));
      },
      addInterest: function (callbackName, object)
      {
         if (this [_interests] === X3DObject .prototype [_interests])
         {
            this [_interests] = new Map ();
            this [_values]    = [ ];
         }

         const
            interestId = this .getInterestId (callbackName, object),
            callback   = object [callbackName];

         if (arguments .length > 2)
         {
            const args = Array .prototype .slice .call (arguments, 2);

            args .unshift (object);
            args .push (this);

            this [_interests] .set (interestId, Function .prototype .bind .apply (callback, args));
         }
         else
         {
            this [_interests] .set (interestId, callback .bind (object, this));
         }
      },
      removeInterest: function (callbackName, object)
      {
         this [_interests] .delete (this .getInterestId (callbackName, object));
      },
      getInterests: function ()
      {
         return this [_interests];
      },
      processInterests: function ()
      {
         if (this [_interests] .size)
         {
            for (const interest of MapUtilities .values (this [_values], this [_interests]))
               interest ();
         }
      },
      toString: function (scene)
      {
         const stream = { string: "" };

         if (scene)
            Generator .Get (stream) .PushExecutionContext (scene);

         this .toStream (stream);

         return stream .string;
      },
      toVRMLString: function ()
      {
         const stream = { string: "" };

         this .toVRMLStream (stream);

         return stream .string;
      },
      toXMLString: function ()
      {
         const stream = { string: "" };

         this .toXMLStream (stream);

         return stream .string;
      },
      toJSONString: function ()
      {
         const stream = { string: "" };

         this .toVRMLStream (stream); // TODO.

         return stream .string;
      },
      toStream: function (stream)
      {
         stream .string = "[object " + this .getTypeName () + "]";
      },
      dispose: function () { },
   };

   for (const key of Reflect .ownKeys (X3DObject .prototype))
      Object .defineProperty (X3DObject .prototype, key, { enumerable: false });

   X3DObject .getId = (function ()
   {
      const map = new WeakMap ();

      let counter = 0;

      return function (object)
      {
         const id = map .get (object);

         if (id !== undefined)
            return id;

         map .set (object, ++ counter);

         return counter;
      };
   })();

   return X3DObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DChildObject',[
   "x_ite/Base/X3DObject",
],
function (X3DObject)
{
"use strict";

   const
      _modificationTime = Symbol (),
      _tainted          = Symbol (),
      _parents          = Symbol ();

   function X3DChildObject ()
   {
      X3DObject .call (this);
   }

   X3DChildObject .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: X3DChildObject,
      [_modificationTime]: 0,
      [_tainted]: false,
      [_parents]: new Set (),
      setModificationTime: function (value)
      {
         this [_modificationTime] = value;
      },
      getModificationTime: function ()
      {
         return this [_modificationTime];
      },
      setTainted: function (value)
      {
         this [_tainted] = value;
      },
      isTainted: function ()
      {
         return this [_tainted];
      },
      addEvent: function ()
      {
         this .setModificationTime (performance .now ());

         for (const parent of this [_parents])
            parent .addEvent (this);
      },
      addEventObject: function (field, event)
      {
         this .setModificationTime (performance .now ());

         for (const parent of this [_parents])
            parent .addEventObject (this, event);
      },
      addParent: function (parent)
      {
         if (this [_parents] === X3DChildObject .prototype [_parents])
            this [_parents] = new Set ();

         this [_parents] .add (parent);
      },
      removeParent: function (parent)
      {
         this [_parents] .delete (parent);
      },
      getParents: function ()
      {
         return this [_parents];
      },
      dispose: function ()
      {
         this [_parents] .clear ();

         X3DObject .prototype .dispose .call (this);
      },
   });

   for (const key of Reflect .ownKeys (X3DChildObject .prototype))
      Object .defineProperty (X3DChildObject .prototype, key, { enumerable: false });

   return X3DChildObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/Events',[],function ()
{
"use strict";

   const _stack = Symbol ();

   function Events ()
   {
      this [_stack] = [ ];
   }

   Events .prototype =
   {
      create: function (field)
      {
         if (this [_stack] .length)
         {
            const event = this [_stack] .pop ();

            event .field = field;
            event .clear ();

            return event;
         }

         const event = new Set ();

         event .field = field;

         return event;
      },
      copy: function (event)
      {
         if (this [_stack] .length)
         {
            const copy = this [_stack] .pop ();

            copy .field = event .field;
            copy .clear ();

            for (const source of event)
            {
               copy .add (source);
            }

            return copy;
         }

         const copy = new Set (event);

         copy .field = event .field;

         return copy;
      },
      push: function (event)
      {
         this [_stack] .push (event);
      },
      clear: function ()
      {
         this [_stack] .length = 0;
      },
   };

   for (const key of Reflect .ownKeys (Events .prototype))
      Object .defineProperty (Events .prototype, key, { enumerable: false });

   return new Events ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DEventObject',[
   "x_ite/Base/X3DChildObject",
   "x_ite/Base/Events",
],
function (X3DChildObject,
          Events)
{
"use strict";

   const _browser = Symbol .for ("X3DEventObject.browser");

   function X3DEventObject (browser)
   {
      X3DChildObject .call (this);

      this [_browser] = browser;
   }

   X3DEventObject .prototype = Object .assign (Object .create (X3DChildObject .prototype),
   {
      constructor: X3DEventObject,
      getBrowser: function ()
      {
         return this [_browser];
      },
      getExtendedEventHandling: function ()
      {
         return true;
      },
      addEvent: function (field)
      {
         if (field .isTainted ())
            return;

         field .setTainted (true);

         this .addEventObject (field, Events .create (field));
      },
      addEventObject: function (field, event)
      {
         const browser = this .getBrowser ();

         // Register for processEvent

         browser .addBrowserEvent ();
         browser .addTaintedField (field, event);

         // Register for eventsProcessed

         if (this .isTainted ())
            return;

         if (field .isInput () || (this .getExtendedEventHandling () && ! field .isOutput ()))
         {
            this .addNodeEvent ();
         }
      },
      addNodeEvent: function ()
      {
         if (this .isTainted ())
            return;

         const browser = this .getBrowser ();

         this .setTainted (true);
         browser .addTaintedNode (this);
         browser .addBrowserEvent ();
      },
      processEvents: function ()
      {
         this .setTainted (false);
         this .processInterests ();
      },
   });

   for (const key of Reflect .ownKeys (X3DEventObject .prototype))
      Object .defineProperty (X3DEventObject .prototype, key, { enumerable: false });

   return X3DEventObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DFieldDefinition',[
   "x_ite/Base/X3DObject",
],
function (X3DObject)
{
"use strict";

   function X3DFieldDefinition (accessType, name, value)
   {
      this .accessType  = accessType;
      this .dataType    = value .getType ();
      this .name        = name;
      this .value       = value;
   }

   X3DFieldDefinition .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: X3DFieldDefinition,
      getTypeName: function ()
      {
         return "X3DFieldDefinition";
      },
   });

   for (const key of Reflect .ownKeys (X3DFieldDefinition .prototype))
      Object .defineProperty (X3DFieldDefinition .prototype, key, { enumerable: false });

   return X3DFieldDefinition;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DInfoArray',['x_ite/Base/X3DBaseNode'],function ()
{
"use strict";

   const
      _array = Symbol (),
      _index = Symbol ();

   const handler =
   {
      get: function (target, key)
      {
         const value = target [key];

         if (value !== undefined)
            return value;

         if (typeof key === "string")
         {
            const index = +key;

            if (Number .isInteger (index))
               return target [_array] [index];

            return;
         }
      },
      set: function (target, key, value)
      {
         if (target [key] === undefined)
            return false;

         target [key] = value;
         return true;
      },
      has: function (target, key)
      {
         if (Number .isInteger (+key))
            return key < target [_array] .length;

         return key in target;
      },
      ownKeys: function (target)
      {
         return Object .keys (target [_array]);
      },
      getOwnPropertyDescriptor: function (target, key)
      {
         if (typeof key !== "string")
            return;

         const index = +key;

         if (Number .isInteger (index) && index < target [_array] .length)
         {
            const propertyDescriptor = Object .getOwnPropertyDescriptor (target [_array], key);

            if (propertyDescriptor)
               propertyDescriptor .writable = false;

            return propertyDescriptor;
         }
      },
   };

   function X3DInfoArray (values)
   {
      this [_array]           = [ ];
      this [_index]           = new Map ();
      this [Symbol .iterator] = this [_array] [Symbol .iterator];

      if (values)
      {
         for (const value of values)
            this .add (value .name, value);
      }

      return new Proxy (this, handler);
   }

   X3DInfoArray .prototype = {
      constructor: X3DInfoArray,
      equals: function (array)
      {
         const
            a      = this [_array],
            b      = array [_array] || array,
            length = a .length;

         if (a === b)
            return true;

         if (length !== b .length)
            return false;

         for (let i = 0; i < length; ++ i)
         {
            if (a [i] !== b [i])
               return false;
         }

         return true;
      },
      has: function (key)
      {
         return this [_index] .has (key);
      },
      get: function (key)
      {
         return this [_index] .get (key);
      },
      add: function (key, value)
      {
         this [_array] .push (value);
         this [_index] .set (key, value);
      },
      addAlias: function (alias, key)
      {
         this [_index] .set (alias, this [_index] .get (key));
      },
      update: function (oldKey, newKey, value)
      {
         const oldValue = this [_index] .get (oldKey);

         if (oldKey !== newKey)
            this .remove (newKey);

         this [_index] .delete (oldKey);
         this [_index] .set (newKey, value);

         if (oldValue !== undefined)
         {
            const index = this [_array] .indexOf (oldValue);

            if (index > -1)
               this [_array] [index] = value;
         }
         else
         {
            this [_array] .push (value);
         }
      },
      remove: function (key)
      {
         const value = this [_index] .get (key);

         if (value === undefined)
            return;

         const index = this [_array] .indexOf (value);

         this [_index] .delete (key);

         if (index > -1)
            this [_array] .splice (index, 1);
      },
      at: Array .prototype .at,
      concat: Array .prototype .concat,
      //entries: function () { return iterator -> [index, value]; },
      every: Array .prototype .every,
      fill: Array .prototype .fill,
      filter: Array .prototype .filter,
      find: Array .prototype .find,
      findIndex: Array .prototype .findIndex,
      forEach: Array .prototype .forEach,
      includes: Array .prototype .includes,
      indexOf: Array .prototype .indexOf,
      join: Array .prototype .join,
      keys: function () { return Array (this .length) .keys (); },
      lastIndexOf: Array .prototype .lastIndexOf,
      map: Array .prototype .map,
      reduce: Array .prototype .reduce,
      reduceRight: Array .prototype .reduceRight,
      slice: Array .prototype .slice,
      some: Array .prototype .some,
      values: function () { return this [Symbol .iterator]; },
      toString: function (scene)
      {
         const stream = { string: "" };

         if (scene)
            Generator .Get (stream) .PushExecutionContext (scene);

         this .toStream (stream);

         return stream .string;
      },
      toVRMLStream: function (stream)
      {
         const X3DBaseNode = require ("x_ite/Base/X3DBaseNode");

         for (const value of this [_array])
         {
            try
            {
               value .toVRMLStream (stream);

               stream .string += "\n";

               if (value instanceof X3DBaseNode)
                  stream .string += "\n";
            }
            catch (error)
            {
               console .error (error);
            }
         }
      },
      toXMLStream: function (stream)
      {
         for (const value of this [_array])
         {
            try
            {
               value .toXMLStream (stream);

               stream .string += "\n";
            }
            catch (error)
            {
               console .error (error);
            }
         }
      },
      toStream: function (stream)
      {
         stream .string = "[object " + this .getTypeName () + "]";
      },
   };

   for (const key of Reflect .ownKeys (X3DInfoArray .prototype))
      Object .defineProperty (X3DInfoArray .prototype, key, { enumerable: false });

   Object .defineProperty (X3DInfoArray .prototype, "length",
   {
      get: function () { return this [_array] .length; },
      enumerable: false,
      configurable: false,
   });

   return X3DInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/FieldDefinitionArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function FieldDefinitionArray (values)
   {
      return X3DInfoArray .call (this, values);
   }

   FieldDefinitionArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: FieldDefinitionArray,
      getTypeName: function ()
      {
         return "FieldDefinitionArray";
      },
   });

   for (const key of Reflect .ownKeys (FieldDefinitionArray .prototype))
      Object .defineProperty (FieldDefinitionArray .prototype, key, { enumerable: false });

   return FieldDefinitionArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Base/FieldArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function FieldArray ()
   {
      return X3DInfoArray .call (this);
   }

   FieldArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: FieldArray,
      getTypeName: function ()
      {
         return "FieldArray";
      },
   });

   for (const key of Reflect .ownKeys (FieldArray .prototype))
      Object .defineProperty (FieldArray .prototype, key, { enumerable: false });

   return FieldArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DField',[
   "jquery",
   "x_ite/Base/X3DChildObject",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/Events",
   "standard/Utility/MapUtilities",
],
function ($,
          X3DChildObject,
          X3DConstants,
          Events,
          MapUtilities)
{
"use strict";

   const
      _value               = Symbol (),
      _accessType          = Symbol (),
      _unit                = Symbol (),
      _references          = Symbol (),
      _referencesCallbacks = Symbol (),
      _fieldInterests      = Symbol (),
      _fieldCallbacks      = Symbol (),
      _inputRoutes         = Symbol (),
      _outputRoutes        = Symbol (),
      _routeCallbacks      = Symbol (),
      _uniformLocation     = Symbol .for ("X3DField.uniformLocation");

   function X3DField (value)
   {
      X3DChildObject .call (this);

      this [_value] = value;

      return this;
   }

   X3DField .prototype = Object .assign (Object .create (X3DChildObject .prototype),
   {
      constructor: X3DField,
      [_value]: null,
      [_accessType]: X3DConstants .initializeOnly,
      [_unit]: null,
      [_uniformLocation]: null,
      [_references]: new Set (),
      [_referencesCallbacks]: new Map (),
      [_fieldInterests]: new Set (),
      [_fieldCallbacks]: new Map (),
      [_inputRoutes]: new Set (),
      [_outputRoutes]: new Set (),
      [_routeCallbacks]: new Map (),
      create: function ()
      {
         return new (this .constructor) ();
      },
      equals: function (field)
      {
         return this [_value] === field .valueOf ();
      },
      assign: function (field)
      {
         // Assigns field to this field.
         this .set (field .getValue ());
         this .addEvent ();
      },
      set: function (value)
      {
         // Sets internal value without generating event.
         this [_value] = value;
      },
      setValue: function (value)
      {
         // Sets internal value and generates event.
         this .set (value instanceof this .constructor ? value .getValue () : value);
         this .addEvent ();
      },
      getValue: function ()
      {
         return this [_value];
      },
      setAccessType: function (value)
      {
         this [_accessType] = value;
      },
      getAccessType: function ()
      {
         return this [_accessType];
      },
      isInitializable: function ()
      {
         return this [_accessType] & X3DConstants .initializeOnly;
      },
      isInput: function ()
      {
         return this [_accessType] & X3DConstants .inputOnly;
      },
      isOutput: function ()
      {
         return this [_accessType] & X3DConstants .outputOnly;
      },
      isReadable: function ()
      {
         return this [_accessType] !== X3DConstants .inputOnly;
      },
      isWritable: function ()
      {
         return this [_accessType] !== X3DConstants .initializeOnly;
      },
      setUnit: function (value)
      {
         this [_unit] = value;
      },
      getUnit: function ()
      {
         return this [_unit];
      },
      hasReferences: function ()
      {
         return this [_references] .size !== 0;
      },
      isReference: function (accessType)
      {
         return accessType === this [_accessType] || accessType === X3DConstants .inputOutput;
      },
      addReference: function (reference)
      {
         const references = this .getReferences ();

         if (references .has (reference))
            return;

         references .add (reference);

         // Create IS relationship

         switch (this .getAccessType () & reference .getAccessType ())
         {
            case X3DConstants .initializeOnly:
               reference .addFieldInterest (this);
               this .assign (reference);
               break;
            case X3DConstants .inputOnly:
               reference .addFieldInterest (this);
               break;
            case X3DConstants .outputOnly:
               this .addFieldInterest (reference);
               break;
            case X3DConstants .inputOutput:
               reference .addFieldInterest (this);
               this .addFieldInterest (reference);
               this .assign (reference);
               break;
         }

         this .processReferencesCallbacks ();
      },
      removeReference: function (reference)
      {
         this .getReferences () .delete (reference);

         // Create IS relationship

         switch (this .getAccessType () & reference .getAccessType ())
         {
            case X3DConstants .initializeOnly:
               reference .removeFieldInterest (this);
               break;
            case X3DConstants .inputOnly:
               reference .removeFieldInterest (this);
               break;
            case X3DConstants .outputOnly:
               this .removeFieldInterest (reference);
               break;
            case X3DConstants .inputOutput:
               reference .removeFieldInterest (this);
               this .removeFieldInterest (reference);
               break;
         }

         this .processReferencesCallbacks ();
      },
      getReferences: function ()
      {
         if (this [_references] === X3DField .prototype [_references])
            this [_references] = new Set ();

         return this [_references];
      },
      addReferencesCallback: function (key, object)
      {
         if (this [_referencesCallbacks] === X3DField .prototype [_referencesCallbacks])
            this [_referencesCallbacks] = new Map ();

         this [_referencesCallbacks] .set (key, object);
      },
      removeReferencesCallback: function (key)
      {
         this [_referencesCallbacks] .delete (key);
      },
      getReferencesCallbacks: function ()
      {
         return this [_referencesCallbacks];
      },
      processReferencesCallbacks: (function ()
      {
         const referencesCallbacksTemp = [ ];

         return function ()
         {
            if (this [_referencesCallbacks] .size)
            {
               for (const referencesCallback of MapUtilities .values (referencesCallbacksTemp, this [_referencesCallbacks]))
                  referencesCallback ();
            }
         };
      })(),
      addFieldInterest: function (field)
      {
         if (this [_fieldInterests] === X3DField .prototype [_fieldInterests])
            this [_fieldInterests] = new Set ();

         this [_fieldInterests] .add (field);
      },
      removeFieldInterest: function (field)
      {
         this [_fieldInterests] .delete (field);
      },
      getFieldInterests: function ()
      {
         return this [_fieldInterests];
      },
      addFieldCallback: function (key, object)
      {
         if (this [_fieldCallbacks] === X3DField .prototype [_fieldCallbacks])
            this [_fieldCallbacks] = new Map ();

         this [_fieldCallbacks] .set (key, object);
      },
      removeFieldCallback: function (key)
      {
         this [_fieldCallbacks] .delete (key);
      },
      getFieldCallbacks: function ()
      {
         return this [_fieldCallbacks];
      },
      addInputRoute: function (route)
      {
         if (this [_inputRoutes] === X3DField .prototype [_inputRoutes])
            this [_inputRoutes] = new Set ();

         this [_inputRoutes] .add (route);

         this .processRouteCallbacks ();
      },
      removeInputRoute: function (route)
      {
         this [_inputRoutes] .delete (route);

         this .processRouteCallbacks ();
      },
      getInputRoutes: function ()
      {
         return this [_inputRoutes];
      },
      addOutputRoute: function (route)
      {
         if (this [_outputRoutes] === X3DField .prototype [_outputRoutes])
            this [_outputRoutes] = new Set ();

         this [_outputRoutes] .add (route);

         this .processRouteCallbacks ();
      },
      removeOutputRoute: function (route)
      {
         this [_outputRoutes] .delete (route);

         this .processRouteCallbacks ();
      },
      getOutputRoutes: function ()
      {
         return this [_outputRoutes];
      },
      addRouteCallback: function (key, object)
      {
         if (this [_routeCallbacks] === X3DField .prototype [_routeCallbacks])
            this [_routeCallbacks] = new Map ();

         this [_routeCallbacks] .set (key, object);
      },
      removeRouteCallback: function (key)
      {
         this [_routeCallbacks] .delete (key);
      },
      getRouteCallbacks: function ()
      {
         return this [_routeCallbacks];
      },
      processRouteCallbacks: (function ()
      {
         const routeCallbacksTemp = [ ];

         return function ()
         {
            if (this [_routeCallbacks] .size)
            {
               for (const routeCallback of MapUtilities .values (routeCallbacksTemp, this [_routeCallbacks]))
                  routeCallback ();
            }
         };
      })(),
      processEvent: (function ()
      {
         const fieldCallbacksTemp = [ ];

         return function (event = Events .create (this))
         {
            if (event .has (this))
               return;

            event .add (this);

            this .setTainted (false);

            const field = event .field;

            if (field !== this)
               this .set (field .getValue (), field .length);

            // Process interests

            this .processInterests ();

            // Process routes

            let first = true;

            if (this [_fieldInterests] .size)
            {
               for (const fieldInterest of this [_fieldInterests] .values ())
               {
                  if (first)
                  {
                     first = false;
                     fieldInterest .addEventObject (this, event);
                  }
                  else
                     fieldInterest .addEventObject (this, Events .copy (event));
               }
            }

            if (first)
               Events .push (event);

            // Process field callbacks

            if (this [_fieldCallbacks] .size)
            {
               for (const fieldCallback of MapUtilities .values (fieldCallbacksTemp, this [_fieldCallbacks]))
                  fieldCallback (this .valueOf ());
            }
         };
      })(),
      addCloneCount: Function .prototype,
      removeCloneCount: Function .prototype,
      valueOf: function ()
      {
         return this;
      },
      fromString: function (string, scene)
      {
         const
            VRMLParser = require ("x_ite/Parser/VRMLParser"),
            parser     = new VRMLParser (scene);

         parser .setUnits (!!scene);
         parser .setInput (string);

         if (parser .fieldValue (this))
            return;

         throw new Error ("Couldn't read value for field '" + this .getName () + "'.");
      },
      dispose: function ()
      {
         for (const route of new Set (this [_inputRoutes]))
            route .dispose ();

         for (const route of new Set (this [_outputRoutes]))
            route .dispose ();

         X3DChildObject .prototype .dispose .call (this);
      }
   });

   for (const key of Reflect .ownKeys (X3DField .prototype))
      Object .defineProperty (X3DField .prototype, key, { enumerable: false });

   return X3DField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFBool',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

   function SFBool (value)
   {
      return X3DField .call (this, !! value);
   }

   SFBool .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFBool,
      copy: function ()
      {
         return new SFBool (this .getValue ());
      },
      isDefaultValue: function ()
      {
         return this .getValue () === false;
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, !! value);
      },
      getTypeName: function ()
      {
         return "SFBool";
      },
      getType: function ()
      {
         return X3DConstants .SFBool;
      },
      valueOf: function ()
      {
         return this .getValue ();
      },
      toStream: function (stream)
      {
         stream .string += this .getValue () ? "TRUE" : "FALSE";
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         stream .string += this .getValue () ? "true" : "false";
      },
   });

   for (const key of Reflect .ownKeys (SFBool .prototype))
      Object .defineProperty (SFBool .prototype, key, { enumerable: false });

   return SFBool;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithm',[],function ()
{
"use strict";

   function Algorithm () { }

   Algorithm .prototype =
   {
      constructor: Algorithm,
      radians: function (value)
      {
         return value * (Math .PI / 180);
      },
      degrees: function (value)
      {
         return value * (180 / Math .PI);
      },
      random: function (min, max)
      {
         return min + Math .random () * (max - min);
      },
      fract: function (value)
      {
         return value % 1;
      },
      clamp: function (value, min, max)
      {
         // http://jsperf.com/math-clamp
         // http://jsperf.com/clamping-methods/2
         return Math .min (Math .max (value, min), max);
      },
      interval: function (value, low, high)
      {
         if (value >= high)
            return ((value - low) % (high - low)) + low;

         if (value < low)
            return ((value - high) % (high - low)) + high;

         return value;
      },
      lerp: function (source, destination, t)
      {
         return source + t * (destination - source);
      },
      slerp: function (source, destination, t)
      {
         let cosom = source .dot (destination);

         // if (cosom <= -1) ... vectors are inverse colinear.

         if (cosom >= 1) // Both normal vectors are equal.
            return source;

         if (cosom < 0)
         {
            // Reverse signs so we travel the short way round.
            cosom = -cosom;
            destination .negate ();
         }

         const
            omega  = Math .acos (cosom),
            sinom  = Math .sin  (omega),
            scale0 = Math .sin ((1 - t) * omega) / sinom,
            scale1 = Math .sin (t * omega) / sinom;

         source .x = source .x * scale0 + destination .x * scale1;
         source .y = source .y * scale0 + destination .y * scale1;
         source .z = source .z * scale0 + destination .z * scale1;
         source .w = source .w * scale0 + destination .w * scale1;

         return source;
      },
      simpleSlerp: function (source, destination, t)
      {
         const cosom = source .dot (destination);

         // if (cosom <= -1) ... vectors are inverse colinear.

         if (cosom >= 1) // Both normal vectors are equal.
            return source;

         const
            omega  = Math .acos (cosom),
            sinom  = Math .sin  (omega),
            scale0 = Math .sin ((1 - t) * omega) / sinom,
            scale1 = Math .sin (t * omega) / sinom;

         source .x = source .x * scale0 + destination .x * scale1;
         source .y = source .y * scale0 + destination .y * scale1;
         source .z = source .z * scale0 + destination .z * scale1;
         source .w = source .w * scale0 + destination .w * scale1;

         return source;
      },
      isPowerOfTwo: function (n)
      {
         return ((n - 1) & n) === 0;
      },
      nextPowerOfTwo: function (n)
      {
         ///  Returns the next power of two of @a n. If n is a power of two, n is returned.

         if (this .isPowerOfTwo (n))
            return n;

         return 1 << 32 - Math .clz32 (n);
      },
      cmp: function (lhs, rhs)
      {
         return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
      },
      less: function (lhs, rhs)
      {
         return lhs < rhs;
      },
      greater: function (lhs, rhs)
      {
         return lhs > rhs;
      },
      lowerBound: function (array, first, last, value, comp = this .less)
      {
         // http://en.cppreference.com/w/cpp/algorithm/lower_bound

         let
            index = 0,
            step  = 0,
            count = last - first;

         while (count > 0)
         {
            step  = count >>> 1;
            index = first + step;

            if (comp (array [index], value))
            {
               first  = ++ index;
               count -= step + 1;
            }
            else
               count = step;
         }

         return first;
      },
      upperBound: function (array, first, last, value, comp = this .less)
      {
         // http://en.cppreference.com/w/cpp/algorithm/upper_bound

         let
            index = 0,
            step  = 0,
            count = last - first;

         while (count > 0)
         {
            step  = count >>> 1;
            index = first + step;

            if (comp (value, array [index]))
               count = step;

            else
            {
               first  = ++ index;
               count -= step + 1;
            }
         }

         return first;
      },
      set_difference: function (lhs, rhs, result)
      {
         for (const key of lhs)
         {
            if (rhs .has (key))
               continue;

            result .add (key);
         }

         return result;
      },
   };

   return new Algorithm ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Color3',[
   "standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

   const clamp = Algorithm .clamp;

   const
      _r = Symbol .for ("X_ITE.Color3.r"),
      _g = Symbol .for ("X_ITE.Color3.g"),
      _b = Symbol .for ("X_ITE.Color3.b");

   function Color3 (r, g, b)
   {
      if (arguments .length)
      {
         this [_r] = clamp (r, 0, 1);
         this [_g] = clamp (g, 0, 1);
         this [_b] = clamp (b, 0, 1);
      }
      else
      {
         this [_r] = 0;
         this [_g] = 0;
         this [_b] = 0;
      }
   }

   Color3 .prototype =
   {
      constructor: Color3,
      length: 3,
      [Symbol .iterator]: function* ()
      {
         yield this [_r];
         yield this [_g];
         yield this [_b];
      },
      copy: function ()
      {
         const copy = Object .create (Color3 .prototype);
         copy [_r] = this [_r];
         copy [_g] = this [_g];
         copy [_b] = this [_b];
         return copy;
      },
      assign: function (color)
      {
         this [_r] = color [_r];
         this [_g] = color [_g];
         this [_b] = color [_b];
      },
      set: function (r, g, b)
      {
         this [_r] = clamp (r, 0, 1);
         this [_g] = clamp (g, 0, 1);
         this [_b] = clamp (b, 0, 1);
      },
      equals: function (color)
      {
         return this [_r] === color [_r] &&
                this [_g] === color [_g] &&
                this [_b] === color [_b];
      },
      getHSV: function (result)
      {
         let h, s, v;

         const min = Math .min (this [_r], this [_g], this [_b]);
         const max = Math .max (this [_r], this [_g], this [_b]);
         v = max; // value

         const delta = max - min;

         if (max !== 0 && delta !== 0)
         {
            s = delta / max; // s

            if (this [_r] === max)
               h =     (this [_g] - this [_b]) / delta;  // between yellow & magenta
            else if (this [_g] === max)
               h = 2 + (this [_b] - this [_r]) / delta;  // between cyan & yellow
            else
               h = 4 + (this [_r] - this [_g]) / delta;  // between magenta & cyan

            h *= Math .PI / 3;  // radiants
            if (h < 0)
               h += Math .PI * 2;
         }
         else
            s = h = 0;         // s = 0, h is undefined

         result [0] = h;
         result [1] = s;
         result [2] = v;

         return result;
      },
      setHSV: function (h, s, v)
      {
         s = clamp (s, 0, 1),
         v = clamp (v, 0, 1);

         // H is given on [0, 2 * Pi]. S and V are given on [0, 1].
         // RGB are each returned on [0, 1].

         if (s === 0)
         {
            // achromatic (grey)
            this [_r] = this [_g] = this [_b] = v;
         }
         else
         {
            const w = Algorithm .degrees (Algorithm .interval (h, 0, Math .PI * 2)) / 60;     // sector 0 to 5

            const i = Math .floor (w);
            const f = w - i;                      // factorial part of h
            const p = v * ( 1 - s );
            const q = v * ( 1 - s * f );
            const t = v * ( 1 - s * ( 1 - f ) );

            switch (i % 6)
            {
               case 0:  this [_r] = v; this [_g] = t; this [_b] = p; break;
               case 1:  this [_r] = q; this [_g] = v; this [_b] = p; break;
               case 2:  this [_r] = p; this [_g] = v; this [_b] = t; break;
               case 3:  this [_r] = p; this [_g] = q; this [_b] = v; break;
               case 4:  this [_r] = t; this [_g] = p; this [_b] = v; break;
               default: this [_r] = v; this [_g] = p; this [_b] = q; break;
            }
         }
      },
      toString: function ()
      {
         return this [_r] + " " +
                this [_g] + " " +
                this [_b];
      },
   };

   const r = {
      get: function () { return this [_r]; },
      set: function (value) { this [_r] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   const g = {
      get: function () { return this [_g]; },
      set: function (value) { this [_g] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   const b = {
      get: function () { return this [_b]; },
      set: function (value) { this [_b] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (Color3 .prototype, "r", r);
   Object .defineProperty (Color3 .prototype, "g", g);
   Object .defineProperty (Color3 .prototype, "b", b);

   r .enumerable = false;
   g .enumerable = false;
   b .enumerable = false;

   Object .defineProperty (Color3 .prototype, "0", r);
   Object .defineProperty (Color3 .prototype, "1", g);
   Object .defineProperty (Color3 .prototype, "2", b);

   Object .assign (Color3,
   {
      HSV: function (h, s, v)
      {
         const color = Object .create (this .prototype);
         color .setHSV (h, s, v);
         return color;
      },
      lerp: function (a, b, t, r)
      {
         // Linearely interpolate in HSV space between source color @a a and destination color @a b by an amount of @a t.
         // Source and destination color must be in HSV space. The resulting HSV color is stored in @a r.

         let
            ha = a [0], hb = b [0];

         const
            sa = a [1], sb = b [1],
            va = a [2], vb = b [2];

         if (sa === 0)
            ha = hb;

         if (sb === 0)
            hb = ha;

         const range = Math .abs (hb - ha);

         if (range <= Math .PI)
         {
            r [0] = ha + t * (hb - ha);
            r [1] = sa + t * (sb - sa);
            r [2] = va + t * (vb - va);
            return r;
         }

         const
            PI2  = Math .PI * 2,
            step = (PI2 - range) * t;

         let h = ha < hb ? ha - step : ha + step;

         if (h < 0)
            h += PI2;

         else if (h > PI2)
            h -= PI2;

         r [0] = h;
         r [1] = sa + t * (sb - sa);
         r [2] = va + t * (vb - va);
         return r;
      },
   });

   return Color3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFColor',[
   "standard/Math/Numbers/Color3",
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (Color3,
          X3DField,
          X3DConstants,
          Generator)
{
"use strict";

   function SFColor (r, g, b)
   {
      switch (arguments .length)
      {
         case 0:
            return X3DField .call (this, new Color3 ());

         case 1:
            return X3DField .call (this, arguments [0]);

         case 3:
            return X3DField .call (this, new Color3 (+r, +g, +b));
      }

      throw new Error ("Invalid arguments.");
   }

   SFColor .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFColor,
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new SFColor (this .getValue () .copy ());
      },
      getTypeName: function ()
      {
         return "SFColor";
      },
      getType: function ()
      {
         return X3DConstants .SFColor;
      },
      equals: function (color)
      {
         return this .getValue () .equals (color .getValue ());
      },
      isDefaultValue: function ()
      {
         return (
            this .getValue () .r === 0 &&
            this .getValue () .g === 0 &&
            this .getValue () .b === 0);
      },
      set: function (value)
      {
         this .getValue () .assign (value);
      },
      getHSV: function ()
      {
         return this .getValue () .getHSV ([ ]);
      },
      setHSV: function (h, s, v)
      {
         this .getValue () .setHSV (h, s, v);
         this .addEvent ();
      },
      lerp: (function ()
      {
         const
            s = [ ],
            d = [ ],
            r = [ ];

         return function (destination, t)
         {
            const result = new SFColor ();

            this .getValue () .getHSV (s),
            destination .getValue () .getHSV (d),
            Color3 .lerp (s, d, t, r),

            result .setHSV (r [0], r [1], r [2], r [3]);

            return result;
         };
      })(),
      toStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            value     = this .getValue (),
            last      = value .length - 1;

         for (let i = 0; i < last; ++ i)
         {
            stream .string += generator .Precision (value [i]);
            stream .string += " ";
         }

         stream .string += generator .Precision (value [last]);
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFColor .prototype))
      Object .defineProperty (SFColor .prototype, key, { enumerable: false });

   const r = {
      get: function ()
      {
         return this .getValue () .r;
      },
      set: function (value)
      {
         this .getValue () .r = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const g = {
      get: function ()
      {
         return this .getValue () .g;
      },
      set: function (value)
      {
         this .getValue () .g = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const b = {
      get: function ()
      {
         return this .getValue () .b;
      },
      set: function (value)
      {
         this .getValue () .b = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFColor .prototype, "r", r);
   Object .defineProperty (SFColor .prototype, "g", g);
   Object .defineProperty (SFColor .prototype, "b", b);

   r .enumerable = false;
   g .enumerable = false;
   b .enumerable = false;

   Object .defineProperty (SFColor .prototype, "0", r);
   Object .defineProperty (SFColor .prototype, "1", g);
   Object .defineProperty (SFColor .prototype, "2", b);

   return SFColor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Color4',[
   "standard/Math/Numbers/Color3",
   "standard/Math/Algorithm",
],
function (Color3, Algorithm)
{
"use strict";

   const clamp = Algorithm .clamp;

   const
      _r = Symbol .for ("X_ITE.Color3.r"),
      _g = Symbol .for ("X_ITE.Color3.g"),
      _b = Symbol .for ("X_ITE.Color3.b"),
      _a = Symbol ();

   function Color4 (r, g, b, a)
   {
      if (arguments .length)
      {
         this [_r] = clamp (r, 0, 1);
         this [_g] = clamp (g, 0, 1);
         this [_b] = clamp (b, 0, 1);
         this [_a] = clamp (a, 0, 1);
      }
      else
      {
         this [_r] = 0;
         this [_g] = 0;
         this [_b] = 0;
         this [_a] = 0;
      }
   }

   Color4 .prototype =
   {
      constructor: Color4,
      length: 4,
      [Symbol .iterator]: function* ()
      {
         yield this [_r];
         yield this [_g];
         yield this [_b];
         yield this [_a];
      },
      copy: function ()
      {
         const copy = Object .create (Color4 .prototype);
         copy [_r] = this [_r];
         copy [_g] = this [_g];
         copy [_b] = this [_b];
         copy [_a] = this [_a];
         return copy;
      },
      assign: function (color)
      {
         this [_r] = color [_r];
         this [_g] = color [_g];
         this [_b] = color [_b];
         this [_a] = color [_a];
      },
      set: function (r, g, b, a)
      {
         this [_r] = clamp (r, 0, 1);
         this [_g] = clamp (g, 0, 1);
         this [_b] = clamp (b, 0, 1);
         this [_a] = clamp (a, 0, 1);
      },
      equals: function (color)
      {
         return this [_r] === color [_r] &&
                this [_g] === color [_g] &&
                this [_b] === color [_b] &&
                this [_a] === color [_a];
      },
      getHSVA: function (result)
      {
         Color3 .prototype .getHSV .call (this, result);

         result [3] = this [_a];

         return result;
      },
      setHSVA: function (h, s, v, a)
      {
         Color3 .prototype .setHSV .call (this, h, s, v);

         this [_a] = clamp (a, 0, 1);
      },
      toString: function ()
      {
         return this [_r] + " " +
                this [_g] + " " +
                this [_b] + " " +
                this [_a];
      },
   };

   const r = {
      get: function () { return this [_r]; },
      set: function (value) { this [_r] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   const g = {
      get: function () { return this [_g]; },
      set: function (value) { this [_g] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   const b = {
      get: function () { return this [_b]; },
      set: function (value) { this [_b] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   const a = {
      get: function () { return this [_a]; },
      set: function (value) { this [_a] = clamp (value, 0, 1); },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (Color4 .prototype, "r", r);
   Object .defineProperty (Color4 .prototype, "g", g);
   Object .defineProperty (Color4 .prototype, "b", b);
   Object .defineProperty (Color4 .prototype, "a", a);

   r .enumerable = false;
   g .enumerable = false;
   b .enumerable = false;
   a .enumerable = false;

   Object .defineProperty (Color4 .prototype, "0", r);
   Object .defineProperty (Color4 .prototype, "1", g);
   Object .defineProperty (Color4 .prototype, "2", b);
   Object .defineProperty (Color4 .prototype, "3", a);

   Object .assign (Color4,
   {
      HSVA: function (h, s, v, a)
      {
         const color = Object .create (this .prototype);
         color .setHSVA (h, s, v, a);
         return color;
      },
      lerp: function (a, b, t, r)
      {
         // Linearely interpolate in HSVA space between source color @a a and destination color @a b by an amount of @a t.
         // Source and destination color must be in HSVA space. The resulting HSVA color is stored in @a r.
         const aa = a [3];
         Color3 .lerp (a, b, t, r);
         r [3] = aa + t * (b [3] - aa);
         return r;
      },
   });

   return Color4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFColorRGBA',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFColor",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Color4",
],
function (X3DField,
          SFColor,
          X3DConstants,
          Color4)
{
"use strict";

   function SFColorRGBA (r, g, b, a)
   {
      switch (arguments .length)
      {
         case 0:
            return X3DField .call (this, new Color4 ());

         case 1:
            return X3DField .call (this, arguments [0]);

         case 4:
            return X3DField .call (this, new Color4 (+r, +g, +b, +a));
      }

      throw new Error ("Invalid arguments.");
   }

   SFColorRGBA .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFColorRGBA,
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new SFColorRGBA (this .getValue () .copy ());
      },
      getTypeName: function ()
      {
         return "SFColorRGBA";
      },
      getType: function ()
      {
         return X3DConstants .SFColorRGBA;
      },
      equals: SFColor .prototype .equals,
      isDefaultValue: function ()
      {
         return (
            this .getValue () .r === 0 &&
            this .getValue () .g === 0 &&
            this .getValue () .b === 0 &&
            this .getValue () .a === 0);
      },
      set: SFColor .prototype .set,
      getHSVA: function ()
      {
         return this .getValue () .getHSVA ([ ]);
      },
      setHSVA: function (h, s, v, a)
      {
         this .getValue () .setHSVA (h, s, v, a);
         this .addEvent ();
      },
      lerp: (function ()
      {
         const
            s = [ ],
            d = [ ],
            r = [ ];

         return function (destination, t)
         {
            const result = new SFColorRGBA ();

            this .getValue () .getHSVA (s),
            destination .getValue () .getHSVA (d),
            Color4 .lerp (s, d, t, r),

            result .setHSVA (r [0], r [1], r [2], r [3]);

            return result;
         };
      })(),
      toStream: SFColor .prototype .toStream,
      toVRMLStream: SFColor .prototype .toVRMLStream,
      toXMLStream: SFColor .prototype .toXMLStream,
   });

   for (const key of Reflect .ownKeys (SFColorRGBA .prototype))
      Object .defineProperty (SFColorRGBA .prototype, key, { enumerable: false });

   const r = {
      get: function ()
      {
         return this .getValue () .r;
      },
      set: function (value)
      {
         this .getValue () .r = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const g = {
      get: function ()
      {
         return this .getValue () .g;
      },
      set: function (value)
      {
         this .getValue () .g = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const b = {
      get: function ()
      {
         return this .getValue () .b;
      },
      set: function (value)
      {
         this .getValue () .b = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const a = {
      get: function ()
      {
         return this .getValue () .a;
      },
      set: function (value)
      {
         this .getValue () .a = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFColorRGBA .prototype, "r", r);
   Object .defineProperty (SFColorRGBA .prototype, "g", g);
   Object .defineProperty (SFColorRGBA .prototype, "b", b);
   Object .defineProperty (SFColorRGBA .prototype, "a", a);

   r .enumerable = false;
   g .enumerable = false;
   b .enumerable = false;
   a .enumerable = false;

   Object .defineProperty (SFColorRGBA .prototype, "0", r);
   Object .defineProperty (SFColorRGBA .prototype, "1", g);
   Object .defineProperty (SFColorRGBA .prototype, "2", b);
   Object .defineProperty (SFColorRGBA .prototype, "3", a);

   return SFColorRGBA;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFDouble',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

   function SFDouble (value)
   {
      return X3DField .call (this, arguments .length ? +value : 0);
   }

   SFDouble .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFDouble,
      copy: function ()
      {
         return new SFDouble (this .getValue ());
      },
      getTypeName: function ()
      {
         return "SFDouble";
      },
      getType: function ()
      {
         return X3DConstants .SFDouble;
      },
      isDefaultValue: function ()
      {
         return this .getValue () === 0;
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, +value);
      },
      valueOf: X3DField .prototype .getValue,
      toStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            category  = generator .Unit (this .getUnit ());

         stream .string += generator .DoublePrecision (generator .ToUnit (category, this .getValue ()));
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFDouble .prototype))
      Object .defineProperty (SFDouble .prototype, key, { enumerable: false });

   return SFDouble;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFFloat',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

   function SFFloat (value)
   {
      return X3DField .call (this, arguments .length ? +value : 0);
   }

   SFFloat .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFFloat,
      copy: function ()
      {
         return new SFFloat (this .getValue ());
      },
      getTypeName: function ()
      {
         return "SFFloat";
      },
      getType: function ()
      {
         return X3DConstants .SFFloat;
      },
      isDefaultValue: function ()
      {
         return this .getValue () === 0;
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, +value);
      },
      valueOf: X3DField .prototype .getValue,
      toStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            category  = generator .Unit (this .getUnit ());

         stream .string += generator .Precision (generator .ToUnit (category, this .getValue ()));
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFFloat .prototype))
      Object .defineProperty (SFFloat .prototype, key, { enumerable: false });

   return SFFloat;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFInt32',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

   function SFInt32 (value)
   {
      return X3DField .call (this, ~~value);
   }

   SFInt32 .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFInt32,
      copy: function ()
      {
         return new SFInt32 (this .getValue ());
      },
      getTypeName: function ()
      {
         return "SFInt32";
      },
      getType: function ()
      {
         return X3DConstants .SFInt32;
      },
      isDefaultValue: function ()
      {
         return this .getValue () === 0;
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, ~~value);
      },
      valueOf: X3DField .prototype .getValue,
      toStream: function (stream, base)
      {
         stream .string += this .getValue () .toString (base);
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         stream .string += this .getValue () .toString ();
      },
   });

   for (const key of Reflect .ownKeys (SFInt32 .prototype))
      Object .defineProperty (SFInt32 .prototype, key, { enumerable: false });

   return SFInt32;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFImage',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFInt32",
   "x_ite/Base/X3DConstants",
],
function (X3DField,
          SFInt32,
          X3DConstants)
{
"use strict";

   /*
    *  Image
    */

   function Image (width, height, comp, array)
   {
      const MFInt32 = require ("x_ite/Fields/ArrayFields") .MFInt32;

      this .width  = ~~width;
      this .height = ~~height;
      this .comp   = ~~comp;
      this .array  = new MFInt32 ();
      this .array .setValue (array);
      this .array .length = this .width * this .height;
   }

   Image .prototype =
   {
      constructor: Image,
      copy: function ()
      {
         return new Image (this .width, this .height, this .comp, this .array);
      },
      equals: function (image)
      {
         return this .width  === image .width &&
                this .height === image .height &&
                this .comp   === image .comp &&
                this .array .equals (image .array);
      },
      assign: function (image)
      {
         this .width  = image .width;
         this .height = image .height;
         this .comp   = image .comp;
         this .array .assign (image .array);
      },
      set: function (width, height, comp, array)
      {
         this .width  = ~~width;
         this .height = ~~height;
         this .comp   = ~~comp;
         this .array .assign (array);
      },
      setWidth: function (value)
      {
         this .width = ~~value;
         this .array .length = this .width  * this .height;
      },
      getWidth: function ()
      {
         return this .width;
      },
      setHeight: function (value)
      {
         this .height = ~~value;
         this .array .length = this .width  * this .height;
      },
      getHeight: function ()
      {
         return this .height;
      },
      setComp: function (value)
      {
         this .comp = ~~value;
      },
      getComp: function ()
      {
         return this .comp;
      },
      setArray: function (value)
      {
         this .array .assign (value);
         this .array .length = this .width  * this .height;
      },
      getArray: function ()
      {
         return this .array;
      },
   };

   /*
    *  SFImage
    */

   function SFImage (width, height, comp, array)
   {
      const MFInt32 = require ("x_ite/Fields/ArrayFields") .MFInt32;

      if (arguments [0] instanceof Image)
         X3DField .call (this, arguments [0]);
      else if (arguments .length === 4)
         X3DField .call (this, new Image (width, height, comp, array));
      else
         X3DField .call (this, new Image (0, 0, 0, new MFInt32 ()));

      this .getValue () .getArray () .addParent (this);
      this .addInterest ("set_size__", this);
      return this;
   }

   SFImage .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFImage,
      set_size__: function ()
      {
         this .getValue () .getArray () .length = this .width * this .height;
      },
      copy: function ()
      {
         return new SFImage (this .getValue () .copy ());
      },
      equals: function (image)
      {
         return this .getValue () .equals (image .getValue ());
      },
      isDefaultValue: function ()
      {
         return (
            this .width  === 0 &&
            this .height === 0 &&
            this .comp   === 0);
      },
      set: function (image)
      {
         this .getValue () .assign (image);
      },
      getTypeName: function ()
      {
         return "SFImage";
      },
      getType: function ()
      {
         return X3DConstants .SFImage;
      },
      toStream: function (stream)
      {
         const
            array = this .array,
            int   = new SFInt32 ();

         stream .string += this .width + " " + this .height + " " + this .comp;

         for (let i = 0, length = this .width * this .height; i < length; ++ i)
         {
            stream .string += " 0x";

            int .set (array [i]);
            int .toXMLStream (stream);
         }
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFImage .prototype))
      Object .defineProperty (SFImage .prototype, key, { enumerable: false });

   const width = {
      get: function ()
      {
         return this .getValue () .getWidth ();
      },
      set: function (value)
      {
         this .getValue () .setWidth (value);
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const height = {
      get: function ()
      {
         return this .getValue () .getHeight ();
      },
      set: function (value)
      {
         this .getValue () .setHeight (value);
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const comp = {
      get: function ()
      {
         return this .getValue () .getComp ();
      },
      set: function (value)
      {
         this .getValue () .setComp (value);
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const array = {
      get: function ()
      {
         return this .getValue () .getArray ();
      },
      set: function (value)
      {
         this .getValue () .setArray (value);
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFImage .prototype, "width",  width);
   Object .defineProperty (SFImage .prototype, "height", height);
   Object .defineProperty (SFImage .prototype, "comp",   comp);
   Object .defineProperty (SFImage .prototype, "array",  array);

   width  .enumerable = false;
   height .enumerable = false;

   Object .defineProperty (SFImage .prototype, "x", width);
   Object .defineProperty (SFImage .prototype, "y", height);

   return SFImage;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFMatrixPrototypeTemplate',[
   "x_ite/Base/X3DField",
],
function (X3DField)
{
"use strict";

   return function (Matrix, SFVec, double)
   {
      return Object .assign (Object .create (X3DField .prototype),
      {
         [Symbol .iterator]: function* ()
         {
            yield* this .getValue ();
         },
         copy: function ()
         {
            return new (this .constructor) (this .getValue () .copy ());
         },
         equals: function (matrix)
         {
            return this .getValue () .equals (matrix .getValue ());
         },
         isDefaultValue: function ()
         {
            return this .getValue () .equals (Matrix .Identity);
         },
         set: function (value)
         {
            this .getValue () .assign (value);
         },
         setTransform: function (translation, rotation, scale, scaleOrientation, center)
         {
            translation      = translation      ? translation      .getValue () : null;
            rotation         = rotation         ? rotation         .getValue () : null;
            scale            = scale            ? scale            .getValue () : null;
            scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
            center           = center           ? center           .getValue () : null;

            this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
         },
         getTransform: function (translation, rotation, scale, scaleOrientation, center)
         {
            translation      = translation      ? translation      .getValue () : null;
            rotation         = rotation         ? rotation         .getValue () : null;
            scale            = scale            ? scale            .getValue () : null;
            scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
            center           = center           ? center           .getValue () : null;

            this .getValue () .get (translation, rotation, scale, scaleOrientation, center);
         },
         determinant: function ()
         {
            return this .getValue () .determinant ();
         },
         transpose: function ()
         {
            return new (this .constructor) (Matrix .transpose (this .getValue ()));
         },
         inverse: function ()
         {
            return new (this .constructor) (Matrix .inverse (this .getValue ()));
         },
         multLeft: function (matrix)
         {
            return new (this .constructor) (Matrix .multLeft (this .getValue (), matrix .getValue ()));
         },
         multRight: function (matrix)
         {
            return new (this .constructor) (Matrix .multRight (this .getValue (), matrix .getValue ()));
         },
         multVecMatrix: function (vector)
         {
            return new SFVec (this .getValue () .multVecMatrix (vector .getValue () .copy ()));
         },
         multMatrixVec: function (vector)
         {
            return new SFVec (this .getValue () .multMatrixVec (vector .getValue () .copy ()));
         },
         multDirMatrix: function (vector)
         {
            return new SFVec (this .getValue () .multDirMatrix (vector .getValue () .copy ()));
         },
         multMatrixDir: function (vector)
         {
            return new SFVec (this .getValue () .multMatrixDir (vector .getValue () .copy ()));
         },
         toStream: function (stream)
         {
            const
               generator = Generator .Get (stream),
               value     = this .getValue (),
               last      = value .length - 1;

            for (let i = 0; i < last; ++ i)
            {
               stream .string += double ? generator .DoublePrecision (value [i]) : generator .Precision (value [i]);
               stream .string += " ";
            }

            stream .string += double ? generator .DoublePrecision (value [last]) : generator .Precision (value [last]);
         },
         toVRMLStream: function (stream)
         {
            this .toStream (stream);
         },
         toXMLStream: function (stream)
         {
            this .toStream (stream);
         },
      });
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVecPrototypeTemplate',[
   "x_ite/Base/X3DField",
   "x_ite/InputOutput/Generator",
],
function (X3DField,
          Generator)
{
"use strict";

   return function (Type, double)
   {
      return Object .assign (Object .create (X3DField .prototype),
      {
         [Symbol .iterator]: function* ()
         {
            yield* this .getValue ();
         },
         copy: function ()
         {
            return new (this .constructor) (this .getValue () .copy ());
         },
         equals: function (vector)
         {
            return this .getValue () .equals (vector .getValue ());
         },
         isDefaultValue: function ()
         {
            return this .getValue () .equals (Type .Zero);
         },
         set: function (value)
         {
            this .getValue () .assign (value);
         },
         add: function (vector)
         {
            return new (this .constructor) (Type .add (this .getValue (), vector .getValue ()));
         },
         distance: function (vector)
         {
            return this .getValue () .distance (vector .getValue ());
         },
         divide: function (value)
         {
            return new (this .constructor) (Type .divide (this .getValue (), value));
         },
         divVec: function (vector)
         {
            return new (this .constructor) (Type .divVec (this .getValue (), vector .getValue ()));
         },
         dot: function (vector)
         {
            return this .getValue () .dot (vector .getValue ());
         },
         length: function ()
         {
            return this .getValue () .abs ();
         },
         lerp: function (destination, t)
         {
            return new (this .constructor) (Type .lerp (this .getValue (), destination, t));
         },
         multiply: function (value)
         {
            return new (this .constructor) (Type .multiply (this .getValue (), value));
         },
         multVec: function (vector)
         {
            return new (this .constructor) (Type .multVec (this .getValue (), vector .getValue ()));
         },
         negate: function ()
         {
            return new (this .constructor) (Type .negate (this .getValue () .copy ()));
         },
         normalize: function (vector)
         {
            return new (this .constructor) (Type .normalize (this .getValue ()));
         },
         subtract: function (vector)
         {
            return new (this .constructor) (Type .subtract (this .getValue (), vector .getValue ()));
         },
         toStream: function (stream)
         {
            const
               generator = Generator .Get (stream),
               value     = this .getValue (),
               category  = generator .Unit (this .getUnit ()),
               last      = value .length - 1;

            for (let i = 0; i < last; ++ i)
            {
               stream .string += double ? generator .DoublePrecision (generator .ToUnit (category, value [i])) : generator .Precision (generator .ToUnit (category, value [i]));
               stream .string += " ";
            }

            stream .string += double ? generator .DoublePrecision (generator .ToUnit (category, value [last])) : generator .Precision (generator .ToUnit (category, value [last]));
         },
         toVRMLStream: function (stream)
         {
            this .toStream (stream);
         },
         toXMLStream: function (stream)
         {
            this .toStream (stream);
         },
      });
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector2',[
   "standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

   function Vector2 (x, y)
   {
      this .x = x;
      this .y = y;
   }

   Vector2 .prototype =
   {
      constructor: Vector2,
      length: 2,
      [Symbol .iterator]: function* ()
      {
         yield this .x;
         yield this .y;
      },
      copy: function ()
      {
         const copy = Object .create (Vector2 .prototype);
         copy .x = this .x;
         copy .y = this .y;
         return copy;
      },
      assign: function (vector)
      {
         this .x = vector .x;
         this .y = vector .y;
         return this;
      },
      set: function (x, y)
      {
         this .x = x;
         this .y = y;
         return this;
      },
      equals: function (vector)
      {
         return this .x === vector .x &&
                this .y === vector .y;
      },
      negate: function ()
      {
         this .x = -this .x;
         this .y = -this .y;
         return this;
      },
      add: function (vector)
      {
         this .x += vector .x;
         this .y += vector .y;
         return this;
      },
      subtract: function (vector)
      {
         this .x -= vector .x;
         this .y -= vector .y;
         return this;
      },
      multiply: function (value)
      {
         this .x *= value;
         this .y *= value;
         return this;
      },
      multVec: function (vector)
      {
         this .x *= vector .x;
         this .y *= vector .y;
         return this;
      },
      divide: function (value)
      {
         this .x /= value;
         this .y /= value;
         return this;
      },
      divVec: function (vector)
      {
         this .x /= vector .x;
         this .y /= vector .y;
         return this;
      },
      normalize: function ()
      {
         const length = Math .hypot (this .x, this .y);

         if (length)
         {
            this .x /= length;
            this .y /= length;
         }

         return this;
      },
      dot: function (vector)
      {
         return this .x * vector .x +
                this .y * vector .y;
      },
      norm: function ()
      {
         const
            x = this .x,
            y = this .y;

         return x * x +
                y * y;
      },
      abs: function ()
      {
         return Math .hypot (this .x, this .y);
      },
      distance: function (vector)
      {
         return Math .hypot (this .x - vector .x,
                             this .y - vector .y);
      },
      lerp: function (destination, t)
      {
         const
            x = this .x,
            y = this .y;

         this .x = x + t * (destination .x - x);
         this .y = y + t * (destination .y - y);
         return this;
      },
      min: function (vector)
      {
         let
            x = this .x,
            y = this .y;

         for (const vector of arguments)
         {
            x = Math .min (x, vector .x);
            y = Math .min (y, vector .y);
         }

         this .x = x;
         this .y = y;
         return this;
      },
      max: function (vector)
      {
         let
            x = this .x,
            y = this .y;

         for (const vector of arguments)
         {
            x = Math .max (x, vector .x);
            y = Math .max (y, vector .y);
         }

         this .x = x;
         this .y = y;
         return this;
      },
      toString: function ()
      {
         return this .x + " " +
                this .y;
      }
   };

   Object .defineProperty (Vector2 .prototype, "0",
   {
      get: function () { return this .x; },
      set: function (value) { this .x = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector2 .prototype, "1",
   {
      get: function () { return this .y; },
      set: function (value) { this .y = value; },
      enumerable: false,
      configurable: false
   });

   Object .assign (Vector2,
   {
      Zero: new Vector2 (0, 0),
      One: new Vector2 (1, 1),
      negate: function (vector)
      {
         return vector .copy () .negate ();
      },
      add: function (lhs, rhs)
      {
         return lhs .copy () .add (rhs);
      },
      subtract: function (lhs, rhs)
      {
         return lhs .copy () .subtract (rhs);
      },
      multiply: function (lhs, rhs)
      {
         return lhs .copy () .multiply (rhs);
      },
      multVec: function (lhs, rhs)
      {
         return lhs .copy () .multVec (rhs);
      },
      divide: function (lhs, rhs)
      {
         return lhs .copy () .divide (rhs);
      },
      divVec: function (lhs, rhs)
      {
         return lhs .copy () .divVec (rhs);
      },
      normalize: function (vector)
      {
         return vector .copy () .normalize ();
      },
      dot: function (lhs, rhs)
      {
         return lhs .copy () .dot (rhs);
      },
      lerp: function (source, destination, t)
      {
         return source .copy () .lerp (destination, t);
      },
      min: function (lhs, rhs)
      {
         return Vector2 .prototype .min .apply (lhs .copy (), arguments);
      },
      max: function (lhs, rhs)
      {
         return Vector2 .prototype .max .apply (lhs .copy (), arguments);
      },
   });

   return Vector2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec2',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFVecPrototypeTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (X3DField, SFVecPrototypeTemplate, X3DConstants, Vector2)
{
"use strict";

   function SFVec2Template (TypeName, Type, double)
   {
      function SFVec2 (x, y)
      {
         switch (arguments .length)
         {
            case 0:
               return X3DField .call (this, new Vector2 (0, 0));

            case 1:
               return X3DField .call (this, arguments [0]);

            case 2:
               return X3DField .call (this, new Vector2 (+x, +y));
         }

         throw new Error ("Invalid arguments.");
      }

      SFVec2 .prototype = Object .assign (Object .create (X3DField .prototype),
         SFVecPrototypeTemplate (Vector2, double),
      {
         constructor: SFVec2,
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
      });

      for (const key of Reflect .ownKeys (SFVec2 .prototype))
         Object .defineProperty (SFVec2 .prototype, key, { enumerable: false });

      const x = {
         get: function ()
         {
            return this .getValue () .x;
         },
         set: function (value)
         {
            this .getValue () .x = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const y = {
         get: function ()
         {
            return this .getValue () .y;
         },
         set: function (value)
         {
            this .getValue () .y = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      Object .defineProperty (SFVec2 .prototype, "x", x);
      Object .defineProperty (SFVec2 .prototype, "y", y);

      x .enumerable = false;
      y .enumerable = false;

      Object .defineProperty (SFVec2 .prototype, "0", x);
      Object .defineProperty (SFVec2 .prototype, "1", y);

      return SFVec2;
   }

   return {
      SFVec2d: SFVec2Template ("SFVec2d", X3DConstants .SFVec2d, true),
      SFVec2f: SFVec2Template ("SFVec2f", X3DConstants .SFVec2f, false),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector3',[
   "standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

   function Vector3 (x, y, z)
   {
      this .x = x;
      this .y = y;
      this .z = z;
   }

   Vector3 .prototype =
   {
      constructor: Vector3,
      length: 3,
      [Symbol .iterator]: function* ()
      {
         yield this .x;
         yield this .y;
         yield this .z;
      },
      copy: function ()
      {
         const copy = Object .create (Vector3 .prototype);
         copy .x = this .x;
         copy .y = this .y;
         copy .z = this .z;
         return copy;
      },
      assign: function (vector)
      {
         this .x = vector .x;
         this .y = vector .y;
         this .z = vector .z;
         return this;
      },
      set: function (x, y, z)
      {
         this .x = x;
         this .y = y;
         this .z = z;
         return this;
      },
      equals: function (vector)
      {
         return this .x === vector .x &&
                this .y === vector .y &&
                this .z === vector .z;
      },
      negate: function ()
      {
         this .x = -this .x;
         this .y = -this .y;
         this .z = -this .z;
         return this;
      },
      add: function (vector)
      {
         this .x += vector .x;
         this .y += vector .y;
         this .z += vector .z;
         return this;
      },
      subtract: function (vector)
      {
         this .x -= vector .x;
         this .y -= vector .y;
         this .z -= vector .z;
         return this;
      },
      multiply: function (value)
      {
         this .x *= value;
         this .y *= value;
         this .z *= value;
         return this;
      },
      multVec: function (vector)
      {
         this .x *= vector .x;
         this .y *= vector .y;
         this .z *= vector .z;
         return this;
      },
      divide: function (value)
      {
         this .x /= value;
         this .y /= value;
         this .z /= value;
         return this;
      },
      divVec: function (vector)
      {
         this .x /= vector .x;
         this .y /= vector .y;
         this .z /= vector .z;
         return this;
      },
      cross: function (vector)
      {
         const
            ax = this   .x, ay = this   .y, az = this   .z,
            bx = vector .x, by = vector .y, bz = vector .z;

         this .x = ay * bz - az * by;
         this .y = az * bx - ax * bz;
         this .z = ax * by - ay * bx;

         return this;
      },
      normalize: function ()
      {
         const length = Math .hypot (this .x, this .y, this .z);

         if (length)
         {
            this .x /= length;
            this .y /= length;
            this .z /= length;
         }

         return this;
      },
      dot: function (vector)
      {
         return this .x * vector .x +
                this .y * vector .y +
                this .z * vector .z;
      },
      norm: function ()
      {
         let
            x = this .x,
            y = this .y,
            z = this .z;

         return x * x +
                y * y +
                z * z;
      },
      abs: function ()
      {
         return Math .hypot (this .x, this .y, this .z);
      },
      distance: function (vector)
      {
         return Math .hypot (this .x - vector .x,
                             this .y - vector .y,
                             this .z - vector .z);
      },
      lerp: function (destination, t)
      {
         const
            x = this .x,
            y = this .y,
            z = this .z;

         this .x = x + t * (destination .x - x);
         this .y = y + t * (destination .y - y);
         this .z = z + t * (destination .z - z);
         return this;
      },
      slerp: (function ()
      {
         const tmp = new Vector3 (0, 0, 0);

         return function (destination, t)
         {
            return Algorithm .simpleSlerp (this, tmp .assign (destination), t);
         };
      })(),
      min: function (vector)
      {
         let
            x = this .x,
            y = this .y,
            z = this .z;

         for (const vector of arguments)
         {
            x = Math .min (x, vector .x);
            y = Math .min (y, vector .y);
            z = Math .min (z, vector .z);
         }

         this .x = x;
         this .y = y;
         this .z = z;
         return this;
      },
      max: function (vector)
      {
         let
            x = this .x,
            y = this .y,
            z = this .z;

         for (const vector of arguments)
         {
            x = Math .max (x, vector .x);
            y = Math .max (y, vector .y);
            z = Math .max (z, vector .z);
         }

         this .x = x;
         this .y = y;
         this .z = z;
         return this;
      },
      toString: function ()
      {
         return this .x + " " +
                this .y + " " +
                this .z;
      }
   };

   Object .defineProperty (Vector3 .prototype, "0",
   {
      get: function () { return this .x; },
      set: function (value) { this .x = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector3 .prototype, "1",
   {
      get: function () { return this .y; },
      set: function (value) { this .y = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector3 .prototype, "2",
   {
      get: function () { return this .z; },
      set: function (value) { this .z = value; },
      enumerable: false,
      configurable: false
   });

   Object .assign (Vector3,
   {
      Zero: new Vector3 (0, 0, 0),
      One: new Vector3 (1, 1, 1),
      xAxis: new Vector3 (1, 0, 0),
      yAxis: new Vector3 (0, 1, 0),
      zAxis: new Vector3 (0, 0, 1),
      negate: function (vector)
      {
         return vector .copy () .negate ();
      },
      add: function (lhs, rhs)
      {
         return lhs .copy () .add (rhs);
      },
      subtract: function (lhs, rhs)
      {
         return lhs .copy () .subtract (rhs);
      },
      multiply: function (lhs, rhs)
      {
         return lhs .copy () .multiply (rhs);
      },
      multVec: function (lhs, rhs)
      {
         return lhs .copy () .multVec (rhs);
      },
      divide: function (lhs, rhs)
      {
         return lhs .copy () .divide (rhs);
      },
      divVec: function (lhs, rhs)
      {
         return lhs .copy () .divVec (rhs);
      },
      cross: function (lhs, rhs)
      {
         return lhs .copy () .cross (rhs);
      },
      normalize: function (vector)
      {
         return vector .copy () .normalize ();
      },
      dot: function (lhs, rhs)
      {
         return lhs .copy () .dot (rhs);
      },
      lerp: function (source, destination, t)
      {
         return source .copy () .lerp (destination, t);
      },
      slerp: function (source, destination, t)
      {
         return source .copy () .slerp (destination, t);
      },
      min: function (lhs, rhs)
      {
         return Vector3 .prototype .min .apply (lhs .copy (), arguments);
      },
      max: function (lhs, rhs)
      {
         return Vector3 .prototype .max .apply (lhs .copy (), arguments);
      },
   });

   return Vector3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix2',[
   "standard/Math/Numbers/Vector2",
   "standard/Math/Algorithm"
],
function (Vector2,
          Algorithm)
{
"use strict";

   function Matrix2 ()
   {
      if (arguments .length)
      {
         this [0] = arguments [0];
         this [1] = arguments [1];
         this [2] = arguments [2];
         this [3] = arguments [3];
      }
      else
      {
         this .identity ();
      }
   }

   Matrix2 .prototype =
   {
      constructor: Matrix2,
      order: 2,
      length: 4,
      [Symbol .iterator]: function* ()
      {
         const length = this .length;

         for (let i = 0; i < length; ++ i)
            yield this [i];
      },
      copy: function ()
      {
         const copy = Object .create (Matrix2 .prototype);
         copy [0] = this [0];
         copy [1] = this [1];
         copy [2] = this [2];
         copy [3] = this [3];
         return copy;
      },
      assign: function (matrix)
      {
         this [0] = matrix [0];
         this [1] = matrix [1];
         this [2] = matrix [2];
         this [3] = matrix [3];
         return this;
      },
      equals: function (matrix)
      {
         return this [0] === matrix [0] &&
                this [1] === matrix [1] &&
                this [2] === matrix [2] &&
                this [3] === matrix [3];
      },
      set1: function (r, c, value)
      {
         this [r * this .order + c] = value;
      },
      get1: function (r, c)
      {
         return this [r * this .order + c];
      },
      set: function ()
      {
         switch (arguments .length)
         {
            case 0:
            {
               this .identity ();
               break;
            }
            case 4:
            {
               this [0] = arguments [0];
               this [1] = arguments [1];
               this [2] = arguments [2];
               this [3] = arguments [3];
               break;
            }
         }
      },
      determinant1: function ()
      {
         return this [0];
      },
      determinant: function ()
      {
         return this [0] * this [3] -
                this [1] * this [2];
      },
      transpose: function ()
      {
         const tmp = this [1];

         this [1] = this [2];
         this [2] = tmp;

         return this;
      },
      inverse: function ()
      {
         const
            A = this [0],
            B = this [1],
            C = this [2],
            D = this [3],
            d = A * D - B * C;

         // if (d === 0) ... determinant is zero.

         this [0] =  D / d;
         this [1] = -B / d;
         this [2] = -C / d;
         this [3] =  A / d;

         return this;
      },
      multLeft: function (matrix)
      {
         const
            a0 = this [0], a1 = this [1],
            a2 = this [2], a3 = this [3],
            b0 = matrix [0], b1 = matrix [1],
            b2 = matrix [2], b3 = matrix [3];

         this [0] = a0 * b0 + a2 * b1;
         this [1] = a1 * b0 + a3 * b1;
         this [2] = a0 * b2 + a2 * b3;
         this [3] = a1 * b2 + a3 * b3;

         return this;
      },
      multRight: function (matrix)
      {
         const
            a0 = this [0], a1 = this [1],
            a2 = this [2], a3 = this [3],
            b0 = matrix [0], b1 = matrix [1],
            b2 = matrix [2], b3 = matrix [3];

         this [0] = b0 * a0 + b2 * a1;
         this [1] = b1 * a0 + b3 * a1;
         this [2] = b0 * a2 + b2 * a3;
         this [3] = b1 * a2 + b3 * a3;

         return this;
      },
      identity: function ()
      {
         this [0] = 1;
         this [1] = 0;
         this [2] = 0;
         this [3] = 1;
      },
      toString: function ()
      {
         return this [0] + " " + this [1] + " " +
                this [2] + " " + this [3]
      },
   };

   Object .defineProperty (Matrix2 .prototype, "x",
   {
      get: (function ()
      {
         const vector = new Vector2 (0, 0);

         return function () { return vector .set (this [0], this [1]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix2 .prototype, "y",
   {
      get: (function ()
      {
         const vector = new Vector2 (0, 0);

         return function () { return vector .set (this [2], this [3]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix2 .prototype, "xAxis",
   {
      get: function () { return this [0]; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix2 .prototype, "origin",
   {
      get: function () { return this [2]; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix2 .prototype, "submatrix",
   {
      get: function () { return this [0]; },
      enumerable: false,
      configurable: false
   });

   Object .assign (Matrix2,
   {
      Identity: new Matrix2 (),
   });

   return Matrix2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/eigendecomposition',[],function ()
{
"use strict";

   const a = [ ]; // more scratch
   const b = [ ]; // more scratch
   const z = [ ]; // more scratch

   // Calculate eigenvalues and eigenvectors.
   // This is from SGI Inventor Matrix.cpp.
   return function (matrix, result)
   {
      const
         ORDER   = matrix .order,
         values  = result .values,
         vectors = result .vectors;

      let
         sm,                // smallest entry
         theta,             // angle for Jacobi rotation
         c, s, t,           // cosine, sine, tangent of theta
         tau,               // sine / (1 + cos)
         h, g,              // two scrap values
         thresh,            // threshold below which no rotation done
         p, q, i, j,
         SIZE = matrix .length;

      // initializations
      for (i = 0; i < ORDER; ++ i)
      {
         a [i] = a [i] || new Array (ORDER);
         b [i] = values [i] = matrix .get1 (i, i);
         z [i] = 0;

         for (j = 0; j < ORDER; ++ j)
         {
            vectors [i] [j] = (i === j) ? 1 : 0;
            a [i] [j] = matrix .get1 (j, i);
         }
      }

      // Why 50? I don't know--it's the way the folks who wrote the
      // algorithm did it:
      for (i = 0; i < 50; ++ i)
      {
         sm = 0;

         for (p = 0; p < ORDER - 1; ++ p)
         {
            for (q = p + 1; q < ORDER; ++ q)
               sm += Math .abs (a [p] [q]);
         }

         if (sm === 0)
            break;

         thresh = i < 3 ?
            0.2 * sm / SIZE :
            0;

         for (p = 0; p < ORDER - 1; ++ p)
         {
            for (q = p + 1; q < ORDER; ++ q)
            {
               g = 100 * Math .abs (a [p] [q]);

               if (i > 3
                   && (Math .abs (values [p]) + g === Math .abs (values [p]))
                   && (Math .abs (values [q]) + g === Math .abs (values [q]))
               )
               {
                  a [p] [q] = 0;
               }

               else if (Math .abs (a [p] [q]) > thresh)
               {
                  h = values [q] - values [p];

                  if (Math .abs (h) + g === Math .abs (h))
                  {
                     t = a [p] [q] / h;
                  }
                  else
                  {
                     theta = 0.5 * h / a [p] [q];
                     t     = 1 / (Math .abs (theta) + Math .sqrt (1 + theta * theta));

                     if (theta < 0)  t = -t;
                  }
                  // End of computing tangent of rotation angle

                  c           = 1 / Math .sqrt (1 + t * t);
                  s           = t * c;
                  tau         = s / (1 + c);
                  h           = t * a [p] [q];
                  z [p]      -= h;
                  z [q]      += h;
                  values [p] -= h;
                  values [q] += h;
                  a [p] [q]   = 0;

                  for (j = 0; j < p; ++ j)
                  {
                     g = a [j] [p];
                     h = a [j] [q];
                     a [j] [p] = g - s * (h + g * tau);
                     a [j] [q] = h + s * (g - h * tau);
                  }

                  for (j = p + 1; j < q; ++ j)
                  {
                     g = a [p] [j];
                     h = a [j] [q];
                     a [p] [j] = g - s * (h + g * tau);
                     a [j] [q] = h + s * (g - h * tau);
                  }

                  for (j = q + 1; j < ORDER; ++ j)
                  {
                     g = a [p] [j];
                     h = a [q] [j];
                     a [p] [j] = g - s * (h + g * tau);
                     a [q] [j] = h + s * (g - h * tau);
                  }

                  for (j = 0; j < ORDER; ++ j)
                  {
                     g = vectors [j] [p];
                     h = vectors [j] [q];
                     vectors [j] [p] = g - s * (h + g * tau);
                     vectors [j] [q] = h + s * (g - h * tau);
                  }
               }
            }
         }

         for (p = 0; p < ORDER; ++ p)
         {
            values [p] = b [p] += z [p];
            z [p] = 0;
         }
      }

      return result;
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix3',[
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix2",
   "standard/Math/Algorithms/eigendecomposition",
],
function (Vector2,
          Vector3,
          Matrix2,
          eigendecomposition)
{
"use strict";

   function Matrix3 ()
   {
      if (arguments .length)
      {
         this [0] = arguments [0];
         this [1] = arguments [1];
         this [2] = arguments [2];
         this [3] = arguments [3];
         this [4] = arguments [4];
         this [5] = arguments [5];
         this [6] = arguments [6];
         this [7] = arguments [7];
         this [8] = arguments [8];
      }
      else
      {
         this .identity ();
      }
   }

   Matrix3 .prototype =
   {
      constructor: Matrix3,
      order: 3,
      length: 9,
      [Symbol .iterator]: function* ()
      {
         const length = this .length;

         for (let i = 0; i < length; ++ i)
            yield this [i];
      },
      copy: function ()
      {
         const copy = Object .create (Matrix3 .prototype);
         copy [0] = this [0];
         copy [1] = this [1];
         copy [2] = this [2];
         copy [3] = this [3];
         copy [4] = this [4];
         copy [5] = this [5];
         copy [6] = this [6];
         copy [7] = this [7];
         copy [8] = this [8];
         return copy;
      },
      assign: function (matrix)
      {
         this [0] = matrix [0];
         this [1] = matrix [1];
         this [2] = matrix [2];
         this [3] = matrix [3];
         this [4] = matrix [4];
         this [5] = matrix [5];
         this [6] = matrix [6];
         this [7] = matrix [7];
         this [8] = matrix [8];
         return this;
      },
      equals: function (matrix)
      {
         return this [0] === matrix [0] &&
                this [1] === matrix [1] &&
                this [2] === matrix [2] &&
                this [3] === matrix [3] &&
                this [4] === matrix [4] &&
                this [5] === matrix [5] &&
                this [6] === matrix [6] &&
                this [7] === matrix [7] &&
                this [8] === matrix [8];
      },
      rotation: function ()
      {
         return math .atan2 (this [1], this [0]);
      },
      set1: function (r, c, value)
      {
         this [r * this .order + c] = value;

         return this;
      },
      get1: function (r, c)
      {
         return this [r * this .order + c];
      },
      set: (function ()
      {
         const invCenter = new Vector2 (0, 0);

         return function (translation, rotation, scale, scaleOrientation, center)
         {
            switch (arguments .length)
            {
               case 0:
               {
                  this .identity ();
                  break;
               }
               case 1:
               {
                  if (translation === null) translation = Vector2 .Zero;

                  this .identity ();
                  this .translate (translation);
                  break;
               }
               case 2:
               {
                  if (translation === null) translation = Vector2 .Zero;
                  if (rotation    === null) rotation    = 0;

                  this .identity ();
                  this .translate (translation);

                  if (rotation !== 0)
                     this .rotate (rotation);

                  break;
               }
               case 3:
               {
                  if (translation === null) translation = Vector2 .Zero;
                  if (rotation    === null) rotation    = 0;
                  if (scale       === null) scale       = Vector2 .One;

                  this .identity ();
                  this .translate (translation);

                  if (rotation !== 0)
                     this .rotate (rotation);

                  if (! scale .equals (Vector2 .One))
                     this .scale  (scale);

                  break;
               }
               case 4:
               {
                  if (translation      === null) translation      = Vector2 .Zero;
                  if (rotation         === null) rotation         = 0;
                  if (scale            === null) scale            = Vector2 .One;
                  if (scaleOrientation === null) scaleOrientation = 0;

                  this .identity ();
                  this .translate (translation);

                  if (rotation !== 0)
                     this .rotate (rotation);

                  if (! scale .equals (Vector2 .One))
                  {
                     const hasScaleOrientation = scaleOrientation !== 0;

                     if (hasScaleOrientation)
                     {
                        this .rotate (scaleOrientation);
                        this .scale (scale);
                        this .rotate (-scaleOrientation);
                     }
                     else
                        this .scale (scale);
                  }

                  break;
               }
               case 5:
               {
                  if (translation      === null) translation      = Vector2 .Zero;
                  if (rotation         === null) rotation         = 0;
                  if (scale            === null) scale            = Vector2 .One;
                  if (scaleOrientation === null) scaleOrientation = 0;
                  if (center           === null) center           = Vector2 .Zero;

                  // P' = T * C * R * SR * S * -SR * -C * P
                  this .identity ();
                  this .translate (translation);

                  const hasCenter = ! center .equals (Vector2 .Zero);

                  if (hasCenter)
                     this .translate (center);

                  if (rotation !== 0)
                     this .rotate (rotation);

                  if (! scale .equals (Vector2 .One))
                  {
                     if (scaleOrientation !== 0)
                     {
                        this .rotate (scaleOrientation);
                        this .scale (scale);
                        this .rotate (-scaleOrientation);
                     }
                     else
                        this .scale (scale);
                  }

                  if (hasCenter)
                     this .translate (invCenter .assign (center) .negate ());

                  break;
               }
               case 9:
               {
                  this [0] = arguments [0];
                  this [1] = arguments [1];
                  this [2] = arguments [2];
                  this [3] = arguments [3];
                  this [4] = arguments [4];
                  this [5] = arguments [5];
                  this [6] = arguments [6];
                  this [7] = arguments [7];
                  this [8] = arguments [8];
                  break;
               }
            }

            return this;
         };
      })(),
      get: (function ()
      {
         const
            dummyTranslation      = new Vector2 (0, 0),
            dummyRotation         = new Vector3 (0, 0, 0),
            dummyScale            = new Vector2 (0, 0),
            dummyScaleOrientation = new Vector3 (0, 0, 0),
            dummyCenter           = new Vector2 (0, 0),
            rotMatrix             = new Matrix2 (),
            soMatrix              = new Matrix2 (),
            c                     = new Vector2 (0, 0);

         return function (translation, rotation, scale, scaleOrientation, center)
         {
            if (translation      === null) translation      = dummyTranslation;
            if (rotation         === null) rotation         = dummyRotation;
            if (scale            === null) scale            = dummyScale;
            if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
            if (center           === null) center           = dummyCenter;

            switch (arguments .length)
            {
               case 1:
               {
                  translation .set (this [6], this [7]);
                  break;
               }
               case 2:
               {
                  this .factor (translation, rotMatrix, dummyScale, soMatrix);

                  rotation [0] = rotMatrix [0];
                  rotation [1] = rotMatrix [1];
                  rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
                  break;
               }
               case 3:
               {
                  this .factor (translation, rotMatrix, scale, soMatrix);

                  rotation [0] = rotMatrix [0];
                  rotation [1] = rotMatrix [1];
                  rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
                  break;
               }
               case 4:
               {
                  this .factor (translation, rotMatrix, scale, soMatrix);

                  rotation [0] = rotMatrix [0];
                  rotation [1] = rotMatrix [1];
                  rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);

                  scaleOrientation [0] = soMatrix [0];
                  scaleOrientation [1] = soMatrix [1];
                  scaleOrientation [2] = Math .atan2 (soMatrix [1], soMatrix [0]);
                  break;
               }
               case 5:
               {
                  m .set (c .assign (center) .negate ());
                  m .multLeft (this);
                  m .translate (center);
                  m .get (translation, rotation, scale, scaleOrientation);
                  break;
               }
            }
         };
      })(),
      factor: (function ()
      {
         const
            si = new Matrix2 (),
            u  = new Matrix2 (),
            b  = new Matrix2 ();

         const eigen = { values: [ ], vectors: [[ ], [ ]] };

         return function (translation, rotation, scale, scaleOrientation)
         {
            // (1) Get translation.
            translation .set (this [6], this [7]);

            // (2) Create 3x3 matrix.
            const a = this .submatrix;

            // (3) Compute det A. If negative, set sign = -1, else sign = 1
            const det      = a .determinant ();
            const det_sign = det < 0 ? -1 : 1;

            // (4) B = A * !A  (here !A means A transpose)
            b .assign (a) .transpose () .multLeft (a);
            const e = eigendecomposition (b, eigen);

            // Find min / max eigenvalues and do ratio test to determine singularity.

            scaleOrientation .set (e .vectors [0] [0], e .vectors [1] [0],
                                   e .vectors [0] [1], e .vectors [1] [1]);

            // Compute s = sqrt(evalues), with sign. Set si = s-inverse

            scale .x = det_sign * Math .sqrt (e .values [0]);
            scale .y = det_sign * Math .sqrt (e .values [1]);

            si [0] = 1 / scale .x;
            si [3] = 1 / scale .y;

            // (5) Compute U = !R ~S R A.
            rotation .assign (u .assign (scaleOrientation) .transpose () .multRight (si) .multRight (scaleOrientation) .multRight (a));
         };
      })(),
      determinant2: function ()
      {
         return this [0] * this [4] -
                this [1] * this [3];
      },
      determinant: function ()
      {
         const
            m0 = this [0], m1 = this [1], m2 = this [2],
            m3 = this [3], m4 = this [4], m5 = this [5],
            m6 = this [6], m7 = this [7], m8 = this [8];

         return m0 * (m4 * m8 - m5 * m7) -
                m1 * (m3 * m8 - m5 * m6) +
                m2 * (m3 * m7 - m4 * m6);
      },
      transpose: function ()
      {
         let tmp;

         tmp = this [1]; this [1] = this [3]; this [3] = tmp;
         tmp = this [2]; this [2] = this [6]; this [6] = tmp;
         tmp = this [5]; this [5] = this [7]; this [7] = tmp;

         return this;
      },
      inverse: function ()
      {
         const
            m0  = this [0],
            m1  = this [1],
            m2  = this [2],
            m3  = this [3],
            m4  = this [4],
            m5  = this [5],
            m6  = this [6],
            m7  = this [7],
            m8  = this [8],
            t4  = m0 * m4,
            t6  = m0 * m7,
            t8  = m3 * m1,
            t10 = m3 * m7,
            t12 = m6 * m1,
            t14 = m6 * m4;

         let d = (t4 * m8 - t6 * m5 - t8 * m8 + t10 * m2 + t12 * m5 - t14 * m2);

         // if (d === 0) ... determinant is zero.

         d = 1 / d;

         const
            b0 =  (m4 * m8 - m7 * m5) * d,
            b1 = -(m1 * m8 - m7 * m2) * d,
            b2 =  (m1 * m5 - m4 * m2) * d,
            b3 = -(m3 * m8 - m6 * m5) * d,
            b4 =  (m0 * m8 - m6 * m2) * d,
            b5 = -(m0 * m5 - m3 * m2) * d;

         this [0] = b0;
         this [1] = b1;
         this [2] = b2;
         this [3] = b3;
         this [4] = b4;
         this [5] = b5;
         this [6] =  (t10 - t14) * d;
         this [7] = -(t6 - t12) * d;
         this [8] =  (t4 - t8) * d;

         return this;
      },
      multLeft: function (matrix)
      {
         const
            a0 = this [0], a1 = this [1], a2 = this [2],
            a3 = this [3], a4 = this [4], a5 = this [5],
            a6 = this [6], a7 = this [7], a8 = this [8],
            b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
            b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
            b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

         this [0] = a0 * b0 + a3 * b1 + a6 * b2;
         this [1] = a1 * b0 + a4 * b1 + a7 * b2;
         this [2] = a2 * b0 + a5 * b1 + a8 * b2;
         this [3] = a0 * b3 + a3 * b4 + a6 * b5;
         this [4] = a1 * b3 + a4 * b4 + a7 * b5;
         this [5] = a2 * b3 + a5 * b4 + a8 * b5;
         this [6] = a0 * b6 + a3 * b7 + a6 * b8;
         this [7] = a1 * b6 + a4 * b7 + a7 * b8;
         this [8] = a2 * b6 + a5 * b7 + a8 * b8;

         return this;
      },
      multRight: function (matrix)
      {
         const
            a0 = this [0], a1 = this [1], a2 = this [2],
            a3 = this [3], a4 = this [4], a5 = this [5],
            a6 = this [6], a7 = this [7], a8 = this [8],
            b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
            b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
            b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

         this [0] = a0 * b0 + a1 * b3 + a2 * b6;
         this [1] = a0 * b1 + a1 * b4 + a2 * b7;
         this [2] = a0 * b2 + a1 * b5 + a2 * b8;
         this [3] = a3 * b0 + a4 * b3 + a5 * b6;
         this [4] = a3 * b1 + a4 * b4 + a5 * b7;
         this [5] = a3 * b2 + a4 * b5 + a5 * b8;
         this [6] = a6 * b0 + a7 * b3 + a8 * b6;
         this [7] = a6 * b1 + a7 * b4 + a8 * b7;
         this [8] = a6 * b2 + a7 * b5 + a8 * b8;

         return this;
      },
      multVecMatrix: function (vector)
      {
         if (vector .length === 2)
         {
            const
               x = vector .x,
               y = vector .y,
               w = x * this [2] + y * this [5] + this [8];

            vector .x = (x * this [0] + y * this [3] + this [6]) / w;
            vector .y = (x * this [1] + y * this [4] + this [7]) / w;

            return vector;
         }

         const
            x = vector .x,
            y = vector .y,
            z = vector .z;

         vector .x = x * this [0] + y * this [3] + z * this [6];
         vector .y = x * this [1] + y * this [4] + z * this [7];
         vector .z = x * this [2] + y * this [5] + z * this [8];

         return vector;
      },
      multMatrixVec: function (vector)
      {
         if (vector .length === 2)
         {
            const
               x = vector .x,
               y = vector .y,
               w = x * this [6] + y * this [7] + this [8];

            vector .x = (x * this [0] + y * this [1] + this [2]) / w;
            vector .y = (x * this [3] + y * this [4] + this [5]) / w;

            return vector;
         }

         const
            x = vector .x,
            y = vector .y,
            z = vector .z;

         vector .x = x * this [0] + y * this [1] + z * this [2];
         vector .y = x * this [3] + y * this [4] + z * this [5];
         vector .z = x * this [6] + y * this [7] + z * this [8];

         return vector;
      },
      multDirMatrix: function (vector)
      {
         const
            x = vector .x,
            y = vector .y;

         vector .x = x * this [0] + y * this [3];
         vector .y = x * this [1] + y * this [4];

         return vector;
      },
      multMatrixDir: function (vector)
      {
         const
            x = vector .x,
            y = vector .y;

         vector .x = x * this [0] + y * this [1];
         vector .y = x * this [3] + y * this [4];

         return vector;
      },
      identity: function ()
      {
         this [0] = 1; this [1] = 0; this [2] = 0;
         this [3] = 0; this [4] = 1; this [5] = 0;
         this [6] = 0; this [7] = 0; this [8] = 1;
      },
      translate: function (translation)
      {
         const
            x = translation .x,
            y = translation .y;

         this [6] += this [0] * x + this [3] * y;
         this [7] += this [1] * x + this [4] * y;

         return this;
      },
      rotate: function (rotation)
      {
         this .multLeft (Matrix3 .Rotation (rotation));

         return this;
      },
      scale: function (scale)
      {
         const
            x = scale .x,
            y = scale .y;

         this [0] *= x;
         this [3] *= y;

         this [1] *= x;
         this [4] *= y;

         return this;
      },
      toString: function ()
      {
         return this [0] + " " + this [1] + " " + this [2] + " " +
                this [3] + " " + this [4] + " " + this [5] + " " +
                this [6] + " " + this [7] + " " + this [8]
      },
   };

   Object .defineProperty (Matrix3 .prototype, "x",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [0], this [1], this [2]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "y",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [3], this [4], this [5]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "z",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [6], this [7], this [8]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "xAxis",
   {
      get: (function ()
      {
         const vector = new Vector2 (0, 0);

         return function () { return vector .set (this [0], this [1]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "yAxis",
   {
      get: (function ()
      {
         const vector = new Vector2 (0, 0);

         return function () { return vector .set (this [3], this [4]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "origin",
   {
      get: (function ()
      {
         const vector = new Vector2 (0, 0);

         return function () { return vector .set (this [6], this [7]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix3 .prototype, "submatrix",
   {
      get: (function ()
      {
         const matrix = new Matrix2 ();

         return function ()
         {
            matrix [0] = this [0]; matrix [1] = this [1];
            matrix [2] = this [3]; matrix [3] = this [4];
            return matrix;
         };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .assign (Matrix3,
   {
      Identity: new Matrix3 (),
      Rotation: function (rotation)
      {
         const
            sinAngle = Math .sin (rotation),
            cosAngle = Math .cos (rotation);

         return new Matrix3 ( cosAngle, sinAngle, 0,
                             -sinAngle, cosAngle, 0,
                              0, 0, 1);
      },
      Matrix2: function (matrix)
      {
         return new Matrix3 (matrix [0], matrix [1], 0,
                             matrix [2], matrix [3], 0,
                             0, 0, 1);
      },
      transpose: function (matrix)
      {
         return matrix .copy () .transpose ();
      },
      inverse: function (matrix)
      {
         return matrix .copy () .inverse ();
      },
      multLeft: function (lhs, rhs)
      {
         return lhs .copy () .multLeft (rhs);
      },
      multRight: function (lhs, rhs)
      {
         return lhs .copy () .multRight (rhs);
      },
   });

   const m = new Matrix3 ();

   return Matrix3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/



define ('x_ite/Fields/SFMatrix3',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFMatrixPrototypeTemplate",
   "x_ite/Fields/SFVec2",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix3",
],
function (X3DField,
          SFMatrixPrototypeTemplate,
          SFVec2,
          X3DConstants,
          Matrix3)
{
"use strict";

   function SFMatrix3Template (TypeName, Type, SFVec2, double)
   {
      function SFMatrix3 (m00, m01, m02,
                          m10, m11, m12,
                          m20, m21, m22)
      {
         switch (arguments .length)
         {
            case 0:
               return X3DField .call (this, new Matrix3 ());

            case 1:
               return X3DField .call (this, arguments [0]);

            case 9:
               return X3DField .call (this, new Matrix3 (+m00, +m01, +m02,
                                                         +m10, +m11, +m12,
                                                         +m20, +m21, +m22));
         }

         throw new Error ("Invalid arguments.");
      }

      SFMatrix3 .prototype = Object .assign (Object .create (X3DField .prototype),
         SFMatrixPrototypeTemplate (Matrix3, SFVec2, double),
      {
         constructor: SFMatrix3,
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
         setTransform: function (translation, rotation, scale, scaleOrientation, center)
         {
            translation      = translation      ? translation      .getValue () : null;
            rotation         = rotation         ? rotation                      : 0;
            scale            = scale            ? scale            .getValue () : null;
            scaleOrientation = scaleOrientation ? scaleOrientation              : 0;
            center           = center           ? center           .getValue () : null;

            this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
         },
      });

      for (const key of Reflect .ownKeys (SFMatrix3 .prototype))
         Object .defineProperty (SFMatrix3 .prototype, key, { enumerable: false });

      function defineProperty (i)
      {
         Object .defineProperty (SFMatrix3 .prototype, i,
         {
            get: function ()
            {
               return this .getValue () [i];
            },
            set: function (value)
            {
               this .getValue () [i] = +value;
               this .addEvent ();
            },
            enumerable: true,
            configurable: false,
         });
      }

      for (let i = 0, length = Matrix3 .prototype .length; i < length; ++ i)
         defineProperty (i);

      return SFMatrix3;
   }

   return {
      SFMatrix3d: SFMatrix3Template ("SFMatrix3d", X3DConstants .SFMatrix3d, SFVec2 .SFVec2d, true),
      SFMatrix3f: SFMatrix3Template ("SFMatrix3f", X3DConstants .SFMatrix3f, SFVec2 .SFVec2f, false),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec3',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFVecPrototypeTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (X3DField,
          SFVecPrototypeTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

   function SFVec3Template (TypeName, Type, double)
   {
      function SFVec3 (x, y, z)
      {
         switch (arguments .length)
         {
            case 0:
               return X3DField .call (this, new Vector3 (0, 0, 0));

            case 1:
               return X3DField .call (this, arguments [0]);

            case 3:
               return X3DField .call (this, new Vector3 (+x, +y, +z));
         }

         throw new Error ("Invalid arguments.");
      }

      SFVec3 .prototype = Object .assign (Object .create (X3DField .prototype),
         SFVecPrototypeTemplate (Vector3, double),
      {
         constructor: SFVec3,
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
         cross: function (vector)
         {
            return new (this .constructor) (Vector3 .cross (this .getValue (), vector .getValue ()));
         },
      });

      for (const key of Reflect .ownKeys (SFVec3 .prototype))
         Object .defineProperty (SFVec3 .prototype, key, { enumerable: false });

      const x = {
         get: function ()
         {
            return this .getValue () .x;
         },
         set: function (value)
         {
            this .getValue () .x = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const y = {
         get: function ()
         {
            return this .getValue () .y;
         },
         set: function (value)
         {
            this .getValue () .y = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const z = {
         get: function ()
         {
            return this .getValue () .z;
         },
         set: function (value)
         {
            this .getValue () .z = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      Object .defineProperty (SFVec3 .prototype, "x", x);
      Object .defineProperty (SFVec3 .prototype, "y", y);
      Object .defineProperty (SFVec3 .prototype, "z", z);

      x .enumerable = false;
      y .enumerable = false;
      z .enumerable = false;

      Object .defineProperty (SFVec3 .prototype, "0", x);
      Object .defineProperty (SFVec3 .prototype, "1", y);
      Object .defineProperty (SFVec3 .prototype, "2", z);

      return SFVec3;
   }

   return {
      SFVec3d: SFVec3Template ("SFVec3d", X3DConstants .SFVec3d, true),
      SFVec3f: SFVec3Template ("SFVec3f", X3DConstants .SFVec3f, false),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector4',[
   "standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

   function Vector4 (x, y, z, w)
   {
      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
   }

   Vector4 .prototype =
   {
      constructor: Vector4,
      length: 4,
      [Symbol .iterator]: function* ()
      {
         yield this .x;
         yield this .y;
         yield this .z;
         yield this .w;
      },
      copy: function ()
      {
         const copy = Object .create (Vector4 .prototype);
         copy .x = this .x;
         copy .y = this .y;
         copy .z = this .z;
         copy .w = this .w;
         return copy;
      },
      assign: function (vector)
      {
         this .x = vector .x;
         this .y = vector .y;
         this .z = vector .z;
         this .w = vector .w;
         return this;
      },
      set: function (x, y, z, w)
      {
         this .x = x;
         this .y = y;
         this .z = z;
         this .w = w;
         return this;
      },
      equals: function (vector)
      {
         return this .x === vector .x &&
                this .y === vector .y &&
                this .z === vector .z &&
                this .w === vector .w;
      },
      getReal: function (vector)
      {
         vector .x = this .x / this .w;
         vector .y = this .y / this .w;
         vector .z = this .z / this .w;
      },
      negate: function ()
      {
         this .x = -this .x;
         this .y = -this .y;
         this .z = -this .z;
         this .w = -this .w;
         return this;
      },
      add: function (vector)
      {
         this .x += vector .x;
         this .y += vector .y;
         this .z += vector .z;
         this .w += vector .w;
         return this;
      },
      subtract: function (vector)
      {
         this .x -= vector .x;
         this .y -= vector .y;
         this .z -= vector .z;
         this .w -= vector .w;
         return this;
      },
      multiply: function (value)
      {
         this .x *= value;
         this .y *= value;
         this .z *= value;
         this .w *= value;
         return this;
      },
      multVec: function (vector)
      {
         this .x *= vector .x;
         this .y *= vector .y;
         this .z *= vector .z;
         this .w *= vector .w;
         return this;
      },
      divide: function (value)
      {
         this .x /= value;
         this .y /= value;
         this .z /= value;
         this .w /= value;
         return this;
      },
      divVec: function (vector)
      {
         this .x /= vector .x;
         this .y /= vector .y;
         this .z /= vector .z;
         this .w /= vector .w;
         return this;
      },
      normalize: function ()
      {
         const length = Math .hypot (this .x, this .y, this .z, this .w);

         if (length)
         {
            this .x /= length;
            this .y /= length;
            this .z /= length;
            this .w /= length;
         }

         return this;
      },
      dot: function (vector)
      {
         return this .x * vector .x +
                this .y * vector .y +
                this .z * vector .z +
                this .w * vector .w;
      },
      norm: function ()
      {
         const
            x = this .x,
            y = this .y,
            z = this .z,
            w = this .w;

         return x * x +
                y * y +
                z * z +
                w * w;
      },
      abs: function ()
      {
         return Math .hypot (this .x, this .y, this .z, this .w);
      },
      distance: function (vector)
      {
         return Math .hypot (this .x - vector .x,
                             this .y - vector .y,
                             this .z - vector .z,
                             this .w - vector .w);
      },
      lerp: function (destination, t)
      {
         const
            x = this .x,
            y = this .y,
            z = this .z,
            w = this .w;

         this .x = x + t * (destination .x - x);
         this .y = y + t * (destination .y - y);
         this .z = z + t * (destination .z - z);
         this .w = w + t * (destination .w - w);
         return this;
      },
      min: function (vector)
      {
         let
            x = this .x,
            y = this .y,
            z = this .z,
            w = this .w;

         for (const vector of arguments)
         {
            x = Math .min (x, vector .x);
            y = Math .min (y, vector .y);
            z = Math .min (z, vector .z);
            w = Math .min (w, vector .w);
         }

         this .x = x;
         this .y = y;
         this .z = z;
         this .w = w;
         return this;
      },
      max: function (vector)
      {
         let
            x = this .x,
            y = this .y,
            z = this .z,
            w = this .w;

         for (const vector of arguments)
         {
            x = Math .max (x, vector .x);
            y = Math .max (y, vector .y);
            z = Math .max (z, vector .z);
            w = Math .max (w, vector .w);
         }

         this .x = x;
         this .y = y;
         this .z = z;
         this .w = w;
         return this;
      },
      toString: function ()
      {
         return this .x + " " +
                this .y + " " +
                this .z + " " +
                this .w;
      },
   };

   Object .defineProperty (Vector4 .prototype, "0",
   {
      get: function () { return this .x; },
      set: function (value) { this .x = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector4 .prototype, "1",
   {
      get: function () { return this .y; },
      set: function (value) { this .y = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector4 .prototype, "2",
   {
      get: function () { return this .z; },
      set: function (value) { this .z = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Vector4 .prototype, "3",
   {
      get: function () { return this .w; },
      set: function (value) { this .w = value; },
      enumerable: false,
      configurable: false
   });

   Object .assign (Vector4,
   {
      Zero: new Vector4 (0, 0, 0, 0),
      One: new Vector4 (1, 1, 1, 1),
      xAxis: new Vector4 (1, 0, 0, 0),
      yAxis: new Vector4 (0, 1, 0, 0),
      zAxis: new Vector4 (0, 0, 1, 0),
      wAxis: new Vector4 (0, 0, 0, 1),
      negate: function (vector)
      {
         return vector .copy () .negate ();
      },
      add: function (lhs, rhs)
      {
         return lhs .copy () .add (rhs);
      },
      subtract: function (lhs, rhs)
      {
         return lhs .copy () .subtract (rhs);
      },
      multiply: function (lhs, rhs)
      {
         return lhs .copy () .multiply (rhs);
      },
      multVec: function (lhs, rhs)
      {
         return lhs .copy () .multVec (rhs);
      },
      divide: function (lhs, rhs)
      {
         return lhs .copy () .divide (rhs);
      },
      divVec: function (lhs, rhs)
      {
         return lhs .copy () .divVec (rhs);
      },
      normalize: function (vector)
      {
         return vector .copy () .normalize ();
      },
      dot: function (lhs, rhs)
      {
         return lhs .copy () .dot (rhs);
      },
      lerp: function (source, destination, t)
      {
         return source .copy () .lerp (destination, t);
      },
      min: function (lhs, rhs)
      {
         return Vector4 .prototype .min .apply (lhs .copy (), arguments);
      },
      max: function (lhs, rhs)
      {
         return Vector4 .prototype .max .apply (lhs .copy (), arguments);
      },
   });

   return Vector4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Quaternion',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithm",
],
function (Vector3, Algorithm)
{
"use strict";

   function Quaternion (x, y, z, w)
   {
      this .x = x;
      this .y = y;
      this .z = z;
      this .w = w;
   }

   Quaternion .prototype =
   {
      constructor: Quaternion,
      length: 4,
      [Symbol .iterator]: function* ()
      {
         yield this .x;
         yield this .y;
         yield this .z;
         yield this .w;
      },
      copy: function ()
      {
         const copy = Object .create (Quaternion .prototype);
         copy .x = this .x;
         copy .y = this .y;
         copy .z = this .z;
         copy .w = this .w;
         return copy;
      },
      assign: function (quat)
      {
         this .x = quat .x;
         this .y = quat .y;
         this .z = quat .z;
         this .w = quat .w;
         return this;
      },
      set: function (x, y, z, w)
      {
         this .x = x;
         this .y = y;
         this .z = z;
         this .w = w;
         return this;
      },
      setMatrix: function (matrix)
      {
         let i;

         // First, find largest diagonal in matrix:
         if (matrix [0] > matrix [4])
         {
            i = matrix [0] > matrix [8] ? 0 : 2;
         }
         else
         {
            i = matrix [4] > matrix [8] ? 1 : 2;
         }

         const scalerow = matrix [0] + matrix [4] + matrix [8];

         if (scalerow > matrix [i * 3 + i])
         {
            // Compute w first:
            this [3] = Math .sqrt (scalerow + 1) / 2;

            // And compute other values:
            const d = 4 * this [3];
            this [0] = (matrix [5] - matrix [7]) / d;
            this [1] = (matrix [6] - matrix [2]) / d;
            this [2] = (matrix [1] - matrix [3]) / d;
         }
         else
         {
            // Compute x, y, or z first:
            const j = (i + 1) % 3;
            const k = (i + 2) % 3;

            // Compute first value:
            this [i] = Math .sqrt (matrix [i * 3 + i] - matrix [j * 3 + j] - matrix [k * 3 + k] + 1) / 2;

            // And the others:
            const d = 4 * this [i];
            this [j] = (matrix [i * 3 + j] + matrix [j * 3 + i]) / d;
            this [k] = (matrix [i * 3 + k] + matrix [k * 3 + i]) / d;
            this [3] = (matrix [j * 3 + k] - matrix [k * 3 + j]) / d;
         }

         return this;
      },
      getMatrix: function (matrix)
      {
         const
            x = this .x,
            y = this .y,
            z = this .z,
            w = this .w;

         const
            a = x * x,
            b = x * y,
            c = y * y,
            d = y * z,
            e = z * x,
            f = z * z,
            g = w * x,
            h = w * y,
            i = w * z;

         matrix [0] = 1 - 2 * (c + f);
         matrix [1] =     2 * (b + i);
         matrix [2] =     2 * (e - h);

         matrix [3] =     2 * (b - i);
         matrix [4] = 1 - 2 * (f + a);
         matrix [5] =     2 * (d + g);

         matrix [6] =     2 * (e + h);
         matrix [7] =     2 * (d - g);
         matrix [8] = 1 - 2 * (c + a);

         return matrix;
      },
      isReal: function ()
      {
         return ! (this .x || this .y || this .z);
      },
      isImag: function ()
      {
         return ! this .w;
      },
      equals: function (quat)
      {
         return this .x === quat .x &&
                this .y === quat .y &&
                this .z === quat .z &&
                this .w === quat .w;
      },
      negate: function ()
      {
         this .x = -this .x;
         this .y = -this .y;
         this .z = -this .z;
         this .w = -this .w;
         return this;
      },
      inverse: function ()
      {
         this .x = -this .x;
         this .y = -this .y;
         this .z = -this .z;
         return this;
      },
      add: function (quat)
      {
         this .x += quat .x;
         this .y += quat .y;
         this .z += quat .z;
         this .w += quat .w;
         return this;
      },
      subtract: function (quat)
      {
         this .x -= quat .x;
         this .y -= quat .y;
         this .z -= quat .z;
         this .w -= quat .w;
         return this;
      },
      multiply: function (value)
      {
         this .x *= value;
         this .y *= value;
         this .z *= value;
         this .w *= value;
         return this;
      },
      multLeft: function (quat)
      {
         const
            ax = this .x, ay = this .y, az = this .z, aw = this .w,
            bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

         this .x = aw * bx + ax * bw + ay * bz - az * by;
         this .y = aw * by + ay * bw + az * bx - ax * bz;
         this .z = aw * bz + az * bw + ax * by - ay * bx;
         this .w = aw * bw - ax * bx - ay * by - az * bz;

         return this;
      },
      multRight: function (quat)
      {
         const
            ax = this .x, ay = this .y, az = this .z, aw = this .w,
            bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

         this .x = bw * ax + bx * aw + by * az - bz * ay;
         this .y = bw * ay + by * aw + bz * ax - bx * az;
         this .z = bw * az + bz * aw + bx * ay - by * ax;
         this .w = bw * aw - bx * ax - by * ay - bz * az;

         return this;
      },
      divide: function (value)
      {
         this .x /= value;
         this .y /= value;
         this .z /= value;
         this .w /= value;
         return this;
      },
      multVecQuat: function (vector)
      {
         const
            qx = this .x, qy = this .y, qz = this .z, qw = this .w,
            vx = vector .x, vy = vector .y, vz = vector .z,
            a  = qw * qw - qx * qx - qy * qy - qz * qz,
            b  = 2 * (vx * qx + vy * qy + vz * qz),
            c  = 2 * qw;

         vector .x = a * vx + b * qx + c * (qy * vz - qz * vy);
         vector .y = a * vy + b * qy + c * (qz * vx - qx * vz);
         vector .z = a * vz + b * qz + c * (qx * vy - qy * vx);

         return vector;
      },
      multQuatVec: function (vector)
      {
         const
            qx = this .x, qy = this .y, qz = this .z, qw = this .w,
            vx = vector .x, vy = vector .y, vz = vector .z,
            a  = qw * qw - qx * qx - qy * qy - qz * qz,
            b  = 2 * (vx * qx + vy * qy + vz * qz),
            c  = 2 * qw;

         vector .x = a * vx + b * qx - c * (qy * vz - qz * vy);
         vector .y = a * vy + b * qy - c * (qz * vx - qx * vz);
         vector .z = a * vz + b * qz - c * (qx * vy - qy * vx);

         return vector;
      },
      normalize: function ()
      {
         let length = Math .hypot (this .x, this .y, this .z, this .w);

         if (length)
         {
            length = 1 / length;

            this .x *= length;
            this .y *= length;
            this .z *= length;
            this .w *= length;
         }

         return this;
      },
      dot: function (quat)
      {
         return this .x * quat .x +
                this .y * quat .y +
                this .z * quat .z +
                this .w * quat .w;
      },
      norm: function ()
      {
         return this .x * this .x +
                this .y * this .y +
                this .z * this .z +
                this .w * this .w;
      },
      abs: function ()
      {
         return Math .hypot (this .x, this .y, this .z, this .w);
      },
      pow: function (exponent)
      {
         if (exponent instanceof Quaternion)
            return this .assign (e .assign (exponent) .multRight (this .log ()) .exp ());

         if (this .isReal ())
            return this .set (0, 0, 0, Math .pow (this .w, exponent));

         const
            l     = this .abs (),
            theta = Math .acos (this .w / l),
            li    = this .imag .abs (),
            ltoe  = Math .pow (l, exponent),
            et    = exponent * theta,
            scale = ltoe / li * Math .sin (et);

         this .x *= scale;
         this .y *= scale;
         this .z *= scale;
         this .w  = ltoe * Math .cos (et);
         return this;
      },
      log: function ()
      {
         if (this .isReal ())
         {
            if (this .w > 0)
               return this .set (0, 0, 0, Math .log (this .w));

            else
               return this .set (Math .PI, 0, 0, Math .log (-this .w));
         }

         const
            l = this .abs (),
            v = this .imag .normalize () .multiply (Math .acos (this .w / l)),
            w = Math .log (l);

         this .x = v .x;
         this .y = v .y;
         this .z = v .z;
         this .w = w;
         return this;
      },
      exp: function ()
      {
         if (this .isReal ())
            return this .set (0, 0, 0, Math .exp (this .w));

         const
            i  = this .imag,
            li = i .abs (),
            ew = Math .exp (this .w),
            w  = ew * Math .cos (li),
            v  = i .multiply (ew * Math .sin (li) / li);

         this .x = v .x;
         this .y = v .y;
         this .z = v .z;
         this .w = w;
         return this;
      },
      slerp: function (destination, t)
      {
         return Algorithm .slerp (this, t1 .assign (destination), t);
      },
      squad: function (a, b, destination, t)
      {
         // We must use shortest path slerp to prevent flipping.  Also see spline.

         return Algorithm .slerp (Algorithm .slerp (this, t1 .assign (destination), t),
                                  Algorithm .slerp (t2 .assign (a), t3 .assign (b), t),
                                  2 * t * (1 - t));
      },
      toString: function ()
      {
         return this .x + " " +
                this .y + " " +
                this .z + " " +
                this .w;
      },
   };

   Object .defineProperty (Quaternion .prototype, "0",
   {
      get: function () { return this .x; },
      set: function (value) { this .x = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Quaternion .prototype, "1",
   {
      get: function () { return this .y; },
      set: function (value) { this .y = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Quaternion .prototype, "2",
   {
      get: function () { return this .z; },
      set: function (value) { this .z = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Quaternion .prototype, "3",
   {
      get: function () { return this .w; },
      set: function (value) { this .w = value; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Quaternion .prototype, "real",
   {
      get: function () { return this .w; },
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Quaternion .prototype, "imag",
   {
      get: (function ()
      {
         const result = new Vector3 (0, 0, 0);

         return function ()
         {
            return result .set (this .x,
                                this .y,
                                this .z);
         };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .assign (Quaternion,
   {
      negate: function (quat)
      {
         return quat .copy () .negate ();
      },
      inverse: function (quat)
      {
         return quat .copy () .inverse ();
      },
      add: function (lhs, rhs)
      {
         return lhs .copy () .add (rhs);
      },
      subtract: function (lhs, rhs)
      {
         return lhs .copy () .subtract (rhs);
      },
      multiply: function (lhs, rhs)
      {
         return lhs .copy () .multiply (rhs);
      },
      multLeft: function (lhs, rhs)
      {
         return lhs .copy () .multLeft (rhs);
      },
      multRight: function (lhs, rhs)
      {
         return lhs .copy () .multRight (rhs);
      },
      divide: function (lhs, rhs)
      {
         return lhs .copy () .divide (rhs);
      },
      normalize: function (quat)
      {
         return quat .copy () .normalize ();
      },
      slerp: function (source, destination, t)
      {
         return source .copy () .slerp (destination, t);
      },
      squad: function (source, a, b, destination, t)
      {
         return source .copy () .squad (a, b, destination, t);
      },
      /*
      bezier: function (q0, a, b, q1, t)
      {
         return q0 .copy () .squad (a, b, q1, t);
      },
      */
      spline: function (Q0, Q1, Q2)
      {
         q0 .assign (Q0);
         q1 .assign (Q1);
         q2 .assign (Q2);

         // If the dot product is smaller than 0 we must negate the quaternion to prevent flipping. If we negate all
         // the terms we get a different quaternion but it represents the same rotation.

         if (q0 .dot (q1) < 0)
            q0 .negate ();

         if (q2 .dot (q1) < 0)
            q2 .negate ();

         q1_i .assign (q1) .inverse ();

         // The result must be normalized as it will be used in slerp and we can only slerp normalized vectors.

         return q1 .multRight (
            t1 .assign (q1_i) .multRight (q0) .log () .add (t2 .assign (q1_i) .multRight (q2) .log ()) .divide (-4) .exp ()
         )
         .normalize () .copy ();
      },
   });

   const
      t1 = new Quaternion (0, 0, 0, 1),
      t2 = new Quaternion (0, 0, 0, 1),
      t3 = new Quaternion (0, 0, 0, 1);

   const
      q0   = new Quaternion (0, 0, 0, 1),
      q1   = new Quaternion (0, 0, 0, 1),
      q2   = new Quaternion (0, 0, 0, 1),
      q1_i = new Quaternion (0, 0, 0, 1);

   return Quaternion;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Rotation4',[
   "standard/Math/Numbers/Quaternion",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Algorithm",
],
function (Quaternion,
          Vector3,
          Vector4,
          Algorithm)
{
"use strict";

   const
      _x     = Symbol (),
      _y     = Symbol (),
      _z     = Symbol (),
      _angle = Symbol ();

   function Rotation4 (x, y, z, angle)
   {
      this [_x]     = 0;
      this [_y]     = 0;
      this [_z]     = 1;
      this [_angle] = 0;

      switch (arguments .length)
      {
         case 0:
         {
            this .value = new Quaternion (0, 0, 0, 1);
            return;
         }
         case 1:
         {
            this .value = arguments [0];
            this .update ();
            return;
         }
         case 2:
         {
            const
               arg0 = arguments [0],
               arg1 = arguments [1];

            this .value = new Quaternion (0, 0, 0, 1);

            if (arg1 instanceof Vector3)
               return this .setFromToVec (arg0, arg1);

            this .set (arg0 .x,
                       arg0 .y,
                       arg0 .z,
                       arg1);

            return;
         }
         case 4:
         {
            this .value = new Quaternion (0, 0, 0, 1);
            this .set (x, y, z, angle);
            return;
         }
      }
   }

   Rotation4 .prototype =
   {
      constructor: Rotation4,
      length: 4,
      [Symbol .iterator]: function* ()
      {
         yield this [_x];
         yield this [_y];
         yield this [_z];
         yield this [_angle];
      },
      update: function ()
      {
         const rotation = this .get ();

         this [_x]     = rotation .x;
         this [_y]     = rotation .y;
         this [_z]     = rotation .z;
         this [_angle] = rotation .w;

         return this;
      },
      copy: function ()
      {
         const copy = Object .create (Rotation4 .prototype);

         copy [_x]     = this [_x];
         copy [_y]     = this [_y];
         copy [_z]     = this [_z];
         copy [_angle] = this [_angle];

         copy .value  = this .value .copy ();

         return copy;
      },
      assign: function (rotation)
      {
         this [_x]     = rotation [_x];
         this [_y]     = rotation [_y];
         this [_z]     = rotation [_z];
         this [_angle] = rotation [_angle];

         this .value .assign (rotation .value);

         return this;
      },
      set: function (x, y, z, angle)
      {
         this [_x]     = x;
         this [_y]     = y;
         this [_z]     = z;
         this [_angle] = angle;

         const scale = Math .hypot (x, y, z);

         if (scale === 0)
         {
            this .value .set (0, 0, 0, 1);
            return this;
         }

         // Calculate quaternion

         const
            halfTheta = Algorithm .interval (angle / 2, 0, Math .PI),
            ascale    = Math .sin (halfTheta) / scale;

         this .value .set (x * ascale,
                           y * ascale,
                           z * ascale,
                           Math .cos (halfTheta));
         return this;
      },
      get: (function ()
      {
         const result = new Vector4 (0, 0, 0, 0);

         return function ()
         {
            const value = this .value;

            if (Math .abs (value .w) > 1)
            {
               return Vector4 .zAxis;
            }
            else
            {
               const
                  angle = Math .acos (value .w) * 2,
                  scale = Math .sin (angle / 2);

               if (scale === 0)
               {
                  return Vector4 .zAxis;
               }
               else
               {
                  const axis = value .imag .divide (scale);

                  return result .set (axis .x,
                                      axis .y,
                                      axis .z,
                                      angle);
               }
            }
         };
      })(),
      setAxisAngle: function (axis, angle)
      {
         return this .set (axis .x, axis .y, axis .z, angle);
      },
      setFromToVec: (function ()
      {
         const
            from = new Vector3 (0, 0, 0),
            to   = new Vector3 (0, 0, 0),
            cv   = new Vector3 (0, 0, 0),
            t    = new Vector3 (0, 0, 0);

         return function (fromVec, toVec)
         {
            // https://bitbucket.org/Coin3D/coin/src/abc9f50968c9/src/base/SbRotation.cpp

            from .assign (fromVec) .normalize ();
            to   .assign (toVec)   .normalize ();

            const
               cos_angle = Algorithm .clamp (from .dot (to), -1, 1),
               crossvec  = cv .assign (from) .cross (to) .normalize (),
               crosslen  = crossvec .abs ();

            if (crosslen === 0)
            {
               // Parallel vectors
               // Check if they are pointing in the same direction.
               if (cos_angle > 0)
                  this .value .set (0, 0, 0, 1); // standard rotation

               // Ok, so they are parallel and pointing in the opposite direction
               // of each other.
               else
               {
                  // Try crossing with x axis.
                  t .assign (from) .cross (Vector3 .xAxis);

                  // If not ok, cross with y axis.
                  if (t .norm () === 0)
                     t .assign (from) .cross (Vector3 .yAxis);

                  t .normalize ();

                  this .value .set (t .x, t .y, t .z, 0);
               }
            }
            else
            {
               // Vectors are not parallel
               // The abs () wrapping is to avoid problems when `dot' "overflows" a tiny wee bit,
               // which can lead to sqrt () returning NaN.
               crossvec .multiply (Math .sqrt (Math .abs (1 - cos_angle) / 2));

               this .value .set (crossvec .x,
                                 crossvec .y,
                                 crossvec .z,
                                 Math .sqrt (Math .abs (1 + cos_angle) / 2));
            }

            this .update ();

            return this;
         };
      })(),
      setAxis: function (vector)
      {
         this .set (vector .x, vector .y, vector .z, this [_angle]);
      },
      getAxis: (function ()
      {
         const axis = new Vector3 (0, 0, 0);

         return function ()
         {
            return axis .set (this [_x], this [_y], this [_z]);
         };
      })(),
      setMatrix: function (matrix)
      {
         this .value .setMatrix (matrix) .normalize ();
         this .update ();
         return this;
      },
      getMatrix: function (matrix)
      {
         return this .value .getMatrix (matrix);
      },
      equals: function (rot)
      {
         return this .value .equals (rot .value);
      },
      inverse: function ()
      {
         this .value .inverse ();
         this .update ();
         return this;
      },
      multLeft: function (rotation)
      {
         this .value .multLeft (rotation .value) .normalize ();
         this .update ();
         return this;
      },
      multRight: function (rotation)
      {
         this .value .multRight (rotation .value) .normalize ();
         this .update ();
         return this;
      },
      multVecRot: function (vector)
      {
         return this .value .multVecQuat (vector);
      },
      multRotVec: function (vector)
      {
         return this .value .multQuatVec (vector);
      },
      normalize: function ()
      {
         this .value .normalize ();
         this .update ();
         return this;
      },
      pow: function (exponent)
      {
         this .value .pow (exponent);
         this .update ();
         return this;
      },
      slerp: function (dest, t)
      {
         this .value .slerp (dest .value, t);
         this .update ();
         return this;
      },
      squad: function (a ,b, dest, t)
      {
         this .value .squad (a .value, b .value, dest .value, t);
         this .update ();
         return this;
      },
      toString: function ()
      {
         return this [_x] + " " +
                this [_y] + " " +
                this [_z] + " " +
                this [_angle];
      }
   };

   const x = {
      get: function ()
      {
         return this [_x];
      },
      set: function (value)
      {
         this [_x] = value;
         this .set (value, this [_y], this [_z], this [_angle]);
      },
      enumerable: true,
      configurable: false
   };

   const y = {
      get: function ()
      {
         return this [_y];
      },
      set: function (value)
      {
         this [_y] = value;
         this .set (this [_x], value, this [_z], this [_angle]);
      },
      enumerable: true,
      configurable: false
   };

   const z = {
      get: function ()
      {
         return this [_z];
      },
      set: function (value)
      {
         this [_z] = value;
         this .set (this [_x], this [_y], value, this [_angle]);
      },
      enumerable: true,
      configurable: false
   };

   const angle = {
      get: function ()
      {
         return this [_angle];
      },
      set: function (value)
      {
         this [_angle] = value;
         this .set (this [_x], this [_y], this [_z], value);
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (Rotation4 .prototype, "x", x);
   Object .defineProperty (Rotation4 .prototype, "y", y);
   Object .defineProperty (Rotation4 .prototype, "z", z);
   Object .defineProperty (Rotation4 .prototype, "angle", angle);

   x     .enumerable = false;
   y     .enumerable = false;
   z     .enumerable = false;
   angle .enumerable = false;

   Object .defineProperty (Rotation4 .prototype, "0", x);
   Object .defineProperty (Rotation4 .prototype, "1", y);
   Object .defineProperty (Rotation4 .prototype, "2", z);
   Object .defineProperty (Rotation4 .prototype, "3", angle);

   Object .assign (Rotation4,
   {
      Identity: new Rotation4 (),
      inverse: function (rotation)
      {
         return rotation .copy () .inverse ();
      },
      multRight: function (lhs, rhs)
      {
         return lhs .copy () .multRight (rhs);
      },
      normalize: function (rotation)
      {
         return rotation .copy () .normalize ();
      },
      slerp: function (source, destination, t)
      {
         return source .copy () .slerp (destination, t);
      },
      squad: function (source, a, b, destination, t)
      {
         return source .copy () .squad (a, b, destination, t);
      },
      /*
      bezier: function (source, a, b, destination, t)
      {
         const copy = Object .create (this .prototype);
         copy .value = Quaternion .bezier (source .value, a, b, destination .value, t);
         copy .update ();
         return copy;
      },
      */
      spline: function (q0, q1, q2)
      {
         const copy = Object .create (this .prototype);
         copy .value = Quaternion .spline (q0 .value, q1 .value, q2 .value);
         copy .update ();
         return copy;
      },
   });

   return Rotation4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix4',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Algorithms/eigendecomposition",
],
function (Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          eigendecomposition)
{
"use strict";

   function Matrix4 ()
   {
      if (arguments .length)
      {
         this [ 0] = arguments [ 0];
         this [ 1] = arguments [ 1];
         this [ 2] = arguments [ 2];
         this [ 3] = arguments [ 3];
         this [ 4] = arguments [ 4];
         this [ 5] = arguments [ 5];
         this [ 6] = arguments [ 6];
         this [ 7] = arguments [ 7];
         this [ 8] = arguments [ 8];
         this [ 9] = arguments [ 9];
         this [10] = arguments [10];
         this [11] = arguments [11];
         this [12] = arguments [12];
         this [13] = arguments [13];
         this [14] = arguments [14];
         this [15] = arguments [15];
      }
      else
      {
         this .identity ();
      }
   }

   Matrix4 .prototype =
   {
      constructor: Matrix4,
      order: 4,
      length: 16,
      [Symbol .iterator]: function* ()
      {
         const length = this .length;

         for (let i = 0; i < length; ++ i)
            yield this [i];
      },
      copy: function ()
      {
         const copy = Object .create (Matrix4 .prototype);
         copy [ 0] = this [ 0];
         copy [ 1] = this [ 1];
         copy [ 2] = this [ 2];
         copy [ 3] = this [ 3];
         copy [ 4] = this [ 4];
         copy [ 5] = this [ 5];
         copy [ 6] = this [ 6];
         copy [ 7] = this [ 7];
         copy [ 8] = this [ 8];
         copy [ 9] = this [ 9];
         copy [10] = this [10];
         copy [11] = this [11];
         copy [12] = this [12];
         copy [13] = this [13];
         copy [14] = this [14];
         copy [15] = this [15];
         return copy;
      },
      assign: function (matrix)
      {
         this [ 0] = matrix [ 0];
         this [ 1] = matrix [ 1];
         this [ 2] = matrix [ 2];
         this [ 3] = matrix [ 3];
         this [ 4] = matrix [ 4];
         this [ 5] = matrix [ 5];
         this [ 6] = matrix [ 6];
         this [ 7] = matrix [ 7];
         this [ 8] = matrix [ 8];
         this [ 9] = matrix [ 9];
         this [10] = matrix [10];
         this [11] = matrix [11];
         this [12] = matrix [12];
         this [13] = matrix [13];
         this [14] = matrix [14];
         this [15] = matrix [15];
         return this;
      },
      equals: function (matrix)
      {
         return this [ 0] === matrix [ 0] &&
                this [ 1] === matrix [ 1] &&
                this [ 2] === matrix [ 2] &&
                this [ 3] === matrix [ 3] &&
                this [ 4] === matrix [ 4] &&
                this [ 5] === matrix [ 5] &&
                this [ 6] === matrix [ 6] &&
                this [ 7] === matrix [ 7] &&
                this [ 8] === matrix [ 8] &&
                this [ 9] === matrix [ 9] &&
                this [10] === matrix [10] &&
                this [11] === matrix [11] &&
                this [12] === matrix [12] &&
                this [13] === matrix [13] &&
                this [14] === matrix [14] &&
                this [15] === matrix [15];
      },
      set1: function (r, c, value)
      {
         this [r * this .order + c] = value;

         return this;
      },
      get1: function (r, c)
      {
         return this [r * this .order + c];
      },
      set: (function ()
      {
         const
            invScaleOrientation = new Rotation4 (),
            invCenter           = new Vector3 (0, 0, 0);

         return function (translation, rotation, scale, scaleOrientation, center)
         {
            switch (arguments .length)
            {
               case 0:
               {
                  this .identity ();
                  break;
               }
               case 1:
               {
                  if (translation === null) translation = Vector3 .Zero;

                  this .identity ();
                  this .translate (translation);
                  break;
               }
               case 2:
               {
                  if (translation === null) translation = Vector3 .Zero;
                  if (rotation    === null) rotation    = Rotation4 .Identity;

                  this .identity ();
                  this .translate (translation);

                  if (! rotation .equals (Rotation4 .Identity))
                     this .rotate (rotation);

                  break;
               }
               case 3:
               {
                  if (translation === null) translation = Vector3 .Zero;
                  if (rotation    === null) rotation    = Rotation4 .Identity;
                  if (scale       === null) scale       = Vector3 .One;

                  this .identity ();
                  this .translate (translation);

                  if (! rotation .equals (Rotation4 .Identity))
                     this .rotate (rotation);

                  if (! scale .equals (Vector3 .One))
                     this .scale  (scale);

                  break;
               }
               case 4:
               {
                  if (translation      === null) translation      = Vector3 .Zero;
                  if (rotation         === null) rotation         = Rotation4 .Identity;
                  if (scale            === null) scale            = Vector3 .One;
                  if (scaleOrientation === null) scaleOrientation = Rotation4 .Identity;

                  this .identity ();
                  this .translate (translation);

                  if (! rotation .equals (Rotation4 .Identity))
                     this .rotate (rotation);

                  if (! scale .equals (Vector3 .One))
                  {
                     const hasScaleOrientation = ! scaleOrientation .equals (Rotation4 .Identity);

                     if (hasScaleOrientation)
                     {
                        this .rotate (scaleOrientation);
                        this .scale (scale);
                        this .rotate (invScaleOrientation .assign (scaleOrientation) .inverse ());
                     }
                     else
                        this .scale (scale);
                  }

                  break;
               }
               case 5:
               {
                  if (translation      === null) translation      = Vector3 .Zero;
                  if (rotation         === null) rotation         = Rotation4 .Identity;
                  if (scale            === null) scale            = Vector3 .One;
                  if (scaleOrientation === null) scaleOrientation = Rotation4 .Identity;
                  if (center           === null) center           = Vector3 .Zero;

                  // P' = T * C * R * SR * S * -SR * -C * P
                  this .identity ();
                  this .translate (translation);

                  const hasCenter = ! center .equals (Vector3 .Zero);

                  if (hasCenter)
                     this .translate (center);

                  if (! rotation .equals (Rotation4 .Identity))
                     this .rotate (rotation);

                  if (! scale .equals (Vector3 .One))
                  {
                     if (! scaleOrientation .equals (Rotation4 .Identity))
                     {
                        this .rotate (scaleOrientation);
                        this .scale (scale);
                        this .rotate (invScaleOrientation .assign (scaleOrientation) .inverse ());
                     }
                     else
                        this .scale (scale);
                  }

                  if (hasCenter)
                     this .translate (invCenter .assign (center) .negate ());

                  break;
               }
               case 16:
               {
                  this [ 0] = arguments [ 0];
                  this [ 1] = arguments [ 1];
                  this [ 2] = arguments [ 2];
                  this [ 3] = arguments [ 3];
                  this [ 4] = arguments [ 4];
                  this [ 5] = arguments [ 5];
                  this [ 6] = arguments [ 6];
                  this [ 7] = arguments [ 7];
                  this [ 8] = arguments [ 8];
                  this [ 9] = arguments [ 9];
                  this [10] = arguments [10];
                  this [11] = arguments [11];
                  this [12] = arguments [12];
                  this [13] = arguments [13];
                  this [14] = arguments [14];
                  this [15] = arguments [15];
                  break;
               }
            }

            return this;
         };
      })(),
      get: (function ()
      {
         const
            dummyTranslation      = new Vector3 (0, 0, 0),
            dummyRotation         = new Rotation4 (),
            dummyScale            = new Vector3 (0, 0, 0),
            dummyScaleOrientation = new Rotation4 (),
            dummyCenter           = new Vector3 (0, 0, 0),
            rot                   = new Matrix3 (),
            so                    = new Matrix3 (),
            c                     = new Vector3 (0, 0, 0);

         return function (translation, rotation, scale, scaleOrientation, center)
         {
            if (translation      === null) translation      = dummyTranslation;
            if (rotation         === null) rotation         = dummyRotation;
            if (scale            === null) scale            = dummyScale;
            if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
            if (center           === null) center           = dummyCenter;

            switch (arguments .length)
            {
               case 1:
               {
                  translation .set (this [12], this [13], this [14]);
                  break;
               }
               case 2:
               {
                  this .factor (translation, rot, dummyScale, so);
                  rotation .setMatrix (rot);
                  break;
               }
               case 3:
               {
                  this .factor (translation, rot, scale, so);
                  rotation .setMatrix (rot);
                  break;
               }
               case 4:
               {
                  this .factor (translation, rot, scale, so);
                  rotation         .setMatrix (rot);
                  scaleOrientation .setMatrix (so);
                  break;
               }
               case 5:
               {
                  m .set (c .assign (center) .negate ());
                  m .multLeft (this);
                  m .translate (center);
                  m .get (translation, rotation, scale, scaleOrientation);
                  break;
               }
            }
         };
      })(),
      setRotation: function (rotation)
      {
         return this .setQuaternion (rotation .value);
      },
      setQuaternion: function (quaternion)
      {
         const
            x = quaternion .x,
            y = quaternion .y,
            z = quaternion .z,
            w = quaternion .w,
            A = y * y,
            B = z * z,
            C = x * y,
            D = z * w,
            E = z * x,
            F = y * w,
            G = x * x,
            H = y * z,
            I = x * w;

         this [0]  = 1 - 2 * (A + B);
         this [1]  = 2 * (C + D);
         this [2]  = 2 * (E - F);
         this [3]  = 0;
         this [4]  = 2 * (C - D);
         this [5]  = 1 - 2 * (B + G);
         this [6]  = 2 * (H + I);
         this [7]  = 0;
         this [8]  = 2 * (E + F);
         this [9]  = 2 * (H - I);
         this [10] = 1 - 2 * (A + G);
         this [11] = 0;
         this [12] = 0;
         this [13] = 0;
         this [14] = 0;
         this [15] = 1;

         return this;
      },
      factor: (function ()
      {
         const
            si = new Matrix3 (),
            u  = new Matrix3 (),
            b  = new Matrix3 ();

         const eigen = { values: [ ], vectors: [[ ], [ ], [ ]] };

         return function (translation, rotation, scale, scaleOrientation)
         {
            // (1) Get translation.
            translation .set (this [12], this [13], this [14]);

            // (2) Create 3x3 matrix.
            const a = this .submatrix;

            // (3) Compute det A. If negative, set sign = -1, else sign = 1
            const det      = a .determinant ();
            const det_sign = det < 0 ? -1 : 1;

            // (4) B = A * !A  (here !A means A transpose)
            b .assign (a) .transpose () .multLeft (a);
            const e = eigendecomposition (b, eigen);

            // Find min / max eigenvalues and do ratio test to determine singularity.

            scaleOrientation .set (e .vectors [0] [0], e .vectors [1] [0], e .vectors [2] [0],
                                   e .vectors [0] [1], e .vectors [1] [1], e .vectors [2] [1],
                                   e .vectors [0] [2], e .vectors [1] [2], e .vectors [2] [2]);

            // Compute s = sqrt(evalues), with sign. Set si = s-inverse

            scale .x = det_sign * Math .sqrt (e .values [0]);
            scale .y = det_sign * Math .sqrt (e .values [1]);
            scale .z = det_sign * Math .sqrt (e .values [2]);

            si [0] = 1 / scale .x;
            si [4] = 1 / scale .y;
            si [8] = 1 / scale .z;

            // (5) Compute U = !R ~S R A.
            rotation .assign (u .assign (scaleOrientation) .transpose () .multRight (si) .multRight (scaleOrientation) .multRight (a));
         };
      })(),
      determinant3: function ()
      {
         const
            m00 = this [0], m01 = this [1], m02 = this [ 2],
            m04 = this [4], m05 = this [5], m06 = this [ 6],
            m08 = this [8], m09 = this [9], m10 = this [10];

         return m00 * (m05 * m10 - m06 * m09) -
                m01 * (m04 * m10 - m06 * m08) +
                m02 * (m04 * m09 - m05 * m08);
      },
      determinant: function ()
      {
         const
            m00 = this [ 0],
            m01 = this [ 1],
            m02 = this [ 2],
            m03 = this [ 3],
            m04 = this [ 4],
            m05 = this [ 5],
            m06 = this [ 6],
            m07 = this [ 7],
            m08 = this [ 8],
            m09 = this [ 9],
            m10 = this [10],
            m11 = this [11],
            m12 = this [12],
            m13 = this [13],
            m14 = this [14],
            m15 = this [15],
            b = m10 * m15,
            c = m14 * m11,
            d = m06 * m15,
            e = m14 * m07,
            f = m06 * m11,
            g = m10 * m07,
            h = m02 * m15,
            i = m14 * m03,
            j = m02 * m11,
            o = m10 * m03,
            r = m02 * m07,
            x = m06 * m03,
            H = b * m05 + e * m09 + f * m13 - (c * m05) - (d * m09) - (g * m13),
            I = c * m01 + h * m09 + o * m13 - (b * m01) - (i * m09) - (j * m13),
            J = d * m01 + i * m05 + r * m13 - (e * m01) - (h * m05) - (x * m13),
            K = g * m01 + j * m05 + x * m09 - (f * m01) - (o * m05) - (r * m09);

         return m00 * H + m04 * I + m08 * J + m12 * K;
      },
      transpose: function ()
      {
         let tmp;

         tmp = this [ 1]; this [ 1] = this [ 4]; this [ 4] = tmp;
         tmp = this [ 2]; this [ 2] = this [ 8]; this [ 8] = tmp;
         tmp = this [ 3]; this [ 3] = this [12]; this [12] = tmp;
         tmp = this [ 6]; this [ 6] = this [ 9]; this [ 9] = tmp;
         tmp = this [ 7]; this [ 7] = this [13]; this [13] = tmp;
         tmp = this [11]; this [11] = this [14]; this [14] = tmp;

         return this;
      },
      inverse: function ()
      {
         const
            m00 = this [ 0],
            m01 = this [ 1],
            m02 = this [ 2],
            m03 = this [ 3],
            m04 = this [ 4],
            m05 = this [ 5],
            m06 = this [ 6],
            m07 = this [ 7],
            m08 = this [ 8],
            m09 = this [ 9],
            m10 = this [10],
            m11 = this [11],
            m12 = this [12],
            m13 = this [13],
            m14 = this [14],
            m15 = this [15],
            b = m10 * m15,
            c = m14 * m11,
            d = m06 * m15,
            e = m14 * m07,
            f = m06 * m11,
            g = m10 * m07,
            h = m02 * m15,
            i = m14 * m03,
            j = m02 * m11,
            o = m10 * m03,
            r = m02 * m07,
            x = m06 * m03,
            t = m08 * m13,
            p = m12 * m09,
            v = m04 * m13,
            s = m12 * m05,
            y = m04 * m09,
            z = m08 * m05,
            A = m00 * m13,
            C = m12 * m01,
            D = m00 * m09,
            E = m08 * m01,
            F = m00 * m05,
            G = m04 * m01,
            H = b * m05 + e * m09 + f * m13 - ((c * m05) + (d * m09) + (g * m13)),
            I = c * m01 + h * m09 + o * m13 - ((b * m01) + (i * m09) + (j * m13)),
            J = d * m01 + i * m05 + r * m13 - ((e * m01) + (h * m05) + (x * m13)),
            K = g * m01 + j * m05 + x * m09 - ((f * m01) + (o * m05) + (r * m09));

         let B = m00 * H + m04 * I + m08 * J + m12 * K;

         // if (B === 0) ... determinant is zero.

         B = 1 / B;

         this [ 0] = B * H;
         this [ 1] = B * I;
         this [ 2] = B * J;
         this [ 3] = B * K;
         this [ 4] = B * (c * m04 + d * m08 + g * m12 - (b * m04) - (e * m08) - (f * m12));
         this [ 5] = B * (b * m00 + i * m08 + j * m12 - (c * m00) - (h * m08) - (o * m12));
         this [ 6] = B * (e * m00 + h * m04 + x * m12 - (d * m00) - (i * m04) - (r * m12));
         this [ 7] = B * (f * m00 + o * m04 + r * m08 - (g * m00) - (j * m04) - (x * m08));
         this [ 8] = B * (t * m07 + s * m11 + y * m15 - (p * m07) - (v * m11) - (z * m15));
         this [ 9] = B * (p * m03 + A * m11 + E * m15 - (t * m03) - (C * m11) - (D * m15));
         this [10] = B * (v * m03 + C * m07 + F * m15 - (s * m03) - (A * m07) - (G * m15));
         this [11] = B * (z * m03 + D * m07 + G * m11 - (y * m03) - (E * m07) - (F * m11));
         this [12] = B * (v * m10 + z * m14 + p * m06 - (y * m14) - (t * m06) - (s * m10));
         this [13] = B * (D * m14 + t * m02 + C * m10 - (A * m10) - (E * m14) - (p * m02));
         this [14] = B * (A * m06 + G * m14 + s * m02 - (F * m14) - (v * m02) - (C * m06));
         this [15] = B * (F * m10 + y * m02 + E * m06 - (D * m06) - (G * m10) - (z * m02));

         return this;
      },
      multLeft: function (matrix)
      {
         const
            a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
            a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
            a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
            a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
            b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
            b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
            b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
            b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

         this [ 0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
         this [ 1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
         this [ 2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
         this [ 3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;
         this [ 4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
         this [ 5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
         this [ 6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
         this [ 7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;
         this [ 8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
         this [ 9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
         this [10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
         this [11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;
         this [12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
         this [13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
         this [14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
         this [15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

         return this;
      },
      multRight: function (matrix)
      {
         const
            a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
            a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
            a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
            a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
            b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
            b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
            b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
            b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

         this [ 0] = a00 * b00 + a01 * b04 + a02 * b08 + a03 * b12;
         this [ 1] = a00 * b01 + a01 * b05 + a02 * b09 + a03 * b13;
         this [ 2] = a00 * b02 + a01 * b06 + a02 * b10 + a03 * b14;
         this [ 3] = a00 * b03 + a01 * b07 + a02 * b11 + a03 * b15;
         this [ 4] = a04 * b00 + a05 * b04 + a06 * b08 + a07 * b12;
         this [ 5] = a04 * b01 + a05 * b05 + a06 * b09 + a07 * b13;
         this [ 6] = a04 * b02 + a05 * b06 + a06 * b10 + a07 * b14;
         this [ 7] = a04 * b03 + a05 * b07 + a06 * b11 + a07 * b15;
         this [ 8] = a08 * b00 + a09 * b04 + a10 * b08 + a11 * b12;
         this [ 9] = a08 * b01 + a09 * b05 + a10 * b09 + a11 * b13;
         this [10] = a08 * b02 + a09 * b06 + a10 * b10 + a11 * b14;
         this [11] = a08 * b03 + a09 * b07 + a10 * b11 + a11 * b15;
         this [12] = a12 * b00 + a13 * b04 + a14 * b08 + a15 * b12;
         this [13] = a12 * b01 + a13 * b05 + a14 * b09 + a15 * b13;
         this [14] = a12 * b02 + a13 * b06 + a14 * b10 + a15 * b14;
         this [15] = a12 * b03 + a13 * b07 + a14 * b11 + a15 * b15;

         return this;
      },
      multVecMatrix: function (vector)
      {
         if (vector .length === 3)
         {
            const
               x = vector .x,
               y = vector .y,
               z = vector .z,
               w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

            vector .x = (x * this [0] + y * this [4] + z * this [ 8] + this [12]) * w;
            vector .y = (x * this [1] + y * this [5] + z * this [ 9] + this [13]) * w;
            vector .z = (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;

            return vector;
         }

         const
            x = vector .x,
            y = vector .y,
            z = vector .z,
            w = vector .w;

         vector .x = x * this [0] + y * this [4] + z * this [ 8] + w * this [12];
         vector .y = x * this [1] + y * this [5] + z * this [ 9] + w * this [13];
         vector .z = x * this [2] + y * this [6] + z * this [10] + w * this [14];
         vector .w = x * this [3] + y * this [7] + z * this [11] + w * this [15];

         return vector;
      },
      multMatrixVec: function (vector)
      {
         if (vector .length === 3)
         {
            const
               x = vector .x,
               y = vector .y,
               z = vector .z,
               w = 1 / (x * this [12] + y * this [13] + z * this [14] + this [15]);

            vector .x = (x * this [0] + y * this [1] + z * this [ 2] + this [ 3]) * w;
            vector .y = (x * this [4] + y * this [5] + z * this [ 6] + this [ 7]) * w;
            vector .z = (x * this [8] + y * this [9] + z * this [10] + this [11]) * w;

            return vector;
         }

         const
            x = vector .x,
            y = vector .y,
            z = vector .z,
            w = vector .w;

         vector .x = x * this [ 0] + y * this [ 1] + z * this [ 2] + w * this [ 3];
         vector .y = x * this [ 4] + y * this [ 5] + z * this [ 6] + w * this [ 7];
         vector .z = x * this [ 8] + y * this [ 9] + z * this [10] + w * this [11];
         vector .w = x * this [12] + y * this [13] + z * this [14] + w * this [15];

         return vector;
      },
      multDirMatrix: function (vector)
      {
         const
            x = vector .x,
            y = vector .y,
            z = vector .z;

         vector .x = x * this [0] + y * this [4] + z * this [ 8];
         vector .y = x * this [1] + y * this [5] + z * this [ 9];
         vector .z = x * this [2] + y * this [6] + z * this [10];

         return vector;
      },
      multMatrixDir: function (vector)
      {
         const
            x = vector .x,
            y = vector .y,
            z = vector .z;

         vector .x = x * this [0] + y * this [1] + z * this [ 2];
         vector .y = x * this [4] + y * this [5] + z * this [ 6];
         vector .z = x * this [8] + y * this [9] + z * this [10];

         return vector;
      },
      identity: function ()
      {
         this [ 0] = 1; this [ 1] = 0; this [ 2] = 0; this [ 3] = 0;
         this [ 4] = 0; this [ 5] = 1; this [ 6] = 0; this [ 7] = 0;
         this [ 8] = 0; this [ 9] = 0; this [10] = 1; this [11] = 0;
         this [12] = 0; this [13] = 0; this [14] = 0; this [15] = 1;
      },
      translate: function (translation)
      {
         const
            x = translation .x,
            y = translation .y,
            z = translation .z;

         this [12] += this [ 0] * x + this [ 4] * y + this [ 8] * z;
         this [13] += this [ 1] * x + this [ 5] * y + this [ 9] * z;
         this [14] += this [ 2] * x + this [ 6] * y + this [10] * z;

         return this;
      },
      rotate: function (rotation)
      {
         this .multLeft (m .setQuaternion (rotation .value));

         return this;
      },
      scale: function (scale)
      {
         const
            x = scale .x,
            y = scale .y,
            z = scale .z;

         this [ 0] *= x;
         this [ 4] *= y;
         this [ 8] *= z;

         this [ 1] *= x;
         this [ 5] *= y;
         this [ 9] *= z;

         this [ 2] *= x;
         this [ 6] *= y;
         this [10] *= z;

         return this;
      },
      getDepth: function (vector)
      {
         const
            x = vector .x,
            y = vector .y,
            z = vector .z,
            w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

         return (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;
      },
      toString: function ()
      {
         return this [ 0] + " " + this [ 1] + " " + this [ 2] + " " + this [ 3] + " " +
                this [ 4] + " " + this [ 5] + " " + this [ 6] + " " + this [ 7] + " " +
                this [ 8] + " " + this [ 9] + " " + this [10] + " " + this [11] + " " +
                this [12] + " " + this [13] + " " + this [14] + " " + this [15]
      },
   };

   Object .defineProperty (Matrix4 .prototype, "x",
   {
      get: (function ()
      {
         const vector = new Vector4 (0, 0, 0, 0);

         return function () { return vector .set (this [0], this [1], this [2], this [3]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "y",
   {
      get: (function ()
      {
         const vector = new Vector4 (0, 0, 0, 0);

         return function () { return vector .set (this [4], this [5], this [6], this [7]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "z",
   {
      get: (function ()
      {
         const vector = new Vector4 (0, 0, 0, 0);

         return function () { return vector .set (this [8], this [9], this [10], this [11]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "w",
   {
      get: (function ()
      {
         const vector = new Vector4 (0, 0, 0, 0);

         return function () { return vector .set (this [12], this [13], this [14], this [15]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "xAxis",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [0], this [1], this [2]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "yAxis",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [4], this [5], this [6]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "zAxis",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [8], this [9], this [10]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "origin",
   {
      get: (function ()
      {
         const vector = new Vector3 (0, 0, 0);

         return function () { return vector .set (this [12], this [13], this [14]); };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .defineProperty (Matrix4 .prototype, "submatrix",
   {
      get: (function ()
      {
         const matrix = new Matrix3 ();

         return function ()
         {
            matrix [0] = this [0]; matrix [1] = this [1]; matrix [2] = this [ 2];
            matrix [3] = this [4]; matrix [4] = this [5]; matrix [5] = this [ 6];
            matrix [6] = this [8]; matrix [7] = this [9]; matrix [8] = this [10];
            return matrix;
         };
      })(),
      enumerable: false,
      configurable: false
   });

   Object .assign (Matrix4,
   {
      Identity: new Matrix4 (),
      Rotation: function (rotation)
      {
         return Object .create (this .prototype) .setQuaternion (rotation .value);
      },
      Quaternion: function (quaternion)
      {
         return Object .create (this .prototype) .setQuaternion (quaternion);
      },
      Matrix3: function (matrix)
      {
         return new Matrix4 (matrix [0], matrix [1], matrix [2], 0,
                             matrix [3], matrix [4], matrix [5], 0,
                             matrix [6], matrix [7], matrix [8], 0,
                             0, 0, 0, 1);
      },
      transpose: function (matrix)
      {
         return matrix .copy () .transpose ();
      },
      inverse: function (matrix)
      {
         return matrix .copy () .inverse ();
      },
      multLeft: function (lhs, rhs)
      {
         return lhs .copy () .multLeft (rhs);
      },
      multRight: function (lhs, rhs)
      {
         return lhs .copy () .multRight (rhs);
      },
   });

   const m = new Matrix4 ();

   return Matrix4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFMatrix4',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFMatrixPrototypeTemplate",
   "x_ite/Fields/SFVec3",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
],
function (X3DField,
          SFMatrixPrototypeTemplate,
          SFVec3,
          X3DConstants,
          Matrix4)
{
"use strict";

   function SFMatrix4Template (TypeName, Type, SFVec3, double)
   {
      function SFMatrix4 (m00, m01, m02, m03,
                          m10, m11, m12, m13,
                          m20, m21, m22, m23,
                          m30, m31, m32, m33)
      {
         switch (arguments .length)
         {
            case 0:
               return X3DField .call (this, new Matrix4 ());

            case 1:
               return X3DField .call (this, arguments [0]);

            case 16:
               return X3DField .call (this, new Matrix4 (+m00, +m01, +m02, +m03,
                                                         +m10, +m11, +m12, +m13,
                                                         +m20, +m21, +m22, +m23,
                                                         +m30, +m31, +m32, +m33));
         }

         throw new Error ("Invalid arguments.");
      }

      SFMatrix4 .prototype = Object .assign (Object .create (X3DField .prototype),
         SFMatrixPrototypeTemplate (Matrix4, SFVec3, double),
      {
         constructor: SFMatrix4,
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
      });

      for (const key of Reflect .ownKeys (SFMatrix4 .prototype))
         Object .defineProperty (SFMatrix4 .prototype, key, { enumerable: false });

      function defineProperty (i)
      {
         Object .defineProperty (SFMatrix4 .prototype, i,
         {
            get: function ()
            {
               return this .getValue () [i];
            },
            set: function (value)
            {
               this .getValue () [i] = value;
               this .addEvent ();
            },
            enumerable: true,
            configurable: false,
         });
      }

      for (let i = 0, length = Matrix4 .prototype .length; i < length; ++ i)
         defineProperty (i);

      return SFMatrix4;
   }

   return {
      SFMatrix4d: SFMatrix4Template ("SFMatrix4d", X3DConstants .SFMatrix4d, SFVec3 .SFVec3d, true),
      SFMatrix4f: SFMatrix4Template ("SFMatrix4f", X3DConstants .SFMatrix4f, SFVec3 .SFVec3f, false),
      VrmlMatrix: SFMatrix4Template ("VrmlMatrix", X3DConstants .VrmlMatrix, SFVec3 .SFVec3f, false),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFNodeCache',['x_ite/Fields/SFNode'],function ()
{
"use strict";

   const cache = new WeakMap ();

   function SFNodeCache () { }

   SFNodeCache .prototype =
   {
      get: function (baseNode)
      {
         const node = cache .get (baseNode);

         if (node)
         {
            return node;
         }
         else
         {
            const
               SFNode = require ("x_ite/Fields/SFNode"),
               node   = new SFNode (baseNode);

            cache .set (baseNode, node);

            return node;
         }
      },
   };

   return new SFNodeCache ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFNode',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
   "x_ite/Fields/SFNodeCache",
],
function (X3DField,
          X3DConstants,
          Generator,
          SFNodeCache)
{
"use strict";

   const
      _target     = Symbol (),
      _proxy      = Symbol (),
      _cloneCount = Symbol ();

   const handler =
   {
      get: function (target, key)
      {
         try
         {
            const value = target [key];

            if (value !== undefined)
               return value;

            const
               field      = target .getValue () .getField (key),
               accessType = field .getAccessType ();

            // Specification conform would be: accessType & X3DConstants .outputOnly.
            // But we allow read access to plain fields, too.
            if (accessType === X3DConstants .inputOnly)
               return undefined;

            return field .valueOf ();
         }
         catch (error)
         {
            return undefined;
         }
      },
      set: function (target, key, value)
      {
         if (key in target)
         {
            target [key] = value;
            return true;
         }

         try
         {
            const
               field      = target .getValue () .getField (key),
               accessType = field .getAccessType ();

            if (accessType !== X3DConstants .outputOnly)
               field .setValue (value);

             return true;
         }
         catch (error)
         {
            console .error (target, key, error);
            return false;
         }
      },
      has: function (target, key)
      {
         try
         {
            return Boolean (target .getValue () .getField (key));
         }
         catch (error)
         {
            return key in target;
         }
      },
      ownKeys: function (target)
      {
         const
            value   = target .getValue (),
            ownKeys = [ ];

         if (value)
         {
            for (const fieldDefinition of value .getFieldDefinitions ())
               ownKeys .push (fieldDefinition .name);
         }

         return ownKeys;
      },
      getOwnPropertyDescriptor: function (target, key)
      {
         const value = target .getValue ();

         if (value)
         {
            const fieldDefinition = value .getFieldDefinitions () .get (key);

            if (fieldDefinition)
            {
               return {
                  value: this .get (target, key),
                  writable: fieldDefinition .accessType !== X3DConstants .outputOnly,
                  enumerable: true,
                  configurable: true,
               };
            }
         }
      },
   };

   function SFNode (value)
   {
      // Node need to test for X3DBaseNode, because there is a special version of SFNode in Script.

      const proxy = new Proxy (this, handler);

      this [_target] = this;
      this [_proxy]  = proxy;

      if (value)
      {
         value .addParent (proxy);

         X3DField .call (this, value);
      }
      else
      {
         X3DField .call (this, null);
      }

      return proxy;
   }

   SFNode .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFNode,
      [_target]: null,
      [_proxy]: null,
      [_cloneCount]: 0,
      copy: function (instance)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return new SFNode (instance ? value .copy (instance) : value);

         return new SFNode ();
      },
      getTypeName: function ()
      {
         return "SFNode";
      },
      getType: function ()
      {
         return X3DConstants .SFNode;
      },
      equals: function (node)
      {
         const target = this [_target];

         if (node)
            return target .getValue () === node .getValue ();

         return target .getValue () === null;
      },
      isDefaultValue: function ()
      {
         const target = this [_target];

         return target .getValue () === null;
      },
      set: function (value)
      {
         const
            target  = this [_target],
            current = target .getValue ();

         if (current)
         {
            current .removeCloneCount (target [_cloneCount]);
            current .removeParent (target [_proxy]);
         }

         // No need to test for X3DBaseNode, because there is a special version of SFNode in Script.

         if (value)
         {
            value .addParent (target [_proxy]);
            value .addCloneCount (target [_cloneCount]);

            X3DField .prototype .set .call (target, value);
         }
         else
         {
            X3DField .prototype .set .call (target, null);
         }
      },
      getNodeTypeName: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return value .getTypeName ();

         throw new Error ("SFNode.getNodeTypeName: node is null.");
      },
      getNodeName: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return value .getName ();

         throw new Error ("SFNode.getNodeName: node is null.");
      },
      getNodeDisplayName: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return value .getDisplayName ();

         throw new Error ("SFNode.getNodeDisplayName: node is null.");
      },
      getNodeType: function ()
      {
         const
            target = this [_target],
             value  = target .getValue ();

         if (value)
            return value .getType () .slice ();

         throw new Error ("SFNode.getNodeType: node is null.");
      },
      getFieldDefinitions: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return value .getFieldDefinitions ();

         throw new Error ("SFNode.getFieldDefinitions: node is null.");
      },
      addFieldCallback: function (name, string, object)
      {
         const target = this [_target];

         switch (arguments .length)
         {
            case 2:
            {
               return X3DField .prototype .addFieldCallback .apply (target, arguments);
            }
            case 3:
            {
               const value = target .getValue ();

               if (value)
                  return value .getField (name) .addFieldCallback (string, object);

               throw new Error ("SFNode.addFieldCallback: node is null.");
            }
         }
      },
      removeFieldCallback: function (name, string)
      {
         const target = this [_target];

         switch (arguments .length)
         {
            case 1:
            {
               return X3DField .prototype .removeFieldCallback .apply (target, arguments);
            }
            case 2:
            {
               const value = target .getValue ();

               if (value)
                  return value .getField (name) .removeFieldCallback (string);

               throw new Error ("SFNode.removeFieldCallback: node is null.");
            }
         }
      },
      addCloneCount: function (count)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         target [_cloneCount] += count;

         if (value)
            value .addCloneCount (count);
      },
      removeCloneCount: function (count)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         target [_cloneCount] -= count;

         if (value)
            value .removeCloneCount (count);
      },
      valueOf: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            return SFNodeCache .get (value);

         return null;
      },
      toStream: function (stream)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            value .toStream (stream);
         else
            stream .string += "NULL";
      },
      toVRMLStream: function (stream)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            value .toVRMLStream (stream);
         else
            stream .string += "NULL";
      },
      toXMLString: function ()
      {
         const
            target    = this [_target],
            stream    = { string: "" },
            generator = Generator .Get (stream),
            value     = target .getValue ();

         generator .PushExecutionContext (value .getExecutionContext ());

         target .toXMLStream (stream);

         generator .PopExecutionContext ();

         return stream .string;
      },
      toXMLStream: function (stream)
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            value .toXMLStream (stream);
         else
            stream .string += "<!-- NULL -->";
      },
      dispose: function ()
      {
         const
            target = this [_target],
            value  = target .getValue ();

         if (value)
            value .dispose ();

         X3DField .prototype .dispose .call (target);
      },
   });

   for (const key of Reflect .ownKeys (SFNode .prototype))
      Object .defineProperty (SFNode .prototype, key, { enumerable: false });

   return SFNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFRotation',[
   "x_ite/Fields/SFVec3",
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
   "standard/Math/Numbers/Rotation4",
],
function (SFVec3,
          X3DField,
          X3DConstants,
          Generator,
          Rotation4)
{
"use strict";

   const SFVec3f = SFVec3 .SFVec3f;

   function SFRotation (x, y, z, angle)
   {
      switch (arguments .length)
      {
         case 0:
            return X3DField .call (this, new Rotation4 ());

         case 1:
            return X3DField .call (this, arguments [0]);

         case 2:
            if (arguments [1] instanceof SFVec3f)
               return X3DField .call (this, new Rotation4 (arguments [0] .getValue (), arguments [1] .getValue ()));

            return X3DField .call (this, new Rotation4 (arguments [0] .getValue (), +arguments [1]));

         case 4:
            return X3DField .call (this, new Rotation4 (+x, +y, +z, +angle));
      }

      throw new Error ("Invalid arguments.");
   }

   SFRotation .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFRotation,
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new SFRotation (this .getValue () .copy ());
      },
      equals: function (rotation)
      {
         return this .getValue () .equals (rotation .getValue ());
      },
      isDefaultValue: function ()
      {
         return this .getValue () .equals (Rotation4 .Identity);
      },
      getTypeName: function ()
      {
         return "SFRotation";
      },
      getType: function ()
      {
         return X3DConstants .SFRotation;
      },
      set: function (value)
      {
         this .getValue () .assign (value);
      },
      setAxis: function (vector)
      {
         this .getValue () .setAxis (vector .getValue ());
         this .addEvent ();
      },
      getAxis: function ()
      {
         return new SFVec3f (this .getValue () .getAxis () .copy ());
      },
      inverse: function ()
      {
         return new SFRotation (Rotation4 .inverse (this .getValue ()));
      },
      multiply: function (rotation)
      {
         return new SFRotation (Rotation4 .multRight (this .getValue (), rotation .getValue ()));
      },
      multVec: function (vector)
      {
         return new SFVec3f (this .getValue () .multVecRot (vector .getValue () .copy ()));
      },
      slerp: function (rotation, t)
      {
         return new SFRotation (Rotation4 .slerp (this .getValue (), rotation .getValue (), t));
      },
      toStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            rotation  = this .getValue ();

         stream .string += generator .DoublePrecision (rotation .x) + " " +
                           generator .DoublePrecision (rotation .y) + " " +
                           generator .DoublePrecision (rotation .z) + " " +
                           generator .DoublePrecision (generator .ToUnit ("angle", rotation .angle));
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFRotation .prototype))
      Object .defineProperty (SFRotation .prototype, key, { enumerable: false });

   const x = {
      get: function ()
      {
         return this .getValue () .x;
      },
      set: function (value)
      {
         this .getValue () .x = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const y = {
      get: function ()
      {
         return this .getValue () .y;
      },
      set: function (value)
      {
         this .getValue () .y = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const z = {
      get: function ()
      {
         return this .getValue () .z;
      },
      set: function (value)
      {
         this .getValue () .z = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   const angle = {
      get: function ()
      {
         return this .getValue () .angle;
      },
      set: function (value)
      {
         this .getValue () .angle = +value;
         this .addEvent ();
      },
      enumerable: true,
      configurable: false
   };

   Object .defineProperty (SFRotation .prototype, "x",     x);
   Object .defineProperty (SFRotation .prototype, "y",     y);
   Object .defineProperty (SFRotation .prototype, "z",     z);
   Object .defineProperty (SFRotation .prototype, "angle", angle);

   x     .enumerable = false;
   y     .enumerable = false;
   z     .enumerable = false;
   angle .enumerable = false;

   Object .defineProperty (SFRotation .prototype, "0", x);
   Object .defineProperty (SFRotation .prototype, "1", y);
   Object .defineProperty (SFRotation .prototype, "2", z);
   Object .defineProperty (SFRotation .prototype, "3", angle);

   return SFRotation;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFString',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

   const
      unescape = /\\(.)/g,
      escape   = /([\\"])/g;

   function SFString (value)
   {
      return X3DField .call (this, arguments .length ? "" + value : "");
   }

   Object .assign (SFString,
   {
      unescape: function (string)
      {
         return string .replace (unescape, "$1");
      },
      escape: function (string)
      {
         return string .replace (escape, "\\$1");
      },
   });

   SFString .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFString,
      [Symbol .iterator]: function* ()
      {
         yield* this .getValue ();
      },
      copy: function ()
      {
         return new SFString (this .getValue ());
      },
      getTypeName: function ()
      {
         return "SFString";
      },
      getType: function ()
      {
         return X3DConstants .SFString;
      },
      isDefaultValue: function ()
      {
         return this .getValue () === "";
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, "" + value);
      },
      valueOf: X3DField .prototype .getValue,
      toStream: function (stream)
      {
         stream .string += '"' + SFString .escape (this .getValue ()) + '"';
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         stream .string += Generator .Get (stream) .XMLEncode (this .getValue ());
      },
   });

   for (const key of Reflect .ownKeys (SFString .prototype))
      Object .defineProperty (SFString .prototype, key, { enumerable: false });

   Object .defineProperty (SFString .prototype, "length",
   {
      get: function ()
      {
         return this .getValue () .length;
      },
      enumerable: true,
      configurable: false
   });

   return SFString;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFTime',[
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

   function SFTime (value)
   {
      return X3DField .call (this, arguments .length ? +value : 0);
   }

   SFTime .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: SFTime,
      copy: function ()
      {
         return new SFTime (this .getValue ());
      },
      getTypeName: function ()
      {
         return "SFTime";
      },
      getType: function ()
      {
         return X3DConstants .SFTime;
      },
      isDefaultValue: function ()
      {
         return this .getValue () === 0;
      },
      set: function (value)
      {
         X3DField .prototype .set .call (this, +value);
      },
      valueOf: X3DField .prototype .getValue,
      toStream: function (stream)
      {
         stream .string += this .getValue ();
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .toStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (SFTime .prototype))
      Object .defineProperty (SFTime .prototype, key, { enumerable: false });

   return SFTime;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec4',[
   "x_ite/Base/X3DField",
   "x_ite/Fields/SFVecPrototypeTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector4",
],
function (X3DField,
          SFVecPrototypeTemplate,
          X3DConstants,
          Vector4)
{
"use strict";

   function SFVec4Template (TypeName, Type, double)
   {
      function SFVec4 (x, y, z, w)
      {
         switch (arguments .length)
         {
            case 0:
               return X3DField .call (this, new Vector4 (0, 0, 0, 0));

            case 1:
               return X3DField .call (this, arguments [0]);

            case 4:
               return X3DField .call (this, new Vector4 (+x, +y, +z, +w));
         }

         throw new Error ("Invalid arguments.");
      }

      SFVec4 .prototype = Object .assign (Object .create (X3DField .prototype),
         SFVecPrototypeTemplate (Vector4, double),
      {
         constructor: SFVec4,
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
      });

      for (const key of Reflect .ownKeys (SFVec4 .prototype))
         Object .defineProperty (SFVec4 .prototype, key, { enumerable: false });

      const x = {
         get: function ()
         {
            return this .getValue () .x;
         },
         set: function (value)
         {
            this .getValue () .x = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const y = {
         get: function ()
         {
            return this .getValue () .y;
         },
         set: function (value)
         {
            this .getValue () .y = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const z = {
         get: function ()
         {
            return this .getValue () .z;
         },
         set: function (value)
         {
            this .getValue () .z = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      const w = {
         get: function ()
         {
            return this .getValue () .w;
         },
         set: function (value)
         {
            this .getValue () .w = +value;
            this .addEvent ();
         },
         enumerable: true,
         configurable: false
      };

      Object .defineProperty (SFVec4 .prototype, "x", x);
      Object .defineProperty (SFVec4 .prototype, "y", y);
      Object .defineProperty (SFVec4 .prototype, "z", z);
      Object .defineProperty (SFVec4 .prototype, "w", w);

      x .enumerable = false;
      y .enumerable = false;
      z .enumerable = false;
      w .enumerable = false;

      Object .defineProperty (SFVec4 .prototype, "0", x);
      Object .defineProperty (SFVec4 .prototype, "1", y);
      Object .defineProperty (SFVec4 .prototype, "2", z);
      Object .defineProperty (SFVec4 .prototype, "3", w);

      return SFVec4;
   }

   return {
      SFVec4d: SFVec4Template ("SFVec4d", X3DConstants .SFVec4d, true),
      SFVec4f: SFVec4Template ("SFVec4f", X3DConstants .SFVec4f, false),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DArrayField',[
   "x_ite/Base/X3DField",
],
function (X3DField)
{
"use strict";

   function X3DArrayField (value)
   {
      X3DField .call (this, value);
   }

   X3DArrayField .prototype = Object .assign (Object .create (X3DField .prototype),
   {
      constructor: X3DArrayField,
      at: Array .prototype .at,
      concat: Array .prototype .concat,
      //entries: function () { return iterator -> [index, value]; },
      every: Array .prototype .every,
      fill: Array .prototype .fill,
      filter: Array .prototype .filter,
      find: Array .prototype .find,
      findIndex: Array .prototype .findIndex,
      forEach: Array .prototype .forEach,
      includes: Array .prototype .includes,
      indexOf: Array .prototype .indexOf,
      join: Array .prototype .join,
      keys: function () { return Array (this .length) .keys (); },
      lastIndexOf: Array .prototype .lastIndexOf,
      map: Array .prototype .map,
      reduce: Array .prototype .reduce,
      reduceRight: Array .prototype .reduceRight,
      slice: Array .prototype .slice,
      some: Array .prototype .some,
      values: function () { return this [Symbol .iterator]; },
   });

   for (const key of Reflect .ownKeys (X3DArrayField .prototype))
      Object .defineProperty (X3DArrayField .prototype, key, { enumerable: false });

   return X3DArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DObjectArrayField',[
   "jquery",
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DArrayField",
   "x_ite/InputOutput/Generator",
],
function ($,
          X3DField,
          X3DArrayField,
          Generator)
{
"use strict";

   const
      _target = Symbol (),
      _proxy  = Symbol ();

   const handler =
   {
      get: function (target, key)
      {
         const value = target [key];

         if (value !== undefined)
            return value;

         if (typeof key === "string")
         {
            const
               array = target .getValue (),
               index = +key;

            if (Number .isInteger (index))
            {
               if (index >= array .length)
                  target .resize (index + 1);

               return array [index] .valueOf ();
            }
            else
            {
               return target [key];
            }
         }
      },
      set: function (target, key, value)
      {
         if (key in target)
         {
            target [key] = value;
            return true;
         }

         const
            array = target .getValue (),
            index = +key;

         if (index >= array .length)
            target .resize (index + 1);

         array [index] .setValue (value);

         return true;
      },
      has: function (target, key)
      {
         if (Number .isInteger (+key))
            return key < target .getValue () .length;

         return key in target;
      },
      ownKeys: function (target)
      {
         return Object .keys (target .getValue ());
      },
      getOwnPropertyDescriptor: function (target, key)
      {
         if (typeof key !== "string")
            return;

         const index = +key;

         if (Number .isInteger (index) && index < target .getValue () .length)
            return Object .getOwnPropertyDescriptor (target .getValue (), key);
      },
   };

   function X3DObjectArrayField (value)
   {
      const proxy = new Proxy (this, handler);

      X3DArrayField .call (this, [ ]);

      this [_target] = this;
      this [_proxy]  = proxy;

      if (value [0] instanceof Array)
         value = value [0];

      X3DObjectArrayField .prototype .push .apply (this, value);

      return proxy;
   }

   X3DObjectArrayField .prototype = Object .assign (Object .create (X3DArrayField .prototype),
   {
      constructor: X3DObjectArrayField,
      [_target]: null,
      [_proxy]: null,
      [Symbol .iterator]: function* ()
      {
         const
            target = this [_target],
            array  = target .getValue ();

         for (const value of array)
            yield value .valueOf ();
      },
      getTarget: function ()
      {
         return this [_target];
      },
      copy: function ()
      {
         const
            target = this [_target],
            copy   = target .create (),
            array  = target .getValue ();

         X3DObjectArrayField .prototype .push .apply (copy, array);

         copy .setModificationTime (0);

         return copy;
      },
      equals: function (array)
      {
         const
            target = this [_target],
            a      = target .getValue (),
            b      = array .getValue (),
            length = a .length;

         if (a === b)
            return true;

         if (length !== b .length)
            return false;

         for (let i = 0; i < length; ++ i)
         {
            if (! a [i] .equals (b [i]))
               return false;
         }

         return true;
      },
      set: function (value)
      {
         const target = this [_target];

         target .resize (value .length, undefined, true);

         const array = target .getValue ();

         for (let i = 0, length = value .length; i < length; ++ i)
            array [i] .set (value [i] instanceof X3DField ? value [i] .getValue () : value [i]);
      },
      isDefaultValue: function ()
      {
         return this .length === 0;
      },
      setValue: function (value)
      {
         const target = this [_target];

         target .set (value instanceof X3DObjectArrayField ? value .getValue () : value);
         target .addEvent ();
      },
      unshift: function (value)
      {
         const
            target = this [_target],
            array  = target .getValue ();

         for (let i = arguments .length - 1; i >= 0; -- i)
         {
            const field = new (target .getSingleType ()) ();

            field .setValue (arguments [i]);
            target .addChildObject (field);
            array .unshift (field);
         }

         target .addEvent ();

         return array .length;
      },
      shift: function ()
      {
         const
            target = this [_target],
            array  = target .getValue ();

         if (array .length)
         {
            const field = array .shift ();
            target .removeChildObject (field);
            target .addEvent ();
            return field .valueOf ();
         }
      },
      push: function (value)
      {
         const
            target = this [_target],
            array  = target .getValue ();

         for (const argument of arguments)
         {
            const field = new (target .getSingleType ()) ();

            field .setValue (argument);
            target .addChildObject (field);
            array .push (field);
         }

         target .addEvent ();

         return array .length;
      },
      pop: function ()
      {
         const
            target = this [_target],
            array  = target .getValue ();

         if (array .length)
         {
            const field = array .pop ();
            target .removeChildObject (field);
            target .addEvent ();
            return field .valueOf ();
         }
      },
      splice: function (index, deleteCount)
      {
         const
            target = this [_target],
            array  = target .getValue ();

         if (index > array .length)
            index = array .length;

         if (index + deleteCount > array .length)
            deleteCount = array .length - index;

         const result = target .erase (index, index + deleteCount);

         if (arguments .length > 2)
            target .insert (index, arguments, 2, arguments .length);

         return result;
      },
      insert: function (index, array, first, last)
      {
         const
            target = this [_target],
            args   = [index, 0];

         for (let i = first; i < last; ++ i)
         {
            const field = new (target .getSingleType ()) ();

            field .setValue (array [i]);
            target .addChildObject (field);
            args .push (field);
         }

         Array .prototype .splice .apply (target .getValue (), args);

         target .addEvent ();
      },
      find: function (first, last, value)
      {
         const
            target = this [_target],
            values = target .getValue ();

         if ($.isFunction (value))
         {
            for (let i = first; i < last; ++ i)
            {
               if (value (values [i] .valueOf ()))
                  return i;
            }

            return last;
         }

         for (let i = first; i < last; ++ i)
         {
            if (values [i] .equals (value))
               return i;
         }

         return last;
      },
      remove: function (first, last, value)
      {
         const
            target = this [_target],
            values = target .getValue ();

         if ($.isFunction (value))
         {
            first = target .find (first, last, value);

            if (first !== last)
            {
               for (let i = first; ++ i < last; )
               {
                  const current = values [i];

                  if (! value (current .valueOf ()))
                  {
                     const tmp = values [first];

                     values [first ++] = current;
                     values [i]        = tmp;
                  }
               }
            }

            if (first !== last)
               target .addEvent ();

            return first;
         }

         first = target .find (first, last, value);

         if (first !== last)
         {
            for (let i = first; ++ i < last; )
            {
               const current = values [i];

               if (! current .equals (value))
               {
                  const tmp = values [first];

                  values [first ++] = current;
                  values [i]        = tmp;
               }
            }
         }

         if (first !== last)
            target .addEvent ();

         return first;
      },
      erase: function (first, last)
      {
         const
            target = this [_target],
            values = target .getValue () .splice (first, last - first);

         for (const value of values)
            target .removeChildObject (value);

         target .addEvent ();

         return values .map (function (value) { return value .valueOf () });
      },
      resize: function (size, value, silent)
      {
         const
            target = this [_target],
            array  = target .getValue ();

         if (size < array .length)
         {
            for (let i = size, length = array .length; i < length; ++ i)
               target .removeChildObject (array [i]);

            array .length = size;

            if (! silent)
               target .addEvent ();
         }
         else if (size > array .length)
         {
            for (let i = array .length; i < size; ++ i)
            {
               const field = new (target .getSingleType ()) ();

               if (value !== undefined)
                  field .setValue (value);

               target .addChildObject (field);
               array .push (field);
            }

            if (! silent)
               target .addEvent ();
         }
      },
      addChildObject: function (value)
      {
         value .addParent (this [_proxy]);
      },
      removeChildObject: function (value)
      {
         value .removeParent (this [_proxy]);
      },
      toStream: function (stream)
      {
         const
            target    = this [_target],
            array     = target .getValue (),
            generator = Generator .Get (stream);

         switch (array .length)
         {
            case 0:
            {
               stream .string += "[ ]";
               break;
            }
            case 1:
            {
               generator .PushUnitCategory (target .getUnit ());

               array [0] .toStream (stream);

               generator .PopUnitCategory ();
               break;
            }
            default:
            {
               generator .PushUnitCategory (target .getUnit ());

               stream .string += "[\n";
               generator .IncIndent ();

               for (let i = 0, length = array .length - 1; i < length; ++ i)
               {
                  stream .string += generator .Indent ();
                  array [i] .toStream (stream);
                  stream .string += ",\n";
               }

               stream .string += generator .Indent ();
               array .at (-1) .toStream (stream);
               stream .string += "\n";

               generator .DecIndent ();
               stream .string += generator .Indent ();
               stream .string += "]";

               generator .PopUnitCategory ();
               break;
            }
         }
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         const
            target = this [_target],
            length = target .length;

         if (length)
         {
            const
               generator = Generator .Get (stream),
               array     = target .getValue ();

            generator .PushUnitCategory (target .getUnit ());

            for (const element of array)
            {
               element .toXMLStream (stream);
               stream .string += ", ";
            }

            array .at (-1) .toXMLStream (stream);

            generator .PopUnitCategory ();
         }
      },
      dispose: function ()
      {
         const
            target = this [_target],
            array  = target .getValue ();

         for (const value of array)
            target .removeChildObject (value);

         array .length = 0;

         X3DArrayField .prototype .dispose .call (target);
      },
   });

   for (const key of Reflect .ownKeys (X3DObjectArrayField .prototype))
      Object .defineProperty (X3DObjectArrayField .prototype, key, { enumerable: false });

   Object .defineProperty (X3DObjectArrayField .prototype, "length",
   {
      get: function () { return this [_target] .getValue () .length; },
      set: function (value) { this [_target] .resize (value); },
      enumerable: false,
      configurable: false,
   });

   return X3DObjectArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DTypedArrayField',[
   "x_ite/Base/X3DArrayField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
   "standard/Math/Algorithm",
],
function (X3DArrayField,
          X3DConstants,
          Generator,
          Algorithm)
{
"use strict";

   const
      _target = Symbol (),
      _tmp    = Symbol (),
      _length = Symbol ();

   const handler =
   {
      get: function (target, key)
      {
         const value = target [key];

         if (value !== undefined)
            return value;

         if (typeof key === "string")
         {
            const index = +key;

            if (Number .isInteger (index))
            {
               const
                  components = target .getComponents (),
                  valueType  = target .getValueType ();

               let array = target .getValue ();

               if (index >= target [_length])
                  array = target .resize (index + 1);

               if (components === 1)
               {
                  // Return native JavaScript value.
                  return valueType (array [index]);
               }
               else
               {
                  // Return reference to index.

                  const
                     value         = new (valueType) (),
                     internalValue = value .getValue (),
                     i             = index * components;

                  value .addEvent = addEvent .bind (target, i, internalValue, components);
                  value .getValue = getValue .bind (target, i, internalValue, components);

                  return value;
               }
            }
            else
            {
               return target [key];
            }
         }
      },
      set: function (target, key, value)
      {
         if (key in target)
         {
            target [key] = value;
            return true;
         }

         const components = target .getComponents ();

         let
            index = +key,
            array = target .getValue ();

         if (index >= target [_length])
            array = target .resize (index + 1);

         if (components === 1)
         {
            array [index] = value;
         }
         else
         {
            index *= components;

            for (let c = 0; c < components; ++ c, ++ index)
               array [index] = value [c];
         }

         target .addEvent ();

         return true;
      },
      has: function (target, key)
      {
         if (Number .isInteger (+key))
            return key < target [_length];

         return key in target;
      },
      ownKeys: function (target)
      {
         const ownKeys = [ ];

         for (let i = 0, length = target [_length]; i < length; ++ i)
            ownKeys .push (String (i));

         return ownKeys;
      },
      getOwnPropertyDescriptor: function (target, key)
      {
         if (typeof key !== "string")
            return;

         const index = +key;

         if (Number .isInteger (index) && index < target [_length])
            return Object .getOwnPropertyDescriptor (target .getValue (), key);
      },
   };

   function X3DTypedArrayField (value)
   {
      X3DArrayField .call (this, new (this .getArrayType ()) (2));

      this [_target] = this;
      this [_tmp]    = [ ];  // Array with components size.

      if (value [0] instanceof Array)
         value = value [0];

      X3DTypedArrayField .prototype .push .apply (this, value);

      return new Proxy (this, handler);
   }

   X3DTypedArrayField .prototype = Object .assign (Object .create (X3DArrayField .prototype),
   {
      constructor: X3DTypedArrayField,
      [_target]: null,
      [_tmp]: null,
      [_length]: 0,
      [Symbol .iterator]: function* ()
      {
         const
            target     = this [_target],
            array      = target .getValue (),
            components = target .getComponents (),
            valueType  = target .getValueType (),
            length     = target [_length];

         if (components === 1)
         {
            // Return native JavaScript value.

            for (let index = 0; index < length; ++ index)
               yield valueType (array [index]);
         }
         else
         {
            // Return reference to index.

            for (let index = 0; index < length; ++ index)
            {
               const
                  value         = new (valueType) (),
                  internalValue = value .getValue (),
                  i             = index * components;

               value .addEvent = addEvent .bind (target, i, internalValue, components);
               value .getValue = getValue .bind (target, i, internalValue, components);

               yield value;
            }
         }
      },
      getTarget: function ()
      {
         return this [_target];
      },
      copy: function ()
      {
         const
            target     = this [_target],
            array      = target .getValue (),
            copy       = target .create (),
            copyArray  = new (target .getArrayType ()) (array);

         copy [_length] = target [_length];

         X3DArrayField .prototype .set .call (copy, copyArray, target [_length]);

         copy .setModificationTime (0);

         return copy;
      },
      equals: function (other)
      {
         if (this === other)
            return true;

         const
            target = this [_target],
            length = target [_length];

         if (length !== other [_length])
            return false;

         const
            a = target  .getValue (),
            b = other .getValue ();

         for (let i = 0, l = length * target .getComponents (); i < l; ++ i)
         {
            if (a [i] !== b [i])
               return false;
         }

         return true;
      },
      assign: function (value)
      {
         const target = this [_target];

         target .set (value .getValue (), value .length);
         target .addEvent ();
      },
      set: function (otherArray /* value of field */, l /* length of field */)
      {
         const
            target      = this [_target],
            components  = target .getComponents (),
            length      = target [_length];

         let
            array       = target .getValue (),
            otherLength = l !== undefined ? l * components : otherArray .length;

         const
            rest = otherLength % components;

         if (rest)
         {
            otherLength -= rest;

            console .warn ("Array length must be multiple of components size, which is " + components + ".");
         }

         otherLength /= components;

         if (array .length < otherArray .length)
         {
            array = target .grow (otherArray .length);

            array .set (otherArray);

            if (rest)
               array .fill (0, otherLength * components, otherLength * components + rest);
         }
         else
         {
            array .set (otherArray);

            if (otherLength < length)
               array .fill (0, otherLength * components, length * components);
         }

         target [_length] = otherLength;
      },
      isDefaultValue: function ()
      {
         return this [_length] === 0;
      },
      setValue: function (value)
      {
         const target = this [_target];

         if (value instanceof target .constructor)
         {
            target .assign (value);
         }
         else
         {
            target .set (value);
            target .addEvent ();
         }
      },
      unshift: function (value)
      {
         const
            target          = this [_target],
            components      = target .getComponents (),
            length          = target [_length],
            argumentsLength = arguments .length,
            array           = target .grow ((length + argumentsLength) * components);

         array .copyWithin (argumentsLength * components, 0, length * components);

         if (components === 1)
         {
            array .set (arguments, 0);
         }
         else
         {
            for (let i = 0, a = 0; a < argumentsLength; ++ a)
            {
               const argument = arguments [a];

               for (let c = 0; c < components; ++ c, ++ i)
               {
                  array [i] = argument [c];
               }
            }
         }

         target [_length] += argumentsLength;

         target .addEvent ();

         return array .length;
      },
      shift: function ()
      {
         const
            target = this [_target],
            length = target [_length];

         if (length)
         {
            const
               array      = target .getValue (),
               components = target .getComponents (),
               valueType  = target .getValueType (),
               newLength  = length - 1;

            if (components === 1)
            {
               var value = valueType (array [0]);
            }
            else
            {
               const tmp = target [_tmp];

               for (let c = 0; c < components; ++ c)
                  tmp [c] = array [c];

               var value = Object .create (valueType .prototype);

               valueType .apply (value, tmp);
            }

            array .copyWithin (0, components, length * components);
            array .fill (0, components * newLength, length * components);

            target [_length] = newLength;

            target .addEvent ();
            return value;
         }
      },
      push: function (value)
      {
         const
            target          = this [_target],
            components      = target .getComponents (),
            length          = target [_length],
            argumentsLength = arguments .length,
            array           = target .grow ((length + argumentsLength) * components);

         if (components === 1)
         {
            array .set (arguments, length);
         }
         else
         {
            for (let i = length * components, a = 0; a < argumentsLength; ++ a)
            {
               const argument = arguments [a];

               for (let c = 0; c < components; ++ c,  ++ i)
               {
                  array [i] = argument [c];
               }
            }
         }

         target [_length] += argumentsLength;

         target .addEvent ();

         return target [_length];
      },
      pop: function ()
      {
         const
            target = this [_target],
            length = target [_length];

         if (length)
         {
            const
               array      = target .getValue (),
               components = target .getComponents (),
               valueType  = target .getValueType (),
               newLength  = length - 1;

            if (components === 1)
            {
               var value = valueType (array [length - 1]); // Don't use at(-1).
            }
            else
            {
               const tmp = target [_tmp];

               for (let c = 0, a = newLength * components; c < components; ++ c, ++ a)
                  tmp [c] = array [a];

               var value = Object .create (valueType .prototype);

               valueType .apply (value, tmp);
            }

            array .fill (0, newLength * components, length * components);

            target [_length] = newLength;

            target .addEvent ();

            return value;
         }
      },
      splice: function (index, deleteCount)
      {
         const
            target = this [_target],
            length = target [_length];

         if (index > length)
            index = length;

         if (index + deleteCount > length)
            deleteCount = length - index;

         const result = target .erase (index, index + deleteCount);

         if (arguments .length > 2)
            target .spliceInsert (index, Array .prototype .splice .call (arguments, 2));

         target .addEvent ();

         return result;
      },
      spliceInsert: function (index, other)
      {
         const
            target      = this [_target],
            components  = target .getComponents (),
            length      = target [_length],
            otherLength = other .length,
            array       = target .grow ((length + otherLength) * components);

         index *= components;

         array .copyWithin (index + otherLength * components, index, length * components);

         if (components === 1)
         {
            array .set (other, index);
         }
         else
         {
            for (let i = 0, a = index; i < otherLength; ++ i)
            {
               const value = other [i];

               for (let c = 0; c < components; ++ c, ++ a)
                  array [a] = value [c];
            }
         }

         target [_length] += otherLength;
      },
      insert: function (index, other, first, last)
      {
         const
            target     = this [_target],
            length     = target [_length],
            otherArray = other .getValue (),
            components = target .getComponents (),
            difference = last - first,
            array      = target .grow ((length + difference) * components);

         index *= components;
         first *= components;
         last  *= components;

         array .copyWithin (index + difference * components, index, length * components);

         for (; first < last; ++ index, ++ first)
            array [index] = otherArray [first];

         target [_length] += difference;

         target .addEvent ();
      },
      erase: function (first, last)
      {
         const
            target      = this [_target],
            array       = target .getValue (),
            components  = target .getComponents (),
            difference  = last - first,
            length      = target [_length],
            newLength   = length - difference,
            values      = target .create (),
            valuesArray = values .grow (difference * components);

         first *= components;
         last  *= components;

         for (let v = 0, f = first; f < last; ++ v, ++ f)
            valuesArray [v] = array [f];

         array .copyWithin (first, last, length * components);
         array .fill (0, newLength * components, length * components);

         target [_length] = newLength;
         values [_length] = difference;

         target .addEvent ();

         return values .slice ();
      },
      resize: function (newLength, value, silent)
      {
         const
            target     = this [_target],
            length     = target [_length],
            components = target .getComponents ();

         let array = target .getValue ();

         if (newLength < length)
         {
            array .fill (0, newLength * components, length * components);

            if (!silent)
               target .addEvent ();
         }
         else if (newLength > length)
         {
            array = target .grow (newLength * components);

            if (value !== undefined)
            {
               if (components === 1)
               {
                  array .fill (value, length * components, newLength * components);
               }
               else
               {
                  for (let i = length * components, il = newLength * components; i < il; )
                  {
                     for (let c = 0; c < components; ++ c, ++ i)
                     {
                        array [i] = value [c];
                     }
                  }
               }
            }

            if (!silent)
               target .addEvent ();
         }

         target [_length] = newLength;

         return array;
      },
      grow: function (length)
      {
         const
            target = this [_target],
            array  = target .getValue ();

         if (length < array .length)
            return array;

         const
            maxLength = Algorithm .nextPowerOfTwo (length),
            newArray  = new (target .getArrayType ()) (maxLength);

         newArray .set (array);

         X3DArrayField .prototype .set .call (target, newArray);

         return newArray;
      },
      shrinkToFit: function ()
      {
         const
            target = this [_target],
            array  = target .getValue (),
            length = target [_length] * target .getComponents ();

         if (array .length == length)
            return array;

         const newArray = array .subarray (0, length);

         X3DArrayField .prototype .set .call (target, newArray);

         return newArray;
      },
      toStream: function (stream)
      {
         const
            target     = this [_target],
            generator  = Generator .Get (stream),
            array      = target .getValue (),
            length     = target [_length],
            components = target .getComponents (),
            value      = new (target .getSingleType ()) ();

         switch (length)
         {
            case 0:
            {
               stream .string += "[ ]";
               break;
            }
            case 1:
            {
               generator .PushUnitCategory (target .getUnit ());

               if (components === 1)
               {
                  value .set (array [0]);

                  value .toStream (stream);
               }
               else
               {
                  for (let c = 0, first = 0; c < components; ++ c, ++ first)
                     value [c] = array [first];

                  value .toStream (stream);
               }

               generator .PopUnitCategory ();
               break;
            }
            default:
            {
               generator .PushUnitCategory (target .getUnit ());

               stream .string += "[\n";
               generator .IncIndent ();

               if (components === 1)
               {
                  for (let i = 0, n = length - 1; i < n; ++ i)
                  {
                     stream .string += generator .Indent ();

                     value .set (array [i * components]);
                     value .toStream (stream);

                     stream .string += ",\n";
                  }

                  stream .string += generator .Indent ();
                  value .set (array [(length - 1) * components]);
                  value .toStream (stream);

                  stream .string += "\n";
               }
               else
               {
                  for (let i = 0, n = length - 1; i < n; ++ i)
                  {
                     stream .string += generator .Indent ();

                     for (let c = 0, first = i * components; c < components; ++ c, ++ first)
                        value [c] = array [first];

                     value .toStream (stream);

                     stream .string += ",\n";
                  }

                  stream .string += generator .Indent ();

                  for (let c = 0, first = (length - 1) * components; c < components; ++ c, ++ first)
                     value [c] = array [first];

                  value .toStream (stream);
                  stream .string += "\n";
               }

               generator .DecIndent ();
               stream .string += generator .Indent ();
               stream .string += "]";

               generator .PopUnitCategory ();
               break;
            }
         }
      },
      toVRMLStream: function (stream)
      {
         this .toStream (stream);
      },
      toXMLStream: function (stream)
      {
         const
            target = this [_target],
            length = target [_length];

         if (length)
         {
            const
               generator  = Generator .Get (stream),
               array      = target .getValue (),
               components = target .getComponents (),
               value      = new (target .getSingleType ()) ();

            generator .PushUnitCategory (target .getUnit ());

            if (components === 1)
            {
               for (let i = 0, n = length - 1; i < n; ++ i)
               {
                  value .set (array [i * components]);
                  value .toXMLStream (stream);

                  stream .string += ", ";
               }

               value .set (array [(length - 1) * components]);

               value .toXMLStream (stream);
            }
            else
            {
               for (let i = 0, n = length - 1; i < n; ++ i)
               {
                  for (let c = 0, first = i * components; c < components; ++ c, ++ first)
                     value [c] = array [first];

                  value .toXMLStream (stream);

                  stream .string += ", ";
               }

               for (let c = 0, first = (length - 1) * components; c < components; ++ c, ++ first)
                  value [c] = array [first];

               value .toXMLStream (stream);
            }

            generator .PopUnitCategory ();
         }
      },
      dispose: function ()
      {
         X3DArrayField .prototype .dispose .call (this [_target]);
      },
   });

   for (const key of Reflect .ownKeys (X3DTypedArrayField .prototype))
      Object .defineProperty (X3DTypedArrayField .prototype, key, { enumerable: false });

   Object .defineProperty (X3DTypedArrayField .prototype, "length",
   {
      get: function () { return this [_length]; },
      set: function (value) { this [_target] .resize (value); },
      enumerable: false,
      configurable: false,
   });

   // Getter/Setter functions to reference a value for a given index.

   function getValue (index, value, components)
   {
      const
         array = this .getValue (),
         tmp   = this [_tmp];

      for (let c = 0; c < components; ++ c, ++ index)
         tmp [c] = array [index];

      value .set .apply (value, tmp);

      return value;
   }

   function addEvent (index, value, components)
   {
      const array = this .getValue ();

      for (let c = 0; c < components; ++ c, ++ index)
         array [index] = value [c];

      this .addEvent ();
   }

   return X3DTypedArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/ArrayFields',[
   "x_ite/Fields/SFBool",
   "x_ite/Fields/SFColor",
   "x_ite/Fields/SFColorRGBA",
   "x_ite/Fields/SFDouble",
   "x_ite/Fields/SFFloat",
   "x_ite/Fields/SFImage",
   "x_ite/Fields/SFInt32",
   "x_ite/Fields/SFMatrix3",
   "x_ite/Fields/SFMatrix4",
   "x_ite/Fields/SFNode",
   "x_ite/Fields/SFRotation",
   "x_ite/Fields/SFString",
   "x_ite/Fields/SFTime",
   "x_ite/Fields/SFVec2",
   "x_ite/Fields/SFVec3",
   "x_ite/Fields/SFVec4",
   "x_ite/Base/X3DObjectArrayField",
   "x_ite/Base/X3DTypedArrayField",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (SFBool,
          SFColor,
          SFColorRGBA,
          SFDouble,
          SFFloat,
          SFImage,
          SFInt32,
          SFMatrix3,
          SFMatrix4,
          SFNode,
          SFRotation,
          SFString,
          SFTime,
          SFVec2,
          SFVec3,
          SFVec4,
          X3DObjectArrayField,
          X3DTypedArrayField,
          X3DConstants,
          Generator)
{
"use strict";

   const
      SFMatrix3d = SFMatrix3 .SFMatrix3d,
      SFMatrix3f = SFMatrix3 .SFMatrix3f,
      SFMatrix4d = SFMatrix4 .SFMatrix4d,
      SFMatrix4f = SFMatrix4 .SFMatrix4f,
      SFVec2d    = SFVec2 .SFVec2d,
      SFVec2f    = SFVec2 .SFVec2f,
      SFVec3d    = SFVec3 .SFVec3d,
      SFVec3f    = SFVec3 .SFVec3f,
      SFVec4d    = SFVec4 .SFVec4d,
      SFVec4f    = SFVec4 .SFVec4f;

   /*
    *  MFNode
    */

   const _cloneCount = Symbol ();

   function MFNode (value)
   {
      return X3DObjectArrayField .call (this, arguments);
   }

   MFNode .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
   {
      constructor: MFNode,
      [_cloneCount]: 0,
      getSingleType: function ()
      {
         return SFNode;
      },
      getValueType: function ()
      {
         return SFNode;
      },
      getArrayType: function ()
      {
         return Array;
      },
      getComponents: function ()
      {
         return 1;
      },
      getTypeName: function ()
      {
         return "MFNode";
      },
      getType: function ()
      {
         return X3DConstants .MFNode;
      },
      copy: function (instance)
      {
         if (instance)
         {
            const copy = new MFNode ();

            for (const node of this .getValue ())
               copy .push (node .copy (instance));

            copy .setModificationTime (0);

            return copy;
         }
         else
         {
            return X3DObjectArrayField .prototype .copy .call (this);
         }
      },
      addCloneCount: function (count)
      {
         this [_cloneCount] += count;

         for (const element of this .getValue ())
            element .addCloneCount (count);
      },
      removeCloneCount: function (count)
      {
         this [_cloneCount] -= count;

         for (const element of this .getValue ())
            element .removeCloneCount (count);
      },
      addChildObject: function (value)
      {
         X3DObjectArrayField .prototype .addChildObject .call (this, value);

         value .addCloneCount (this [_cloneCount]);
      },
      removeChildObject: function (value)
      {
         X3DObjectArrayField .prototype .removeChildObject .call (this, value);

         value .removeCloneCount (this [_cloneCount]);
      },
      toStream: function (stream)
      {
         const
            target    = this .getTarget (),
            array     = target .getValue (),
            generator = Generator .Get (stream);

         switch (array .length)
         {
            case 0:
            {
               stream .string += "[ ]";
               break;
            }
            case 1:
            {
               generator .PushUnitCategory (target .getUnit ());

               array [0] .toStream (stream);

               generator .PopUnitCategory ();
               break;
            }
            default:
            {
               generator .PushUnitCategory (target .getUnit ());

               stream .string += "[\n";
               generator .IncIndent ();

               for (let i = 0, length = array .length; i < length; ++ i)
               {
                  stream .string += generator .Indent ();
                  array [i] .toStream (stream);
                  stream .string += "\n";
               }

               generator .DecIndent ();
               stream .string += generator .Indent ();
               stream .string += "]";

               generator .PopUnitCategory ();
               break;
            }
         }
      },
      toVRMLString: function ()
      {
         this .addCloneCount (1);

         const string = X3DObjectArrayField .prototype .toVRMLString .call (this);

         this .removeCloneCount (1);

         return string;
      },
      toVRMLStream: function (stream)
      {
         const
            target    = this .getTarget (),
            array     = target .getValue (),
            generator = Generator .Get (stream);

         switch (array .length)
         {
            case 0:
            {
               stream .string += "[ ]";
               break;
            }
            case 1:
            {
               generator .EnterScope ();

               array [0] .toVRMLStream (stream);

               generator .LeaveScope ();
               break;
            }
            default:
            {
               generator .EnterScope ();

               stream .string += "[\n";
               generator .IncIndent ();

               for (const element of array)
               {
                  stream .string += generator .Indent ();
                  element .toVRMLStream (stream);
                  stream .string += "\n";
               }

               generator .DecIndent ();
               stream .string += generator .Indent ();
               stream .string += "]";

               generator .LeaveScope ();
               break;
            }
         }
      },
      toXMLString: function ()
      {
         this .addCloneCount (1);

         const string = X3DObjectArrayField .prototype .toXMLString .call (this);

         this .removeCloneCount (1);

         return string;
      },
      toXMLStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            length    = this .length;

         if (length)
         {
            generator .EnterScope ();

            const array = this .getValue ();

            for (let i = 0, n = length - 1; i < n; ++ i)
            {
               const node = array [i] .getValue ();

               if (node)
               {
                  node .toXMLStream (stream);
                  stream .string += "\n";
               }
               else
               {
                  stream .string += generator .Indent ();
                  stream .string += "<";
                  stream .string += "NULL";

                  const containerField = generator .ContainerField ();

                  if (containerField)
                  {
                     stream .string += " ";
                     stream .string += "containerField='";
                     stream .string += generator .XMLEncode (containerField .getName ());
                     stream .string += "'";
                  }

                  stream .string += "/>";
               }
            }

            const node = array .at (-1) .getValue ();

            if (node)
            {
               node .toXMLStream (stream);
            }
            else
            {
               stream .string += generator .Indent ();
               stream .string += "<";
               stream .string += "NULL";

               const containerField = generator .ContainerField ();

               if (containerField)
               {
                  stream .string += " ";
                  stream .string += "containerField='";
                  stream .string += generator .XMLEncode (containerField .getName ());
                  stream .string += "'";
               }
            }

            generator .LeaveScope ();
         }
      },
      dispose: function ()
      {
         this .resize (0);

         X3DObjectArrayField .prototype .dispose .call (this);
      },
   });

   for (const key of Reflect .ownKeys (MFNode .prototype))
      Object .defineProperty (MFNode .prototype, key, { enumerable: false });

   function MFString (value)
   {
      return X3DObjectArrayField .call (this, arguments);
   }

   MFString .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
   {
      constructor: MFString,
      getValueType: function ()
      {
         return String;
      },
      getSingleType: function ()
      {
         return SFString;
      },
      getArrayType: function ()
      {
         return Array;
      },
      getComponents: function ()
      {
         return 1;
      },
      getTypeName: function ()
      {
         return "MFString";
      },
      getType: function ()
      {
         return X3DConstants .MFString;
      },
      toXMLStream: function (stream)
      {
         const length = this .length;

         if (length)
         {
            const value = this .getValue ();

            for (let i = 0, n = length - 1; i < n; ++ i)
            {
               stream .string += "\"";
               value [i] .toXMLStream (stream);
               stream .string += "\"";
               stream .string += ", ";
            }

            stream .string += "\"";
            value .at (-1) .toXMLStream (stream);
            stream .string += "\"";
         }
      },
   });

   for (const key of Reflect .ownKeys (MFString .prototype))
      Object .defineProperty (MFString .prototype, key, { enumerable: false });

   function ArrayTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
   {
      function ArrayField (value)
      {
         return X3DObjectArrayField .call (this, arguments);
      }

      ArrayField .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
      {
         constructor: ArrayField,
         getSingleType: function ()
         {
            return SingleType;
         },
         getValueType: function ()
         {
            return ValueType;
         },
         getArrayType: function ()
         {
            return ArrayType;
         },
         getComponents: function ()
         {
            return Components;
         },
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
      });

      for (const key of Reflect .ownKeys (ArrayField .prototype))
         Object .defineProperty (ArrayField .prototype, key, { enumerable: false });

      return ArrayField;
   }

   function TypedArrayTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
   {
      function ArrayField (value)
      {
         return X3DTypedArrayField .call (this, arguments);
      }

      ArrayField .prototype = Object .assign (Object .create (X3DTypedArrayField .prototype),
      {
         constructor: ArrayField,
         getSingleType: function ()
         {
            return SingleType;
         },
         getValueType: function ()
         {
            return ValueType;
         },
         getArrayType: function ()
         {
            return ArrayType;
         },
         getComponents: function ()
         {
            return Components;
         },
         getTypeName: function ()
         {
            return TypeName;
         },
         getType: function ()
         {
            return Type;
         },
      });

      for (const key of Reflect .ownKeys (ArrayField .prototype))
         Object .defineProperty (ArrayField .prototype, key, { enumerable: false });

      return ArrayField;
   }

   function Value (value) { return value; }

   const ArrayFields =
   {
      MFBool:      TypedArrayTemplate ("MFBool",      X3DConstants .MFBool,      SFBool,      Boolean,     Uint8Array,   1),
      MFColor:     TypedArrayTemplate ("MFColor",     X3DConstants .MFColor,     SFColor,     SFColor,     Float32Array, 3),
      MFColorRGBA: TypedArrayTemplate ("MFColorRGBA", X3DConstants .MFColorRGBA, SFColorRGBA, SFColorRGBA, Float32Array, 4),
      MFDouble:    TypedArrayTemplate ("MFDouble",    X3DConstants .MFDouble,    SFDouble,    Value,       Float64Array, 1),
      MFFloat:     TypedArrayTemplate ("MFFloat",     X3DConstants .MFFloat,     SFFloat,     Value,       Float32Array, 1),
      MFImage:     ArrayTemplate      ("MFImage",     X3DConstants .MFImage,     SFImage,     SFImage,     Array,        1),
      MFInt32:     TypedArrayTemplate ("MFInt32",     X3DConstants .MFInt32,     SFInt32,     Value,       Int32Array,   1),
      MFMatrix3d:  TypedArrayTemplate ("MFMatrix3d",  X3DConstants .MFMatrix3d,  SFMatrix3d,  SFMatrix3d,  Float64Array, 9),
      MFMatrix3f:  TypedArrayTemplate ("MFMatrix3f",  X3DConstants .MFMatrix3f,  SFMatrix3f,  SFMatrix3f,  Float32Array, 9),
      MFMatrix4d:  TypedArrayTemplate ("MFMatrix4d",  X3DConstants .MFMatrix4d,  SFMatrix4d,  SFMatrix4d,  Float64Array, 16),
      MFMatrix4f:  TypedArrayTemplate ("MFMatrix4f",  X3DConstants .MFMatrix4f,  SFMatrix4f,  SFMatrix4f,  Float32Array, 16),
      MFNode:      MFNode,
      MFRotation:  TypedArrayTemplate ("MFRotation",  X3DConstants .MFRotation,  SFRotation,  SFRotation,  Float64Array, 4),
      MFString:    MFString,
      MFTime:      TypedArrayTemplate ("MFTime",      X3DConstants .MFTime,      SFTime,      Value,       Float64Array, 1),
      MFVec2d:     TypedArrayTemplate ("MFVec2d",     X3DConstants .MFVec2d,     SFVec2d,     SFVec2d,     Float64Array, 2),
      MFVec2f:     TypedArrayTemplate ("MFVec2f",     X3DConstants .MFVec2f,     SFVec2f,     SFVec2f,     Float32Array, 2),
      MFVec3d:     TypedArrayTemplate ("MFVec3d",     X3DConstants .MFVec3d,     SFVec3d,     SFVec3d,     Float64Array, 3),
      MFVec3f:     TypedArrayTemplate ("MFVec3f",     X3DConstants .MFVec3f,     SFVec3f,     SFVec3f,     Float32Array, 3),
      MFVec4d:     TypedArrayTemplate ("MFVec4d",     X3DConstants .MFVec4d,     SFVec4d,     SFVec4d,     Float64Array, 4),
      MFVec4f:     TypedArrayTemplate ("MFVec4f",     X3DConstants .MFVec4f,     SFVec4f,     SFVec4f,     Float32Array, 4),
   };

   return ArrayFields;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields',[
   "x_ite/Fields/SFBool",
   "x_ite/Fields/SFColor",
   "x_ite/Fields/SFColorRGBA",
   "x_ite/Fields/SFDouble",
   "x_ite/Fields/SFFloat",
   "x_ite/Fields/SFImage",
   "x_ite/Fields/SFInt32",
   "x_ite/Fields/SFMatrix3",
   "x_ite/Fields/SFMatrix4",
   "x_ite/Fields/SFNode",
   "x_ite/Fields/SFRotation",
   "x_ite/Fields/SFString",
   "x_ite/Fields/SFTime",
   "x_ite/Fields/SFVec2",
   "x_ite/Fields/SFVec3",
   "x_ite/Fields/SFVec4",
   "x_ite/Fields/ArrayFields",
],
function (SFBool,
          SFColor,
          SFColorRGBA,
          SFDouble,
          SFFloat,
          SFImage,
          SFInt32,
          SFMatrix3,
          SFMatrix4,
          SFNode,
          SFRotation,
          SFString,
          SFTime,
          SFVec2,
          SFVec3,
          SFVec4,
          ArrayFields)
{
"use strict";

   const Fields = Object .assign (
   {
      SFBool:      SFBool,
      SFColor:     SFColor,
      SFColorRGBA: SFColorRGBA,
      SFDouble:    SFDouble,
      SFFloat:     SFFloat,
      SFImage:     SFImage,
      SFInt32:     SFInt32,
      SFMatrix3d:  SFMatrix3 .SFMatrix3d,
      SFMatrix3f:  SFMatrix3 .SFMatrix3f,
      SFMatrix4d:  SFMatrix4 .SFMatrix4d,
      SFMatrix4f:  SFMatrix4 .SFMatrix4f,
      SFNode:      SFNode,
      SFRotation:  SFRotation,
      SFString:    SFString,
      SFTime:      SFTime,
      SFVec2d:     SFVec2 .SFVec2d,
      SFVec2f:     SFVec2 .SFVec2f,
      SFVec3d:     SFVec3 .SFVec3d,
      SFVec3f:     SFVec3 .SFVec3f,
      SFVec4d:     SFVec4 .SFVec4d,
      SFVec4f:     SFVec4 .SFVec4f,
      VrmlMatrix:  SFMatrix4 .VrmlMatrix,
   },
   ArrayFields);

   return Fields;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DBaseNode',[
   "x_ite/Base/X3DEventObject",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/FieldArray",
   "x_ite/Fields",
   "x_ite/Base/X3DConstants",
],
function (X3DEventObject,
          X3DFieldDefinition,
          FieldDefinitionArray,
          FieldArray,
          Fields,
          X3DConstants)
{
"use strict";

   const
      _executionContext  = Symbol (),
      _type              = Symbol (),
      _fieldDefinitions  = Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions"),
      _fields            = Symbol (),
      _predefinedFields  = Symbol (),
      _aliases           = Symbol (),
      _userDefinedFields = Symbol (),
      _initialized       = Symbol (),
      _live              = Symbol (),
      _set_live__        = Symbol ("X3DBaseNode.set_live__"),
      _private           = Symbol (),
      _cloneCount        = Symbol ();

   function X3DBaseNode (executionContext)
   {
      if (this [_executionContext])
         return;

      X3DEventObject .call (this, executionContext .getBrowser ());

      this [_executionContext]  = executionContext;
      this [_type]              = [ X3DConstants .X3DBaseNode ];
      this [_fields]            = new FieldArray ();
      this [_predefinedFields]  = new FieldArray ();
      this [_aliases]           = new Map ();
      this [_userDefinedFields] = new FieldArray ();
      this [_live]              = true;
      this [_initialized]       = false;
      this [_private]           = false;
      this [_cloneCount]        = 0;

      // Setup fields.

      if (this .canUserDefinedFields ())
         this [_fieldDefinitions] = new FieldDefinitionArray (this [_fieldDefinitions]);

      for (const fieldDefinition of this [_fieldDefinitions])
         this .addField (fieldDefinition);

      this .addChildObjects ("name_changed",       new Fields .SFTime (),
                             "typeName_changed",   new Fields .SFTime (),
                             "fields_changed",     new Fields .SFTime (),
                             "cloneCount_changed", new Fields .SFTime ())
   }

   X3DBaseNode .prototype = Object .assign (Object .create (X3DEventObject .prototype),
   {
      constructor: X3DBaseNode,
      [_fieldDefinitions]: new FieldDefinitionArray ([ ]),
      setName: function (value)
      {
         X3DEventObject .prototype .setName .call (this, value)

         if (this [_initialized])
            this ._name_changed = this .getBrowser () .getCurrentTime ();
      },
      getMainScene: function ()
      {
         let scene = this [_executionContext] .getScene ();

         while (! scene .isMainScene ())
            scene = scene .getScene ();

         return scene;
      },
      getScene: function ()
      {
         let executionContext = this [_executionContext];

         while (! executionContext .isScene ())
            executionContext = executionContext .getExecutionContext ();

         return executionContext;
      },
      getExecutionContext: function ()
      {
         return this [_executionContext];
      },
      setExecutionContext: function (value)
      {
         // Currently only useful for Scene.
         this [_executionContext] = value;
      },
      addType: function (value)
      {
         this [_type] .push (value);
      },
      getType: function ()
      {
         return this [_type];
      },
      getInnerNode: function ()
      {
         return this;
      },
      isLive: (function ()
      {
         function isLive ()
         {
            return this ._isLive;
         }

         return function ()
         {
            ///  Returns the live event of this node.

            // Change function.

            Object .defineProperty (this, "isLive",
            {
               value: isLive,
               enumerable: false,
               configurable: true,
            });

            // Add isLive event.

            this .addChildObjects ("isLive", new Fields .SFBool (this .getLiveState ()));

            // Event processing is done manually and immediately, so:
            this ._isLive .removeParent (this);

            // Connect to execution context.

            if (this .getOuterNode && this .getOuterNode ())
               this .getOuterNode () .isLive () .addInterest (_set_live__, this);

            else if (this [_executionContext] !== this)
               this [_executionContext] .isLive () .addInterest (_set_live__, this);

            // Return field

            return this .isLive ();
         };
      })(),
      setLive: function (value)
      {
         ///  Sets the own live state of this node.  Setting the live state to false
         ///  temporarily disables this node completely.

         this [_live] = value .valueOf ();

         this [_set_live__] ();
      },
      getLive: function ()
      {
         ///  Returns the own live state of this node.

         return this [_live];
      },
      getLiveState: function ()
      {
         ///  Determines the live state of this node.

         if (this .getOuterNode && this .getOuterNode ())
            return this .getLive () && this .getOuterNode () .isLive () .getValue ();

         else if (this !== this [_executionContext])
            return this .getLive () && this [_executionContext] .isLive () .getValue ();

         return this .getLive ();
      },
      [_set_live__]: function ()
      {
         const
            live   = this .getLiveState (),
            isLive = this .isLive ();

         if (live)
         {
            if (isLive .getValue ())
               return;

            isLive .set (true);
            isLive .processEvent ();
         }
         else
         {
            if (isLive .getValue ())
            {
               isLive .set (false);
               isLive .processEvent ();
            }
         }
      },
      create: function (executionContext)
      {
         return new (this .constructor) (executionContext || this [_executionContext]);
      },
      copy: function (executionContext)
      {
         const copy = this .create (executionContext);

         if (this .canUserDefinedFields ())
         {
            for (const fieldDefinition of this [_fieldDefinitions])
            {
               if (copy .getFields () .has (fieldDefinition .name))
                  continue;

               copy .addUserDefinedField (fieldDefinition .accessType, fieldDefinition .name, fieldDefinition .value .copy ());
            }
         }

         for (const field of this [_fields])
            copy .getFields () .get (field .getName ()) .assign (field);

         copy .setup ();

         return copy;
      },
      setup: function ()
      {
         if (this [_initialized])
            return;

         this [_initialized] = true;

         for (const field of this [_fields])
            field .setTainted (false);

         this .initialize ();
      },
      isInitialized: function ()
      {
         return this [_initialized];
      },
      initialize: function () { },
      addChildObjects: function (name, field)
      {
         for (let i = 0, length = arguments .length; i < length; i += 2)
            this .addChildObject (arguments [i], arguments [i + 1]);
      },
      addChildObject: function (name, field)
      {
         field .addParent (this);
         field .setName (name);

         Object .defineProperty (this, "_" + name,
         {
            get: function () { return field; },
            set: function (value) { field .setValue (value); },
            enumerable: false,
            configurable: false,
         });
      },
      getFieldDefinitions: function ()
      {
         return this [_fieldDefinitions];
      },
      getFieldsAreEnumerable: function ()
      {
         return false;
      },
      addField: function (fieldDefinition)
      {
         const
            accessType = fieldDefinition .accessType,
            name       = fieldDefinition .name,
            field      = fieldDefinition .value .copy ();

         field .setTainted (!this [_initialized]);
         field .addParent (this);
         field .setName (name);
         field .setAccessType (accessType);

         this [_fields]           .add (name, field);
         this [_predefinedFields] .add (name, field);

         Object .defineProperty (this, "_" + name,
         {
            get: function () { return field; },
            set: function (value) { field .setValue (value); },
            enumerable: this .getFieldsAreEnumerable (),
            configurable: true, // false : non deletable
         });

         if (!this .getPrivate ())
            field .addCloneCount (1);

         if (this [_initialized])
            this ._fields_changed = this .getBrowser () .getCurrentTime ();
      },
      getField: (function ()
      {
         const
            set_field     = /^set_(.*?)$/,
            field_changed = /^(.*?)_changed$/;

         return function (name)
         {
            const field = this [_fields] .get (name) || this [_aliases] .get (name);

            if (field)
               return field;

            const match = name .match (set_field);

            if (match)
            {
               const field = this [_fields] .get (match [1]) || this [_aliases] .get (match [1]);

               if (field && field .getAccessType () === X3DConstants .inputOutput)
                  return field;
            }
            else
            {
               const match = name .match (field_changed);

               if (match)
               {
                  const field = this [_fields] .get (match [1]) || this [_aliases] .get (match [1]);

                  if (field && field .getAccessType () === X3DConstants .inputOutput)
                     return field;
               }
            }

            throw new Error ("Unknown field '" + name + "' in node class " + this .getTypeName () + ".");
         };
      })(),
      addAlias: function (alias, field)
      {
         this [_aliases] .set (alias, field);

         Object .defineProperty (this, "_" + alias,
         {
            get: function () { return field; },
            set: function (value) { field .setValue (value); },
            enumerable: true,
            configurable: false,
         });
      },
      removeField: function (name)
      {
         const field = this [_predefinedFields] .get (name);

         if (field)
         {
            field .removeParent (this);

            this [_fields]           .remove (name);
            this [_predefinedFields] .remove (name);

            delete this ["_" + field .getName ()];

            if (!this .getPrivate ())
               field .removeCloneCount (1);

            if (this [_initialized])
               this ._fields_changed = this .getBrowser () .getCurrentTime ();
         }
      },
      canUserDefinedFields: function ()
      {
         return false;
      },
      addUserDefinedField: function (accessType, name, field)
      {
         if (this [_userDefinedFields] .has (name))
            this .removeUserDefinedField (name);

         field .setTainted (!this [_initialized]);
         field .addParent (this);
         field .setName (name);
         field .setAccessType (accessType);

         this [_fieldDefinitions]  .add (name, new X3DFieldDefinition (accessType, name, field));
         this [_fields]            .add (name, field);
         this [_userDefinedFields] .add (name, field);

         if (!this .getPrivate ())
            field .addCloneCount (1);

         if (this [_initialized])
            this ._fields_changed = this .getBrowser () .getCurrentTime ();
      },
      removeUserDefinedField: function (name)
      {
         const field = this [_userDefinedFields] .get (name);

         if (field)
         {
            field .removeParent (this);

            this [_fields]            .remove (name);
            this [_userDefinedFields] .remove (name);
            this [_fieldDefinitions]  .remove (name);

            if (!this .getPrivate ())
               field .removeCloneCount (1);

            if (this [_initialized])
               this ._fields_changed = this .getBrowser () .getCurrentTime ();
         }
      },
      getUserDefinedFields: function ()
      {
         return this [_userDefinedFields];
      },
      getPredefinedFields: function ()
      {
         return this [_predefinedFields];
      },
      getChangedFields: function (extended)
      {
         /* param routes: also return fields with routes */

         const changedFields = [ ];

         if (extended)
         {
            for (const field of this [_userDefinedFields])
               changedFields .push (field);
         }

         for (const field of this [_predefinedFields])
         {
            if (extended)
            {
               if (field .getInputRoutes () .size || field .getOutputRoutes () .size)
               {
                  changedFields .push (field);
                  continue;
               }
            }

            if (field .getReferences () .size === 0)
            {
               if (!field .isInitializable ())
                  continue;

               if (this .isDefaultValue (field))
                  continue;
            }

            changedFields .push (field);
         }

         return changedFields;
      },
      isDefaultValue: function (field)
      {
         const fieldDefinition = this .getFieldDefinitions () .get (field .getName ());

         if (fieldDefinition)
            return fieldDefinition .value .equals (field);

         return !field .getModificationTime ();
      },
      getFields: function ()
      {
         return this [_fields];
      },
      getSourceText: function ()
      {
         return null;
      },
      hasRoutes: function ()
      {
         ///  Returns true if there are any routes from or to fields of this node otherwise false.

         for (const field of this [_fields])
         {
            if (field .getInputRoutes () .size)
               return true;

            if (field .getOutputRoutes () .size)
               return true;
         }

         return false;
      },
      getPrivate: function ()
      {
         return this [_private];
      },
      setPrivate: function (value)
      {
         this [_private] = value;

         if (value)
         {
            for (const field of this [_fields])
               field .removeCloneCount (1);
         }
         else
         {
            for (const field of this [_fields])
               field .addCloneCount (1);
         }
      },
      getCloneCount: function ()
      {
         return this [_cloneCount];
      },
      addCloneCount: function (count)
      {
         if (count === 0)
            return;

         const time = this .getBrowser () .getCurrentTime ();

         this [_cloneCount] += count;

         this [_executionContext] ._sceneGraph_changed = time;

         if (this [_initialized])
            this ._cloneCount_changed = time;
      },
      removeCloneCount: function (count)
      {
         if (count === 0)
            return;

         const time = this .getBrowser () .getCurrentTime ();

         this [_cloneCount] -= count;

         this [_executionContext] ._sceneGraph_changed = time;

         if (this [_initialized])
            this ._cloneCount_changed = time;
      },
      dispose: function ()
      {
         for (const field of this .getFields ())
            field .dispose ();

         X3DEventObject .prototype .dispose .call (this);
      },
   });

   for (const key of Reflect .ownKeys (X3DBaseNode .prototype))
      Object .defineProperty (X3DBaseNode .prototype, key, { enumerable: false });

   return X3DBaseNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/VERSION',[],function ()
{
   return "6.0.0";
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/DEBUG',[],function ()
{
"use strict";

   // Modified during dist build.

   return false;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/Context',[
   "x_ite/DEBUG",
],
function (DEBUG)
{
"use strict";

   const extensions = [
      "ANGLE_instanced_arrays",
      "EXT_blend_minmax",
      "EXT_frag_depth",
      "EXT_shader_texture_lod",
      "EXT_texture_filter_anisotropic",
      "OES_element_index_uint",
      "OES_standard_derivatives",
      "OES_texture_float",
      "OES_texture_float_linear",
      "OES_texture_half_float",
      "OES_texture_half_float_linear",
      "OES_vertex_array_object",
      "WEBGL_compressed_texture_s3tc",
      //"WEBGL_debug_renderer_info",
      "WEBGL_debug_shaders",
      "WEBGL_depth_texture",
      "WEBGL_draw_buffers",
      "WEBGL_lose_context",

      "EXT_color_buffer_float",
      "EXT_color_buffer_half_float",
      "EXT_disjoint_timer_query",
      "EXT_disjoint_timer_query_webgl2",
      "EXT_sRGB",
      "WEBGL_color_buffer_float",
      "WEBGL_compressed_texture_astc",
      "WEBGL_compressed_texture_atc",
      "WEBGL_compressed_texture_etc",
      "WEBGL_compressed_texture_etc1",
      "WEBGL_compressed_texture_pvrtc",
      "WEBGL_compressed_texture_s3tc",
      "WEBGL_compressed_texture_s3tc_srgb",

      "EXT_float_blend",
      "OES_fbo_render_mipmap",
      "WEBGL_get_buffer_sub_data_async",
      "WEBGL_multiview",
      "WEBGL_security_sensitive_resources",
      "WEBGL_shared_resources",

      "EXT_clip_cull_distance",
      "WEBGL_debug",
      "WEBGL_dynamic_texture",
      "WEBGL_subarray_uploads",
      "WEBGL_texture_multisample",
      "WEBGL_texture_source_iframe",
      "WEBGL_video_texture",

      "EXT_texture_storage",
      "OES_depth24",
      "WEBGL_debug_shader_precision",
      "WEBGL_draw_elements_no_range_check",
      "WEBGL_subscribe_uniform",
      "WEBGL_texture_from_depth_video",
   ];

   const Context =
   {
      create: function (canvas, version, preserveDrawingBuffer)
      {
         const options = { preserveDrawingBuffer: preserveDrawingBuffer };

         let gl = null;

         if (version >= 2 && ! gl)
         {
            gl = canvas .getContext ("webgl2", options);

            if (gl)
               gl .getVersion = function () { return 2; };
         }

         if (version >= 1 && ! gl)
         {
            gl = canvas .getContext ("webgl",              options) ||
                 canvas .getContext ("experimental-webgl", options);

            if (gl)
            {
               gl .getVersion = function () { return 1; };

               {
                  const ext = gl .getExtension ("OES_vertex_array_object");

                  gl .bindVertexArray   =  ext .bindVertexArrayOES   .bind (ext);
                  gl .createVertexArray =  ext .createVertexArrayOES .bind (ext);
                  gl .deleteVertexArray =  ext .deleteVertexArrayOES .bind (ext);
                  gl .isVertexArray     =  ext .isVertexArrayOES     .bind (ext);
               }
            }
          }

         if (! gl)
            throw new Error ("Couldn't create WebGL context.");

         // Feature detection:

         // If the aliased lineWidth ranges are both 1, gl .lineWidth is probably not possible,
         // thus we disable it completely to prevent webgl errors.

         const aliasedLineWidthRange = gl .getParameter (gl .ALIASED_LINE_WIDTH_RANGE);

         if (aliasedLineWidthRange [0] === 1 && aliasedLineWidthRange [1] === 1)
         {
            gl .lineWidth            = Function .prototype;
            gl .MUST_TRANSFORM_LINES = gl .getVersion () >= 2;

            if (DEBUG)
               console .info ("Lines are transformed if necessary to obtain thick lines.");
         }
         else
         {
            gl .MUST_TRANSFORM_LINES = false;
         }

         // Load extensions.

         for (const extension of extensions)
            gl .getExtension (extension);

         // Return context.

         return gl;
      },
   }

   return Context;
});

/**
 * @license text 2.0.16 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.16',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('text', ['text/text'], function (main) { return main; });


define('text!locale/de.po',[],function () { return 'msgid ""\nmsgstr ""\n"Project-Id-Version: X_ITE\\n"\n"POT-Creation-Date: 2015-12-23 04:56+0100\\n"\n"PO-Revision-Date: 2015-12-23 04:57+0100\\n"\n"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\\n"\n"Language-Team: \\n"\n"Language: de\\n"\n"MIME-Version: 1.0\\n"\n"Content-Type: text/plain; charset=UTF-8\\n"\n"Content-Transfer-Encoding: 8bit\\n"\n"X-Generator: Poedit 1.8.4\\n"\n"X-Poedit-Basepath: ../x_ite\\n"\n"Plural-Forms: nplurals=2; plural=(n != 1);\\n"\n"X-Poedit-SourceCharset: UTF-8\\n"\n"X-Poedit-SearchPath-0: .\\n"\n\nmsgid "Less Properties"\nmsgstr "Weniger Eigenschaften"\n\nmsgid "More Properties"\nmsgstr "Mehr Eigenschaften"\n\nmsgid "Frame rate"\nmsgstr "Bildrate"\n\nmsgid "fps"\nmsgstr "BpS"\n\nmsgid "Speed"\nmsgstr "Geschwindigkeit"\n\nmsgid "m/s"\nmsgstr ""\n\nmsgid "km/h"\nmsgstr ""\n\nmsgid "Browser"\nmsgstr ""\n\nmsgid "ms"\nmsgstr ""\n\nmsgid "X3D total"\nmsgstr "X3D gesamt"\n\nmsgid "Event Processing"\nmsgstr "Ereignisverarbeitung"\n\nmsgid "Pointer"\nmsgstr "Zeigegerät"\n\nmsgid "Camera"\nmsgstr "Kamera"\n\nmsgid "Collision Detection"\nmsgstr "Kollisionserkennung"\n\nmsgid "Rendering"\nmsgstr "Rendering"\n\nmsgid "Number of Shapes"\nmsgstr "Anzahl der Formen"\n\nmsgid "Number of Sensors"\nmsgstr "Anzahl der Sensoren"\n\nmsgid "Browser Timings"\nmsgstr "Zeitberechnung"\n\nmsgid "X_ITE Browser"\nmsgstr ""\n\nmsgid "Viewpoints"\nmsgstr "Ansichtspunkte"\n\nmsgid "Available Viewers"\nmsgstr "Verfügbare Betrachter"\n\nmsgid "Straighten Horizon"\nmsgstr "Horizont gerade richten"\n\nmsgid "Primitive Quality"\nmsgstr "Qualität der Grundobjekte"\n\nmsgid "High"\nmsgstr "Hoch"\n\nmsgid "high"\nmsgstr "hoch"\n\nmsgid "Medium"\nmsgstr "Mittel"\n\nmsgid "medium"\nmsgstr "mittel"\n\nmsgid "Low"\nmsgstr "Niedrig"\n\nmsgid "low"\nmsgstr "niedrig"\n\nmsgid "Texture Quality"\nmsgstr "Textur Qualität"\n\nmsgid "Display Rubberband"\nmsgstr "Gummiband anzeigen"\n\nmsgid "Rubberband"\nmsgstr "Gummiband"\n\nmsgid "on"\nmsgstr "an"\n\nmsgid "off"\nmsgstr "aus"\n\nmsgid "Mute Browser"\nmsgstr "Browser stumm schalten"\n\nmsgid "Browser muted"\nmsgstr "Browser stumm geschalten"\n\nmsgid "Browser unmuted"\nmsgstr "Browser Ton an"\n\nmsgid "Leave Fullscreen"\nmsgstr "Vollbild verlassen"\n\nmsgid "Fullscreen"\nmsgstr "Vollbild"\n\nmsgid "About X_ITE"\nmsgstr "Über X_ITE"\n\nmsgid "Examine Viewer"\nmsgstr "Untersuchen"\n\nmsgid "Walk Viewer"\nmsgstr "Laufen"\n\nmsgid "Fly Viewer"\nmsgstr "Fliegen"\n\nmsgid "Plane Viewer"\nmsgstr "Ebenen Betrachter"\n\nmsgid "Look At Viewer"\nmsgstr "Auf Objekte zielen"\n\nmsgid "None Viewer"\nmsgstr "Kein Betrachter"\n\nmsgid "Loading %1 file"\nmsgstr "Lade %1 Datei"\n\nmsgid "Loading %1 files"\nmsgstr "Lade %1 Dateien"\n\nmsgid "Loading done"\nmsgstr "Fertig mit Laden"\n\nmsgid "Failed loading world."\nmsgstr "Laden der Dateien fehlgeschlagen."\n\nmsgid "Show World Info"\nmsgstr "World Info anzeigen"\n\nmsgid "Viewpoint is copied to clipboard."\nmsgstr "Ansichtspunkt wurde in die Zwischenablage kopiert."\n';});


define('text!locale/fr.po',[],function () { return 'msgid ""\nmsgstr ""\n"Project-Id-Version: X_ITE\\n"\n"POT-Creation-Date: 2015-12-23 04:58+0100\\n"\n"PO-Revision-Date: 2015-12-23 05:07+0100\\n"\n"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\\n"\n"Language-Team: \\n"\n"Language: fr\\n"\n"MIME-Version: 1.0\\n"\n"Content-Type: text/plain; charset=UTF-8\\n"\n"Content-Transfer-Encoding: 8bit\\n"\n"X-Generator: Poedit 1.8.4\\n"\n"X-Poedit-Basepath: ../x_ite\\n"\n"Plural-Forms: nplurals=2; plural=(n != 1);\\n"\n"X-Poedit-SourceCharset: UTF-8\\n"\n"X-Poedit-SearchPath-0: .\\n"\n\nmsgid "Less Properties"\nmsgstr "Moins de propriétés"\n\nmsgid "More Properties"\nmsgstr "Plus de propriétés"\n\nmsgid "Frame rate"\nmsgstr "Fréquence"\n\nmsgid "fps"\nmsgstr "fps"\n\nmsgid "Speed"\nmsgstr "Vélocité"\n\nmsgid "m/s"\nmsgstr ""\n\nmsgid "km/h"\nmsgstr ""\n\nmsgid "Browser"\nmsgstr "X_ITE Navigateur"\n\nmsgid "ms"\nmsgstr ""\n\nmsgid "X3D total"\nmsgstr "X3D total"\n\nmsgid "Traitement des événements"\nmsgstr "Routes"\n\nmsgid "Pointer"\nmsgstr "Pointeur"\n\nmsgid "Camera"\nmsgstr "Caméra"\n\nmsgid "Collision Detection"\nmsgstr "Détection des collisions"\n\nmsgid "Rendering"\nmsgstr "Rendement"\n\nmsgid "Number of Shapes"\nmsgstr "Nombre de formes"\n\nmsgid "Number of Sensors"\nmsgstr "Nombre de senseurs"\n\nmsgid "Browser Timings"\nmsgstr "Calcul du temps"\n\nmsgid "X_ITE Browser"\nmsgstr "X_ITE Navigateur"\n\nmsgid "Viewpoints"\nmsgstr "Points de vue"\n\nmsgid "Available Viewers"\nmsgstr "Visionneurs disponibles"\n\nmsgid "Straighten Horizon"\nmsgstr "Redresser l\'horizon"\n\nmsgid "Primitive Quality"\nmsgstr "Qualité des objets simples"\n\nmsgid "High"\nmsgstr "Haut"\n\nmsgid "high"\nmsgstr "haut"\n\nmsgid "Medium"\nmsgstr "Moyenne"\n\nmsgid "medium"\nmsgstr "moyenne"\n\nmsgid "Low"\nmsgstr "Faible"\n\nmsgid "low"\nmsgstr "faible"\n\nmsgid "Texture Quality"\nmsgstr "Qualité des textures"\n\nmsgid "Display Rubberband"\nmsgstr "Présenter le bande élastique"\n\nmsgid "Rubberband"\nmsgstr "Bande élastique"\n\nmsgid "on"\nmsgstr "marche"\n\nmsgid "off"\nmsgstr "arrêt"\n\nmsgid "Mute Browser"\nmsgstr "Rendre navigateur muet"\n\nmsgid "Browser muted"\nmsgstr "Navigateur muet"\n\nmsgid "Browser unmuted"\nmsgstr "Son de navigateur réactivé"\n\nmsgid "Leave Fullscreen"\nmsgstr "Sortie en plein écran"\n\nmsgid "Fullscreen"\nmsgstr "Plein écran"\n\nmsgid "About X_ITE"\nmsgstr "À propos de X_ITE"\n\nmsgid "Examine Viewer"\nmsgstr "Examiner"\n\nmsgid "Walk Viewer"\nmsgstr "Aller"\n\nmsgid "Fly Viewer"\nmsgstr "Voler"\n\nmsgid "Plane Viewer"\nmsgstr "Visionneur de la plaine"\n\nmsgid "Look At Viewer"\nmsgstr "Regarder un objet de près"\n\nmsgid "None Viewer"\nmsgstr "Pas de visionneur"\n\nmsgid "Loading %1 file"\nmsgstr "Télécharger %1 fichier"\n\nmsgid "Loading %1 files"\nmsgstr "Télécharger %1 fichiers"\n\nmsgid "Loading done"\nmsgstr "Téléchargement fini"\n\nmsgid "Failed loading world."\nmsgstr "Le chargement des fichiers a échoué."\n\nmsgid "Show World Info"\nmsgstr "Afficher World Info"\n\nmsgid "Viewpoint is copied to clipboard."\nmsgstr "Le point de vue est copié dans le presse-papiers."\n';});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('locale/gettext',[
   "text!locale/de.po",
   "text!locale/fr.po",
],
function (de, fr)
{
"use strict";

   function execAll (regex, string)
   {
      var
         match   = null,
         matches = [ ];

      while (match = regex .exec (string))
         matches .push (match);

      return matches;
   }

   function getLanguage ()
   {
      for (var i = 0; i < navigator .languages; ++ i)
      {
         var language = navigator .languages [i] .split ("-") [0];

         if (locales [language])
            return language;
      }

      return (navigator .language || navigator .userLanguage) .split ("-") [0];
   }

   function setLocale (language)
   {
      if (locales [language])
      {
         var
            matches = execAll (msg, locales [language]),
            locale  = locales [language] = { };

         for (var i = 0, length = matches .length; i < length; ++ i)
         {
            if (matches [i] [2] .length)
               locale [matches [i] [1]] = matches [i] [2];
         }
      }
   }

   var locales =
   {
      en: "C",
      de: de,
      fr: fr,
   };

   var
      msg      = /msgid\s+"(.*?)"\nmsgstr\s+"(.*?)"\n/g,
      language = getLanguage ();

   setLocale (language);

   function gettext (string)
   {
      var locale = locales [language];

      if (locale === undefined)
         return string;

      var translation = locale [string];

      if (translation === undefined)
         return string;

      return translation;
   }

   return gettext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

define ('x_ite/Browser/Core/BrowserTimings',[
   "jquery",
   "x_ite/Base/X3DBaseNode",
   "locale/gettext",
],
function ($,
          X3DBaseNode,
          _)
{
"use strict";

   function f2 (n) { return n .toFixed (2); }

   function BrowserTimings (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .localStorage = this .getBrowser () .getLocalStorage () .addNameSpace ("BrowserTimings.");
      this .enabled      = false;
   }

   BrowserTimings .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BrowserTimings,
      getTypeName: function ()
      {
         return "BrowserTimings";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "browserTimings";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         this .localStorage .addDefaultValues ({ type: "LESS" });

         this .localeOptions = { minimumFractionDigits: 2, maximumFractionDigits: 2 };
         this .startTime     = 0;
         this .frames        = 0;

         this .element = $("<div></div>") .hide () .addClass ("x_ite-private-browser-timings") .appendTo (this .getBrowser () .getSurface ());
         this .table   = $("<table></table>") .appendTo (this .element);
         this .header  = $("<thead></thead>") .append ($("<tr></tr>") .append ($("<th colspan='2'></th>"))) .appendTo (this .table);
         this .body    = $("<tbody></tbody>") .appendTo (this .table);
         this .footer  = $("<tfoot></tfoot>") .append ($("<tr></tr>") .append ($("<td colspan='2'></td>"))) .appendTo (this .table);
         this .button  = $("<button></button>") .attr ("type", "button") .appendTo (this .footer .find ("td"));
         this .rows    = [ ];

         this .button .on ("click touchend", this .set_type__ .bind (this));

         this .set_button__ ();
      },
      getEnabled: function ()
      {
         return this .enabled;
      },
      setEnabled: function (enabled)
      {
         if (this .enabled === enabled)
            return;

         this .enabled = enabled;

         if (enabled)
         {
            this .element .fadeIn ();
            this .getBrowser () .prepareEvents () .addInterest ("update", this);
            this .update ();
         }
         else
         {
            this .element .fadeOut ();
            this .getBrowser () .prepareEvents () .removeInterest ("update", this);
         }
      },
      set_type__: function ()
      {
         if (this .localStorage .type === "MORE")
            this .localStorage .type = "LESS";
         else
            this .localStorage .type = "MORE";

         this .set_button__ ();
         this .build ();
      },
      set_button__: function ()
      {
         if (this .localStorage .type === "MORE")
            this .button .text (_("Less Properties"));
         else
            this .button .text (_("More Properties"));
      },
      update: function ()
      {
         const currentTime = this .getBrowser () .getCurrentTime ();

         if (currentTime - this .startTime > 1)
         {
            this .build ();

            this .frames    = 0;
            this .startTime = currentTime;
         }
         else
            ++ this .frames;
      },
      build: function ()
      {
         const
            browser     = this .getBrowser (),
            currentTime = browser .getCurrentTime (),
            language    = navigator .language || navigator .userLanguage,
            fixed       = this .localeOptions,
            rows        = this .rows;

         let r = 0;

         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Frame rate") + ":")) .append ($("<td></td>") .text (f2(this .frames / (currentTime - this .startTime)) .toLocaleString (language, fixed) + " " + _("fps")));
         rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Speed")      + ":")) .append ($("<td></td>") .text (f2(this .getSpeed (browser .currentSpeed))         .toLocaleString (language, fixed) + " " + this .getSpeedUnit (browser .currentSpeed)));

         if (this .localStorage .type === "MORE")
         {
            const
               layers         = browser .getWorld () .getLayerSet () .getLayers (),
               activeLayer    = browser .getActiveLayer (),
               systemTime     = browser .getSystemTime (),
               navigationTime = activeLayer && browser .getCollisionCount () ? activeLayer .collisionTime : 0,
               collisionTime  = browser .getCollisionTime () + navigationTime,
               routingTime    = browser .getBrowserTime () - (browser .getCameraTime () + browser .getCollisionTime () + browser .getDisplayTime () + navigationTime),
               prepareEvents  = browser .prepareEvents () .getInterests () .size - 1,
               sensors        = browser .sensorEvents () .getInterests () .size;

            let
               opaqueShapes      = 0,
               transparentShapes = 0;

            for (const layer of layers)
            {
               opaqueShapes      += layer .numOpaqueShapes;
               transparentShapes += layer .numTransparentShapes;
            }

            rows [1] .addClass ("x_ite-private-more");

            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Browser")   + ":")) .append ($("<td></td>") .text (f2(systemTime)           .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("X3D total")       + ":")) .append ($("<td></td>") .text (f2(browser .getBrowserTime ()) .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Event Processing")   + ":")) .append ($("<td></td>") .text (f2(routingTime)          .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Pointer")   + ":")) .append ($("<td></td>") .text (f2(browser .getPointerTime ()) .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Camera")    + ":")) .append ($("<td></td>") .text (f2(browser .getCameraTime ())  .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Picking")   + ":")) .append ($("<td></td>") .text (f2(browser .getPickingTime ()) .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Collision Detection") + ":")) .append ($("<td></td>") .text (f2(collisionTime)        .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Rendering")   + ":")) .append ($("<td></td>") .text (f2(browser .getDisplayTime ()) .toLocaleString (language, fixed) + " " + _("ms")));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Number of Shapes")    + ":")) .append ($("<td></td>") .text (opaqueShapes + " + " + transparentShapes));
            rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Number of Sensors")   + ":")) .append ($("<td></td>") .text (prepareEvents + sensors));
         }

         rows .length = r;

         this .header .find ("th") .text (_("Browser Timings"));
         this .body .empty ();
         this .body .append (rows);
      },
      getSpeed: function (speed)
      {
         if (speed < 15)
            return speed;

         return speed * 3.6;
      },
      getSpeedUnit: function (speed)
      {
         if (speed < 15)
            return _("m/s");

         return _("km/h");
      },
   });

   return BrowserTimings;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/PrimitiveQuality',[],function ()
{
"use strict";

   let i = 0;

   const PrimitiveQuality =
   {
      LOW:    i ++,
      MEDIUM: i ++,
      HIGH:   i ++,
   };

   return PrimitiveQuality;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/Shading',[],function ()
{
"use strict";

   let i = 0;

   const Shading =
   {
      POINT:     i ++,
      WIREFRAME: i ++,
      FLAT:      i ++,
      GOURAUD:   i ++,
      PHONG:     i ++,
   };

   return Shading;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/TextureQuality',[],function ()
{
"use strict";

   let i = 0;

   const TextureQuality =
   {
      LOW:    i ++,
      MEDIUM: i ++,
      HIGH:   i ++,
   };

   return TextureQuality;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/BrowserOptions',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Core/PrimitiveQuality",
   "x_ite/Browser/Core/Shading",
   "x_ite/Browser/Core/TextureQuality",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode,
          X3DConstants,
          PrimitiveQuality,
          Shading,
          TextureQuality)
{
"use strict";

   function BrowserOptions (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addAlias ("AntiAliased", this ._Antialiased);

      const browser = executionContext .getBrowser ();

      this .localStorage     = browser .getLocalStorage () .addNameSpace ("BrowserOptions.");
      this .textureQuality   = TextureQuality .MEDIUM
      this .primitiveQuality = PrimitiveQuality .MEDIUM;
      this .shading          = Shading .GOURAUD;

      this .setAttributeSplashScreen ();
   }

   BrowserOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BrowserOptions,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "SplashScreen",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Dashboard",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Rubberband",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "EnableInlineViewpoints", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Antialiased",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "TextureQuality",         new Fields .SFString ("MEDIUM")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "PrimitiveQuality",       new Fields .SFString ("MEDIUM")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "QualityWhenMoving",      new Fields .SFString ("MEDIUM")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Shading",                new Fields .SFString ("GOURAUD")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "MotionBlur",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Gravity",                new Fields .SFFloat (9.80665)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "StraightenHorizon",      new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "LogarithmicDepthBuffer", new Fields .SFBool (false)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "Timings",                new Fields .SFBool (false)),
      ]),
      getTypeName: function ()
      {
         return "BrowserOptions";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "browserOptions";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         this .localStorage .addDefaultValues ({
            Rubberband:        this ._Rubberband        .getValue (),
            PrimitiveQuality:  this ._PrimitiveQuality  .getValue (),
            TextureQuality:    this ._TextureQuality    .getValue (),
            StraightenHorizon: this ._StraightenHorizon .getValue (),
            Timings:           this ._Timings           .getValue (),
         });

         this ._SplashScreen           .addInterest ("set_splashScreen__",           this);
         this ._Rubberband             .addInterest ("set_rubberband__",             this);
         this ._PrimitiveQuality       .addInterest ("set_primitiveQuality__",       this);
         this ._TextureQuality         .addInterest ("set_textureQuality__",         this);
         this ._Shading                .addInterest ("set_shading__",                this);
         this ._StraightenHorizon      .addInterest ("set_straightenHorizon__",      this);
         this ._LogarithmicDepthBuffer .addInterest ("set_logarithmicDepthBuffer__", this);
         this ._Timings                .addInterest ("set_timings__",                this);

         this .configure ();
      },
      configure: function ()
      {
         if (!this .isInitialized ())
            return;

         const localStorage = this .localStorage;

         for (const fieldDefinition of this .getFieldDefinitions ())
         {
            const field = this .getField (fieldDefinition .name);

            if (localStorage [fieldDefinition .name] !== undefined)
               continue;

            if (!field .equals (fieldDefinition .value))
               field .assign (fieldDefinition .value);
         }

         const
            rubberband        = localStorage .Rubberband,
            primitiveQuality  = localStorage .PrimitiveQuality,
            textureQuality    = localStorage .TextureQuality,
            straightenHorizon = localStorage .StraightenHorizon,
            timings           = localStorage .Timings;

         this .setAttributeSplashScreen ();

         if (rubberband !== this ._Rubberband .getValue ())
            this ._Rubberband = rubberband;

         if (primitiveQuality !== this ._PrimitiveQuality .getValue ())
            this ._PrimitiveQuality = primitiveQuality;

         if (textureQuality !== this ._TextureQuality .getValue ())
            this ._TextureQuality = textureQuality;

         if (straightenHorizon !== this ._StraightenHorizon .getValue ())
            this ._StraightenHorizon = straightenHorizon;

         if (timings !== this ._Timings .getValue ())
            this ._Timings = timings;
      },
      setAttributeSplashScreen: function ()
      {
         this ._SplashScreen .set (this .getSplashScreen ());
      },
      getCache: function ()
      {
         return toBoolean (this .getBrowser () .getElement () .attr ("cache"), true);
      },
      getContextMenu: function ()
      {
         return toBoolean (this .getBrowser () .getElement () .attr ("contextMenu"), true);
      },
      getDebug: function ()
      {
         return toBoolean (this .getBrowser () .getElement () .attr ("debug"), false);
      },
      getNotifications: function ()
      {
         return toBoolean (this .getBrowser () .getElement () .attr ("notifications"), true);
      },
      getSplashScreen: function ()
      {
         return toBoolean (this .getBrowser () .getElement () .attr ("splashScreen"), true);
      },
      getPrimitiveQuality: function ()
      {
         return this .primitiveQuality;
      },
      getShading: function ()
      {
         return this .shading;
      },
      getTextureQuality: function ()
      {
         return this .textureQuality;
      },
      set_splashScreen__: function (splashScreen)
      {
         this .getBrowser () .getElement () .attr ("splashScreen", splashScreen .getValue () ? "true" : "false");
      },
      set_rubberband__: function (rubberband)
      {
         this .localStorage .Rubberband = rubberband .getValue ();

         this .getBrowser () .getViewer () .initShaders ();
      },
      set_primitiveQuality__: function (value)
      {
         const
            browser          = this .getBrowser (),
            primitiveQuality = value .getValue () .toUpperCase ();

         this .localStorage .PrimitiveQuality = primitiveQuality;

         const
            cone     = browser .getConeOptions (),
            cylinder = browser .getCylinderOptions (),
            sphere   = browser .getSphereOptions ();

         switch (primitiveQuality)
         {
            case "LOW":
            {
               if (this .primitiveQuality === PrimitiveQuality .LOW)
                  break;

               this .primitiveQuality = PrimitiveQuality .LOW;

               if (browser .setGeometry2DPrimitiveQuality)
                  browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

               cone     ._xDimension = 16;
               cylinder ._xDimension = 16;
               sphere   ._xDimension = 20;
               sphere   ._yDimension = 9;
               break;
            }
            case "HIGH":
            {
               if (this .primitiveQuality === PrimitiveQuality .HIGH)
                  break;

               this .primitiveQuality = PrimitiveQuality .HIGH;

               if (browser .setGeometry2DPrimitiveQuality)
                  browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

               cone     ._xDimension = 32;
               cylinder ._xDimension = 32;
               sphere   ._xDimension = 64;
               sphere   ._yDimension = 31;
               break;
            }
            default:
            {
               if (this .primitiveQuality === PrimitiveQuality .MEDIUM)
                  break;

               this .primitiveQuality = PrimitiveQuality .MEDIUM;

               if (browser .setGeometry2DPrimitiveQuality)
                  browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

               cone     ._xDimension = 20;
               cylinder ._xDimension = 20;
               sphere   ._xDimension = 32;
               sphere   ._yDimension = 15;
               break;
            }
         }
      },
      set_textureQuality__: function (value)
      {
         const
            browser        = this .getBrowser (),
            textureQuality = value .getValue () .toUpperCase ();

         this .localStorage .TextureQuality = textureQuality;

         const textureProperties = browser .getDefaultTextureProperties ();

         switch (textureQuality)
         {
            case "LOW":
            {
               if (this .textureQuality === TextureQuality .LOW)
                  break;

               this .textureQuality = TextureQuality .LOW;

               textureProperties ._magnificationFilter = "AVG_PIXEL";
               textureProperties ._minificationFilter  = "AVG_PIXEL";
               textureProperties ._textureCompression  = "FASTEST";
               textureProperties ._generateMipMaps     = true;

               //glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
               //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
               break;
            }
            case "HIGH":
            {
               if (this .textureQuality === TextureQuality .HIGH)
                  break;

               this .textureQuality = TextureQuality .HIGH;

               textureProperties ._magnificationFilter = "NICEST";
               textureProperties ._minificationFilter  = "NICEST";
               textureProperties ._textureCompression  = "NICEST";
               textureProperties ._generateMipMaps     = true;

               //glHint (GL_GENERATE_MIPMAP_HINT,        GL_NICEST);
               //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
               break;
            }
            default:
            {
               if (this .textureQuality === TextureQuality .MEDIUM)
                  break;

               this .textureQuality = TextureQuality .MEDIUM;

               textureProperties ._magnificationFilter = "NICEST";
               textureProperties ._minificationFilter  = "NEAREST_PIXEL_AVG_MIPMAP";
               textureProperties ._textureCompression  = "NICEST";
               textureProperties ._generateMipMaps     = true;

               //glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
               //glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
               break;
            }
         }
      },
      set_shading__: function (value)
      {
         const shading = value .getValue () .toUpperCase ();

         switch (shading)
         {
            case "POINT":
            case "POINTSET":
            {
               this .shading = Shading .POINT;
               break;
            }
            case "WIREFRAME":
            {
               this .shading = Shading .WIREFRAME;
               break;
            }
            case "FLAT":
            {
               this .shading = Shading .FLAT;
               break;
            }
            case "PHONG":
            {
               this .shading = Shading .PHONG;
               break;
            }
            default:
            {
               this .shading = Shading .GOURAUD;
               break;
            }
         }

         this .getBrowser () .setShading (this .shading);
      },
      set_straightenHorizon__: function (straightenHorizon)
      {
         this .localStorage .StraightenHorizon = straightenHorizon .getValue ();
      },
      set_logarithmicDepthBuffer__: function (logarithmicDepthBuffer)
      {
         const
            browser = this .getBrowser (),
            gl      = browser .getContext ();

         logarithmicDepthBuffer = logarithmicDepthBuffer .getValue () && (gl .getVersion () >= 2 || Boolean (gl .getExtension ("EXT_frag_depth")));

         if (logarithmicDepthBuffer === browser .getRenderingProperties () ._LogarithmicDepthBuffer .getValue ())
            return;

         browser .getRenderingProperties () ._LogarithmicDepthBuffer = logarithmicDepthBuffer;

         // Recompile shaders.

         // There's no need to update background shader.

         for (const shader of browser .getStandardShaders ())
         {
            shader ._parts [0] .getValue () ._url .addEvent ();
            shader ._parts [1] .getValue () ._url .addEvent ();
         }
      },
      set_timings__: function (timings)
      {
         this .localStorage .Timings = timings .getValue ();

         this .getBrowser () .getBrowserTimings () .setEnabled (timings .getValue ());
      },
   });

   function toBoolean (value, defaultValue)
   {
      if (value === "true" || value === "TRUE")
         return true;

      if (value === "false" || value === "FALSE")
         return false;

      return defaultValue;
   }

   return BrowserOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/BrowserProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode,
          X3DConstants)
{
"use strict";

   function BrowserProperties (executionContext)
   {
      X3DBaseNode .call (this, executionContext);
   }

   BrowserProperties .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BrowserProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ABSTRACT_NODES",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "CONCRETE_NODES",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "EXTERNAL_INTERACTIONS", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "PROTOTYPE_CREATE",      new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "DOM_IMPORT",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "XML_ENCODING",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "CLASSIC_VRML_ENCODING", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "BINARY_ENCODING",       new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "BrowserProperties";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "browserProperties";
      },
   });

   return BrowserProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/RenderingProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode,
          X3DConstants)
{
"use strict";

   function RenderingProperties (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addAlias ("AntiAliased", this ._Antialiased);
   }

   RenderingProperties .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: RenderingProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "Shading",                new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "MaxTextureSize",         new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "TextureUnits",           new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "MaxLights",              new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "Antialiased",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .outputOnly, "ColorDepth",             new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "TextureMemory",          new Fields .SFDouble ()),
         new X3DFieldDefinition (X3DConstants .outputOnly, "LogarithmicDepthBuffer", new Fields .SFBool (false)),
      ]),
      getTypeName: function ()
      {
         return "RenderingProperties";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "renderingProperties";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         const browser = this .getBrowser ();

         this ._MaxTextureSize = browser .getMaxTextureSize ();
         this ._TextureUnits   = browser .getMaxCombinedTextureUnits ();
         this ._MaxLights      = browser .getMaxLights ();
         this ._ColorDepth     = browser .getColorDepth ();
         this ._TextureMemory  = browser .getTextureMemory ();

         browser .getBrowserOptions () ._Shading .addInterest ("set_shading__", this);

         this .set_shading__ (browser .getBrowserOptions () ._Shading);
      },
      set_shading__: function (shading)
      {
         this ._Shading = shading;
      },
   });

   return RenderingProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/Notification',[
   "jquery",
   "x_ite/Fields/SFString",
   "x_ite/Base/X3DBaseNode",
],
function ($,
          SFString,
          X3DBaseNode)
{
"use strict";

   $.fn.textWidth = function (string)
   {
      const
         children = $(this) .children (),
         html     = $(this) .html (),
         span     = '<span>' + html + '</span>';
      $(this) .html (span);
      const width = $(this) .find ('span:first') .width ();
      $(this) .empty ();
      $(this) .append (children);
      return width;
   };

   function Notification (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addChildObjects ("string", new SFString ());
   }

   Notification .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: Notification,
      getTypeName: function ()
      {
         return "Notification";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         this .element = $("<div></div>")
            .hide ()
            .addClass ("x_ite-private-notification")
            .appendTo (this .getBrowser () .getSurface ())
            .animate ({ width: 0 });

         $("<span></span>") .appendTo (this .element);

         this ._string .addInterest ("set_string__", this);
      },
      set_string__: function ()
      {
         if (! this .getBrowser () .getBrowserOptions () .getNotifications ())
            return;

         if (this ._string .length === 0)
            return;

         this .element .children () .text (this ._string .getValue ());

         this .element
            .stop (true, true)
            .fadeIn (0)
            .animate ({ width: this .element .textWidth () })
            .animate ({ "delay": 1 }, 5000)
            .animate ({ width: 0 })
            .fadeOut (0);
      },
   });

   return Notification;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DNode',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (Fields,
          X3DBaseNode,
          X3DConstants,
          Generator)
{
"use strict";

   function X3DNode (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addType (X3DConstants .X3DNode);
   }

   X3DNode .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DNode,
      copy: function (instance)
      {
         if (!instance || instance .getType () .includes (X3DConstants .X3DExecutionContext))
         {
            return X3DBaseNode .prototype .copy .call (this, instance);
         }
         else
         {
            const executionContext = instance .getBody ();

            // First try to get a named node with the node's name.

            if (this .getName () .length)
            {
               const namedNode = executionContext .getNamedNodes () .get (this .getName ());

               if (namedNode)
                  return namedNode;
            }

            // Create copy.

            const copy = this .create (executionContext);

            if (this .getNeedsName ())
               this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (), this);

            if (this .getName () .length)
               executionContext .updateNamedNode (this .getName (), copy);

            // Default fields

            for (const sourceField of this .getPredefinedFields ())
            {
               try
               {
                  const destinationField = copy .getField (sourceField .getName ());

                  if (sourceField .hasReferences ())
                  {
                     // IS relationship

                     for (const originalReference of sourceField .getReferences ())
                     {
                        try
                        {
                           destinationField .addReference (instance .getField (originalReference .getName ()));
                        }
                        catch (error)
                        {
                           console .error (error .message);
                        }
                     }
                  }
                  else
                  {
                     if (sourceField .getAccessType () & X3DConstants .initializeOnly)
                     {
                        switch (sourceField .getType ())
                        {
                           case X3DConstants .SFNode:
                           case X3DConstants .MFNode:
                              destinationField .assign (sourceField .copy (instance));
                              break;
                           default:
                              destinationField .assign (sourceField);
                              break;
                        }
                     }
                  }

                  destinationField .setModificationTime (sourceField .getModificationTime ());
               }
               catch (error)
               {
                  console .log (error .message);
               }
            }

            // User-defined fields

            for (const sourceField of this .getUserDefinedFields ())
            {
               const destinationField = sourceField .copy (instance);

               copy .addUserDefinedField (sourceField .getAccessType (),
                                          sourceField .getName (),
                                          destinationField);

               if (sourceField .hasReferences ())
               {
                  // IS relationship

                  for (const originalReference of sourceField .getReferences ())
                  {
                     try
                     {
                        destinationField .addReference (instance .getField (originalReference .getName ()));
                     }
                     catch (error)
                     {
                        console .error ("No reference '" + originalReference .getName () + "' inside execution context " + instance .getTypeName () + " '" + instance .getName () + "'.");
                     }
                  }
               }

               destinationField .setModificationTime (sourceField .getModificationTime ());
            }

            copy .setup ();

            return copy;
         }
      },
      getDisplayName: (function ()
      {
         const _TrailingNumber = /_\d+$/;

         return function ()
         {
            return this .getName () .replace (_TrailingNumber, "");
         };
      })(),
      getNeedsName: function ()
      {
         if (this .getName () .length)
            return false;

         if (this .getCloneCount () > 1)
            return true;

         if (this .hasRoutes ())
            return true;

         const executionContext = this .getExecutionContext ()

         for (const importedNode of executionContext .getImportedNodes ())
         {
            if (importedNode .getInlineNode () === this)
               return true;
         }

         if (executionContext .isScene ())
         {
            for (const exportedNode of executionContext .getExportedNodes ())
            {
               if (exportedNode .getLocalNode () === this)
                  return true;
            }
         }

         return false;
      },
      getFieldsAreEnumerable: function ()
      {
         return true;
      },
      traverse: function () { },
      toStream: function (stream)
      {
         stream .string += this .getTypeName () + " { }";
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         generator .EnterScope ();

         const name = generator .Name (this);

         if (name .length)
         {
            if (generator .ExistsNode (this))
            {
               stream .string += "USE";
               stream .string += " ";
               stream .string += name;

               generator .LeaveScope ();
               return;
            }
         }

         if (name .length)
         {
            generator .AddNode (this);

            stream .string += "DEF";
            stream .string += " ";
            stream .string += name;
            stream .string += " ";
         }

         stream .string += this .getTypeName ();
         stream .string += " ";
         stream .string += "{";

         const
            fields            = this .getChangedFields (),
            userDefinedFields = this .getUserDefinedFields ();

         let
            fieldTypeLength  = 0,
            accessTypeLength = 0;

         if (this .canUserDefinedFields ())
         {
            for (const field of userDefinedFields)
            {
               fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
               accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
            }

            if (userDefinedFields .length)
            {
               stream .string += "\n";
               generator .IncIndent ();

               for (const field of userDefinedFields)
               {
                  this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);

                  stream .string += "\n";
               }

               generator .DecIndent ();

               if (fields .length !== 0)
                  stream .string += "\n";
            }
         }

         if (fields .length === 0)
         {
            if (userDefinedFields .length)
               stream .string += generator .Indent ();
            else
               stream .string += " ";
         }
         else
         {
            if (userDefinedFields .length === 0)
               stream .string += "\n";

            generator .IncIndent ();

            fields .forEach (function (field)
            {
               this .toVRMLStreamField (stream, field, fieldTypeLength, accessTypeLength);

               stream .string += "\n";
            },
            this);

            generator .DecIndent ();
            stream .string += generator .Indent ();
         }

         stream .string += "}";

         generator .LeaveScope ();
      },
      toVRMLStreamField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
         {
            if (field .isInitializable ())
            {
               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
         else
         {
            let
               index                  = 0,
               initializableReference = false;

            field .getReferences () .forEach (function (reference)
            {
               initializableReference = initializableReference || reference .isInitializable ();

               // Output build in reference field

               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";
               stream .string += "IS";
               stream .string += " ";
               stream .string += reference .getName ();

               ++ index;

               if (index !== field .getReferences () .size)
                  stream .string += "\n";
            });

            if (field .getAccessType () === X3DConstants .inputOutput && !initializableReference && !this .isDefaultValue (field))
            {
               // Output build in field

               stream .string += "\n";
               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
      },
      toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
         {
            stream .string += generator .Indent ();
            stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
            stream .string += " ";
            stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
            stream .string += " ";
            stream .string += field .getName ();

            if (field .isInitializable ())
            {
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
         else
         {
            let
               index                  = 0,
               initializableReference = false;

            field .getReferences () .forEach (function (reference)
            {
               initializableReference = initializableReference || reference .isInitializable ();

               // Output user defined reference field

               stream .string += generator .Indent ();
               stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
               stream .string += " ";
               stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
               stream .string += " ";
               stream .string += field .getName ();
               stream .string += " ";
               stream .string += "IS";
               stream .string += " ";
               stream .string += reference .getName ();

               ++ index;

               if (index !== field .getReferences () .size)
                  stream .string += "\n";
            });

            if (field .getAccessType () === X3DConstants .inputOutput && !initializableReference && !field .isDefaultValue ())
            {
               stream .string += "\n";
               stream .string += generator .Indent ();
               stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
               stream .string += " ";
               stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
               stream .string += " ";
               stream .string += field .getName ();

               if (field .isInitializable ())
               {
                  stream .string += " ";

                  field .toVRMLStream (stream);
               }
            }
         }
      },
      toXMLStream: function (stream)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         generator .EnterScope ();

         const name = generator .Name (this);

         if (name .length)
         {
            if (generator .ExistsNode (this))
            {
               stream .string += generator .Indent ();
               stream .string += "<";
               stream .string += this .getTypeName ();
               stream .string += " ";
               stream .string += "USE='";
               stream .string += generator .XMLEncode (name);
               stream .string += "'";

               const containerField = generator .ContainerField ();

               if (containerField)
               {
                  if (containerField .getName () !== this .getContainerField ())
                  {
                     stream .string += " ";
                     stream .string += "containerField='";
                     stream .string += generator .XMLEncode (containerField .getName ());
                     stream .string += "'";
                  }
               }

               stream .string += "/>";

               generator .LeaveScope ();
               return;
            }
         }

         stream .string += generator .Indent ();
         stream .string += "<";
         stream .string += this .getTypeName ();

         if (name .length)
         {
            generator .AddNode (this);

            stream .string += " ";
            stream .string += "DEF='";
            stream .string += generator .XMLEncode (name);
            stream .string += "'";
         }

         const containerField = generator .ContainerField ();

         if (containerField)
         {
            if (containerField .getName () !== this .getContainerField ())
            {
               stream .string += " ";
               stream .string += "containerField='";
               stream .string += generator .XMLEncode (containerField .getName ());
               stream .string += "'";
            }
         }

         const
            fields            = this .getChangedFields (),
            userDefinedFields = this .getUserDefinedFields ();

         const
            references = [ ],
            childNodes = [ ];

         let cdata = this .getSourceText ();

         if (cdata && cdata .length === 0)
            cdata = null;

         generator .IncIndent ();
         generator .IncIndent ();

         for (const field of fields)
         {
            // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
            // for this field.

            let mustOutputValue = false;

            if (generator .ExecutionContext ())
            {
               if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
               {
                  let initializableReference = false;

                  field .getReferences () .forEach (function (fieldReference)
                  {
                     initializableReference = initializableReference || fieldReference .isInitializable ();
                  });

                  if (!initializableReference)
                     mustOutputValue = !this .isDefaultValue (field);
               }
            }

            // If we have no execution context we are not in a proto and must not generate IS references the same is true
            // if the node is a shared node as the node does not belong to the execution context.

            if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode || mustOutputValue)
            {
               if (mustOutputValue)
                  references .push (field);

               if (field .isInitializable ())
               {
                  switch (field .getType ())
                  {
                     case X3DConstants .SFNode:
                     case X3DConstants .MFNode:
                     {
                        childNodes .push (field);
                        break;
                     }
                     default:
                     {
                        if (field === cdata)
                           break;

                        stream .string += "\n";
                        stream .string += generator .Indent ();
                        stream .string += field .getName ();
                        stream .string += "='";

                        field .toXMLStream (stream);

                        stream .string += "'";
                        break;
                     }
                  }
               }
            }
            else
            {
               references .push (field);
            }
         }

         generator .DecIndent ();
         generator .DecIndent ();

         if ((!this .canUserDefinedFields () || !userDefinedFields .length) && (!references .length || sharedNode) && !childNodes .length && !cdata)
         {
            stream .string += "/>";
         }
         else
         {
            stream .string += ">\n";

            generator .IncIndent ();

            if (this .canUserDefinedFields ())
            {
               for (const field of userDefinedFields)
               {
                  stream .string += generator .Indent ();
                  stream .string += "<field";
                  stream .string += " ";
                  stream .string += "accessType='";
                  stream .string += generator .AccessType (field .getAccessType ());
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "type='";
                  stream .string += field .getTypeName ();
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "name='";
                  stream .string += generator .XMLEncode (field .getName ());
                  stream .string += "'";

                  // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
                  // for this field.

                  let mustOutputValue = false;

                  if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
                  {
                     let initializableReference = false;

                     field .getReferences () .forEach (function (fieldReference)
                     {
                        initializableReference = initializableReference || fieldReference .isInitializable ();
                     });

                     if (!initializableReference)
                        mustOutputValue = true;
                  }

                  if ((field .getReferences () .size === 0 || !generator .ExecutionContext ()) || sharedNode || mustOutputValue)
                  {
                     if (mustOutputValue && generator .ExecutionContext ())
                        references .push (field);

                     if (!field .isInitializable () || field .isDefaultValue ())
                     {
                        stream .string += "/>\n";
                     }
                     else
                     {
                        // Output value

                        switch (field .getType ())
                        {
                           case X3DConstants .SFNode:
                           case X3DConstants .MFNode:
                           {
                              generator .PushContainerField (field);

                              stream .string += ">\n";

                              generator .IncIndent ();

                              field .toXMLStream (stream);

                              stream .string += "\n";

                              generator .DecIndent ();

                              stream .string += generator .Indent ();
                              stream .string += "</field>\n";

                              generator .PopContainerField ();
                              break;
                           }
                           default:
                           {
                              stream .string += " ";
                              stream .string += "value='";

                              field .toXMLStream (stream);

                              stream .string += "'";
                              stream .string += "/>\n";
                              break;
                           }
                        }
                     }
                  }
                  else
                  {
                     if (generator .ExecutionContext ())
                        references .push (field);

                     stream .string += "/>\n";
                  }
               }
            }

            if (references .length && !sharedNode)
            {
               stream .string += generator .Indent ();
               stream .string += "<IS>";
               stream .string += "\n";

               generator .IncIndent ();

               for (const field of references)
               {
                  const protoFields = field .getReferences ();

                  protoFields .forEach (function (protoField)
                  {
                     stream .string += generator .Indent ();
                     stream .string += "<connect";
                     stream .string += " ";
                     stream .string += "nodeField='";
                     stream .string += generator .XMLEncode (field .getName ());
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "protoField='";
                     stream .string += generator .XMLEncode (protoField .getName ());
                     stream .string += "'";
                     stream .string += "/>\n";
                  });
               }

               generator .DecIndent ();

               stream .string += generator .Indent ();
               stream .string += "</IS>\n";
            }

            for (const field of childNodes)
            {
               generator .PushContainerField (field);

               field .toXMLStream (stream);

               stream .string += "\n";

               generator .PopContainerField ();
            }

            if (cdata)
            {
               for (const value of cdata)
               {
                  stream .string += "<![CDATA[";
                  stream .string += generator .escapeCDATA (value);
                  stream .string += "]]>\n";
               }
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</";
            stream .string += this .getTypeName ();
            stream .string += ">";
         }

         generator .LeaveScope ();
      },
      dispose: function ()
      {
         const executionContext = this .getExecutionContext ();

         // Remove named node if any.

         if (this .getName ())
            executionContext .removeNamedNode (this .getName ())

         // Remove imported node if any.

         if (!executionContext .isMainScene ())
         {
            const parentContext = executionContext .getExecutionContext ();

            for (const importedNode of parentContext .getImportedNodes ())
            {
               try
               {
                  if (importedNode .getExportedNode () === this)
                     parentContext .removeImportedNode (importedNode .getImportedName ());
               }
               catch (error)
               {
                  //console .error (error);
               }
            }
         }

         // Remove exported node if any.

         if (executionContext .isScene ())
         {
            for (const exportedNode of executionContext .getExportedNodes ())
            {
               if (exportedNode .getLocalNode () === this)
                  executionContext .removeExportedNode (exportedNode .getExportedName ());
            }
         }

         // Remove routes from and to node if any, and dispose values of fields.

         for (const field of this .getFields ())
            field .dispose ();

         // Remove node from entire scene graph.

         for (const firstParent of new Set (this .getParents ()))
         {
            if (firstParent instanceof Fields .SFNode)
            {
               for (const secondParent of new Set (firstParent .getParents ()))
               {
                  if (secondParent instanceof Fields .MFNode)
                  {
                     const length = secondParent .length;

                     secondParent .erase (secondParent .remove (0, length, firstParent), length);
                  }
               }

               firstParent .setValue (null);
            }
         }

         // Call super.dispose, where fields get disposed.

         X3DBaseNode .prototype .dispose .call (this);
      },
   });

   return X3DNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DChildNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DNode,
          X3DConstants)
{
"use strict";

   function X3DChildNode (executionContext)
   {
      if (this .getExecutionContext ())
         return;

      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DChildNode);

      this .addChildObjects ("isCameraObject",   new Fields .SFBool ());
      this .addChildObjects ("isPickableObject", new Fields .SFBool ());

      this ._isCameraObject   .setAccessType (X3DConstants .outputOnly);
      this ._isPickableObject .setAccessType (X3DConstants .outputOnly);
   }

   X3DChildNode .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DChildNode,
      setCameraObject: function (value)
      {
         if (value !== this ._isCameraObject .getValue ())
            this ._isCameraObject = value;
      },
      getCameraObject: function ()
      {
         return this ._isCameraObject .getValue ();
      },
      setPickableObject: function (value)
      {
         if (value !== this ._isPickableObject .getValue ())
            this ._isPickableObject = value;
      },
      getPickableObject: function ()
      {
         return this ._isPickableObject .getValue ();
      },
   });

   return X3DChildNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DBindableNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DBindableNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DBindableNode);

      this .addChildObjects ("transitionActive", new Fields .SFBool ());
   }

   X3DBindableNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DBindableNode,
      getCameraObject: function ()
      {
         return true;
      },
      transitionStart: function ()
      { },
   });

   return X3DBindableNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DSensorNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DSensorNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSensorNode);
   }

   X3DSensorNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DSensorNode,
   });

   return X3DSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time/X3DTimeDependentNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DTimeDependentNode (executionContext)
   {
      this .addType (X3DConstants .X3DTimeDependentNode);

      this .addChildObjects ("initialized", new Fields .SFTime (),
                             "isEvenLive",  new Fields .SFBool ());

      this .startTimeValue  = 0;
      this .pauseTimeValue  = 0;
      this .resumeTimeValue = 0;
      this .stopTimeValue   = 0;
      this .start           = 0;
      this .pause           = 0;
      this .pauseInterval   = 0;
      this .startTimeout    = null;
      this .pauseTimeout    = null;
      this .resumeTimeout   = null;
      this .stopTimeout     = null;
      this .disabled        = false;
   }

   X3DTimeDependentNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DTimeDependentNode,
      initialize: function ()
      {
         this .isLive ()   .addInterest ("set_live__", this);
         this ._isEvenLive .addInterest ("set_live__", this);

         this ._initialized .addInterest ("set_loop__",       this);
         this ._enabled     .addInterest ("set_enabled__",    this);
         this ._loop        .addInterest ("set_loop__",       this);
         this ._startTime   .addInterest ("set_startTime__",  this);
         this ._pauseTime   .addInterest ("set_pauseTime__",  this);
         this ._resumeTime  .addInterest ("set_resumeTime__", this);
         this ._stopTime    .addInterest ("set_stopTime__",   this);

         this .startTimeValue  = this ._startTime  .getValue ();
         this .pauseTimeValue  = this ._pauseTime  .getValue ();
         this .resumeTimeValue = this ._resumeTime .getValue ();
         this .stopTimeValue   = this ._stopTime   .getValue ();

         this ._initialized = this .getBrowser () .getCurrentTime ();
      },
      getDisabled: function ()
      {
         return this .disabled;
      },
      getLiveState: function ()
      {
         ///  Determines the live state of this node.

         return this .getLive () && (this .getExecutionContext () .isLive () .getValue () || this ._isEvenLive .getValue ());
      },
      getElapsedTime: function ()
      {
         return this .getBrowser () .getCurrentTime () - this .start - this .pauseInterval;
      },
      resetElapsedTime: function ()
      {
         this .start         = this .getBrowser () .getCurrentTime ();
         this .pause         = this .getBrowser () .getCurrentTime ();
         this .pauseInterval = 0;
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue () || this ._isEvenLive .getValue ())
         {
            if (this .disabled)
            {
               this .disabled = false;

               if (this ._isActive .getValue () && !this ._isPaused .getValue ())
                  this .real_resume ();
            }
         }
         else
         {
            if (!this .disabled && this ._isActive .getValue () && !this ._isPaused .getValue ())
            {
               // Only disable if needed, ie. if running!
               this .disabled = true;
               this .real_pause ();
            }
         }
      },
      set_enabled__: function ()
      {
         if (this ._enabled .getValue ())
            this .set_loop__ ();

         else
            this .stop ();
      },
      set_loop__: function ()
      {
         if (this ._enabled .getValue ())
         {
            if (this ._loop .getValue ())
            {
               if (this .stopTimeValue <= this .startTimeValue)
               {
                  if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
                     this .do_start ();
               }
            }
         }
      },
      set_startTime__: function ()
      {
         this .startTimeValue = this ._startTime .getValue ();

         if (this ._enabled .getValue ())
         {
            this .removeTimeout ("startTimeout");

            if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
               this .do_start ();

            else
               this .addTimeout ("startTimeout", "do_start", this .startTimeValue);
         }
      },
      set_pauseTime__: function ()
      {
         this .pauseTimeValue = this ._pauseTime .getValue ();

         if (this ._enabled .getValue ())
         {
            this .removeTimeout ("pauseTimeout");

            if (this .pauseTimeValue <= this .resumeTimeValue)
               return;

            if (this .pauseTimeValue <= this .getBrowser () .getCurrentTime ())
               this .do_pause ();

            else
               this .addTimeout ("pauseTimeout", "do_pause", this .pauseTimeValue);
         }
      },
      set_resumeTime__: function ()
      {
         this .resumeTimeValue = this ._resumeTime .getValue ();

         if (this ._enabled .getValue ())
         {
            this .removeTimeout ("resumeTimeout");

            if (this .resumeTimeValue <= this .pauseTimeValue)
               return;

            if (this .resumeTimeValue <= this .getBrowser () .getCurrentTime ())
               this .do_resume ();

            else
               this .addTimeout ("resumeTimeout", "do_resume", this .resumeTimeValue);
         }
      },
      set_stopTime__: function ()
      {
         this .stopTimeValue = this ._stopTime .getValue ();

         if (this ._enabled .getValue ())
         {
            this .removeTimeout ("stopTimeout");

            if (this .stopTimeValue <= this .startTimeValue)
               return;

            if (this .stopTimeValue <= this .getBrowser () .getCurrentTime ())
               this .do_stop ();

            else
               this .addTimeout ("stopTimeout","do_stop", this .stopTimeValue);
         }
      },
      do_start: function ()
      {
         if (!this ._isActive .getValue ())
         {
            this .resetElapsedTime ();

            // The event order below is very important.

            this ._isActive = true;

            this .set_start ();

            if (this .isLive () .getValue ())
            {
               this .getBrowser () .timeEvents () .addInterest ("set_time" ,this);
            }
            else
            {
               this .disabled = true;
               this .real_pause ();
            }

            this ._elapsedTime = 0;
         }
      },
      do_pause: function ()
      {
         if (this ._isActive .getValue () && !this ._isPaused .getValue ())
         {
            this ._isPaused = true;

            if (this .pauseTimeValue !== this .getBrowser () .getCurrentTime ())
               this .pauseTimeValue = this .getBrowser () .getCurrentTime ();

            if (this .isLive () .getValue ())
               this .real_pause ();
         }
      },
      real_pause: function ()
      {
         this .pause = performance .now ();

         this .set_pause ();

         this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
      },
      do_resume: function ()
      {
         if (this ._isActive .getValue () && this ._isPaused .getValue ())
         {
            this ._isPaused = false;

            if (this .resumeTimeValue !== this .getBrowser () .getCurrentTime ())
               this .resumeTimeValue = this .getBrowser () .getCurrentTime ();

            if (this .isLive () .getValue ())
               this .real_resume ();
         }
      },
      real_resume: function ()
      {
         const interval = (performance .now () - this .pause) / 1000;

         this .pauseInterval += interval;

         this .set_resume (interval);

         this .getBrowser () .timeEvents () .addInterest ("set_time", this);
         this .getBrowser () .addBrowserEvent ();
      },
      do_stop: function ()
      {
         this .stop ();
      },
      stop: function ()
      {
         if (this ._isActive .getValue ())
         {
            // The event order below is very important.

            this .set_stop ();

            this ._elapsedTime = this .getElapsedTime ();

            if (this ._isPaused .getValue ())
               this ._isPaused = false;

            this ._isActive = false;

            this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
         }
      },
      timeout: function (callback)
      {
         if (this ._enabled .getValue ())
         {
            this .getBrowser () .advanceTime (performance .now ());

            this [callback] ();
         }
      },
      addTimeout: function (name, callback, time)
      {
         this .removeTimeout (name);
         this [name] = setTimeout (this .timeout .bind (this, callback), (time - this .getBrowser () .getCurrentTime ()) * 1000);
      },
      removeTimeout: function (name)
      {
         clearTimeout (this [name]);
         this [name] = null;
      },
      set_start: function () { },
      set_pause: function () { },
      set_resume: function () { },
      set_stop: function () { },
      set_time: function () { },
   });

   return X3DTimeDependentNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time/TimeSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DSensorNode",
   "x_ite/Components/Time/X3DTimeDependentNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSensorNode,
          X3DTimeDependentNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function TimeSensor (executionContext)
   {
      X3DSensorNode        .call (this, executionContext);
      X3DTimeDependentNode .call (this, executionContext);

      this .addType (X3DConstants .TimeSensor);

      this .addChildObjects ("range", new Fields .MFFloat (0, 0, 1)); // current, first, last (in fractions) - play range starting at current

      this .cycle    = 0;
      this .interval = 0;
      this .fraction = 0;
      this .first    = 0;
      this .last     = 1;
      this .scale    = 1;
   }

   TimeSensor .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
      X3DTimeDependentNode .prototype,
   {
      constructor: TimeSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "cycleInterval",    new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "loop",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "startTime",        new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "resumeTime",       new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pauseTime",        new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "stopTime",         new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isPaused",         new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",         new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "cycleTime",        new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "elapsedTime",      new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "fraction_changed", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "time",             new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "TimeSensor";
      },
      getComponentName: function ()
      {
         return "Time";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DSensorNode        .prototype .initialize .call (this);
         X3DTimeDependentNode .prototype .initialize .call (this);

         this ._cycleInterval .addInterest ("set_cycleInterval__", this);
         this ._range         .addInterest ("set_range__",         this);
      },
      setRange: function (currentFraction, firstFraction, lastFraction)
      {
         const
            currentTime   = this .getBrowser () .getCurrentTime (),
            startTime     = this ._startTime .getValue (),
            cycleInterval = this ._cycleInterval .getValue ();

         this .first    = firstFraction;
         this .last     = lastFraction;
         this .scale    = this .last - this .first;
         this .interval = cycleInterval * this .scale;
         this .fraction = Algorithm .fract ((currentFraction >= 1 ? 0 : currentFraction) + (this .interval ? (currentTime - startTime) / this .interval : 0));
         this .cycle    = currentTime - (this .fraction -  this .first) * cycleInterval;
      },
      set_cycleInterval__: function ()
      {
         if (this ._isActive .getValue ())
            this .setRange (this .fraction, this ._range [1], this ._range [2]);
      },
      set_range__: function ()
      {
         if (this ._isActive .getValue ())
         {
            this .setRange (this ._range [0], this ._range [1], this ._range [2]);

            if (!this ._isPaused .getValue ())
               this .set_fraction (this .getBrowser () .getCurrentTime ());
         }
      },
      set_start: function ()
      {
         this .setRange (this ._range [0], this ._range [1], this ._range [2]);

         if (this .isLive () .getValue ())
         {
            this ._fraction_changed = this .fraction;
            this ._time             = this .getBrowser () .getCurrentTime ();
         }
      },
      set_resume: function (pauseInterval)
      {
         const
            currentTime   = this .getBrowser () .getCurrentTime (),
            startTime     = this ._startTime .getValue ();

         this .setRange (this .interval ? Algorithm .fract (this .fraction - (currentTime - startTime) / this .interval) : 0, this ._range [1], this ._range [2]);
      },
      set_fraction: function (time)
      {
         this ._fraction_changed = this .fraction = this .first + (this .interval ? Algorithm .fract ((time - this .cycle) / this .interval) : 0) * this .scale;
      },
      set_time: function ()
      {
         // The event order below is very important.

         const time = this .getBrowser () .getCurrentTime ();

         if (time - this .cycle >= this .interval)
         {
            if (this ._loop .getValue ())
            {
               if (this .interval)
               {
                  this .cycle += this .interval * Math .floor ((time - this .cycle) / this .interval);

                  this ._elapsedTime = this .getElapsedTime ();
                  this ._cycleTime   = time;

                  this .set_fraction (time);
               }
            }
            else
            {
               this ._fraction_changed = this .fraction = this .last;
               this .stop ();
            }
         }
         else
         {
            this ._elapsedTime = this .getElapsedTime ();

            this .set_fraction (time);
         }

         this ._time = time;
      },
   });

   return TimeSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/X3DInterpolatorNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (X3DChildNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function X3DInterpolatorNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DInterpolatorNode);
   }

   X3DInterpolatorNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DInterpolatorNode,
      setup: function ()
      {
         // If an X3DInterpolatorNode value_changed outputOnly field is read before it receives any inputs,
         // keyValue[0] is returned if keyValue is not empty. If keyValue is empty (i.e., [ ]), the initial
         // value for the respective field type is returned (EXAMPLE  (0, 0, 0) for Fields .SFVec3f);

         this .set_key__ ();

         if (this ._key .length)
            this .interpolate (0, 0, 0);

         X3DChildNode .prototype .setup .call (this);
      },
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);

         this ._set_fraction .addInterest ("set_fraction__", this);
         this ._key          .addInterest ("set_key__", this);
      },
      set_fraction__: function ()
      {
         const
            key      = this ._key,
            length   = key .length,
            fraction = this ._set_fraction .getValue ();

         switch (length)
         {
            case 0:
               // Interpolator nodes containing no keys in the key field shall not produce any events.
               return;
            case 1:
               return this .interpolate (0, 0, 0);
            default:
            {
               if (fraction <= key [0])
                  return this .interpolate (0, 1, 0);

               const index1 = Algorithm .upperBound (key, 0, length, fraction);

               if (index1 !== length)
               {
                  const
                     index0 = index1 - 1,
                     weight = (fraction - key [index0]) / (key [index1] - key [index0]);

                  this .interpolate (index0, index1, Algorithm .clamp (weight, 0, 1));
               }
               else
                  this .interpolate (length - 2, length - 1, 1);
            }
         }
      },
      set_key__: function ()
      {
         this .set_keyValue__ ();
      },
      set_keyValue__: function () { },
      interpolate: function () { },
   });

   return X3DInterpolatorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/EaseInEaseOut',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants)
{
"use strict";

   function EaseInEaseOut (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .EaseInEaseOut);
   }

   EaseInEaseOut .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: EaseInEaseOut,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                 new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",             new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",                      new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "easeInEaseOut",            new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "modifiedFraction_changed", new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "EaseInEaseOut";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._easeInEaseOut .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         if (this ._easeInEaseOut .length < this ._key .length)
            this ._easeInEaseOut .resize (this ._key .length, this ._easeInEaseOut .length ? this ._easeInEaseOut [this ._easeInEaseOut .length - 1] : new Fields .SFVec2f ());
      },
      interpolate: function (index0, index1, weight)
      {
         let
            easeOut = this ._easeInEaseOut [index0] .y,
            easeIn  = this ._easeInEaseOut [index1] .x;
         
         const sum = easeOut + easeIn;

         if (sum < 0)
         {
            this ._modifiedFraction_changed = weight;
         }
         else
         {
            if (sum > 1)
            {
               easeIn  /= sum;
               easeOut /= sum;
            }

            const t = 1 / (2 - easeOut - easeIn);

            if (weight < easeOut)
            {
               this ._modifiedFraction_changed = (t / easeOut) * weight * weight;
            }
            else if (weight <= 1 - easeIn) // Spec says (weight < 1 - easeIn), but then we get a NaN below if easeIn == 0.
            {
               this ._modifiedFraction_changed = t * (2 * weight - easeOut);
            }
            else
            {
               const w = 1 - weight;

               this ._modifiedFraction_changed = 1 - ((t * w * w) / easeIn);
            }
         }
      },
   });

   return EaseInEaseOut;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/PositionInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function PositionInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .PositionInterpolator);
   }

   PositionInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: PositionInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "PositionInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec3f ());
      },
      interpolate: (function ()
      {
         const keyValue = new Vector3 (0, 0, 0);

         return function (index0, index1, weight)
         {
            this ._value_changed = keyValue .assign (this ._keyValue [index0] .getValue ()) .lerp (this ._keyValue [index1] .getValue (), weight);
         };
      })(),
   });

   return PositionInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/OrientationInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Rotation4"
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Rotation4)
{
"use strict";

   function OrientationInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .OrientationInterpolator);

      this ._keyValue      .setUnit ("angle");
      this ._value_changed .setUnit ("angle");
   }

   OrientationInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: OrientationInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFRotation ()),
      ]),
      getTypeName: function ()
      {
         return "OrientationInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFRotation ());
      },
      interpolate: (function ()
      {
         const
            keyValue0 = new Rotation4 (0, 0, 1, 0),
            keyValue1 = new Rotation4 (0, 0, 1, 0);

         return function (index0, index1, weight)
         {
            // Both values can change in slerp.
            keyValue0 .assign (this ._keyValue [index0] .getValue ());
            keyValue1 .assign (this ._keyValue [index1] .getValue ());

            this ._value_changed = keyValue0 .slerp (keyValue1, weight);
         };
      }) (),
   });

   return OrientationInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/TraverseType',[],function ()
{
"use strict";

   let i = 0;

   const TraverseType =
   {
      POINTER:   i ++,
      CAMERA:    i ++,
      PICKING:   i ++,
      COLLISION: i ++,
      SHADOW:    i ++,
      DISPLAY:   i ++,
   };

   return TraverseType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/X3DViewpointNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DBindableNode",
   "x_ite/Components/Time/TimeSensor",
   "x_ite/Components/Interpolation/EaseInEaseOut",
   "x_ite/Components/Interpolation/PositionInterpolator",
   "x_ite/Components/Interpolation/OrientationInterpolator",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DBindableNode,
          TimeSensor,
          EaseInEaseOut,
          PositionInterpolator,
          OrientationInterpolator,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

   function X3DViewpointNode (executionContext)
   {
      X3DBindableNode .call (this, executionContext);

      this .addType (X3DConstants .X3DViewpointNode);

      this .addChildObjects ("positionOffset",         new Fields .SFVec3f (),
                             "orientationOffset",      new Fields .SFRotation (),
                             "scaleOffset",            new Fields .SFVec3f (1, 1, 1),
                             "scaleOrientationOffset", new Fields .SFRotation (),
                             "centerOfRotationOffset", new Fields .SFVec3f (),
                             "fieldOfViewScale",       new Fields .SFFloat (1));

      this .userPosition         = new Vector3 (0, 1, 0);
      this .userOrientation      = new Rotation4 (0, 0, 1, 0);
      this .userCenterOfRotation = new Vector3 (0, 0, 0);
      this .modelMatrix          = new Matrix4 ();
      this .cameraSpaceMatrix    = new Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  10, 1);
      this .viewMatrix           = new Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -10, 1);

      const browser = this .getBrowser ();

      this .timeSensor                   = new TimeSensor              (browser .getPrivateScene ());
      this .easeInEaseOut                = new EaseInEaseOut           (browser .getPrivateScene ());
      this .positionInterpolator         = new PositionInterpolator    (browser .getPrivateScene ());
      this .orientationInterpolator      = new OrientationInterpolator (browser .getPrivateScene ());
      this .scaleInterpolator            = new PositionInterpolator    (browser .getPrivateScene ());
      this .scaleOrientationInterpolator = new OrientationInterpolator (browser .getPrivateScene ());
   }

   X3DViewpointNode .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
   {
      constructor: X3DViewpointNode,
      initialize: function ()
      {
         X3DBindableNode .prototype .initialize .call (this);

         this .timeSensor ._stopTime = 1;
         this .timeSensor .setup ();

         this .easeInEaseOut ._key           = new Fields .MFFloat (0, 1);
         this .easeInEaseOut ._easeInEaseOut = new Fields .MFVec2f (new Fields .SFVec2f (0, 0), new Fields .SFVec2f (0, 0));
         this .easeInEaseOut .setup ();

         this .positionInterpolator         ._key = new Fields .MFFloat (0, 1);
         this .orientationInterpolator      ._key = new Fields .MFFloat (0, 1);
         this .scaleInterpolator            ._key = new Fields .MFFloat (0, 1);
         this .scaleOrientationInterpolator ._key = new Fields .MFFloat (0, 1);

         this .positionInterpolator         .setup ();
         this .orientationInterpolator      .setup ();
         this .scaleInterpolator            .setup ();
         this .scaleOrientationInterpolator .setup ();

         this .timeSensor ._isActive         .addFieldInterest (this ._transitionActive);
         this .timeSensor ._fraction_changed .addFieldInterest (this .easeInEaseOut ._set_fraction);

         this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .positionInterpolator         ._set_fraction);
         this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .orientationInterpolator      ._set_fraction);
         this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .scaleInterpolator            ._set_fraction);
         this .easeInEaseOut ._modifiedFraction_changed .addFieldInterest (this .scaleOrientationInterpolator ._set_fraction);

         this .positionInterpolator         ._value_changed .addFieldInterest (this ._positionOffset);
         this .orientationInterpolator      ._value_changed .addFieldInterest (this ._orientationOffset);
         this .scaleInterpolator            ._value_changed .addFieldInterest (this ._scaleOffset);
         this .scaleOrientationInterpolator ._value_changed .addFieldInterest (this ._scaleOrientationOffset);

         this ._isBound .addInterest ("set_bound__", this);
      },
      getEaseInEaseOut: function ()
      {
         return this .easeInEaseOut;
      },
      setInterpolators: function () { },
      getPosition: function ()
      {
         return this ._position .getValue ();
      },
      getUserPosition: function ()
      {
         return this .userPosition .assign (this .getPosition ()) .add (this ._positionOffset .getValue ());
      },
      getOrientation: function ()
      {
         return this ._orientation .getValue ();
      },
      getUserOrientation: function ()
      {
         return this .userOrientation .assign (this .getOrientation ()) .multRight (this ._orientationOffset .getValue ());
      },
      getCenterOfRotation: function ()
      {
         return this ._centerOfRotation .getValue ();
      },
      getUserCenterOfRotation: function ()
      {
         return this .userCenterOfRotation .assign (this .getCenterOfRotation ()) .add (this ._centerOfRotationOffset .getValue ());
      },
      getProjectionMatrix: function (renderObject)
      {
         const navigationInfo = renderObject .getNavigationInfo ();

         return this .getProjectionMatrixWithLimits (navigationInfo .getNearValue (),
                                                     navigationInfo .getFarValue (this),
                                                     renderObject .getLayer () .getViewport () .getRectangle (renderObject .getBrowser ()));
      },
      getCameraSpaceMatrix: function ()
      {
         return this .cameraSpaceMatrix;
      },
      getViewMatrix: function ()
      {
         return this .viewMatrix;
      },
      getModelMatrix: function ()
      {
         return this .modelMatrix;
      },
      getMaxFarValue: function ()
      {
         return this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer") ? 1e10 : 1e5;
      },
      getUpVector: function ()
      {
         // Local y-axis,
         // see http://www.web3d.org/documents/specifications/19775-1/V3.3/index.html#NavigationInfo.
         return Vector3 .yAxis;
      },
      getSpeedFactor: function ()
      {
         return 1;
      },
      setVRMLTransition: function (value)
      {
         // VRML behaviour support.
         this .VRMLTransition = value;
      },
      getVRMLTransition: function ()
      {
         // VRML behaviour support.
         return this .VRMLTransition;
      },
      transitionStart: (function ()
      {
         const
            relativePosition         = new Vector3 (0, 0, 0),
            relativeOrientation      = new Rotation4 (0, 0, 1, 0),
            relativeScale            = new Vector3 (0, 0, 0),
            relativeScaleOrientation = new Rotation4 (0, 0, 1, 0);

         return function (layerNode, fromViewpointNode, toViewpointNode)
         {
            this .to = toViewpointNode;

            if (toViewpointNode ._jump .getValue ())
            {
               if (! toViewpointNode ._retainUserOffsets .getValue ())
                  toViewpointNode .resetUserOffsets ();

               // Copy from toViewpointNode all fields.

               if (this !== toViewpointNode)
               {
                  for (const field of toViewpointNode .getFields ())
                     this .getField (field .getName ()) .assign (field);
               }

               // Respect NavigationInfo.

               const
                  navigationInfoNode = layerNode .getNavigationInfo (),
                  transitionTime     = navigationInfoNode ._transitionTime .getValue ();

               let transitionType = navigationInfoNode .getTransitionType ();

               // VRML behavior

               if (this .getExecutionContext () .getSpecificationVersion () == "2.0")
               {
                  if (toViewpointNode .getVRMLTransition ())
                     transitionType = "LINEAR";
                  else
                     transitionType = "TELEPORT";
               }

               toViewpointNode .setVRMLTransition (false);

               // End VRML behavior

               if (transitionTime <= 0)
                  transitionType = "TELEPORT";

               switch (transitionType)
               {
                  case "TELEPORT":
                  {
                     navigationInfoNode ._transitionComplete = true;
                     return;
                  }
                  case "ANIMATE":
                  {
                     this .easeInEaseOut ._easeInEaseOut = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));
                     break;
                  }
                  default:
                  {
                     // LINEAR
                     this .easeInEaseOut ._easeInEaseOut = new Fields .MFVec2f (new Fields .SFVec2f (0, 0), new Fields .SFVec2f (0, 0));
                     break;
                  }
               }

               this .timeSensor ._cycleInterval = transitionTime;
               this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
               this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

               this .timeSensor ._isActive .addInterest ("set_active__", this, navigationInfoNode);

               toViewpointNode .getRelativeTransformation (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

               this .positionInterpolator         ._keyValue = new Fields .MFVec3f    (relativePosition,         toViewpointNode ._positionOffset);
               this .orientationInterpolator      ._keyValue = new Fields .MFRotation (relativeOrientation,      toViewpointNode ._orientationOffset);
               this .scaleInterpolator            ._keyValue = new Fields .MFVec3f    (relativeScale,            toViewpointNode ._scaleOffset);
               this .scaleOrientationInterpolator ._keyValue = new Fields .MFRotation (relativeScaleOrientation, toViewpointNode ._scaleOrientationOffset);

               this ._positionOffset         = relativePosition;
               this ._orientationOffset      = relativeOrientation;
               this ._scaleOffset            = relativeScale;
               this ._scaleOrientationOffset = relativeScaleOrientation;

               this .setInterpolators (fromViewpointNode, toViewpointNode);

               this ._transitionActive = true;
            }
            else
            {
               toViewpointNode .getRelativeTransformation (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

               toViewpointNode ._positionOffset         = relativePosition;
               toViewpointNode ._orientationOffset      = relativeOrientation;
               toViewpointNode ._scaleOffset            = relativeScale;
               toViewpointNode ._scaleOrientationOffset = relativeScaleOrientation;

               toViewpointNode .setInterpolators (fromViewpointNode, toViewpointNode);
            }
         };
      })(),
      transitionStop: function ()
      {
         this .timeSensor ._stopTime = this .getBrowser () .getCurrentTime ();
         this .timeSensor ._isActive .removeInterest ("set_active__", this);
      },
      resetUserOffsets: function ()
      {
         this ._positionOffset         = Vector3   .Zero;
         this ._orientationOffset      = Rotation4 .Identity;
         this ._scaleOffset            = Vector3   .One;
         this ._scaleOrientationOffset = Rotation4 .Identity;
         this ._centerOfRotationOffset = Vector3   .Zero;
         this ._fieldOfViewScale       = 1;
      },
      getRelativeTransformation: function (fromViewpointNode, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation)
      {
         const differenceMatrix = this .modelMatrix .copy () .multRight (fromViewpointNode .getViewMatrix ()) .inverse ();

         differenceMatrix .get (relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

         relativePosition .subtract (this .getPosition ());
         relativeOrientation .assign (this .getOrientation () .copy () .inverse () .multRight (relativeOrientation));
      },
      lookAtPoint: function (layerNode, point, factor, straighten)
      {
         this .getCameraSpaceMatrix () .multVecMatrix (point);

         Matrix4 .inverse (this .getModelMatrix ()) .multVecMatrix (point);

         const minDistance = layerNode .getNavigationInfo () .getNearValue () * 2;

         this .lookAt (layerNode, point, minDistance, factor, straighten);
      },
      lookAtBBox: function (layerNode, bbox, factor, straighten)
      {
         bbox = bbox .copy () .multRight (Matrix4 .inverse (this .getModelMatrix ()));

         const minDistance = layerNode .getNavigationInfo () .getNearValue () * 2;

         this .lookAt (layerNode, bbox .center, minDistance, factor, straighten);
      },
      lookAt: function (layerNode, point, distance, factor, straighten)
      {
         const
            offset = point .copy () .add (this .getUserOrientation () .multVecRot (new Vector3 (0, 0, distance))) .subtract (this .getPosition ());

         layerNode .getNavigationInfo () ._transitionStart = true;

         this .timeSensor ._cycleInterval = 0.2;
         this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
         this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

         this .timeSensor ._isActive .addInterest ("set_active__", this, layerNode .getNavigationInfo ());

         this .easeInEaseOut ._easeInEaseOut = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));

         const
            translation = Vector3 .lerp (this ._positionOffset .getValue (), offset, factor),
            direction   = Vector3 .add (this .getPosition (), translation) .subtract (point);

         let rotation = Rotation4 .multRight (this ._orientationOffset .getValue (), new Rotation4 (this .getUserOrientation () .multVecRot (new Vector3 (0, 0, 1)), direction));

         if (straighten)
         {
            rotation = Rotation4 .inverse (this .getOrientation ()) .multRight (this .straightenHorizon (Rotation4 .multRight (this .getOrientation (), rotation)));
         }

         this .positionInterpolator         ._keyValue = new Fields .MFVec3f (this ._positionOffset, translation);
         this .orientationInterpolator      ._keyValue = new Fields .MFRotation (this ._orientationOffset, rotation);
         this .scaleInterpolator            ._keyValue = new Fields .MFVec3f (this ._scaleOffset, this ._scaleOffset);
         this .scaleOrientationInterpolator ._keyValue = new Fields .MFRotation (this ._scaleOrientationOffset, this ._scaleOrientationOffset);

         this .setInterpolators (this, this);

         this ._centerOfRotationOffset = Vector3 .subtract (point, this .getCenterOfRotation ());
         this ._set_bind               = true;
      },
      straighten: function (layerNode, horizon)
      {
         layerNode .getNavigationInfo () ._transitionStart = true;

         this .timeSensor ._cycleInterval = 0.4;
         this .timeSensor ._stopTime      = this .getBrowser () .getCurrentTime ();
         this .timeSensor ._startTime     = this .getBrowser () .getCurrentTime ();

         this .timeSensor ._isActive .addInterest ("set_active__", this, layerNode .getNavigationInfo ());

         this .easeInEaseOut ._easeInEaseOut = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));

         const rotation = Rotation4 .multRight (Rotation4 .inverse (this .getOrientation ()), this .straightenHorizon (this .getUserOrientation ()));

         this .positionInterpolator         ._keyValue = new Fields .MFVec3f (this ._positionOffset, this ._positionOffset);
         this .orientationInterpolator      ._keyValue = new Fields .MFRotation (this ._orientationOffset, rotation);
         this .scaleInterpolator            ._keyValue = new Fields .MFVec3f (this ._scaleOffset, this ._scaleOffset);
         this .scaleOrientationInterpolator ._keyValue = new Fields .MFRotation (this ._scaleOrientationOffset, this ._scaleOrientationOffset);

         this .setInterpolators (this, this);

         this ._set_bind = true;
      },
      straightenHorizon: (function ()
      {
         const
            localXAxis  = new Vector3 (0, 0, 0),
            localZAxis  = new Vector3 (0, 0, 0),
            rotation    = new Rotation4 (0, 0, 1, 0);

         return function (orientation)
         {
            orientation .multVecRot (localXAxis .assign (Vector3 .xAxis) .negate ());
            orientation .multVecRot (localZAxis .assign (Vector3 .zAxis));

            const
                upVector = this .getUpVector (),
               vector   = localZAxis .cross (upVector);

            // If viewer looks along the up vector.
            if (Math .abs (localZAxis .dot (upVector)) >= 1)
               return orientation;

            if (Math .abs (vector .dot (localXAxis)) >= 1)
               return orientation;

            rotation .setFromToVec (localXAxis, vector);

            return orientation .multRight (rotation);
         };
      })(),
      set_active__: function (navigationInfoNode, active)
      {
         if (this ._isBound .getValue () && ! active .getValue () && this .timeSensor ._fraction_changed .getValue () === 1)
         {
            navigationInfoNode ._transitionComplete = true;
         }
      },
      set_bound__: function ()
      {
         if (this ._isBound .getValue ())
            this .getBrowser () .getNotification () ._string = this ._description;
         else
            this .timeSensor ._stopTime = this .getBrowser () .getCurrentTime ();
      },
      traverse: function (type, renderObject)
      {
         if (type !== TraverseType .CAMERA)
            return;

         renderObject .getLayer () .getViewpoints () .push (this);

         this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
      },
      update: function ()
      {
         this .cameraSpaceMatrix .set (this .getUserPosition (),
                                       this .getUserOrientation (),
                                       this ._scaleOffset .getValue (),
                                       this ._scaleOrientationOffset .getValue ());

         this .cameraSpaceMatrix .multRight ((this .to || this) .modelMatrix);

         this .viewMatrix .assign (this .cameraSpaceMatrix) .inverse ();
      }
   });

   return X3DViewpointNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Spheroid3',[],function ()
{
"use strict";

   function Spheroid3 (semiMajorAxis, semiMinorAxis)
   {
      switch (arguments .length)
      {
         case 0:
            this .semiMajorAxis = 0; // a
            this .semiMinorAxis = 0; // c
            break;
         case 2:
            this .semiMajorAxis = semiMajorAxis; // a
            this .semiMinorAxis = semiMinorAxis; // c
            break;
         case 3:
            const f_1 = arguments [1];
            this .semiMajorAxis = semiMajorAxis;                 // a
            this .semiMinorAxis = semiMajorAxis * (1 - 1 / f_1); // c
            break;
      }
   }

   Spheroid3 .prototype =
   {
      constructor: Spheroid3,
      getSemiMajorAxis: function ()
      {
         // Returns the semi-major axis (a)
         return this .semiMajorAxis; // a
      },
      getSemiMinorAxis: function ()
      {
         // Returns the semi-minor axis (c)
         return this .semiMinorAxis; // c
      },
      toString: function ()
      {
         return this .semiMajorAxis + " " + this .semiMinorAxis;
      },
   };

   return Spheroid3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Geospatial/ReferenceEllipsoids',[
   "standard/Math/Geometry/Spheroid3",
],
function (Spheroid3)
{
"use strict";

   const ReferenceEllipsoids =
   {
      // Earth
      // X3D Specification
      AA: new Spheroid3 (6377563.396, 299.3249646,   true), // Airy 1830
      AM: new Spheroid3 (6377340.189, 299.3249646,   true), // Modified Airy
      AN: new Spheroid3 (6378160,     298.25,        true), // Australian National
      BN: new Spheroid3 (6377483.865, 299.1528128,   true), // Bessel 1841 (Namibia)
      BR: new Spheroid3 (6377397.155, 299.1528128,   true), // Bessel 1841 (Ethiopia Indonesia...)
      CC: new Spheroid3 (6378206.4,   294.9786982,   true), // Clarke 1866
      CD: new Spheroid3 (6378249.145, 293.465,       true), // Clarke 1880
      EA: new Spheroid3 (6377276.345, 300.8017,      true), // Everest (India 1830)
      EB: new Spheroid3 (6377298.556, 300.8017,      true), // Everest (Sabah & Sarawak)
      EC: new Spheroid3 (6377301.243, 300.8017,      true), // Everest (India 1956)
      ED: new Spheroid3 (6377295.664, 300.8017,      true), // Everest (W. Malaysia 1969)
      EE: new Spheroid3 (6377304.063, 300.8017,      true), // Everest (W. Malaysia & Singapore 1948)
      EF: new Spheroid3 (6377309.613, 300.8017,      true), // Everest (Pakistan)
      FA: new Spheroid3 (6378155,     298.3,         true), // Modified Fischer 1960
      HE: new Spheroid3 (6378200,     298.3,         true), // Helmert 1906
      HO: new Spheroid3 (6378270,     297,           true), // Hough 1960
      ID: new Spheroid3 (6378160,     298.247,       true), // Indonesian 1974
      IN: new Spheroid3 (6378388,     297,           true), // International 1924
      KA: new Spheroid3 (6378245,     298.3,         true), // Krassovsky 1940
      RF: new Spheroid3 (6378137,     298.257222101, true), // Geodetic Reference System 1980 (GRS 80)
      SA: new Spheroid3 (6378160,     298.25,        true), // South American 1969
      WD: new Spheroid3 (6378135,     298.26,        true), // WGS 72
      WE: new Spheroid3 (6378137,     298.257223563, true), // WGS 84
      // Solar System
      // http://en.wikipedia.de
      // Can someone give me more accurate parameters.
      SUN:     new Spheroid3 (696342000, 1 / 9e-6, true),
      MERCURY: new Spheroid3 (2439700,  2439700),
      VENUS:   new Spheroid3 (6051800,  6051800),
      MOON:    new Spheroid3 (1738140,  1735970),
      MARS:    new Spheroid3 (3395428,  3377678), // http://adsabs.harvard.edu/abs/2010EM%26P..106....1A
      JUPITER: new Spheroid3 (71492000, 66854000),
      SATURN:  new Spheroid3 (60268000, 54364000),
      URANUS:  new Spheroid3 (2555000,  24973000),
      NEPTUNE: new Spheroid3 (24764000, 24341000),
      PLUTO:   new Spheroid3 (1153000,  1153000),
   };

   return ReferenceEllipsoids;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Geospatial/Geodetic',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithm",
],
function (Vector3,
          Algorithm)
{
"use strict";

   const
      EPS_H = 1e-3,
      EPS_P = 1e-10,
      IMAX  = 30;

   function Geodetic (spheroid, latitudeFirst, radians)
   {
      this .longitudeFirst = ! latitudeFirst;
      this .degrees        = ! radians;
      this .a              = spheroid .getSemiMajorAxis ();
      this .c              = spheroid .getSemiMinorAxis ();
      this .c2a2           = Math .pow (spheroid .getSemiMinorAxis () / this .a, 2);
      this .ecc2           = 1 - this .c2a2;
   }

   Geodetic .prototype =
   {
      constructor: Geodetic,
      convert: function (geodetic, result)
      {
         const elevation = geodetic .z;

         if (this .longitudeFirst)
         {
            var
               latitude  = geodetic .y,
               longitude = geodetic .x;
         }
         else
         {
            var
               latitude  = geodetic .x,
               longitude = geodetic .y;
         }

         if (this .degrees)
         {
            latitude  *= Math .PI / 180;
            longitude *= Math .PI / 180;
         }

         return this .convertRadians (latitude, longitude, elevation, result);
      },
      convertRadians: function (latitude, longitude, elevation, result)
      {
         const
            slat  = Math .sin (latitude),
            slat2 = Math .pow (slat, 2),
            clat  = Math .cos (latitude),
            N     = this .a / Math .sqrt (1 - this .ecc2 * slat2),
            Nhl   = (N + elevation) * clat;

         return result .set (Nhl * Math .cos (longitude),
                             Nhl * Math .sin (longitude),
                             (N * this .c2a2 + elevation) * slat);
      },
      apply: function (geocentric, result)
      {
         this .applyRadians (geocentric, result);

         if (this .degrees)
         {
            result .x *= 180 / Math .PI; // latitude
            result .y *= 180 / Math .PI; // longitude
         }

         if (this .longitudeFirst)
         {
            const tmp = result .x;

            result .x = result .y; // latitude
            result .y = tmp;       // longitude
         }

         return result;
      },
      applyRadians: function (geocentric, result)
      {
         const
            x = geocentric .x,
            y = geocentric .y,
            z = geocentric .z;

         const P = Math .sqrt (x * x + y * y);

         // Handle pole case.
         if (P == 0)
            return result .set (Math .PI, 0, z - this .c);

         let
            latitude  = 0,
            longitude = Math .atan2 (y, x),
            elevation = 0;

         let
            a    = this .a,
            N    = a,
            ecc2 = this .ecc2;

         for (let i = 0; i < IMAX; ++ i)
         {
            const
               h0 = elevation,
               b0 = latitude;

            latitude = Math .atan (z / P / (1 - ecc2 * N / (N + elevation)));

            const sin_p = Math .sin (latitude);

            N         = a / Math .sqrt (1 - ecc2 * sin_p * sin_p);
            elevation = P / Math .cos (latitude) - N;

            if (Math .abs (elevation - h0) < EPS_H && Math .abs (latitude - b0) < EPS_P)
               break;
         }

         return result .set (latitude, longitude, elevation);
      },
      normal: function (geocentric, result)
      {
         const geodetic = this .applyRadians (geocentric, result);

         const
            latitude  = geodetic .x,
            longitude = geodetic .y;

         const clat = Math .cos (latitude);

         const
            nx = Math .cos (longitude) * clat,
            ny = Math .sin (longitude) * clat,
            nz = Math .sin (latitude);

         return result .set (nx, ny, nz);
      },
      /*
      lerp: function (s, d, t)
      {
         var
            source     =  this .source      .assign (s),
            destination = this .destination .assign (d);

         var
            RANGE    = this .degrees ? 180 : M_PI,
            RANGE1_2 = RANGE / 2,
            RANGE2   = RANGE * 2;

         var range = 0;

         if (this .longitudeFirst)
         {
            source .x = Algorithm .interval (source .x, -RANGE,    RANGE);
            source .y = Algorithm .interval (source .y, -RANGE1_2, RANGE1_2);

            destination .x = Algorithm .interval (destination .x, -RANGE,    RANGE);
            destination .y = Algorithm .interval (destination .y, -RANGE1_2, RANGE1_2);

            range = Math .abs (destination .x - source .x);
         }
         else
         {
            source .x = Algorithm .interval (source .x, -RANGE1_2, RANGE1_2);
            source .y = Algorithm .interval (source .y, -RANGE,    RANGE);

            destination .x = Algorithm .interval (destination .x, -RANGE1_2, RANGE1_2);
            destination .y = Algorithm .interval (destination .y, -RANGE,    RANGE);

            range = Math .abs (destination .y - source .y);
         }

         if (range <= RANGE)
            return source .lerp (destination, t);

         var step = (RANGE2 - range) * t;

         if (this .longitudeFirst)
         {
            var longitude = source .x < destination .x ? source .x - step : source .x + step;

            if (longitude < -RANGE)
               longitude += RANGE2;

            else if (longitude > RANGE)
               longitude -= RANGE2;

            return source .set (longitude,
                                source .y + t * (destination .y - source .y),
                                source .z + t * (destination .z - source .z));
         }

         var longitude = source .y < destination .y ? source .y - step : source .y + step;

         if (longitude < -RANGE)
            longitude += RANGE2;

         else if (longitude > RANGE)
            longitude -= RANGE2;

         return source .set (source .x + t * (destination .x - source .x),
                             longitude,
                             source .z + t * (destination .z - source .z));
      },
      source: new Vector3 (0, 0, 0),
      destination: new Vector3 (0, 0, 0),
      */
   };

   return Geodetic;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Geospatial/UniversalTransverseMercator',[
   "standard/Geospatial/Geodetic",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithm",
],
function (Geodetic,
          Vector3,
          Algorithm)
{
"use strict";

   const
      N0 = 1.0e7,
      E0 = 5.0e5,
      k0 = 0.9996;

   function UniversalTransverseMercator (spheroid, zone, northernHemisphere, northingFirst)
   {
      const
         a    = spheroid .getSemiMajorAxis (),
         ecc2 = 1 - Math .pow (spheroid .getSemiMinorAxis () / a, 2),
         EE   = ecc2 / (1 - ecc2),
         e1   = (1 - Math .sqrt (1 - ecc2)) / (1 + Math .sqrt (1 - ecc2));

      this .southernHemisphere = ! northernHemisphere;
      this .eastingFirst       = ! northingFirst;
      this .a                  = a;
      this .ecc2               = ecc2;
      this .EE                 = EE;
      this .E8                 = 8 * EE;
      this .E9                 = 9 * EE;
      this .E252               = 252 * EE;
      this .e1                 = e1;
      this .A                  = k0 * (a * (1 - ecc2 / 4 - 3 * ecc2 * ecc2 / 64 - 5 * ecc2 * ecc2 * ecc2 / 256));
      this .B                  = 3 * e1 / 2 - 7 * e1 * e1 * e1 / 32;
      this .C                  = 21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32;
      this .D                  = 151 * e1 * e1 * e1 / 96;
      this .E                  = a * (1 - ecc2);
      this .W                  = 1 - ecc2 / 4 - 3 * ecc2 * ecc2 / 64 - 5 * ecc2 * ecc2 * ecc2 / 256;
      this .X                  = 3 * ecc2 / 8 + 3 * ecc2 * ecc2 / 32 + 45 * ecc2 * ecc2 * ecc2 / 1024;
      this .Y                  = 15 * ecc2 * ecc2 / 256 + 45 * ecc2 * ecc2 * ecc2 / 1024;
      this .Z                  = 35 * ecc2 * ecc2 * ecc2 / 3072;
      this .longitude0         = Algorithm .radians (zone * 6 - 183);
      this .geodeticConverter  = new Geodetic (spheroid, true, true);
   }

   UniversalTransverseMercator .prototype =
   {
      constructor: UniversalTransverseMercator,
      convert: function (utm, result)
      {
         // https://gist.github.com/duedal/840476

         if (this .eastingFirst)
         {
            var
               northing = utm .y,
               easting  = utm .x;
         }
         else
         {
            var
               northing = utm .x,
               easting  = utm .y;
         }

         // Check for southern hemisphere and remove offset from easting.

         let S = this .southernHemisphere;

         if (northing < 0)
         {
            S        = ! this .southernHemisphere;
            northing = -northing;
         }

         if (S)
            northing -= N0;

         easting -= E0;

         // Begin calculation.

         const
            mu   = northing / this .A,
            phi1 = mu + this .B * Math .sin (2 * mu) + this .C * Math .sin (4 * mu) + this .D * Math .sin (6 * mu);

         const
            sinphi1 = Math .pow (Math .sin (phi1), 2),
            cosphi1 = Math .cos (phi1),
            tanphi1 = Math .tan (phi1);

         const
            N1 = this .a / Math .sqrt (1 - this .ecc2 * sinphi1),
            T2 = Math .pow (tanphi1, 2),
            T8 = Math .pow (tanphi1, 8),
            C1 = this .EE * T2,
            C2 = C1 * C1,
            R1 = this .E / Math .pow (1 - this .ecc2 * sinphi1, 1.5),
            I  = easting / (N1 * k0);

         const
            J = (5 + 3 * T2 + 10 * C1 - 4 * C2 - this .E9) * Math .pow (I, 4) / 24,
            K = (61 + 90 * T2 + 298 * C1 + 45 * T8 - this .E252 - 3 * C2) * Math .pow (I, 6) / 720,
            L = (5 - 2 * C1 + 28 * T2 - 3 * C2 + this .E8 + 24 * T8) * Math .pow (I, 5) / 120;

         const
            latitude  = phi1 - (N1 * tanphi1 / R1) * (I * I / 2 - J + K),
            longitude = this .longitude0 + (I - (1 + 2 * T2 + C1) * Math .pow (I, 3) / 6 + L) / cosphi1;

         return this .geodeticConverter .convertRadians (latitude, longitude, utm .z, result);
      },
      apply: function (geocentric, result)
      {
         // https://gist.github.com/duedal/840476

         const
            geodetic  = this .geodeticConverter .applyRadians (geocentric, result),
            latitude  = geodetic .x,
            longitude = geodetic .y;

         const
            tanlat = Math .tan (latitude),
            coslat = Math .cos (latitude);

         const
            EE = this .EE,
            N  = this .a / Math .sqrt (1 - this .ecc2 * Math .pow (Math .sin (latitude), 2)),
            T  = tanlat * tanlat,
            T6 = T * T * T,
            C  = EE * coslat * coslat,
            A  = coslat * (longitude - this .longitude0);

         const M = this .a * (this .W * latitude
                              - this .X * Math .sin (2 * latitude)
                              + this .Y * Math .sin (4 * latitude)
                              - this .Z * Math .sin (6 * latitude));

         const easting = k0 * N * (A + (1 - T + C) * Math .pow (A, 3) / 6
                                   + (5 - 18 * T6 + 72 * C - 58 * EE) * Math .pow (A, 5) / 120)
                         + E0;

         let northing = k0 * (M + N * tanlat * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * Math .pow (A, 4) / 24
                                                + (61 - 58 * T6 + 600 * C - 330 * EE) * Math .pow (A, 6) / 720));

         if (latitude < 0)
         {
            northing += N0;

            if (! this .southernHemisphere)
               northing = -northing;
         }
         else
         {
            if (this .southernHemisphere)
               northing = -northing;
         }

         if (this .eastingFirst)
            return result .set (easting, northing, geodetic .z);

         return result .set (northing, easting, geodetic .z);
      },
      //lerp: Vector3 .lerp,
   };

   return UniversalTransverseMercator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geospatial/Geocentric',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithm",
],
function (Vector3,
          Algorithm)
{
"use strict";

   function Geocentric () { }

   Geocentric .prototype =
   {
      constructor: Geocentric,
      convert: function (geocentric, result)
      {
         return result .assign (geocentric);
      },
      apply: function (geocentric, result)
      {
         return result .assign (geocentric);
      },
      slerp: function (source, destination, t)
      {
         const
            sourceLength      = source      .abs (),
            destinationLength = destination .abs ();

         source      .normalize ();
         destination .normalize ();

         return Algorithm .simpleSlerp (source, destination, t) .multiply (Algorithm .lerp (sourceLength, destinationLength, t));
      },
   };

   return Geocentric;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geospatial/Geospatial',[
   "standard/Geospatial/ReferenceEllipsoids",
   "standard/Geospatial/Geodetic",
   "standard/Geospatial/UniversalTransverseMercator",
   "x_ite/Browser/Geospatial/Geocentric",
],
function (ReferenceEllipsoids,
          Geodetic,
          UniversalTransverseMercator,
          Geocentric)
{
"use strict";

   let i = 0;

   const
      GD  = i ++,
      UTM = i ++,
      GC  = i ++;

   const CoordinateSystems = {
      GD:  GD,
      GDC: GD,
      UTM: UTM,
      GC:  GC,
      GCC: GC,
      GS:  GC,
   };

   const Zone = /^Z(\d+)$/;

   const Geospatial =
   {
      GD: GD,
      UTM: UTM,
      GC: GC,
      getReferenceFrame: function (geoSystem, radians)
      {
         switch (this .getCoordinateSystem (geoSystem))
         {
            case GD:
            {
               return new Geodetic (this .getEllipsoid (geoSystem),
                                    this .getLatitudeFirst (geoSystem),
                                    radians);
            }
            case UTM:
            {
               return new UniversalTransverseMercator (this .getEllipsoid (geoSystem),
                                                       this .getZone (geoSystem),
                                                       this .getNorthernHemisphere (geoSystem),
                                                       this .getNorthingFirst (geoSystem));
            }
            case GC:
            {
               return new Geocentric ();
            }
         }

         return new Geodetic (ReferenceEllipsoids .WE, true, radians);
      },
      getElevationFrame: function (geoSystem, radians)
      {
         return new Geodetic (this .getEllipsoid (geoSystem), true, radians);
      },
      getCoordinateSystem: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            const coordinateSystem = CoordinateSystems [gs];

            if (coordinateSystem !== undefined)
               return coordinateSystem;
         }

         return GD;
      },
      getEllipsoid: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            const ellipsoid = ReferenceEllipsoids [gs];

            if (ellipsoid !== undefined)
               return ellipsoid;
         }

         return ReferenceEllipsoids .WE;
      },
      getEllipsoidString: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            const ellipsoid = ReferenceEllipsoids [gs];

            if (ellipsoid !== undefined)
               return gs;
         }

         return "WE";
      },
      isStandardOrder: function (geoSystem)
      {
         switch (this .getCoordinateSystem (geoSystem))
         {
            case GD:
            {
               return this .getLatitudeFirst (geoSystem);
            }
            case UTM:
            {
               return this .getNorthingFirst (geoSystem);
            }
            case GC:
            {
               return true;
            }
         }

         return this .getLatitudeFirst (geoSystem);
      },
      getLatitudeFirst: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            if (gs === "longitude_first")
               return false;
         }

         return true;
      },
      getNorthingFirst: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            if (gs === "easting_first")
               return false;
         }

         return true;
      },
      getZone: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            const match = gs .match (Zone);

            if (match)
               return parseInt (match [1]);
         }

         return 1;
      },
      getNorthernHemisphere: function (geoSystem)
      {
         for (const gs of geoSystem)
         {
            if (gs === "S")
               return false;
         }

         return true;
      },
   };

   return Geospatial;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DCast',[
   "x_ite/Fields",
],
function (Fields)
{
"use strict";

   return function (type, node, innerNode = true)
   {
      try
      {
         if (node)
         {
            if (node instanceof Fields .SFNode)
               node = node .getValue ();

            if (node)
            {
               if (innerNode)
                  node = node .getInnerNode ();

               if (node .getType () .indexOf (type) !== -1)
                  return node;
            }
         }
      }
      catch (error)
      { }

      return null;
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geospatial/X3DGeospatialObject',[
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Geospatial/Geospatial",
   "x_ite/Base/X3DCast",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (X3DConstants,
          Geospatial,
          X3DCast,
          Vector3,
          Matrix4)
{
"use strict";

   var
      vector = new Vector3 (0, 0, 0),
      result = new Vector3 (0, 0, 0),
      t      = new Vector3 (0, 0, 0),
      x      = new Vector3 (0, 0, 0),
      y      = new Vector3 (0, 0, 0),
      z      = new Vector3 (0, 0, 0);

   function X3DGeospatialObject (executionContext)
   {
      this .addType (X3DConstants .X3DGeospatialObject);

      this .radians         = false;
      this .origin          = new Vector3 (0, 0, 0);
      this .originMatrix    = new Matrix4 ();
      this .invOriginMatrix = new Matrix4 ();
   }

   X3DGeospatialObject .prototype =
   {
      constructor: X3DGeospatialObject,
      initialize: function ()
      {
         this ._geoSystem .addInterest ("set_geoSystem__", this);
         this ._geoOrigin .addInterest ("set_geoOrigin__", this);

         this .set_geoSystem__ ();
         this .set_geoOrigin__ ();
      },
      set_geoSystem__: function ()
      {
         this .coordinateSystem = Geospatial .getCoordinateSystem (this ._geoSystem);
         this .referenceFrame   = Geospatial .getReferenceFrame   (this ._geoSystem, this .radians);
         this .elevationFrame   = Geospatial .getElevationFrame   (this ._geoSystem, this .radians);
         this .standardOrder    = Geospatial .isStandardOrder     (this ._geoSystem);
      },
      set_geoOrigin__: function ()
      {
         if (this .geoOriginNode)
         {
            this .geoOriginNode .removeInterest ("set_origin__",    this);
            this .geoOriginNode .removeInterest ("set_rotateYUp__", this);
            this .geoOriginNode .removeInterest ("addNodeEvent",    this);
         }

         this .geoOriginNode = X3DCast (X3DConstants .GeoOrigin, this ._geoOrigin);

         if (this .geoOriginNode)
         {
            this .geoOriginNode .addInterest ("set_origin__",    this);
            this .geoOriginNode .addInterest ("set_rotateYUp__", this);
            this .geoOriginNode .addInterest ("addNodeEvent",    this);
         }

         this .set_origin__ ();
         this .set_rotateYUp__ ();
      },
      set_origin__: function ()
      {
         if (this .geoOriginNode)
            this .geoOriginNode .getOrigin (this .origin);
         else
            this .origin .set (0, 0, 0);

         this .set_originMatrix__ ();
      },
      set_originMatrix__: function ()
      {
         if (this .geoOriginNode)
         {
            // Position
            var t = this .origin;

            // Let's work out the orientation at that location in order
            // to maintain a view where +Y is in the direction of gravitional
            // up for that region of the planet's surface. This will be the
            // value of the rotation matrix for the transform.

            this .elevationFrame .normal (t, y);

            x .set (0, 0, 1) .cross (y);

            // Handle pole cases.
            if (x .equals (Vector3 .Zero))
               x .set (1, 0, 0);

            z .assign (x) .cross (y);

            x .normalize ();
            z .normalize ();

            this .originMatrix .set (x .x, x .y, x .z, 0,
                                       y .x, y .y, y .z, 0,
                                       z .x, z .y, z .z, 0,
                                       t .x, t .y, t .z, 1);

            this .invOriginMatrix .assign (this .originMatrix) .inverse ();
         }
      },
      set_rotateYUp__: function ()
      {
         if (this .geoOriginNode && this .geoOriginNode ._rotateYUp .getValue ())
         {
            this .getCoord          = getCoordRotateYUp;
            this .getGeoCoord       = getGeoCoordRotateYUp;
            this .getGeoUpVector    = getGeoUpVectorRotateYUp;
            this .getLocationMatrix = getLocationMatrixRotateYUp;
         }
         else
         {
            delete this .getCoord;
            delete this .getGeoCoord;
            delete this .getGeoUpVector;
            delete this .getLocationMatrix;
         }
      },
      getReferenceFrame: function ()
      {
         return this .referenceFrame;
      },
      getStandardOrder: function ()
      {
         return this .standardOrder;
      },
      getCoord: function (geoPoint, result)
      {
         return this .referenceFrame .convert (geoPoint, result) .subtract (this .origin);
      },
      getGeoCoord: function (point, result)
      {
         return this .referenceFrame .apply (vector .assign (point) .add (this .origin), result);
      },
      getGeoElevation: function (point)
      {
         return this .getGeoCoord (point, result) .z;
      },
      getGeoUpVector: function (point, result)
      {
         return this .elevationFrame .normal (vector .assign (point) .add (this .origin), result);
      },
      getLocationMatrix: function (geoPoint, result)
      {
         var
            origin         = this .origin,
            locationMatrix = getStandardLocationMatrix .call (this, geoPoint, result);

         // translateRight (-origin)
         locationMatrix [12] -= origin .x;
         locationMatrix [13] -= origin .y;
         locationMatrix [14] -= origin .z;

         return locationMatrix;
      },
   };

   function getCoordRotateYUp (geoPoint, result)
   {
      return this .invOriginMatrix .multVecMatrix (this .referenceFrame .convert (geoPoint, result));
   }

   function getGeoCoordRotateYUp (point, result)
   {
      return this .referenceFrame .apply (this .originMatrix .multVecMatrix (vector .assign (point)), result);
   }

   function getGeoUpVectorRotateYUp (point, result)
   {
      return this .invOriginMatrix .multDirMatrix (this .elevationFrame .normal (this .originMatrix .multVecMatrix (vector .assign (point)), result));
   }

   function getLocationMatrixRotateYUp (geoPoint, result)
   {
      return getStandardLocationMatrix .call (this, geoPoint, result) .multRight (this .invOriginMatrix);
   }

   function getStandardLocationMatrix (geoPoint, result)
   {
      // Position
      this .referenceFrame .convert (geoPoint, t);

      // Let's work out the orientation at that location in order
      // to maintain a view where +Y is in the direction of gravitional
      // up for that region of the planet's surface. This will be the
      // value of the rotation matrix for the transform.

      this .elevationFrame .normal (t, y);

      x .set (0, 0, 1) .cross (y);

      // Handle pole cases.
      if (x .equals (Vector3 .Zero))
         x .set (1, 0, 0);

      z .assign (x) .cross (y);

      x .normalize ();
      z .normalize ();

      return result .set (x .x, x .y, x .z, 0,
                          y .x, y .y, y .z, 0,
                          z .x, z .y, z .z, 0,
                          t .x, t .y, t .z, 1);
   }

   return X3DGeospatialObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/ScalarInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function ScalarInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .ScalarInterpolator);
   }

   ScalarInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: ScalarInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "ScalarInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : 0);
      },
      interpolate: function (index0, index1, weight)
      {
         this ._value_changed = Algorithm .lerp (this ._keyValue [index0], this ._keyValue [index1], weight);
      },
   });

   return ScalarInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/NavigationInfo',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DBindableNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBindableNode,
          TraverseType,
          X3DConstants)
{
"use strict";

   const TransitionType =
   {
      TELEPORT: true,
      LINEAR:   true,
      ANIMATE:  true,
   };

   function NavigationInfo (executionContext)
   {
      X3DBindableNode .call (this, executionContext);

      this .addType (X3DConstants .NavigationInfo);

      this .addChildObjects ("transitionStart",  new Fields .SFBool (),
                             "availableViewers", new Fields .MFString (),
                             "viewer",           new Fields .SFString ("EXAMINE"));

      this ._avatarSize      .setUnit ("length");
      this ._speed           .setUnit ("speed");
      this ._visibilityLimit .setUnit ("speed");
   }

   NavigationInfo .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
   {
      constructor: NavigationInfo,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "type",               new Fields .MFString ("EXAMINE", "ANY")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "avatarSize",         new Fields .MFFloat (0.25, 1.6, 0.75)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "speed",              new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "headlight",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityLimit",    new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transitionType",     new Fields .MFString ("LINEAR")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transitionTime",     new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "transitionComplete", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",           new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "NavigationInfo";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DBindableNode .prototype .initialize .call (this);

         this ._type               .addInterest ("set_type__",               this);
         this ._headlight          .addInterest ("set_headlight__",          this);
         this ._transitionStart    .addInterest ("set_transitionStart__",    this);
         this ._transitionComplete .addInterest ("set_transitionComplete__", this);
         this ._isBound            .addInterest ("set_isBound__",            this);

         this .set_type__ ();
         this .set_headlight__ ();
      },
      getViewer: function ()
      {
         return this ._viewer .getValue ();
      },
      getCollisionRadius: function ()
      {
         if (this ._avatarSize .length > 0)
         {
            if (this ._avatarSize [0] > 0)
               return this ._avatarSize [0];
         }

         return 0.25;
      },
      getAvatarHeight: function ()
      {
         if (this ._avatarSize .length > 1)
            return this ._avatarSize [1];

         return 1.6;
      },
      getStepHeight: function ()
      {
         if (this ._avatarSize .length > 2)
            return this ._avatarSize [2];

         return 0.75;
      },
      getNearValue: function ()
      {
         const nearValue = this .getCollisionRadius ();

         if (nearValue === 0)
            return 1e-5;

         else
            return nearValue / 2;
      },
      getFarValue: function (viewpoint)
      {
         return this ._visibilityLimit .getValue ()
                ? this ._visibilityLimit .getValue ()
                : viewpoint .getMaxFarValue ();
      },
      getTransitionType: function ()
      {
         for (const value of this ._transitionType)
         {
            const transitionType = TransitionType [value];

            if (transitionType)
               return value;
         }

         return "LINEAR";
      },
      set_type__: function ()
      {
         // Determine active viewer.

         this ._viewer = "EXAMINE";

         for (const string of this ._type)
         {
            switch (string)
            {
               case "EXAMINE":
               case "WALK":
               case "FLY":
               case "LOOKAT":
               case "PLANE":
               case "NONE":
                  this ._viewer = string;
                  break;
               case "PLANE_create3000.de":
                  this ._viewer = "PLANE";
                  break;
               default:
                  continue;
            }

            // Leave for loop.
            break;
         }

         // Determine available viewers.

         let
            examineViewer = false,
            walkViewer    = false,
            flyViewer     = false,
            planeViewer   = false,
            noneViewer    = false,
            lookAt        = false;

         if (! this ._type .length)
         {
            examineViewer = true;
            walkViewer    = true;
            flyViewer     = true;
            planeViewer   = true;
            noneViewer    = true;
            lookAt        = true;
         }
         else
         {
            for (const string of this ._type)
            {
               switch (string)
               {
                  case "EXAMINE":
                     examineViewer = true;
                     continue;
                  case "WALK":
                     walkViewer = true;
                     continue;
                  case "FLY":
                     flyViewer = true;
                     continue;
                  case "LOOKAT":
                     lookAt = true;
                     continue;
                  case "PLANE":
                     planeViewer = true;
                     continue;
                  case "NONE":
                     noneViewer = true;
                     continue;
                  case "ANY":
                     examineViewer = true;
                     walkViewer    = true;
                     flyViewer     = true;
                     planeViewer   = true;
                     noneViewer    = true;
                     lookAt        = true;
                     break;
                  default:
                     // Some string defaults to EXAMINE.
                     examineViewer = true;
                     continue;
               }

               break;
            }
         }

         this ._availableViewers .length = 0;

         if (examineViewer)
            this ._availableViewers .push ("EXAMINE");

         if (walkViewer)
            this ._availableViewers .push ("WALK");

         if (flyViewer)
            this ._availableViewers .push ("FLY");

         if (planeViewer)
            this ._availableViewers .push ("PLANE");

         if (lookAt)
            this ._availableViewers .push ("LOOKAT");

         if (noneViewer)
            this ._availableViewers .push ("NONE");
      },
      set_headlight__: function ()
      {
         if (this ._headlight .getValue ())
            delete this .enable;
         else
            this .enable = Function .prototype;
      },
      set_transitionStart__: function ()
      {
         if (! this ._transitionActive .getValue ())
            this ._transitionActive = true;
      },
      set_transitionComplete__: function ()
      {
         if (this ._transitionActive .getValue ())
            this ._transitionActive = false;
      },
      set_isBound__: function ()
      {
         if (this ._isBound .getValue ())
            return;

         if (this ._transitionActive .getValue ())
            this ._transitionActive = false;
      },
      enable: function (type, renderObject)
      {
         if (type !== TraverseType .DISPLAY)
            return;

         if (this ._headlight .getValue ())
            renderObject .getGlobalObjects () .push (renderObject .getBrowser () .getHeadlight ());
      },
      traverse: function (type, renderObject)
      {
         if (type !== TraverseType .CAMERA)
            return;

         renderObject .getLayer () .getNavigationInfos () .push (this);
      }
   });

   return NavigationInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Camera',[
   "standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

   return {
      frustum: function (l, r, b, t, n, f, matrix)
      {
         const
            r_l = r - l,
            t_b = t - b,
            f_n = f - n,
            n_2 = 2 * n,

            A = (r + l) / r_l,
            B = (t + b) / t_b,
            C = -(f + n) / f_n,
            D = -(n_2 * f) / f_n,
            E = n_2 / r_l,
            F = n_2 / t_b;

         return matrix .set (E, 0, 0, 0,
                             0, F, 0, 0,
                             A, B, C, -1,
                             0, 0, D, 0);
      },
      perspective: function (fieldOfView, zNear, zFar, width, height, matrix)
      {
         const ratio = Math .tan (fieldOfView / 2) * zNear;

         if (width > height)
         {
            const aspect = width * ratio / height;
            return this .frustum (-aspect, aspect, -ratio, ratio, zNear, zFar, matrix);
         }
         else
         {
            const aspect = height * ratio / width;
            return this .frustum (-ratio, ratio, -aspect, aspect, zNear, zFar, matrix);
         }
      },
      perspective2: function (fieldOfView, zNear, zFar, width, height, matrix)
      {
         const ratio = Math .tan (fieldOfView / 2) * zNear;

         return this .frustum (-ratio, ratio, -ratio, ratio, zNear, zFar, matrix);
      },
      ortho: function (l, r, b, t, n, f, matrix)
      {
         const
            r_l = r - l,
            t_b = t - b,
            f_n = f - n,

            A =  2 / r_l,
            B =  2 / t_b,
            C = -2 / f_n,
            D = -(r + l) / r_l,
            E = -(t + b) / t_b,
            F = -(f + n) / f_n;

         return matrix .set (A, 0, 0, 0,
                             0, B, 0, 0,
                             0, 0, C, 0,
                             D, E, F, 1);
      },
      orthoBox: (function ()
      {
         const
            min = new Vector3 (0, 0, 0),
            max = new Vector3 (0, 0, 0);

         return function (box, matrix)
         {
            box .getExtents (min, max);

            return this .ortho (min .x, max .x, min .y, max .y, -max .z, -min .z, matrix);
         };
      })(),
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geospatial/GeoViewpoint',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Navigation/X3DViewpointNode",
   "x_ite/Components/Geospatial/X3DGeospatialObject",
   "x_ite/Components/Interpolation/ScalarInterpolator",
   "x_ite/Components/Navigation/NavigationInfo",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Camera",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewpointNode,
          X3DGeospatialObject,
          ScalarInterpolator,
          NavigationInfo,
          X3DConstants,
          Camera,
          Vector2,
          Vector3,
          Rotation4,
          Matrix4,
          Algorithm)
{
"use strict";

   function traverse (type, renderObject)
   {
      X3DViewpointNode .prototype .traverse .call (this, type, renderObject);

      this .navigationInfoNode .traverse (type, renderObject);
   }

   function GeoViewpoint (executionContext)
   {
      X3DViewpointNode    .call (this, executionContext);
      X3DGeospatialObject .call (this, executionContext);

      this .addType (X3DConstants .GeoViewpoint);

      this ._centerOfRotation .setUnit ("length");
      this ._fieldOfView      .setUnit ("angle");

      this .navigationInfoNode      = new NavigationInfo (executionContext);
      this .fieldOfViewInterpolator = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
      this .projectionMatrix        = new Matrix4 ();
      this .elevation               = 0;

      switch (executionContext .specificationVersion)
      {
         case "2.0":
         case "3.0":
         case "3.1":
         case "3.2":
            this .traverse = traverse;
            break;
      }
   }

   GeoViewpoint .prototype = Object .assign (Object .create (X3DViewpointNode .prototype),
      X3DGeospatialObject .prototype,
   {
      constructor: GeoViewpoint,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "geoOrigin",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "geoSystem",         new Fields .MFString ("GD", "WE")),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_bind",          new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "description",       new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "position",          new Fields .SFVec3d (0, 0, 100000)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "orientation",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "centerOfRotation",  new Fields .SFVec3d ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fieldOfView",       new Fields .SFFloat (0.7854)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "jump",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "retainUserOffsets", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "navType",           new Fields .MFString ("EXAMINE", "ANY")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "headlight",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "speedFactor",       new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isBound",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "bindTime",          new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "GeoViewpoint";
      },
      getComponentName: function ()
      {
         return "Geospatial";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DViewpointNode    .prototype .initialize .call (this);
         X3DGeospatialObject .prototype .initialize .call (this);

         this ._position       .addInterest ("set_position__", this);
         this ._positionOffset .addInterest ("set_position__", this);
         this ._navType        .addFieldInterest (this .navigationInfoNode ._type);
         this ._headlight      .addFieldInterest (this .navigationInfoNode ._headlight);

         this .navigationInfoNode .setup ();

         this .set_position__ ();

         // Setup interpolators

         this .fieldOfViewInterpolator ._key = [ 0, 1 ];
         this .fieldOfViewInterpolator .setup ();

         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewInterpolator ._set_fraction);
         this .fieldOfViewInterpolator ._value_changed .addFieldInterest (this ._fieldOfViewScale);
      },
      setInterpolators: function (fromViewpointNode, toViewpointNode)
      {
         if (fromViewpointNode .getType () .indexOf (X3DConstants .Viewpoint) >= 0)
         {
            const scale = fromViewpointNode .getFieldOfView () / toViewpointNode .getFieldOfView ();

            this .fieldOfViewInterpolator ._keyValue = new Fields .MFFloat (scale, toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewScale = scale;
         }
         else
         {
            this .fieldOfViewInterpolator ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewScale = toViewpointNode ._fieldOfViewScale .getValue ();
         }
      },
      setPosition: (function ()
      {
         var geoPosition = new Vector3 (0, 0, 0);

         return function (value)
         {
            this ._position .setValue (this .getGeoCoord (value, geoPosition));
         };
      })(),
      getPosition: (function ()
      {
         var position = new Vector3 (0, 0, 0);

         return function ()
         {
            return this .getCoord (this ._position .getValue (), position);
         };
      })(),
      set_position__: (function ()
      {
         var position = new Vector3 (0, 0, 0);

         return function ()
         {
            this .getCoord (this ._position .getValue (), position);

            this .elevation = this .getGeoElevation (position .add (this ._positionOffset .getValue ()));
         };
      })(),
      setOrientation: (function ()
      {
         var
            locationMatrix = new Matrix4 (),
            geoOrientation = new Rotation4 (0, 0, 1, 0);

         return function (value)
         {
            ///  Returns the resulting orientation for this viewpoint.

            var rotationMatrix = this .getLocationMatrix (this ._position .getValue (), locationMatrix) .submatrix;

            geoOrientation .setMatrix (rotationMatrix);

            this ._orientation .setValue (geoOrientation .inverse () .multLeft (value));
         };
      })(),
      getOrientation: (function ()
      {
         var
            locationMatrix = new Matrix4 (),
            orientation    = new Rotation4 (0, 0, 1, 0);

         return function ()
         {
            ///  Returns the resulting orientation for this viewpoint.

            var rotationMatrix = this .getLocationMatrix (this ._position .getValue (), locationMatrix) .submatrix;

            orientation .setMatrix (rotationMatrix);

            return orientation .multLeft (this ._orientation .getValue ());
         };
      })(),
      getCenterOfRotation: (function ()
      {
         var centerOfRotation = new Vector3 (0, 0, 0);

         return function ()
         {
            return this .getCoord (this ._centerOfRotation .getValue (), centerOfRotation);
         };
      })(),
      getFieldOfView: function ()
      {
         var fov = this ._fieldOfView * this ._fieldOfViewScale;

         return fov > 0 && fov < Math .PI ? fov : Math .PI / 4;
      },
      getMaxFarValue: function ()
      {
         return this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer") ? 1e10 : 1e9;
      },
      getUpVector: (function ()
      {
         var
            position = new Vector3 (0, 0, 0),
            upVector = new Vector3 (0, 0, 0);

         return function ()
         {
            this .getCoord (this ._position .getValue (), position);

            return this .getGeoUpVector .call (this, position .add (this ._positionOffset .getValue ()), upVector);
         };
      })(),
      getSpeedFactor: function ()
      {
         return (Math .max (this .elevation, 0.0) + 10) / 10 * this ._speedFactor .getValue ();
      },
      getScreenScale: (function ()
      {
         var screenScale = new Vector3 (0, 0, 0);

         return function (point, viewport)
         {
            // Returns the screen scale in meter/pixel for on pixel.

            var
               width  = viewport [2],
               height = viewport [3],
               size   = Math .abs (point .z) * Math .tan (this .getFieldOfView () / 2) * 2;

            if (width > height)
               size /= height;
            else
               size /= width;

            return screenScale .set (size, size, size);
         };
      })(),
      getViewportSize: (function ()
      {
         var viewportSize = new Vector2 (0, 0);

         return function (viewport, nearValue)
         {
            var
               width  = viewport [2],
               height = viewport [3],
               size   = nearValue * Math .tan (this .getFieldOfView () / 2) * 2,
               aspect = width / height;

            if (aspect > 1)
               return viewportSize .set (size * aspect, size);

            return viewportSize .set (size, size / aspect);
         };
      })(),
      getLookAtDistance: function (bbox)
      {
         return (bbox .size .abs () / 2) / Math .tan (this .getFieldOfView () / 2);
      },
      getProjectionMatrixWithLimits: function (nearValue, farValue, viewport, limit)
      {
         if (limit || this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer"))
            return Camera .perspective (this .getFieldOfView (), nearValue, farValue, viewport [2], viewport [3], this .projectionMatrix);

         // Linear interpolate nearValue and farValue

         var
            geoZNear = Math .max (Algorithm .lerp (Math .min (nearValue, 1e4), 1e4, this .elevation / 1e7), 1),
            geoZFar  = Math .max (Algorithm .lerp (1e6, Math .max (farValue, 1e6),  this .elevation / 1e7), 1e6);

         return Camera .perspective (this .getFieldOfView (), geoZNear, geoZFar, viewport [2], viewport [3], this .projectionMatrix);
      },
   });

   return GeoViewpoint;
});

define ('lib/jquery.fullscreen-min',[
   "jquery",
],
function (jQuery)
{
/*
 jquery.fullscreen 1.1.5
 https://github.com/kayahr/jquery-fullscreen-plugin
 Copyright (C) 2012-2013 Klaus Reimer <k@ailis.de>
 Licensed under the MIT license
 (See http://www.opensource.org/licenses/mit-license)
*/
function d(c){var b,a;if(!this.length)return this;b=this[0];b.ownerDocument?a=b.ownerDocument:(a=b,b=a.documentElement);if(null==c){if(!a.exitFullscreen&&!a.webkitExitFullscreen&&!a.webkitCancelFullScreen&&!a.msExitFullscreen&&!a.mozCancelFullScreen)return null;c=!!a.fullscreenElement||!!a.msFullscreenElement||!!a.webkitIsFullScreen||!!a.mozFullScreen;return!c?c:a.fullscreenElement||a.webkitFullscreenElement||a.webkitCurrentFullScreenElement||a.msFullscreenElement||a.mozFullScreenElement||c}c?(c=
b.requestFullscreen||b.webkitRequestFullscreen||b.webkitRequestFullScreen||b.msRequestFullscreen||b.mozRequestFullScreen)&&c.call(b):(c=a.exitFullscreen||a.webkitExitFullscreen||a.webkitCancelFullScreen||a.msExitFullscreen||a.mozCancelFullScreen)&&c.call(a);return this}jQuery.fn.fullScreen=d;jQuery.fn.toggleFullScreen=function(){return d.call(this,!d.call(this))};var e,f,g;e=document;
e.webkitCancelFullScreen?(f="webkitfullscreenchange",g="webkitfullscreenerror"):e.msExitFullscreen?(f="MSFullscreenChange",g="MSFullscreenError"):e.mozCancelFullScreen?(f="mozfullscreenchange",g="mozfullscreenerror"):(f="fullscreenchange",g="fullscreenerror");jQuery(document).bind(f,function(){jQuery(document).trigger(new jQuery.Event("fullscreenchange"))});jQuery(document).bind(g,function(){jQuery(document).trigger(new jQuery.Event("fullscreenerror"))});

});

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('jquery-mousewheel/jquery.mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

define('jquery-mousewheel', ['jquery-mousewheel/jquery.mousewheel'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/ContextMenu',[
   "jquery",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Geospatial/GeoViewpoint",
   "locale/gettext",
   "lib/jquery.fullscreen-min",
   "jquery-mousewheel",
],
function ($,
          X3DBaseNode,
          GeoViewpoint,
          _)
{
"use strict";

   const _userMenu = Symbol ();

   function ContextMenu (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this [_userMenu] = null;
   }

   ContextMenu .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: ContextMenu,
      getTypeName: function ()
      {
         return "ContextMenu";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "contextMenu";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         const browser = this .getBrowser ();

         this .init ({
            element: browser .getElement (),
            appendTo: browser .getShadow (),
            build: this .build .bind (this),
            animation: {duration: 500, show: "fadeIn", hide: "fadeOut"},
         });
      },
      getUserMenu: function ()
      {
         return this [_userMenu];
      },
      setUserMenu: function (userMenu)
      {
         this [_userMenu] = userMenu;
      },
      createUserMenu: function ()
      {
         const userMenu = { };

         if (typeof this [_userMenu] === "function")
         {
            const menu = this [_userMenu] ();

            if ($.isPlainObject (menu))
            {
               for (const key in menu)
                  userMenu ["user-" + key] = menu [key];
            }
         }

         return userMenu;
      },
      build: function (event)
      {
         const
            browser          = this .getBrowser (),
            activeLayer      = browser .getActiveLayer (),
            currentViewpoint = activeLayer ? activeLayer .getViewpoint () : null,
            fullscreen       = browser .getElement () .fullScreen ();

         if (! browser .getBrowserOptions () .getContextMenu ())
            return;

         const menu = {
            className: "x_ite-private-menu",
            items: {
               "title": {
                  name: browser .getName () + " Browser v" + browser .getVersion (),
                  className: "context-menu-title context-menu-not-selectable",
               },
               "separator0": "--------",
               "viewpoints": {
                  name: _("Viewpoints"),
                  className: "context-menu-icon x_ite-private-icon-viewpoint",
                  items: this .getViewpoints (),
               },
               "available-viewers": {
                  name: _("Available Viewers"),
                  items: this .getAvailableViewers (),
               },
               "separator1": "--------",
               "straighten-horizon": {
                  name: _("Straighten Horizon"),
                  type: "checkbox",
                  selected: browser .getBrowserOption ("StraightenHorizon"),
                  events: {
                     click: function (event)
                     {
                        const straightenHorizon = $(event .target) .is (":checked");

                        browser .setBrowserOption ("StraightenHorizon", straightenHorizon);

                        if (straightenHorizon)
                        {
                           browser .getNotification () ._string = _("Straighten Horizon") + ": " + _("on");

                           const activeViewpoint = browser .getActiveViewpoint ();

                           if (activeViewpoint)
                              activeViewpoint .straighten (browser .getActiveLayer (), true);
                        }
                        else
                        {
                           browser .getNotification () ._string = _("Straighten Horizon") + ": " + _("off");
                        }
                     }
                     .bind (this),
                  },
               },
               "separator2": "--------",
               "primitive-quality": {
                  name: _("Primitive Quality"),
                  className: "context-menu-icon x_ite-private-icon-primitive-quality",
                  items: {
                     "high": {
                        name: _("High"),
                        type: "radio",
                        radio: "primitive-quality",
                        selected: browser .getBrowserOption ("PrimitiveQuality") === "HIGH",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("PrimitiveQuality", "HIGH");
                              browser .getNotification () ._string = _("Primitive Quality") + ": " + _("high");
                           }
                           .bind (this),
                        },
                     },
                     "medium": {
                        name: _("Medium"),
                        type: "radio",
                        radio: "primitive-quality",
                        selected: browser .getBrowserOption ("PrimitiveQuality") === "MEDIUM",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("PrimitiveQuality", "MEDIUM");
                              browser .getNotification () ._string = _("Primitive Quality") + ": " + _("medium");
                           }
                           .bind (this),
                        },
                     },
                     "low": {
                        name: _("Low"),
                        type: "radio",
                        radio: "primitive-quality",
                        selected: browser .getBrowserOption ("PrimitiveQuality") === "LOW",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("PrimitiveQuality", "LOW");
                              browser .getNotification () ._string = _("Primitive Quality") + ": " + _("low");
                           }
                           .bind (this),
                        },
                     },
                  },
               },
               "texture-quality": {
                  name: _("Texture Quality"),
                  className: "context-menu-icon x_ite-private-icon-texture-quality",
                  items: {
                     "high": {
                        name: _("High"),
                        type: "radio",
                        radio: "texture-quality",
                        selected: browser .getBrowserOption ("TextureQuality") === "HIGH",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("TextureQuality", "HIGH");
                              browser .getNotification () ._string = _("Texture Quality") + ": " + _("high");
                           }
                           .bind (this),
                        },
                     },
                     "medium": {
                        name: _("Medium"),
                        type: "radio",
                        radio: "texture-quality",
                        selected: browser .getBrowserOption ("TextureQuality") === "MEDIUM",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("TextureQuality", "MEDIUM");
                              browser .getNotification () ._string = _("Texture Quality") + ": " + _("medium");
                           }
                           .bind (this),
                        },
                     },
                     "low": {
                        name: _("Low"),
                        type: "radio",
                        radio: "texture-quality",
                        selected: browser .getBrowserOption ("TextureQuality") === "LOW",
                        events: {
                           click: function ()
                           {
                              browser .setBrowserOption ("TextureQuality", "LOW");
                              browser .getNotification () ._string = _("Texture Quality") + ": " + _("low");
                           }
                           .bind (this),
                        },
                     },
                  },
               },
               "display-rubberband": {
                  name: _("Display Rubberband"),
                  type: "checkbox",
                  selected: browser .getBrowserOption ("Rubberband"),
                  events: {
                     click: function (event)
                     {
                        const rubberband = $(event .target) .is (":checked");

                        browser .setBrowserOption ("Rubberband", rubberband);

                        if (rubberband)
                           browser .getNotification () ._string = _("Rubberband") + ": " + _("on");
                        else
                           browser .getNotification () ._string = _("Rubberband") + ": " + _("off");
                     }
                     .bind (this),
                  },
               },
               "browser-timings": {
                  name: _("Browser Timings"),
                  type: "checkbox",
                  selected: browser .getBrowserOption ("Timings"),
                  events: {
                     click: function (event)
                     {
                        browser .setBrowserOption ("Timings", $(event .target) .is (":checked"));
                        browser .getSurface () .focus ();
                     }
                     .bind (this),
                  },
               },
               "fullscreen": {
                  name: fullscreen ? _("Leave Fullscreen") : _("Fullscreen"),
                  className: "context-menu-icon " + (fullscreen
                     ? "x_ite-private-icon-leave-fullscreen"
                     : "x_ite-private-icon-enter-fullscreen"),
                  callback: function ()
                  {
                     browser .getElement () .toggleFullScreen ();
                  }
                  .bind (this),
               },
               "separator3": "--------",
            },
         };

         Object .assign (menu .items, this .createUserMenu ());

         Object .assign (menu .items, {
            "separator4": "--------",
            "world-info": {
               name: _("Show World Info"),
               className: "context-menu-icon x_ite-private-icon-world-info",
               callback: function ()
               {
                  define .show ();

                  require (["https://cdn.jsdelivr.net/gh/showdownjs/showdown@1.9.1/dist/showdown.min.js"], function (showdown)
                  {
                     define .hide ();

                     browser .getShadow () .find (".x_ite-private-world-info") .remove ();

                     const
                        converter = new showdown .Converter (),
                        priv      = browser .getShadow () .find (".x_ite-private-browser"),
                        overlay   = $("<div></div>") .addClass ("x_ite-private-world-info-overlay") .appendTo (priv),
                        div       = $("<div></div>") .addClass ("x_ite-private-world-info") .appendTo (overlay),
                        worldInfo = browser .getExecutionContext () .getWorldInfos () [0],
                        title     = worldInfo .title,
                        info      = worldInfo .info;

                     converter .setOption ("omitExtraWLInCodeBlocks",            true);
                     converter .setOption ("simplifiedAutoLink",                 true);
                     converter .setOption ("excludeTrailingPunctuationFromURLs", true);
                     converter .setOption ("literalMidWordUnderscores",          true);
                     converter .setOption ("strikethrough",                      true);
                     converter .setOption ("openLinksInNewWindow",               false);

                     $("<div></div>") .addClass ("x_ite-private-world-info-top") .text ("World Info") .appendTo (div);

                     if (title .length)
                     {
                        $("<div></div>") .addClass ("x_ite-private-world-info-title") .text (title) .appendTo (div);
                     }

                     for (const line of info)
                     {
                        $("<div></div>") .addClass ("x_ite-private-world-info-info") .html (converter .makeHtml (line)) .appendTo (div);
                     }

                     div .find ("a") .on ("click", function (event) { event .stopPropagation (); });

                     // Open external link in new tab.
                     div .find ("a[href^=http]") .each (function ()
                     {
                        if (this .href .indexOf (location .hostname) !== -1)
                           return;

                        $(this) .attr ("target", "_blank");
                     });

                     overlay .on ("click", function () { overlay .remove (); });
                  })
               },
            },
            "about": {
               name: _("About X_ITE"),
               className: "context-menu-icon x_ite-private-icon-help-about",
               callback: function ()
               {
                  window .open (browser .getProviderUrl ());
               },
            },
         });

         if ($.isEmptyObject (menu .items .viewpoints .items))
            delete menu .items ["viewpoints"];

         if (Object .keys (menu .items ["available-viewers"] .items) .length < 2)
         {
            delete menu .items ["available-viewers"];
         }

         if (! browser .getCurrentViewer () .match (/^(?:EXAMINE|FLY)$/) || (currentViewpoint instanceof GeoViewpoint))
         {
            delete menu .items ["straighten-horizon"];
         }

         const worldInfo = browser .getExecutionContext () .getWorldInfos () [0];

         if (! worldInfo || (worldInfo .title .length === 0 && worldInfo .info .length === 0))
         {
            delete menu .items ["world-info"];
         }

         return menu;
      },
      getViewpoints: function ()
      {
         const
            browser     = this .getBrowser (),
            activeLayer = browser .getActiveLayer ();

         if (! activeLayer)
            return { };

         const
            enableInlineViewpoints = browser .getBrowserOption ("EnableInlineViewpoints"),
            currentScene           = browser .currentScene,
            viewpoints             = activeLayer .getViewpoints () .get (),
            currentViewpoint       = activeLayer .getViewpoint (),
            menu                   = { };

         for (const viewpoint of viewpoints)
         {
            const description = viewpoint ._description .getValue ();

            if (description === "")
               continue;

            if (! enableInlineViewpoints && viewpoint .getScene () !== currentScene)
               continue;

            const item = {
               name: description,
               callback: function (viewpoint)
               {
                  browser .bindViewpoint (browser .getActiveLayer (), viewpoint);
                  browser .getSurface () .focus ();
               }
               .bind (this, viewpoint),
            };

            if (viewpoint === currentViewpoint)
               item .className = "context-menu-selected";

            menu ["Viewpoint" + viewpoint .getId ()] = item;
         }

         return menu;
      },
      getAvailableViewers: function ()
      {
         const
            browser          = this .getBrowser (),
            currentViewer    = browser ._viewer .getValue (),
            availableViewers = browser ._availableViewers,
            menu             = { };

         for (const viewer of availableViewers)
         {
            menu [viewer] = {
               name: _(this .getViewerName (viewer)),
               className: "context-menu-icon x_ite-private-icon-" + viewer .toLowerCase () + "-viewer",
               callback: function (viewer)
               {
                  browser ._viewer = viewer;
                  browser .getNotification () ._string = _(this .getViewerName (viewer));
                  browser .getSurface () .focus ();
               }
               .bind (this, viewer),
            };

            if (viewer === currentViewer)
               menu [viewer] .className += " context-menu-selected";
         }

         return menu;
      },
      getViewerName: function (viewer)
      {
         switch (viewer)
         {
            case "EXAMINE":
               return _("Examine Viewer");
            case "WALK":
               return _("Walk Viewer");
            case "FLY":
               return _("Fly Viewer");
            case "PLANE":
               return _("Plane Viewer");
            case "LOOKAT":
               return _("Look At Viewer");
            case "NONE":
               return _("None Viewer");
         }
      },
      init: function (options)
      {
         this .show = this .createRoot .bind (this, options);

         options .element .on ("contextmenu", this .show);
      },
      show: function (event)
      { },
      hide: function (event)
      { },
      createRoot: function (options, event)
      {
         const
            menu  = options .build (event),
            level = 1;

         if (! menu) return;

         // Layer

         const layer = $("<div></div>")
            .addClass ("context-menu-layer")
            .addClass (menu .className)
            .appendTo (options .appendTo);

         const hide = this .hide = function ()
         {
            delete this .hide;

            layer .remove ();

            ul [options .animation .hide] (options .animation .duration, function ()
            {
               ul .remove ();

               if (options .events && typeof options .events .hide === "function")
                  options .events .hide ();
            });

            return false;
         }
         .bind (this);

         // Menu

         const
            x = event .pageX - $(document) .scrollLeft (),
            y = event .pageY - $(document) .scrollTop ();

         const ul = $("<ul></ul>")
            .hide ()
            .addClass ("context-menu-list")
            .addClass (menu .className)
            .addClass ("context-menu-root")
            .css ({ "left": x, "top": y })
            .appendTo (layer);

         for (const k in menu .items)
            ul .append (this .createItem (menu .items [k], "context-menu-root", k, level + 1, hide));

         ul [options .animation .show] (options .animation .duration);

         // Reposition menu if to right or to low.

         if (ul .offset () .left - $(document) .scrollLeft () + ul .outerWidth () > $(window) .width ())
            ul .offset ({ "left":  $(document) .scrollLeft () + Math .max (0, $(window) .width () - ul .outerWidth ()) });

         if (ul .offset () .top - $(document) .scrollTop () + ul .outerHeight () > $(window) .height ())
            ul .offset ({ "top": $(document) .scrollTop () + Math .max (0, $(window) .height () - ul .outerHeight ()) });

         // Display submenus on the left or right side.
         // If the submenu is higher than vh, add scrollbars.

         ul .find ("ul") .each (function (i, e)
         {
            e = $(e);

            const
               width    = e .outerWidth () + ul .outerWidth (),
               position = ul .offset () .left - $(document) .scrollLeft () + width > $(window) .width () ? "right" : "left";

            e .css ("width", e .outerWidth ());
            e .css (position, e .parent () .closest ("ul") .width ());

            if (e .outerHeight () >= $(window) .height ())
               e .css ({ "max-height": "100vh", "overflow-y": "scroll" });
         });

         // If the submenu is higher than vh, reposition it.

         ul .find ("li") .on ("mouseenter touchstart", function (event)
         {
            event .stopImmediatePropagation ();

            const
               t = $(event .target) .closest ("li"),
               e = t .children ("ul");

            if (! e .length)
               return;

            e .css ("top", "");

            const bottom = e .offset () .top + e .outerHeight () - $(window) .scrollTop () - $(window) .height ();

            if (bottom > 0)
               e .offset ({ "top": e .offset () .top - bottom });
         });

         // Layer

         layer .on ("click contextmenu", hide);
         ul .on ("contextmenu", hide);

         // Show

         if (options .events && typeof options .events .show === "function")
            options .events .show (ul);

         return false;
      },
      createItem: function (item, parent, key, level, hide)
      {
         const li = $("<li></li>") .addClass ("context-menu-item");

         switch (typeof item)
         {
            case "string":
            {
               if (item .match (/^-+$/))
                  li .addClass (["context-menu-separator", "context-menu-not-selectable"]);

               break;
            }
            case "object":
            {
               if (item .className)
                  li .addClass (item .className);

               switch (item .type)
               {
                  case "radio":
                  case "checkbox":
                  {
                     const
                        label = $("<label></label>") .appendTo (li),
                        input = $("<input></input>") .appendTo (label);

                     input
                        .attr ("type", item .type)
                        .attr ("name", "context-menu-input-" + parent);

                     $("<span></span>") .text (item .name) .appendTo (label);

                     if (item .selected)
                        input .attr ("checked", "checked");

                     for (const key in item .events)
                     {
                        if (typeof item .events [key] === "function")
                           input .on (key, item .events [key]);
                     }

                     li .addClass ("context-menu-input");

                     break;
                  }
                  default:
                  {
                     if (item .name)
                        $("<span></span>") .text (item .name) .appendTo (li);

                     if (typeof item .callback === "function")
                        li .on ("click", item .callback) .on ("click", hide);

                     break;
                  }
               }

               break;
            }
         }

         if (typeof item .items === "object" && level < 3)
         {
            const ul = $("<ul></ul>")
               .addClass ("context-menu-list")
               .css ({ "z-index": level })
               .appendTo (li);

            for (const k in item .items)
               ul .append (this .createItem (item .items [k], key, k, level + 1, hide));

            li .addClass ("context-menu-submenu");
         }

         return li;
      },
   });

   return ContextMenu;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of the X_ITE Project.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains "non-military use only" components.
 *
 * Copyright 2016 Andreas Plesch.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/HTMLSupport',[],function ()
{
"use strict";

   // Maps are set when component is registered.

   const
      nodeTypeNames = new Map (), // (TYPENAME -> TypeName)
      fieldNames    = new Map (); // (fieldname -> fieldName)

   const HTMLSupport =
   {
      addNodeTypeName: function (typeName)
      {
         nodeTypeNames .set (typeName,                 typeName);
         nodeTypeNames .set (typeName .toUpperCase (), typeName);
      },
      getNodeTypeName: function (typeName)
      {
         return nodeTypeNames .get (typeName);
      },
      addFieldName: function (name)
      {
         fieldNames .set (name,                 name);
         fieldNames .set (name .toLowerCase (), name);
      },
      getFieldName: function (name)
      {
         return fieldNames .get (name);
      },
   };

   return HTMLSupport;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedNodes',[
   "x_ite/Base/X3DConstants",
   "x_ite/Parser/HTMLSupport",
],
function (X3DConstants,
          HTMLSupport)
{
"use strict";

   const
      types         = new Map (),
      abstractTypes = new Map ();

   let nodeType = X3DConstants .X3DBaseNode;

   function SupportedNodes () { }

   SupportedNodes .prototype =
   {
      addType: function (typeName, Type)
      {
         X3DConstants [typeName] = ++ nodeType; // Start with 1, as X3DBaseNode is 0.

         types .set (typeName, Type);

         HTMLSupport .addNodeTypeName (typeName);

         // HTMLSupport

         for (const fieldDefinition of Type .prototype [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")])
         {
            const
               name       = fieldDefinition .name,
               accessType = fieldDefinition .accessType;

            if (accessType & X3DConstants .initializeOnly)
               HTMLSupport .addFieldName (name)
         }
      },
      getType: function (typeName)
      {
         return types .get (typeName);
      },
      getTypes ()
      {
         return Array .from (types .values ());
      },
      addAbstractType: function (typeName, Type)
      {
         X3DConstants [typeName] = ++ nodeType;

         abstractTypes .set (typeName, Type);
      },
      getAbstractType: function (typeName)
      {
         return abstractTypes .get (typeName);
      },
      getAbstractTypes ()
      {
         return Array .from (abstractTypes .values ());
      },
   };

   for (const key of Reflect .ownKeys (SupportedNodes .prototype))
      Object .defineProperty (SupportedNodes .prototype, key, { enumerable: false });

   return new SupportedNodes ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/NamedNodesArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function NamedNodesArray (array)
   {
      return X3DInfoArray .call (this, array);
   }

   NamedNodesArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: NamedNodesArray,
      getTypeName: function ()
      {
         return "NamedNodesArray";
      },
   });

   for (const key of Reflect .ownKeys (NamedNodesArray .prototype))
      Object .defineProperty (NamedNodesArray .prototype, key, { enumerable: false });

   return NamedNodesArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3dNode',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (Fields,
          X3DBaseNode,
          X3DConstants,
          Generator)
{
"use strict";

   function X3DNode (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addType (X3DConstants .X3DNode);
   }

   X3DNode .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DNode,
      copy: function (instance)
      {
         if (!instance || instance .getType () .includes (X3DConstants .X3DExecutionContext))
         {
            return X3DBaseNode .prototype .copy .call (this, instance);
         }
         else
         {
            const executionContext = instance .getBody ();

            // First try to get a named node with the node's name.

            if (this .getName () .length)
            {
               const namedNode = executionContext .getNamedNodes () .get (this .getName ());

               if (namedNode)
                  return namedNode;
            }

            // Create copy.

            const copy = this .create (executionContext);

            if (this .getNeedsName ())
               this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (), this);

            if (this .getName () .length)
               executionContext .updateNamedNode (this .getName (), copy);

            // Default fields

            for (const sourceField of this .getPredefinedFields ())
            {
               try
               {
                  const destinationField = copy .getField (sourceField .getName ());

                  if (sourceField .hasReferences ())
                  {
                     // IS relationship

                     for (const originalReference of sourceField .getReferences ())
                     {
                        try
                        {
                           destinationField .addReference (instance .getField (originalReference .getName ()));
                        }
                        catch (error)
                        {
                           console .error (error .message);
                        }
                     }
                  }
                  else
                  {
                     if (sourceField .getAccessType () & X3DConstants .initializeOnly)
                     {
                        switch (sourceField .getType ())
                        {
                           case X3DConstants .SFNode:
                           case X3DConstants .MFNode:
                              destinationField .assign (sourceField .copy (instance));
                              break;
                           default:
                              destinationField .assign (sourceField);
                              break;
                        }
                     }
                  }

                  destinationField .setModificationTime (sourceField .getModificationTime ());
               }
               catch (error)
               {
                  console .log (error .message);
               }
            }

            // User-defined fields

            for (const sourceField of this .getUserDefinedFields ())
            {
               const destinationField = sourceField .copy (instance);

               copy .addUserDefinedField (sourceField .getAccessType (),
                                          sourceField .getName (),
                                          destinationField);

               if (sourceField .hasReferences ())
               {
                  // IS relationship

                  for (const originalReference of sourceField .getReferences ())
                  {
                     try
                     {
                        destinationField .addReference (instance .getField (originalReference .getName ()));
                     }
                     catch (error)
                     {
                        console .error ("No reference '" + originalReference .getName () + "' inside execution context " + instance .getTypeName () + " '" + instance .getName () + "'.");
                     }
                  }
               }

               destinationField .setModificationTime (sourceField .getModificationTime ());
            }

            copy .setup ();

            return copy;
         }
      },
      getDisplayName: (function ()
      {
         const _TrailingNumber = /_\d+$/;

         return function ()
         {
            return this .getName () .replace (_TrailingNumber, "");
         };
      })(),
      getNeedsName: function ()
      {
         if (this .getName () .length)
            return false;

         if (this .getCloneCount () > 1)
            return true;

         if (this .hasRoutes ())
            return true;

         const executionContext = this .getExecutionContext ()

         for (const importedNode of executionContext .getImportedNodes ())
         {
            if (importedNode .getInlineNode () === this)
               return true;
         }

         if (executionContext .isScene ())
         {
            for (const exportedNode of executionContext .getExportedNodes ())
            {
               if (exportedNode .getLocalNode () === this)
                  return true;
            }
         }

         return false;
      },
      getFieldsAreEnumerable: function ()
      {
         return true;
      },
      traverse: function () { },
      toStream: function (stream)
      {
         stream .string += this .getTypeName () + " { }";
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         generator .EnterScope ();

         const name = generator .Name (this);

         if (name .length)
         {
            if (generator .ExistsNode (this))
            {
               stream .string += "USE";
               stream .string += " ";
               stream .string += name;

               generator .LeaveScope ();
               return;
            }
         }

         if (name .length)
         {
            generator .AddNode (this);

            stream .string += "DEF";
            stream .string += " ";
            stream .string += name;
            stream .string += " ";
         }

         stream .string += this .getTypeName ();
         stream .string += " ";
         stream .string += "{";

         const
            fields            = this .getChangedFields (),
            userDefinedFields = this .getUserDefinedFields ();

         let
            fieldTypeLength  = 0,
            accessTypeLength = 0;

         if (this .canUserDefinedFields ())
         {
            for (const field of userDefinedFields)
            {
               fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
               accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
            }

            if (userDefinedFields .length)
            {
               stream .string += "\n";
               generator .IncIndent ();

               for (const field of userDefinedFields)
               {
                  this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);

                  stream .string += "\n";
               }

               generator .DecIndent ();

               if (fields .length !== 0)
                  stream .string += "\n";
            }
         }

         if (fields .length === 0)
         {
            if (userDefinedFields .length)
               stream .string += generator .Indent ();
            else
               stream .string += " ";
         }
         else
         {
            if (userDefinedFields .length === 0)
               stream .string += "\n";

            generator .IncIndent ();

            fields .forEach (function (field)
            {
               this .toVRMLStreamField (stream, field, fieldTypeLength, accessTypeLength);

               stream .string += "\n";
            },
            this);

            generator .DecIndent ();
            stream .string += generator .Indent ();
         }

         stream .string += "}";

         generator .LeaveScope ();
      },
      toVRMLStreamField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
         {
            if (field .isInitializable ())
            {
               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
         else
         {
            let
               index                  = 0,
               initializableReference = false;

            field .getReferences () .forEach (function (reference)
            {
               initializableReference = initializableReference || reference .isInitializable ();

               // Output build in reference field

               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";
               stream .string += "IS";
               stream .string += " ";
               stream .string += reference .getName ();

               ++ index;

               if (index !== field .getReferences () .size)
                  stream .string += "\n";
            });

            if (field .getAccessType () === X3DConstants .inputOutput && !initializableReference && !this .isDefaultValue (field))
            {
               // Output build in field

               stream .string += "\n";
               stream .string += generator .Indent ();
               stream .string += field .getName ();
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
      },
      toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode)
         {
            stream .string += generator .Indent ();
            stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
            stream .string += " ";
            stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
            stream .string += " ";
            stream .string += field .getName ();

            if (field .isInitializable ())
            {
               stream .string += " ";

               field .toVRMLStream (stream);
            }
         }
         else
         {
            let
               index                  = 0,
               initializableReference = false;

            field .getReferences () .forEach (function (reference)
            {
               initializableReference = initializableReference || reference .isInitializable ();

               // Output user defined reference field

               stream .string += generator .Indent ();
               stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
               stream .string += " ";
               stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
               stream .string += " ";
               stream .string += field .getName ();
               stream .string += " ";
               stream .string += "IS";
               stream .string += " ";
               stream .string += reference .getName ();

               ++ index;

               if (index !== field .getReferences () .size)
                  stream .string += "\n";
            });

            if (field .getAccessType () === X3DConstants .inputOutput && !initializableReference && !field .isDefaultValue ())
            {
               stream .string += "\n";
               stream .string += generator .Indent ();
               stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
               stream .string += " ";
               stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
               stream .string += " ";
               stream .string += field .getName ();

               if (field .isInitializable ())
               {
                  stream .string += " ";

                  field .toVRMLStream (stream);
               }
            }
         }
      },
      toXMLStream: function (stream)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         generator .EnterScope ();

         const name = generator .Name (this);

         if (name .length)
         {
            if (generator .ExistsNode (this))
            {
               stream .string += generator .Indent ();
               stream .string += "<";
               stream .string += this .getTypeName ();
               stream .string += " ";
               stream .string += "USE='";
               stream .string += generator .XMLEncode (name);
               stream .string += "'";

               const containerField = generator .ContainerField ();

               if (containerField)
               {
                  if (containerField .getName () !== this .getContainerField ())
                  {
                     stream .string += " ";
                     stream .string += "containerField='";
                     stream .string += generator .XMLEncode (containerField .getName ());
                     stream .string += "'";
                  }
               }

               stream .string += "/>";

               generator .LeaveScope ();
               return;
            }
         }

         stream .string += generator .Indent ();
         stream .string += "<";
         stream .string += this .getTypeName ();

         if (name .length)
         {
            generator .AddNode (this);

            stream .string += " ";
            stream .string += "DEF='";
            stream .string += generator .XMLEncode (name);
            stream .string += "'";
         }

         const containerField = generator .ContainerField ();

         if (containerField)
         {
            if (containerField .getName () !== this .getContainerField ())
            {
               stream .string += " ";
               stream .string += "containerField='";
               stream .string += generator .XMLEncode (containerField .getName ());
               stream .string += "'";
            }
         }

         const
            fields            = this .getChangedFields (),
            userDefinedFields = this .getUserDefinedFields ();

         const
            references = [ ],
            childNodes = [ ];

         let cdata = this .getSourceText ();

         if (cdata && cdata .length === 0)
            cdata = null;

         generator .IncIndent ();
         generator .IncIndent ();

         for (const field of fields)
         {
            // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
            // for this field.

            let mustOutputValue = false;

            if (generator .ExecutionContext ())
            {
               if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
               {
                  let initializableReference = false;

                  field .getReferences () .forEach (function (fieldReference)
                  {
                     initializableReference = initializableReference || fieldReference .isInitializable ();
                  });

                  if (!initializableReference)
                     mustOutputValue = !this .isDefaultValue (field);
               }
            }

            // If we have no execution context we are not in a proto and must not generate IS references the same is true
            // if the node is a shared node as the node does not belong to the execution context.

            if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode || mustOutputValue)
            {
               if (mustOutputValue)
                  references .push (field);

               if (field .isInitializable ())
               {
                  switch (field .getType ())
                  {
                     case X3DConstants .SFNode:
                     case X3DConstants .MFNode:
                     {
                        childNodes .push (field);
                        break;
                     }
                     default:
                     {
                        if (field === cdata)
                           break;

                        stream .string += "\n";
                        stream .string += generator .Indent ();
                        stream .string += field .getName ();
                        stream .string += "='";

                        field .toXMLStream (stream);

                        stream .string += "'";
                        break;
                     }
                  }
               }
            }
            else
            {
               references .push (field);
            }
         }

         generator .DecIndent ();
         generator .DecIndent ();

         if ((!this .canUserDefinedFields () || !userDefinedFields .length) && (!references .length || sharedNode) && !childNodes .length && !cdata)
         {
            stream .string += "/>";
         }
         else
         {
            stream .string += ">\n";

            generator .IncIndent ();

            if (this .canUserDefinedFields ())
            {
               for (const field of userDefinedFields)
               {
                  stream .string += generator .Indent ();
                  stream .string += "<field";
                  stream .string += " ";
                  stream .string += "accessType='";
                  stream .string += generator .AccessType (field .getAccessType ());
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "type='";
                  stream .string += field .getTypeName ();
                  stream .string += "'";
                  stream .string += " ";
                  stream .string += "name='";
                  stream .string += generator .XMLEncode (field .getName ());
                  stream .string += "'";

                  // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
                  // for this field.

                  let mustOutputValue = false;

                  if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
                  {
                     let initializableReference = false;

                     field .getReferences () .forEach (function (fieldReference)
                     {
                        initializableReference = initializableReference || fieldReference .isInitializable ();
                     });

                     if (!initializableReference)
                        mustOutputValue = true;
                  }

                  if ((field .getReferences () .size === 0 || !generator .ExecutionContext ()) || sharedNode || mustOutputValue)
                  {
                     if (mustOutputValue && generator .ExecutionContext ())
                        references .push (field);

                     if (!field .isInitializable () || field .isDefaultValue ())
                     {
                        stream .string += "/>\n";
                     }
                     else
                     {
                        // Output value

                        switch (field .getType ())
                        {
                           case X3DConstants .SFNode:
                           case X3DConstants .MFNode:
                           {
                              generator .PushContainerField (field);

                              stream .string += ">\n";

                              generator .IncIndent ();

                              field .toXMLStream (stream);

                              stream .string += "\n";

                              generator .DecIndent ();

                              stream .string += generator .Indent ();
                              stream .string += "</field>\n";

                              generator .PopContainerField ();
                              break;
                           }
                           default:
                           {
                              stream .string += " ";
                              stream .string += "value='";

                              field .toXMLStream (stream);

                              stream .string += "'";
                              stream .string += "/>\n";
                              break;
                           }
                        }
                     }
                  }
                  else
                  {
                     if (generator .ExecutionContext ())
                        references .push (field);

                     stream .string += "/>\n";
                  }
               }
            }

            if (references .length && !sharedNode)
            {
               stream .string += generator .Indent ();
               stream .string += "<IS>";
               stream .string += "\n";

               generator .IncIndent ();

               for (const field of references)
               {
                  const protoFields = field .getReferences ();

                  protoFields .forEach (function (protoField)
                  {
                     stream .string += generator .Indent ();
                     stream .string += "<connect";
                     stream .string += " ";
                     stream .string += "nodeField='";
                     stream .string += generator .XMLEncode (field .getName ());
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "protoField='";
                     stream .string += generator .XMLEncode (protoField .getName ());
                     stream .string += "'";
                     stream .string += "/>\n";
                  });
               }

               generator .DecIndent ();

               stream .string += generator .Indent ();
               stream .string += "</IS>\n";
            }

            for (const field of childNodes)
            {
               generator .PushContainerField (field);

               field .toXMLStream (stream);

               stream .string += "\n";

               generator .PopContainerField ();
            }

            if (cdata)
            {
               for (const value of cdata)
               {
                  stream .string += "<![CDATA[";
                  stream .string += generator .escapeCDATA (value);
                  stream .string += "]]>\n";
               }
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</";
            stream .string += this .getTypeName ();
            stream .string += ">";
         }

         generator .LeaveScope ();
      },
      dispose: function ()
      {
         const executionContext = this .getExecutionContext ();

         // Remove named node if any.

         if (this .getName ())
            executionContext .removeNamedNode (this .getName ())

         // Remove imported node if any.

         if (!executionContext .isMainScene ())
         {
            const parentContext = executionContext .getExecutionContext ();

            for (const importedNode of parentContext .getImportedNodes ())
            {
               try
               {
                  if (importedNode .getExportedNode () === this)
                     parentContext .removeImportedNode (importedNode .getImportedName ());
               }
               catch (error)
               {
                  //console .error (error);
               }
            }
         }

         // Remove exported node if any.

         if (executionContext .isScene ())
         {
            for (const exportedNode of executionContext .getExportedNodes ())
            {
               if (exportedNode .getLocalNode () === this)
                  executionContext .removeExportedNode (exportedNode .getExportedName ());
            }
         }

         // Remove routes from and to node if any, and dispose values of fields.

         for (const field of this .getFields ())
            field .dispose ();

         // Remove node from entire scene graph.

         for (const firstParent of new Set (this .getParents ()))
         {
            if (firstParent instanceof Fields .SFNode)
            {
               for (const secondParent of new Set (firstParent .getParents ()))
               {
                  if (secondParent instanceof Fields .MFNode)
                  {
                     const length = secondParent .length;

                     secondParent .erase (secondParent .remove (0, length, firstParent), length);
                  }
               }

               firstParent .setValue (null);
            }
         }

         // Call super.dispose, where fields get disposed.

         X3DBaseNode .prototype .dispose .call (this);
      },
   });

   return X3DNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DImportedNode',[
   "x_ite/Components/Core/X3dNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Fields/SFNodeCache",
   "x_ite/InputOutput/Generator",
],
function (X3dNode,
          X3DConstants,
          SFNodeCache,
          Generator)
{
"use strict";

   const
      _inlineNode   = Symbol (),
      _exportedName = Symbol (),
      _importedName = Symbol (),
      _routes       = Symbol ();

   function X3DImportedNode (executionContext, inlineNode, exportedName, importedName)
   {
      X3dNode .call (this, executionContext);

      this [_inlineNode]   = inlineNode;
      this [_exportedName] = exportedName;
      this [_importedName] = importedName;
      this [_routes]       = new Set ();

      this [_inlineNode] ._loadState .addInterest ("set_loadState__", this);
   }

   X3DImportedNode .prototype = Object .assign (Object .create (X3dNode .prototype),
   {
      constructor: X3DImportedNode,
      getInlineNode: function ()
      {
         return this [_inlineNode];
      },
      getExportedName: function ()
      {
         return this [_exportedName];
      },
      getExportedNode: function ()
      {
         return this [_inlineNode] .getInternalScene () .getExportedNode (this [_exportedName]) .getValue ();
      },
      getImportedName: function ()
      {
         return this [_importedName];
      },
      addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
      {
         // Add route.

         const route = {
            sourceNode: sourceNode,
            sourceField: sourceField,
            destinationNode: destinationNode,
            destinationField: destinationField,
         };

         this [_routes] .add (route);

         // Try to resolve source or destination node routes.

         if (this [_inlineNode] .checkLoadState () === X3DConstants .COMPLETE_STATE)
            this .resolveRoute (route);
      },
      resolveRoute: function (route)
      {
         try
         {
            const
               sourceField      = route .sourceField,
               destinationField = route .destinationField;

            let
               sourceNode      = route .sourceNode,
               destinationNode = route .destinationNode;

            if (route .real)
               route .real .dispose ();

            if (sourceNode instanceof X3DImportedNode)
               sourceNode = sourceNode .getExportedNode ();

            if (destinationNode instanceof X3DImportedNode)
               destinationNode = destinationNode .getExportedNode ();

            route .real = this .getExecutionContext () .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
         }
         catch (error)
         {
            console .error (error .message);
         }
      },
      deleteRoute: function (real)
      {
         for (const route of this [_routes])
         {
            if (route .real === real)
               this [_routes] .delete (route);
         }
      },
      deleteRoutes: function ()
      {
         for (const route of this [_routes])
         {
            const real = route .real

            if (real)
            {
               delete route .real;
               this .getExecutionContext () .deleteSimpleRoute (real);
            }
         }
      },
      set_loadState__: function ()
      {
         switch (this [_inlineNode] .checkLoadState ())
         {
            case X3DConstants .NOT_STARTED_STATE:
            case X3DConstants .FAILED_STATE:
            {
               this .deleteRoutes ();
               break;
            }
            case X3DConstants .COMPLETE_STATE:
            {
               this .deleteRoutes ();

               for (const route of this [_routes])
                  this .resolveRoute (route);

               break;
            }
         }
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         if (generator .ExistsNode (this .getInlineNode ()))
         {
            stream .string += generator .Indent ();
            stream .string += "IMPORT";
            stream .string += " ";
            stream .string += generator .Name (this .getInlineNode ());
            stream .string += ".";
            stream .string += this .getExportedName ();

            if (this .getImportedName () !== this .getExportedName ())
            {
               stream .string += " ";
               stream .string += "AS";
               stream .string += " ";
               stream .string += this .getImportedName ();
            }

            try
            {
               generator .AddRouteNode (this);
               generator .AddImportedNode (this .getExportedNode (), this .getImportedName ());
            }
            catch (error)
            {
               // Output unresolved routes.

               for (const route of this [_routes])
               {
                  const
                     sourceNode       = route .sourceNode,
                     sourceField      = route .sourceField,
                     destinationNode  = route .destinationNode,
                     destinationField = route .destinationField;

                  if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
                  {
                     const sourceNodeName = sourceNode instanceof X3DImportedNode
                        ? sourceNode .getImportedName ()
                        : generator .Name (sourceNode);

                     const destinationNodeName = destinationNode instanceof X3DImportedNode
                        ? destinationNode .getImportedName ()
                        : generator .Name (destinationNode);

                     stream .string += "\n";
                     stream .string += "\n";
                     stream .string += generator .Indent ();
                     stream .string += "ROUTE";
                     stream .string += " ";
                     stream .string += sourceNodeName;
                     stream .string += ".";
                     stream .string += sourceField;
                     stream .string += " ";
                     stream .string += "TO";
                     stream .string += " ";
                     stream .string += destinationNodeName;
                     stream .string += ".";
                     stream .string += destinationField;
                  }
               }
            }
         }
         else
            throw new Error ("X3DImportedNode.toXMLStream: Inline node does not exist.");
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         if (generator .ExistsNode (this .getInlineNode ()))
         {
            stream .string += generator .Indent ();
            stream .string += "<IMPORT";
            stream .string += " ";
            stream .string += "inlineDEF='";
            stream .string += generator .XMLEncode (generator .Name (this .getInlineNode ()));
            stream .string += "'";
            stream .string += " ";
            stream .string += "importedDEF='";
            stream .string += generator .XMLEncode (this .getExportedName ());
            stream .string += "'";

            if (this .getImportedName () !== this .getExportedName ())
            {
               stream .string += " ";
               stream .string += "AS='";
               stream .string += generator .XMLEncode (this .getImportedName ());
               stream .string += "'";
            }

            stream .string += "/>";

            try
            {
               generator .AddRouteNode (this);
               generator .AddImportedNode (this .getExportedNode (), this .getImportedName ());
            }
            catch (error)
            {
               // Output unresolved routes.

               for (const route of this [_routes])
               {
                  const
                     sourceNode       = route .sourceNode,
                     sourceField      = route .sourceField,
                     destinationNode  = route .destinationNode,
                     destinationField = route .destinationField;

                  if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
                  {
                     const sourceNodeName = sourceNode instanceof X3DImportedNode
                        ? sourceNode .getImportedName ()
                        : generator .Name (sourceNode);

                     const destinationNodeName = destinationNode instanceof X3DImportedNode
                        ? destinationNode .getImportedName ()
                        : generator .Name (destinationNode);

                     stream .string += "\n";
                     stream .string += "\n";
                     stream .string += generator .Indent ();
                     stream .string += "<ROUTE";
                     stream .string += " ";
                     stream .string += "fromNode='";
                     stream .string += generator .XMLEncode (sourceNodeName);
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "fromField='";
                     stream .string += generator .XMLEncode (sourceField);
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "toNode='";
                     stream .string += generator .XMLEncode (destinationNodeName);
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "toField='";
                     stream .string += generator .XMLEncode (destinationField);
                     stream .string += "'";
                     stream .string += "/>";
                  }
               }
            }
         }
         else
            throw new Error ("X3DImportedNode.toXMLStream: Inline node does not exist.");
      },
      dispose: function ()
      {
         this [_inlineNode] ._loadState .removeInterest ("set_loadState__", this);

         this .deleteRoutes ();

         X3dNode .prototype .dispose .call (this);
      },
   });

   for (const key of Reflect .ownKeys (X3DImportedNode .prototype))
      Object .defineProperty (X3DImportedNode .prototype, key, { enumerable: false });

   Object .defineProperty (X3DImportedNode .prototype, "inlineNode",
   {
      get: function ()
      {
         return SFNodeCache .get (this [_inlineNode]);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DImportedNode .prototype, "exportedName",
   {
      get: function ()
      {
         return this [_exportedName];
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DImportedNode .prototype, "exportedNode",
   {
      get: function ()
      {
         return this [_inlineNode] .getInternalScene () .getExportedNode (this [_exportedName]);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DImportedNode .prototype, "importedName",
   {
      get: function ()
      {
         return this [_importedName];
      },
      enumerable: true,
      configurable: false
   });

   return X3DImportedNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/ImportedNodesArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function ImportedNodesArray (array)
   {
      return X3DInfoArray .call (this, array);
   }

   ImportedNodesArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ImportedNodesArray,
      getTypeName: function ()
      {
         return "ImportedNodesArray";
      },
   });

   for (const key of Reflect .ownKeys (ImportedNodesArray .prototype))
      Object .defineProperty (ImportedNodesArray .prototype, key, { enumerable: false });

   return ImportedNodesArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/ExternProtoDeclarationArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function ExternProtoDeclarationArray (values)
   {
      return X3DInfoArray .call (this, values);
   }

   ExternProtoDeclarationArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ExternProtoDeclarationArray,
      getTypeName: function ()
      {
         return "ExternProtoDeclarationArray";
      },
   });

   for (const key of Reflect .ownKeys (ExternProtoDeclarationArray .prototype))
      Object .defineProperty (ExternProtoDeclarationArray .prototype, key, { enumerable: false });

   return ExternProtoDeclarationArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/ProtoDeclarationArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function ProtoDeclarationArray (array)
   {
      return X3DInfoArray .call (this, array);
   }

   ProtoDeclarationArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ProtoDeclarationArray,
      getTypeName: function ()
      {
         return "ProtoDeclarationArray";
      },
   });

   for (const key of Reflect .ownKeys (ProtoDeclarationArray .prototype))
      Object .defineProperty (ProtoDeclarationArray .prototype, key, { enumerable: false });

   return ProtoDeclarationArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/RouteArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function RouteArray ()
   {
      return X3DInfoArray .call (this);
   }

   RouteArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: RouteArray,
      getTypeName: function ()
      {
         return "RouteArray";
      },
   });

   for (const key of Reflect .ownKeys (RouteArray .prototype))
      Object .defineProperty (RouteArray .prototype, key, { enumerable: false });

   return RouteArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/X3DRoute',[
   "x_ite/Base/X3DObject",
   "x_ite/Base/X3DConstants",
   "x_ite/Fields/SFNodeCache",
   "x_ite/InputOutput/Generator",
],
function (X3DObject,
          X3DConstants,
          SFNodeCache,
          Generator)
{
"use strict";

   const
      _executionContext = Symbol (),
      _sourceNode       = Symbol (),
      _sourceField      = Symbol (),
      _destinationNode  = Symbol (),
      _destinationField = Symbol ();

   function X3DRoute (executionContext, sourceNode, sourceField, destinationNode, destinationField)
   {
      X3DObject .call (this, executionContext);

      this [_executionContext] = executionContext;
      this [_sourceNode]       = sourceNode;
      this [_sourceField]      = sourceField;
      this [_destinationNode]  = destinationNode;
      this [_destinationField] = destinationField;

      // Must connect in every context, to make X3DBaseNode.hasRoutes work.

      sourceField .addFieldInterest (destinationField);

      sourceField      .addOutputRoute (this);
      destinationField .addInputRoute (this);
   }

   X3DRoute .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      getTypeName: function ()
      {
         return "X3DRoute";
      },
      getExecutionContext: function ()
      {
         return this [_executionContext];
      },
      getSourceNode: function ()
      {
         ///  SAI
         return this [_sourceNode];
      },
      getSourceField: function ()
      {
         ///  SAI
         return this [_sourceField];
      },
      getDestinationNode: function ()
      {
         ///  SAI
         return this [_destinationNode];
      },
      getDestinationField: function ()
      {
         ///  SAI
         return this [_destinationField];
      },
      disconnect: function ()
      {
         this [_sourceField] .removeFieldInterest (this [_destinationField]);

         this [_sourceField]      .removeOutputRoute (this);
         this [_destinationField] .removeInputRoute (this);
      },
      toVRMLStream: function (stream)
      {
         const
            generator           = Generator .Get (stream),
            sourceNodeName      = generator .LocalName (this [_sourceNode]),
            destinationNodeName = generator .LocalName (this [_destinationNode]);

         stream .string += generator .Indent ();
         stream .string += "ROUTE";
         stream .string += " ";
         stream .string += sourceNodeName;
         stream .string += ".";
         stream .string += this [_sourceField] .getName ();

         if (this [_sourceField] .getAccessType () === X3DConstants .inputOutput)
            stream .string += "_changed";

         stream .string += " ";
         stream .string += "TO";
         stream .string += " ";
         stream .string += destinationNodeName;
         stream .string += ".";

         if (this [_destinationField] .getAccessType () === X3DConstants .inputOutput)
            stream .string += "set_";

         stream .string += this [_destinationField] .getName ();
      },
      toXMLStream: function (stream)
      {
         const
            generator           = Generator .Get (stream),
            sourceNodeName      = generator .LocalName (this [_sourceNode]),
            destinationNodeName = generator .LocalName (this [_destinationNode]);

         stream .string += generator .Indent ();
         stream .string += "<ROUTE";
         stream .string += " ";
         stream .string += "fromNode='";
         stream .string += generator .XMLEncode (sourceNodeName);
         stream .string += "'";
         stream .string += " ";
         stream .string += "fromField='";
         stream .string += generator .XMLEncode (this [_sourceField] .getName ());

         if (this [_sourceField] .getAccessType () === X3DConstants .inputOutput)
            stream .string += "_changed";

         stream .string += "'";
         stream .string += " ";
         stream .string += "toNode='";
         stream .string += generator .XMLEncode (destinationNodeName);
         stream .string += "'";
         stream .string += " ";
         stream .string += "toField='";

         if (this [_destinationField] .getAccessType () === X3DConstants .inputOutput)
            stream .string += "set_";

         stream .string += generator .XMLEncode (this [_destinationField] .getName ());
         stream .string += "'";
         stream .string += "/>";
      },
      dispose: function ()
      {
         this .disconnect ();

         this [_executionContext] .deleteRoute (this);

         X3DObject .prototype .dispose .call (this);
      }
   });

   for (const key of Reflect .ownKeys (X3DRoute .prototype))
      Object .defineProperty (X3DRoute .prototype, key, { enumerable: false });

   Object .defineProperty (X3DRoute .prototype, "sourceNode",
   {
      get: function ()
      {
         return SFNodeCache .get (this [_sourceNode]);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DRoute .prototype, "sourceField",
   {
      get: function ()
      {
         return this [_sourceField] .getName ();
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DRoute .prototype, "destinationNode",
   {
      get: function ()
      {
         return SFNodeCache .get (this [_destinationNode]);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DRoute .prototype, "destinationField",
   {
      get: function ()
      {
         return this [_destinationField] .getName ();
      },
      enumerable: true,
      configurable: false
   });

   return X3DRoute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DExecutionContext',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Execution/NamedNodesArray",
   "x_ite/Execution/X3DImportedNode",
   "x_ite/Execution/ImportedNodesArray",
   "x_ite/Prototype/ExternProtoDeclarationArray",
   "x_ite/Prototype/ProtoDeclarationArray",
   "x_ite/Routing/RouteArray",
   "x_ite/Routing/X3DRoute",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
   "x_ite/Fields/SFNodeCache",
   "standard/Math/Algorithm",
],
function (SupportedNodes,
          Fields,
          X3DBaseNode,
          NamedNodesArray,
          X3DImportedNode,
          ImportedNodesArray,
          ExternProtoDeclarationArray,
          ProtoDeclarationArray,
          RouteArray,
          X3DRoute,
          X3DCast,
          X3DConstants,
          Generator,
          SFNodeCache,
          Algorithm)
{
"use strict";

   const
      _namedNodes     = Symbol (),
      _importedNodes  = Symbol (),
      _protos         = Symbol (),
      _externprotos   = Symbol (),
      _routes         = Symbol (),
      _outerNode      = Symbol ();

   SupportedNodes .addAbstractType ("X3DExecutionContext", X3DExecutionContext);

   function X3DExecutionContext (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addType (X3DConstants .X3DExecutionContext)

      this .addChildObjects ("rootNodes",          new Fields .MFNode (),
                             "worldInfos",         new Fields .MFNode (),
                             "sceneGraph_changed", new Fields .SFTime ());

      this ._rootNodes .setAccessType (X3DConstants .initializeOnly);
      this ._rootNodes .addCloneCount (1);

      this [_namedNodes]     = new NamedNodesArray ();
      this [_importedNodes]  = new ImportedNodesArray ();
      this [_protos]         = new ProtoDeclarationArray ();
      this [_externprotos]   = new ExternProtoDeclarationArray ();
      this [_routes]         = new RouteArray ();

      this .addChildObjects ("namedNodes_changed",    new Fields .SFTime (),
                             "importedNodes_changed", new Fields .SFTime (),
                             "protos_changed",        new Fields .SFTime (),
                             "externprotos_changed",  new Fields .SFTime (),
                             "routes_changed",        new Fields .SFTime ())

   }

   X3DExecutionContext .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DExecutionContext,
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         if (!this .isScene ())
            this ._sceneGraph_changed .addInterest ("set_sceneGraph", this)
      },
      set_sceneGraph: function ()
      {
         this .getExecutionContext () ._sceneGraph_changed = this .getBrowser () .getCurrentTime ();
      },
      isScene: function ()
      {
         return false;
      },
      getTypeName: function ()
      {
         return "X3DExecutionContext";
      },
      [_outerNode]: null,
      getOuterNode: function ()
      {
         // Can be either of type X3DProtoDeclaration or X3DPrototypeInstance, or null.
         return this [_outerNode];
      },
      setOuterNode: function (value)
      {
         this [_outerNode] = value;
      },
      getSpecificationVersion: function ()
      {
         return this .getExecutionContext () .getSpecificationVersion ();
      },
      getEncoding: function ()
      {
         return this .getExecutionContext () .getEncoding ();
      },
      getWorldURL: function ()
      {
         return this .getExecutionContext () .getWorldURL ();
      },
      getProfile: function ()
      {
         return this .getExecutionContext () .getProfile ();
      },
      getComponents: function ()
      {
         return this .getExecutionContext () .getComponents ();
      },
      fromUnit: function (category, value)
      {
         return this .getExecutionContext () .fromUnit (category, value);
      },
      toUnit: function (category, value)
      {
         return this .getExecutionContext () .toUnit (category, value);
      },
      getUnits: function ()
      {
         return this .getExecutionContext () .getUnits ();
      },
      createNode: function (typeName, setup = true)
      {
         typeName = String (typeName);

         if (setup === false)
         {
            const Type = this .getBrowser () .getSupportedNode (typeName);

            if (!Type)
               return null;

            return new Type (this);
         }
         else
         {
            const Type = this .getBrowser () .getSupportedNode (typeName);

            if (!Type)
               throw new Error ("Unknown node type '" + typeName + "'.");

            const baseNode = new Type (this);

            baseNode .setup ();

            return SFNodeCache .get (baseNode);
         }
      },
      createProto: function (name, setup = true)
      {
         name = String (name);

         let executionContext = this;

         for (;;)
         {
            const proto = executionContext .protos .get (name);

            if (proto)
               return proto .createInstance (this, setup);

            const externproto = executionContext .externprotos .get (name);

            if (externproto)
               return externproto .createInstance (this, setup);

            if (executionContext .isScene ())
               break;

            executionContext = executionContext .getExecutionContext ();
         }

         if (setup === false)
            return null;

         throw new Error ("Unknown proto or externproto type '" + name + "'.");
      },
      addNamedNode: function (name, node)
      {
         if (this [_namedNodes] .has (name))
            throw new Error ("Couldn't add named node: node named '" + name + "' is already in use.");

         this .updateNamedNode (name, node);
      },
      updateNamedNode: function (name, node)
      {
         name = String (name);
         node = X3DCast (X3DConstants .X3DNode, node, false);

         if (!node)
            throw new Error ("Couldn't update named node: node must be of type X3DNode.");

         if (node .getExecutionContext () !== this)
            throw new Error ("Couldn't update named node: node does not belong to this execution context.");

         if (name .length === 0)
            throw new Error ("Couldn't update named node: node name is empty.");

         // Remove named node.

         this .removeNamedNode (node .getName ());
         this .removeNamedNode (name);

         // Update named node.

         node .setName (name);

         this [_namedNodes] .add (name, node);

         this ._namedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      removeNamedNode: function (name)
      {
         name = String (name);

         const node = this [_namedNodes] .get (name);

         if (!node)
            return;

         node .setName ("");

         this [_namedNodes] .remove (name);

         this ._namedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      getNamedNode: function (name)
      {
         name = String (name);

         const node = this [_namedNodes] .get (name);

         if (node)
            return SFNodeCache .get (node);

         throw new Error ("Named node '" + name + "' not found.");
      },
      getNamedNodes: function ()
      {
         return this [_namedNodes];
      },
      getUniqueName: function (name = "")
      {
         return getUniqueName .call (this, _namedNodes, name);
      },
      addImportedNode: function (inlineNode, exportedName, importedName)
      {
         if (importedName === undefined)
            importedName = exportedName;

         exportedName = String (exportedName);
         importedName = String (importedName);

         if (this [_importedNodes] .has (importedName))
            throw new Error ("Couldn't add imported node: imported name '" + importedName + "' already in use.");

         this .updateImportedNode (inlineNode, exportedName, importedName);
      },
      updateImportedNode: function (inlineNode, exportedName, importedName)
      {
         inlineNode   = X3DCast (X3DConstants .Inline, inlineNode, false);
         exportedName = String (exportedName);
         importedName = importedName === undefined ? exportedName : String (importedName);

         if (!inlineNode)
            throw new Error ("Node must be of type Inline node.");

         if (inlineNode .getExecutionContext () !== this)
            throw new Error ("Couldn't update imported node: Inline node does not belong to this execution context.");

         if (exportedName .length === 0)
            throw new Error ("Couldn't update imported node: exported name is empty.");

         if (importedName .length === 0)
            throw new Error ("Couldn't update imported node: imported name is empty.");

         // Update imported node.

         this .removeImportedNode (importedName);

         const importedNode = new X3DImportedNode (this, inlineNode, exportedName, importedName);

         this [_importedNodes] .add (importedName, importedNode);

         importedNode .setup ();

         this ._importedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      removeImportedNode: function (importedName)
      {
         importedName = String (importedName);

         const importedNode = this [_importedNodes] .get (importedName);

         if (!importedNode)
            return;

         importedNode .dispose ();

         this [_importedNodes] .remove (importedName);

         this ._importedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      getImportedNode: function (importedName)
      {
         importedName = String (importedName);

         const importedNode = this [_importedNodes] .get (importedName);

         if (importedNode)
            return SFNodeCache .get (importedNode .getExportedNode ());

         throw new Error ("Imported node '" + importedName + "' not found.");
      },
      getImportedNodes: function ()
      {
         return this [_importedNodes];
      },
      getLocalNode: function (name)
      {
         name = String (name);

         try
         {
            return this .getNamedNode (name);
         }
         catch (error)
         {
            const importedNode = this [_importedNodes] .get (name);

            if (importedNode)
               return SFNodeCache .get (importedNode);

            throw new Error ("Unknown named or imported node '" + name + "'.");
         }
      },
      getLocalName: function (node)
      {
         node = X3DCast (X3DConstants .X3DNode, node, false);

         if (!node)
            throw new Error ("Couldn't get local name: node must be of type X3DNode.");

         if (node .getExecutionContext () === this)
            return node .getName ();

         for (const importedNode of this [_importedNodes])
         {
            try
            {
               if (importedNode .getExportedNode () === node)
                  return importedNode .getImportedName ();
            }
            catch (error)
            {
               //console .error (error);
            }
         }

         throw new Error ("Couldn't get local name: node is shared.");
      },
      setRootNodes: function () { },
      getRootNodes: function ()
      {
         return this ._rootNodes;
      },
      getProtoDeclaration: function (name)
      {
         name = String (name);

         const proto = this [_protos] .get (name);

         if (proto)
            return proto;

         throw new Error ("Proto declaration '" + name + "' not found.");
      },
      addProtoDeclaration (name, proto)
      {
         name = String (name);

         const X3DProtoDeclaration = require ("x_ite/Prototype/X3DProtoDeclaration");

         if (!(proto instanceof X3DProtoDeclaration))
            throw new Error ("Couldn't add proto declaration: proto must be of type X3DProtoDeclaration.");

         if (this [_protos] .get (name))
            throw new Error ("Couldn't add proto declaration: proto '" + name + "' already in use.");

         name = String (name);

         if (name .length === 0)
            throw new Error ("Couldn't add proto declaration: proto name is empty.");

         this [_protos] .add (name, proto);
         proto .setName (name);

         this ._protos_changed = this .getBrowser () .getCurrentTime ();
      },
      updateProtoDeclaration (name, proto)
      {
         name = String (name);

         const X3DProtoDeclaration = require ("x_ite/Prototype/X3DProtoDeclaration");

         if (!(proto instanceof X3DProtoDeclaration))
            throw new Error ("Couldn't add proto declaration: proto must be of type X3DProtoDeclaration.");

         name = String (name);

         if (name .length === 0)
            throw new Error ("Couldn't add proto declaration: proto name is empty.");

         this [_protos] .update (proto .getName (), name, proto);
         proto .setName (name);

         this ._protos_changed = this .getBrowser () .getCurrentTime ();
      },
      removeProtoDeclaration (name)
      {
         name = String (name);

         this [_protos] .remove (name);

         this ._protos_changed = this .getBrowser () .getCurrentTime ();
      },
      getProtoDeclarations: function ()
      {
         return this [_protos];
      },
      getUniqueProtoName: function (name = "")
      {
         return getUniqueName .call (this, _protos, name);
      },
      getExternProtoDeclaration: function (name)
      {
         name = String (name);

         const externproto = this [_externprotos] .get (name);

         if (externproto)
            return externproto;

         throw new Error ("Extern proto declaration '" + name + "' not found.");
      },
      addExternProtoDeclaration (name, externproto)
      {
         name = String (name);

         const X3DExternProtoDeclaration = require ("x_ite/Prototype/X3DExternProtoDeclaration");

         if (!(externproto instanceof X3DExternProtoDeclaration))
            throw new Error ("Couldn't add extern proto declaration: extern proto must be of type X3DExternProtoDeclaration.");

         if (this [_externprotos] .get (name))
            throw new Error ("Couldn't add extern proto declaration: extern proto '" + name + "' already in use.");

         name = String (name);

         if (name .length === 0)
            throw new Error ("Couldn't add extern proto declaration: extern proto name is empty.");

         this [_externprotos] .add (name, externproto);
         externproto .setName (name);

         this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
      },
      updateExternProtoDeclaration (name, externproto)
      {
         name = String (name);

         const X3DExternProtoDeclaration = require ("x_ite/Prototype/X3DExternProtoDeclaration");

         if (!(externproto instanceof X3DExternProtoDeclaration))
            throw new Error ("Couldn't add extern proto declaration: extern proto must be of type X3DExternProtoDeclaration.");

         name = String (name);

         if (name .length === 0)
            throw new Error ("Couldn't add extern proto declaration: extern proto name is empty.");

         this [_externprotos] .update (externproto .getName (), name, externproto);
         externproto .setName (name);

         this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
      },
      removeExternProtoDeclaration (name)
      {
         name = String (name);

         this [_externprotos] .remove (name);

         this ._externprotos_changed = this .getBrowser () .getCurrentTime ();
      },
      getExternProtoDeclarations: function ()
      {
         return this [_externprotos];
      },
      getUniqueExternProtoName: function (name = "")
      {
         return getUniqueName .call (this, _externprotos, name);
      },
      addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
      {
         sourceNode       = X3DCast (X3DConstants .X3DNode, sourceNode, false);
         sourceField      = String (sourceField);
         destinationNode  = X3DCast (X3DConstants .X3DNode, destinationNode, false);
         destinationField = String (destinationField);

         if (!sourceNode)
            throw new Error ("Bad ROUTE specification: source node must be of type X3DNode.");

         if (!destinationNode)
            throw new Error ("Bad ROUTE specification: destination node must be of type X3DNode.");

         // Imported nodes handling.

         let
            importedSourceNode      = sourceNode      instanceof X3DImportedNode ? sourceNode      : null,
            importedDestinationNode = destinationNode instanceof X3DImportedNode ? destinationNode : null;

         try
         {
            // If sourceNode is shared node try to find the corresponding X3DImportedNode.
            if (sourceNode .getExecutionContext () !== this)
               importedSourceNode = this .getLocalNode (this .getLocalName (sourceNode)) .getValue ();
         }
         catch (error)
         {
            // Source node is shared but not imported.
         }

         try
         {
            // If destinationNode is shared node try to find the corresponding X3DImportedNode.
            if (destinationNode .getExecutionContext () !== this)
               importedDestinationNode = this .getLocalNode (this .getLocalName (destinationNode)) .getValue ();
         }
         catch (error)
         {
            // Destination node is shared but not imported.
         }

         if (importedSourceNode instanceof X3DImportedNode && importedDestinationNode instanceof X3DImportedNode)
         {
            importedSourceNode      .addRoute (importedSourceNode, sourceField, importedDestinationNode, destinationField);
            importedDestinationNode .addRoute (importedSourceNode, sourceField, importedDestinationNode, destinationField);
         }
         else if (importedSourceNode instanceof X3DImportedNode)
         {
            importedSourceNode .addRoute (importedSourceNode, sourceField, destinationNode, destinationField);
         }
         else if (importedDestinationNode instanceof X3DImportedNode)
         {
            importedDestinationNode .addRoute (sourceNode, sourceField, importedDestinationNode, destinationField);
         }

         // If either sourceNode or destinationNode is an X3DImportedNode return here without value.
         if (importedSourceNode === sourceNode || importedDestinationNode === destinationNode)
            return;

         // Create route and return.

         return this .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
      },
      addSimpleRoute: function (sourceNode, sourceField, destinationNode, destinationField)
      {
         // Source and dest node are here X3DBaseNode.

         try
         {
            // Private function.
            // Create route and return.

            sourceField      = sourceNode      .getField (sourceField),
            destinationField = destinationNode .getField (destinationField);

            if (!sourceField .isOutput ())
               throw new Error ("Field named '" + sourceField .getName () + "' in node named '" + sourceNode .getName () + "' of type " + sourceNode .getTypeName () + " is not an output field.");

            if (!destinationField .isInput ())
               throw new Error ("Field named '" + destinationField .getName () + "' in node named '" + destinationNode .getName () + "' of type " + destinationNode .getTypeName () + " is not an input field.");

            if (sourceField .getType () !== destinationField .getType ())
               throw new Error ("ROUTE types " + sourceField .getTypeName () + " and " + destinationField .getTypeName () + " do not match.");

            const id = sourceField .getId () + "." + destinationField .getId ();

            let route = this [_routes] .get (id);

            if (route)
               return route;

            route = new X3DRoute (this, sourceNode, sourceField, destinationNode, destinationField);

            this [_routes] .add (id, route);

            this ._routes_changed = this .getBrowser () .getCurrentTime ();

            return route;
         }
         catch (error)
         {
            throw new Error ("Bad ROUTE specification: " + error .message);
         }
      },
      deleteRoute: function (route)
      {
         // sourceNode, sourceField, destinationNode, destinationField
         if (arguments .length === 4)
         {
            route = this .getRoute .apply (this, arguments);

            if (!route)
               return false;
         }

         if (this .deleteSimpleRoute (route))
            this .deleteImportedRoute (route .sourceNode, route .destinationNode, route);
      },
      deleteSimpleRoute: function (route)
      {
         try
         {
            const
               sourceField      = route .getSourceField (),
               destinationField = route .getDestinationField (),
               id               = sourceField .getId () + "." + destinationField .getId ();

            this [_routes] .remove (id);
            route .disconnect ();

            this ._routes_changed = this .getBrowser () .getCurrentTime ();

            return true;
         }
         catch (error)
         {
            console .error (error);
            return false;
         }
      },
      deleteImportedRoute (sourceNode, destinationNode, route)
      {
         // Imported nodes handling.

         let
            importedSourceNode      = null,
            importedDestinationNode = null;

         try
         {
            // If sourceNode is shared node try to find the corresponding X3DImportedNode.
            if (sourceNode .getValue () .getExecutionContext () !== this)
               importedSourceNode = this .getLocalNode (this .getLocalName (sourceNode)) .getValue ();
         }
         catch (error)
         {
            // Source node is shared but not imported.
         }

         try
         {
            // If destinationNode is shared node try to find the corresponding X3DImportedNode.
            if (destinationNode .getValue () .getExecutionContext () !== this)
               importedDestinationNode = this .getLocalNode (this .getLocalName (destinationNode)) .getValue ();
         }
         catch (error)
         {
            // Destination node is shared but not imported.
         }

         if (importedSourceNode instanceof X3DImportedNode && importedDestinationNode instanceof X3DImportedNode)
         {
            importedSourceNode      .deleteRoute (route);
            importedDestinationNode .deleteRoute (route);
         }
         else if (importedSourceNode instanceof X3DImportedNode)
         {
            importedSourceNode .deleteRoute (route);
         }
         else if (importedDestinationNode instanceof X3DImportedNode)
         {
            importedDestinationNode .deleteRoute (route);
         }
      },
      getRoute: function (sourceNode, sourceField, destinationNode, destinationField)
      {
         sourceNode       = X3DCast (X3DConstants .X3DNode, sourceNode, false);
         sourceField      = String (sourceField)
         destinationNode  = X3DCast (X3DConstants .X3DNode, destinationNode, false);
         destinationField = String (destinationField)

         if (!sourceNode)
            throw new Error ("Bad ROUTE specification: sourceNode must be of type X3DNode.");

         if (!destinationNode)
            throw new Error ("Bad ROUTE specification: destinationNode must be of type X3DNode.");

         sourceField      = sourceNode      .getField (sourceField);
         destinationField = destinationNode .getField (destinationField);

         const id = sourceField .getId () + "." + destinationField .getId ();

         return this [_routes] .get (id);
      },
      getRoutes: function ()
      {
         return this [_routes];
      },
      getWorldInfos: function ()
      {
         return this ._worldInfos;
      },
      addWorldInfo: function (worldInfoNode)
      {
         this ._worldInfos .push (worldInfoNode);
      },
      removeWorldInfo: function (worldInfoNode)
      {
         for (let i = this ._worldInfos .length - 1; i >= 0; -- i)
         {
            if (this ._worldInfos [i] .getValue () === worldInfoNode)
               this ._worldInfos .splice (i, 1);
         }
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         generator .PushExecutionContext (this);
         generator .EnterScope ();
         generator .ImportedNodes (this .getImportedNodes ());

         // Output extern protos

         this .getExternProtoDeclarations () .toVRMLStream (stream);

         // Output protos

         this .getProtoDeclarations () .toVRMLStream (stream);

         // Output root nodes

         const rootNodes = this .getRootNodes ();

         for (let i = 0, length = rootNodes .length; i < length; ++ i)
         {
            const rootNode = rootNodes [i];

            stream .string += generator .Indent ();

            if (rootNode)
               rootNode .toVRMLStream (stream);
            else
               stream .string += "NULL";

            stream .string += "\n";

            if (i !== length - 1)
               stream .string += "\n";
         }

         // Output imported nodes

         const importedNodes = this .getImportedNodes ();

         if (importedNodes .size)
         {
            stream .string += "\n";

            importedNodes .forEach (function (importedNode)
            {
               try
               {
                  importedNode .toVRMLStream (stream);

                  stream .string += "\n";
               }
               catch (error)
               { }
            });
         }

         // Output routes

         const routes = this .getRoutes ();

         if (routes .length)
         {
            stream .string += "\n";

            routes .toVRMLStream (stream);
         }

         generator .LeaveScope ();
         generator .PopExecutionContext ();
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         generator .PushExecutionContext (this);
         generator .EnterScope ();
         generator .ImportedNodes (this .getImportedNodes ());

         // Output extern protos

         this .getExternProtoDeclarations () .toXMLStream (stream);

         // Output protos

         this .getProtoDeclarations () .toXMLStream (stream);

         // Output root nodes

         const rootNodes = this .getRootNodes ();

         if (rootNodes .length)
         {
            rootNodes .toXMLStream (stream);

            stream .string += "\n";
         }

         // Output imported nodes

         const importedNodes = this .getImportedNodes ();

         importedNodes .forEach (function (importedNode)
         {
            try
            {
               importedNode .toXMLStream (stream);

               stream .string += "\n";
            }
            catch (error)
            { }
         });

         // Output routes

         this .getRoutes () .toXMLStream (stream);

         generator .LeaveScope ();
         generator .PopExecutionContext ();
      },
      dispose: function ()
      {
         this ._rootNodes .dispose ();

         for (const route of this [_routes])
            this .deleteRoute (route);

         X3DBaseNode .prototype .dispose .call (this);
      },
   });

   const getUniqueName = (function ()
   {
      const _TrailingNumbers = /_\d+$/;

      return function (array, name = "")
      {
         name = String (name) .replace (_TrailingNumbers, "");

         let
            newName = name,
            i       = 64;

         for (; i;)
         {
            if (!(this [array] .has (newName) || newName .length === 0))
               break;

            const
               min = i,
               max = i <<= 1;

            newName  = name;
            newName += '_';
            newName += Math .round (Algorithm .random (min, max));
         }

         return newName;
      };
   })();

   for (const key of Reflect .ownKeys (X3DExecutionContext .prototype))
      Object .defineProperty (X3DExecutionContext .prototype, key, { enumerable: false });

   Object .defineProperty (X3DExecutionContext .prototype, "specificationVersion",
   {
      get: function () { return this .getSpecificationVersion (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "encoding",
   {
      get: function () { return this .getEncoding (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "profile",
   {
      get: function () { return this .getProfile (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "components",
   {
      get: function () { return this .getComponents (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "worldURL",
   {
      get: function () { return this .getWorldURL (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "units",
   {
      get: function () { return this .getUnits (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "rootNodes",
   {
      get: function () { return this .getRootNodes (); },
      set: function (value) { this .setRootNodes (value); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "protos",
   {
      get: function () { return this .getProtoDeclarations (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "externprotos",
   {
      get: function () { return this .getExternProtoDeclarations (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExecutionContext .prototype, "routes",
   {
      get: function () { return this .getRoutes (); },
      enumerable: true,
      configurable: false
   });

   return X3DExecutionContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ComponentInfo',[
   "x_ite/Base/X3DObject",
   "x_ite/InputOutput/Generator",
],
function (X3DObject,
          Generator)
{
"use strict";

   function ComponentInfo (name, level, title, providerUrl)
   {
      this .name        = name;
      this .level       = level;
      this .title       = title;
      this .providerUrl = providerUrl;
   }

   ComponentInfo .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: ComponentInfo,
      getTypeName: function ()
      {
         return "ComponentInfo";
      },
      toVRMLStream: function (stream)
      {
         stream .string += "COMPONENT";
         stream .string += " ";
         stream .string += this .name;
         stream .string += " ";
         stream .string += ":";
         stream .string += " ";
         stream .string += this .level;
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "<component";
         stream .string += " ";
         stream .string += "name='";
         stream .string += this .name;
         stream .string += "'";
         stream .string += " ";
         stream .string += "level='";
         stream .string += this .level;
         stream .string += "'";
         stream .string += "/>";
      },
   });

   for (const key of Reflect .ownKeys (ComponentInfo .prototype))
      Object .defineProperty (ComponentInfo .prototype, key, { enumerable: false });

   return ComponentInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ComponentInfoArray',[
   "x_ite/Configuration/ComponentInfo",
   "x_ite/Base/X3DInfoArray",
],
function (ComponentInfo,
          X3DInfoArray)
{
"use strict";

   function ComponentInfoArray (values)
   {
      return X3DInfoArray .call (this, values);
   }

   ComponentInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ComponentInfoArray,
      getTypeName: function ()
      {
         return "ComponentInfoArray";
      },
      addComponent: function (value)
      {
         this .add (value .name, new ComponentInfo (value .name, value .level, value .title, value .providerUrl));
      },
   });

   for (const key of Reflect .ownKeys (ComponentInfoArray .prototype))
      Object .defineProperty (ComponentInfoArray .prototype, key, { enumerable: false });

   return ComponentInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/UnitInfo',[
   "x_ite/Base/X3DObject",
   "x_ite/InputOutput/Generator",
],
function (X3DObject,
          Generator)
{
"use strict";

   function UnitInfo (category, name, conversionFactor)
   {
      Object .defineProperty (this, "category", {
          value: category,
          writable: false,
      });

      this .name             = name;
      this .conversionFactor = conversionFactor;
   }

   UnitInfo .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: UnitInfo,
      getTypeName: function ()
      {
         return "UnitInfo";
      },
      toVRMLStream: function (stream)
      {
         stream .string += "UNIT";
         stream .string += " ";
         stream .string += this .category;
         stream .string += " ";
         stream .string += this .name;
         stream .string += " ";
         stream .string += this .conversionFactor;
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "<unit";
         stream .string += " ";
         stream .string += "category='";
         stream .string += this .category;
         stream .string += "'";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (this .name);
         stream .string += "'";
         stream .string += " ";
         stream .string += "conversionFactor='";
         stream .string += this .conversionFactor;
         stream .string += "'";
         stream .string += "/>";
      },
   });

   for (const key of Reflect .ownKeys (UnitInfo .prototype))
      Object .defineProperty (UnitInfo .prototype, key, { enumerable: false });

   Object .defineProperty (UnitInfo .prototype, "conversion_factor",
   {
      get: function () { return this .conversionFactor; },
      enumerable: false,
      configurable: false
   });

   return UnitInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/UnitInfoArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function UnitInfoArray (values)
   {
      return X3DInfoArray .call (this, values);
   }

   UnitInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: UnitInfoArray,
      getTypeName: function ()
      {
         return "UnitInfoArray";
      },
   });

   for (const key of Reflect .ownKeys (UnitInfoArray .prototype))
      Object .defineProperty (UnitInfoArray .prototype, key, { enumerable: false });

   return UnitInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DExportedNode',[
   "x_ite/Base/X3DObject",
   "x_ite/Fields/SFNodeCache",
   "x_ite/InputOutput/Generator",
],
function (X3DObject,
          SFNodeCache,
          Generator)
{
"use strict";

   const
      _exportedName = Symbol (),
      _localNode    = Symbol ();

   function X3DExportedNode (exportedName, localNode)
   {
      X3DObject .call (this);

      this [_exportedName] = exportedName;
      this [_localNode]    = localNode;
   }

   X3DExportedNode .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: X3DExportedNode,
      getExportedName: function ()
      {
         return this [_exportedName];
      },
      getLocalNode: function ()
      {
         return this [_localNode];
      },
      toVRMLStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            localName = generator .LocalName (this [_localNode]);

         stream .string += generator .Indent ();
         stream .string += "EXPORT";
         stream .string += " ";
         stream .string += localName;

         if (this [_exportedName] !== localName)
         {
            stream .string += " ";
            stream .string += "AS";
            stream .string += " ";
            stream .string += this [_exportedName];
         }
      },
      toXMLStream: function (stream)
      {
         const
            generator = Generator .Get (stream),
            localName = generator .LocalName (this [_localNode]);

         stream .string += generator .Indent ();
         stream .string += "<EXPORT";
         stream .string += " ";
         stream .string += "localDEF='";
         stream .string += generator .XMLEncode (localName);
         stream .string += "'";

         if (this [_exportedName] !== localName)
         {
            stream .string += " ";
            stream .string += "AS='";
            stream .string += generator .XMLEncode (this [_exportedName]);
            stream .string += "'";
         }

         stream .string += "/>";
      },
   });

   for (const key of Reflect .ownKeys (X3DExportedNode .prototype))
      Object .defineProperty (X3DExportedNode .prototype, key, { enumerable: false });

   Object .defineProperty (X3DExportedNode .prototype, "exportedName",
   {
      get: function ()
      {
         return SFNodeCache .get (this [_exportedName]);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExportedNode .prototype, "localNode",
   {
      get: function ()
      {
         return SFNodeCache .get (this [_localNode]);
      },
      enumerable: true,
      configurable: false
   });

   return X3DExportedNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/ExportedNodesArray',[
   "x_ite/Base/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

   function ExportedNodesArray (array)
   {
      return X3DInfoArray .call (this, array);
   }

   ExportedNodesArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ExportedNodesArray,
      getTypeName: function ()
      {
         return "ExportedNodesArray";
      },
   });

   for (const key of Reflect .ownKeys (ExportedNodesArray .prototype))
      Object .defineProperty (ExportedNodesArray .prototype, key, { enumerable: false });

   return ExportedNodesArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DScene',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields",
   "x_ite/Execution/X3DExecutionContext",
   "x_ite/Configuration/ComponentInfoArray",
   "x_ite/Configuration/UnitInfo",
   "x_ite/Configuration/UnitInfoArray",
   "x_ite/Execution/X3DExportedNode",
   "x_ite/Execution/ExportedNodesArray",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
   "x_ite/Fields/SFNodeCache",
],
function (SupportedNodes,
          Fields,
          X3DExecutionContext,
          ComponentInfoArray,
          UnitInfo,
          UnitInfoArray,
          X3DExportedNode,
          ExportedNodesArray,
          X3DCast,
          X3DConstants,
          Generator,
          SFNodeCache)
{
"use strict";

   const
      _specificationVersion = Symbol (),
      _encoding             = Symbol (),
      _profile              = Symbol (),
      _components           = Symbol (),
      _worldURL             = Symbol (),
      _units                = Symbol (),
      _metadata             = Symbol (),
      _exportedNodes        = Symbol ();

   SupportedNodes .addAbstractType ("X3DScene", X3DScene);

   function X3DScene (executionContext)
   {
      X3DExecutionContext .call (this, executionContext);

      this .addType (X3DConstants .X3DScene)

      this [_specificationVersion] = "3.3";
      this [_encoding]             = "SCRIPTED";
      this [_profile]              = null;
      this [_components]           = new ComponentInfoArray ([ ]);
      this [_worldURL]             = location .toString ();
      this [_units]                = new UnitInfoArray ();

      this [_units] .add ("angle",  new UnitInfo ("angle",  "radian",   1));
      this [_units] .add ("force",  new UnitInfo ("force",  "newton",   1));
      this [_units] .add ("length", new UnitInfo ("length", "metre",    1));
      this [_units] .add ("mass",   new UnitInfo ("mass",   "kilogram", 1));

      this [_metadata]      = new Map ();
      this [_exportedNodes] = new ExportedNodesArray ();

      this .addChildObjects ("profile_changed",       new Fields .SFTime (),
                             "components_changed",    new Fields .SFTime (),
                             "units_changed",         new Fields .SFTime (),
                             "metadata_changed",      new Fields .SFTime (),
                             "exportedNodes_changed", new Fields .SFTime ())

      this .getRootNodes () .setAccessType (X3DConstants .inputOutput);

      this .setLive (false);
   }

   X3DScene .prototype = Object .assign (Object .create (X3DExecutionContext .prototype),
   {
      constructor: X3DScene,
      getTypeName: function ()
      {
         return "X3DScene";
      },
      isMainScene: function ()
      {
         return this === this .getExecutionContext ();
      },
      isScene: function ()
      {
         return true;
      },
      setSpecificationVersion: function (specificationVersion)
      {
         this [_specificationVersion] = String (specificationVersion);
      },
      getSpecificationVersion: function ()
      {
         return this [_specificationVersion];
      },
      setEncoding: function (encoding)
      {
         this [_encoding] = String (encoding);
      },
      getEncoding: function ()
      {
         return this [_encoding];
      },
      setWorldURL: function (url)
      {
         this [_worldURL] = String (url);
      },
      getWorldURL: function ()
      {
         return this [_worldURL];
      },
      setProfile: function (profile)
      {
         this [_profile] = profile;

         this ._profile_changed = this .getBrowser () .getCurrentTime ();
      },
      getProfile: function ()
      {
         return this [_profile];
      },
      addComponent: function (component)
      {
         this [_components] .add (component .name, component);

         this ._components_changed = this .getBrowser () .getCurrentTime ();
      },
      removeComponent: function (component)
      {
         this [_components] .remove (component .name);

         this ._components_changed = this .getBrowser () .getCurrentTime ();
      },
      getComponents: function ()
      {
         return this [_components];
      },
      updateUnit: function (category, name, conversionFactor)
      {
         // Private function.

         const unit = this [_units] .get (category);

         if (!unit)
            return;

         unit .name             = String (name);
         unit .conversionFactor = Number (conversionFactor);

         this ._units_changed = this .getBrowser () .getCurrentTime ();
      },
      getUnit: function (category)
      {
         return this [_units] .get (category);
      },
      getUnits: function ()
      {
         return this [_units];
      },
      fromUnit: function (category, value)
      {
         switch (category)
         {
            // Base units

            case "angle":
            case "force":
            case "length":
            case "mass":
               return value * this .getUnits () .get (category) .conversionFactor;

            // Derived units

            case "acceleration:":
               return value * this .getUnits () .get ("length") .conversionFactor;
            case "angularRate":
               return value * this .getUnits () .get ("angle") .conversionFactor;
            case "area":
               return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
            case "speed":
               return value * this .getUnits () .get ("length") .conversionFactor;
            case "volume":
               return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
         }

         return value;
      },
      toUnit: function (category, value)
      {
         switch (category)
         {
            // Base units

            case "angle":
            case "force":
            case "length":
            case "mass":
               return value / this .getUnits () .get (category) .conversionFactor;

            // Derived units

            case "acceleration:":
               return value / this .getUnits () .get ("length") .conversionFactor;
            case "angularRate":
               return value / this .getUnits () .get ("angle") .conversionFactor;
            case "area":
               return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
            case "speed":
               return value / this .getUnits () .get ("length") .conversionFactor;
            case "volume":
               return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
         }

         return value;
      },
      setMetaData: function (name, value)
      {
         name = String (name)

         if (!name .length)
            return;

         this [_metadata] .set (name, String (value));

         this ._metadata_changed = this .getBrowser () .getCurrentTime ();
      },
      removeMetaData: function (name)
      {
         name = String (name);

         this [_metadata] .delete (name);

         this ._metadata_changed = this .getBrowser () .getCurrentTime ();
      },
      getMetaData: function (name)
      {
         name = String (name);

         return this [_metadata] .get (name);
      },
      getMetaDatas: function ()
      {
         return this [_metadata];
      },
      addExportedNode: function (exportedName, node)
      {
         exportedName = String (exportedName);

         if (this [_exportedNodes] .has (exportedName))
            throw new Error ("Couldn't add exported node: exported name '" + exportedName + "' already in use.");

         this .updateExportedNode (exportedName, node);

         this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      updateExportedNode: function (exportedName, node)
      {
         exportedName = String (exportedName);
         node         = X3DCast (X3DConstants .X3DNode, node, false);

         if (exportedName .length === 0)
            throw new Error ("Couldn't update exported node: node exported name is empty.");

         if (!node)
            throw new Error ("Couldn't update exported node: node must be of type X3DNode.");

         //if (node .getExecutionContext () !== this)
         //	throw new Error ("Couldn't update exported node: node does not belong to this execution context.");

         this .removeExportedNode (exportedName);

         const exportedNode = new X3DExportedNode (exportedName, node);

         this [_exportedNodes] .add (exportedName, exportedNode);

         this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      removeExportedNode: function (exportedName)
      {
         exportedName = String (exportedName);

         this [_exportedNodes] .remove (exportedName);

         this ._exportedNodes_changed = this .getBrowser () .getCurrentTime ();
      },
      getExportedNode: function (exportedName)
      {
         exportedName = String (exportedName);

         const exportedNode = this [_exportedNodes] .get (exportedName);

         if (exportedNode)
            return SFNodeCache .get (exportedNode .getLocalNode ());

         throw new Error ("Exported node '" + exportedName + "' not found.");
      },
      getExportedNodes: function ()
      {
         return this [_exportedNodes];
      },
      addRootNode: function (node)
      {
         node = SFNodeCache .get (X3DCast (X3DConstants .X3DNode, node, false));

         const rootNodes = this .getRootNodes ();

         for (const rootNode of rootNodes)
         {
            if (rootNode .equals (node))
               return;
         }

         rootNodes .push (node);
      },
      removeRootNode: function (node)
      {
         node = SFNodeCache .get (X3DCast (X3DConstants .X3DNode, node, false));

         const
            rootNodes = this .getRootNodes (),
            length    = rootNodes .length;

         rootNodes .erase (rootNodes .remove (0, length, node), length);
      },
      setRootNodes: function (value)
      {
         if (!(value instanceof Fields .MFNode))
            throw new Error ("Value must be of type MFNode.");

         this .getRootNodes () .assign (value);
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         let specificationVersion = this .getSpecificationVersion ();

         if (specificationVersion === "2.0")
            specificationVersion = "3.3";

         stream .string += "#X3D V";
         stream .string += specificationVersion;
         stream .string += " ";
         stream .string += "utf8";
         stream .string += " ";
         stream .string += this .getBrowser () .name;
         stream .string += " ";
         stream .string += "V";
         stream .string += this .getBrowser () .version;
         stream .string += "\n";
         stream .string += "\n";

         const profile = this .getProfile ();

         if (profile)
         {
            profile .toVRMLStream (stream);

            stream .string += "\n";
            stream .string += "\n";
         }

         const components = this .getComponents ();

         if (components .length)
         {
            components .toVRMLStream (stream);

            stream .string += "\n";
         }

         // Units
         {
            let empty = true;

            for (const unit of this .getUnits ())
            {
               if (unit .conversionFactor !== 1)
               {
                  empty = false;

                  unit .toVRMLStream (stream);

                  stream .string += "\n";
               }
            }

            if (!empty)
               stream .string += "\n";
         }

         const metadata = this .getMetaDatas ();

         if (metadata .size)
         {
            metadata .forEach (function (value, key)
            {
               stream .string += "META";
               stream .string += " ";
               stream .string += new Fields .SFString (key) .toString ();
               stream .string += " ";
               stream .string += new Fields .SFString (value) .toString ();
               stream .string += "\n";
            });

            stream .string += "\n";
         }

         const exportedNodes = this .getExportedNodes ();

         generator .PushExecutionContext (this);
         generator .EnterScope ();
         generator .ExportedNodes (exportedNodes);

         X3DExecutionContext .prototype .toVRMLStream .call (this, stream);

         if (exportedNodes .size)
         {
            stream .string += "\n";

            exportedNodes .forEach (function (exportedNode)
            {
               try
               {
                  exportedNode .toVRMLStream (stream);

                  stream .string += "\n";
               }
               catch (error)
               {
                  console .error (error);
               }
            });
         }

         generator .LeaveScope ();
         generator .PopExecutionContext ();
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         let specificationVersion = this .getSpecificationVersion ();

         if (specificationVersion === "2.0")
            specificationVersion = "3.3";

         stream .string += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
         stream .string += "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D ";
         stream .string += specificationVersion;
         stream .string += "//EN\" \"http://www.web3d.org/specifications/x3d-";
         stream .string += specificationVersion;
         stream .string += ".dtd\">\n";

         stream .string += "<X3D";
         stream .string += " ";
         stream .string += "profile='";
         stream .string += this .getProfile () ? this .getProfile () .name : "Full";
         stream .string += "'";
         stream .string += " ";
         stream .string += "version='";
         stream .string += specificationVersion;
         stream .string += "'";
         stream .string += " ";
         stream .string += "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance'";
         stream .string += " ";
         stream .string += "xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-";
         stream .string += specificationVersion;
         stream .string += ".xsd'>\n";

         generator .IncIndent ();

         stream .string += generator .Indent ();
         stream .string += "<head>\n";

         generator .IncIndent ();

         // <head>

         this .getComponents () .toXMLStream (stream);

         for (const unit of this .getUnits ())
         {
            if (unit .conversionFactor !== 1)
            {
               unit .toXMLStream (stream);

               stream .string += "\n";
            }
         }

         this .getMetaDatas () .forEach (function (value, key)
         {
            stream .string += generator .Indent ();
            stream .string += "<meta";
            stream .string += " ";
            stream .string += "name='";
            stream .string += generator .XMLEncode (key);
            stream .string += "'";
            stream .string += " ";
            stream .string += "content='";
            stream .string += generator .XMLEncode (value);
            stream .string += "'";
            stream .string += "/>\n";
         });

         // </head>

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</head>\n";
         stream .string += generator .Indent ();
         stream .string += "<Scene>\n";

         generator .IncIndent ();

         // <Scene>

         const exportedNodes = this .getExportedNodes ();

         generator .PushExecutionContext (this);
         generator .EnterScope ();
         generator .ExportedNodes (exportedNodes);

         X3DExecutionContext .prototype .toXMLStream .call (this, stream);

         for (const exportedNode of exportedNodes)
         {
            try
            {
               exportedNode .toXMLStream (stream);

               stream .string += "\n";
            }
            catch (error)
            {
               console .error (error);
            }
         }

         generator .LeaveScope ();
         generator .PopExecutionContext ();

         // </Scene>

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</Scene>\n";

         generator .DecIndent ();

         stream .string += "</X3D>\n";
      },
   });

   for (const key of Reflect .ownKeys (X3DScene .prototype))
      Object .defineProperty (X3DScene .prototype, key, { enumerable: false });

   return X3DScene;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/Scene',[
   "x_ite/Fields",
   "x_ite/Execution/X3DScene",
],
function (Fields,
          X3DScene)
{
"use strict";

   const
      _browser        = Symbol .for ("X3DEventObject.browser"),
      _loadingObjects = Symbol ();

   function Scene (browser)
   {
      this [_browser] = browser;

      X3DScene .call (this, this);

      this .addChildObjects ("initLoadCount", new Fields .SFInt32 (),  // Pre load count, must be zero before the scene can be passed to the requester.
                             "loadCount",     new Fields .SFInt32 ()); // Load count of all X3DUrlObjects.

      this [_loadingObjects] = new Set ();
   }

   Scene .prototype = Object .assign (Object .create (X3DScene .prototype),
   {
      constructor: Scene,
      setExecutionContext: function (value)
      {
         if (!this .isMainScene ())
         {
            const scene = this .getScene ();

            for (const object of this [_loadingObjects])
               scene .removeLoadCount (object);
         }

         X3DScene .prototype .setExecutionContext .call (this, value);

         if (!this .isMainScene ())
         {
            const scene = this .getScene ();

            for (const object of this [_loadingObjects])
               scene .addLoadCount (object);
         }
      },
      addInitLoadCount: function (node)
      {
         this ._initLoadCount = this ._initLoadCount .getValue () + 1;
      },
      removeInitLoadCount: function (node)
      {
         this ._initLoadCount = this ._initLoadCount .getValue () - 1;
      },
      addLoadCount: function (node)
      {
         if (this [_loadingObjects] .has (node))
            return;

         this [_loadingObjects] .add (node);

         this ._loadCount = this [_loadingObjects] .size;

         const
            browser = this .getBrowser (),
            scene   = this .getScene ();

         if (this === browser .getExecutionContext () || this .loader === browser .loader)
            browser .addLoadCount (node);

         if (!this .isMainScene ())
            scene .addLoadCount (node);
      },
      removeLoadCount: function (node)
      {
         if (!this [_loadingObjects] .has (node))
            return;

         this [_loadingObjects] .delete (node);

         this ._loadCount = this [_loadingObjects] .size;

         const
            browser = this .getBrowser (),
            scene   = this .getScene ();

         if (this === browser .getExecutionContext () || this .loader === browser .loader)
            browser .removeLoadCount (node);

         if (!this .isMainScene ())
            scene .removeLoadCount (node);
      },
      getLoadingObjects: function ()
      {
         return this [_loadingObjects];
      },
   });

   for (const key of Reflect .ownKeys (Scene .prototype))
      Object .defineProperty (Scene .prototype, key, { enumerable: false });

   return Scene;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/X3DParser',[],function ()
{
"use strict";

   function X3DParser (scene)
   {
      this .scene             = scene;
      this .executionContexts = [ scene ];
      this .prototypes        = [ ];
      this .units             = true;
   }

   X3DParser .prototype = {
      constructor: X3DParser,
      getScene: function ()
      {
         return this .scene;
      },
      getBrowser: function ()
      {
         return this .scene .getBrowser ();
      },
      getExecutionContext: function ()
      {
         return this .executionContexts .at (-1);
      },
      pushExecutionContext: function (executionContext)
      {
         return this .executionContexts .push (executionContext);
      },
      popExecutionContext: function ()
      {
         this .executionContexts .pop ();
      },
      getPrototype: function ()
      {
         return this .prototypes .at (-1);
      },
      pushPrototype: function (prototype)
      {
         return this .prototypes .push (prototype);
      },
      popPrototype: function ()
      {
         this .prototypes .pop ();
      },
      isInsideProtoDefinition: function ()
      {
         return Boolean (this .prototypes .length);
      },
      addRootNode: function (node)
      {
         this .getExecutionContext () .rootNodes .push (node);
      },
      getProviderUrls: (function ()
      {
         const componentsUrl = /\.js$/;

         return function ()
         {
            const
               scene             = this .getScene (),
               profile           = scene .getProfile () ? scene .getProfile () : scene .getBrowser () .getProfile ("Full"),
               profileComponents = profile .components,
               components        = scene .getComponents (),
               providerUrls      = new Set ();

            for (const component of profileComponents)
            {
               const providerUrl = component .providerUrl;

               if (providerUrl .match (componentsUrl))
                  providerUrls .add (providerUrl);
            }

            for (const component of components)
            {
               const providerUrl = component .providerUrl;

               if (providerUrl .match (componentsUrl))
                  providerUrls .add (providerUrl);
            }

            if (typeof __global_require__ === "function" && typeof __filename === "string")
            {
               for (const url of providerUrls)
                  __global_require__ (__global_require__ ("url") .fileURLToPath (url));
            }

            return Array .from (providerUrls);
         };
      })(),
      setUnits: function (generator)
      {
         if (typeof arguments [0] == "boolean")
         {
            this .units = arguments [0];
            return;
         }

         const
            version = /Titania\s+V(\d+).*/,
            match   = generator .match (version);

         if (match)
         {
            const major = parseInt (match [1]);

            // Before version 4 units are wrongly implemented.
            if (major < 4)
            {
               this .units = false;
               return;
            }
         }

         this .units = true;
      },
      getUnits: function ()
      {
         return this .units;
      },
      fromUnit: function (category, value)
      {
         if (this .units)
            return this .scene .fromUnit (category, value);

         return value;
      },
   };

   return X3DParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/X3DUrlObject',[
   "x_ite/Fields",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DConstants)
{
"use strict";

   const
      _cache                   = Symbol (),
      _autoRefreshStartTime    = Symbol (),
      _autoRefreshCompleteTime = Symbol (),
      _autoRefreshId           = Symbol ();

   function X3DUrlObject (executionContext)
   {
      this .addType (X3DConstants .X3DUrlObject);

      this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE),
                             "loadNow", new Fields .SFTime ());

      this [_cache]                = true;
      this [_autoRefreshStartTime] = performance .now ();
   }

   X3DUrlObject .prototype =
   {
      constructor: X3DUrlObject,
      initialize: function ()
      {
         this .isLive () .addInterest ("set_live__", this);

         this ._load                 .addInterest ("set_load__",        this);
         this ._url                  .addInterest ("set_url__",         this);
         this ._loadNow              .addInterest ("loadNow",           this);
         this ._autoRefresh          .addInterest ("set_autoRefresh__", this);
         this ._autoRefreshTimeLimit .addInterest ("set_autoRefresh__", this);
      },
      setLoadState: function (value, notify = true)
      {
         this ._loadState = value;

         if (value === X3DConstants .COMPLETE_STATE)
         {
            this [_autoRefreshCompleteTime] = performance .now ();
            this .setAutoRefreshTimer (this ._autoRefresh .getValue ());
         }

         if (!notify)
            return;

         switch (value)
         {
            case X3DConstants .NOT_STARTED_STATE:
               break;
            case X3DConstants .IN_PROGRESS_STATE:
            {
               this .getScene () .addLoadCount (this);
               break;
            }
            case X3DConstants .COMPLETE_STATE:
            case X3DConstants .FAILED_STATE:
            {
               this .getScene () .removeLoadCount (this);
               break;
            }
         }
      },
      checkLoadState: function ()
      {
         return this ._loadState .getValue ();
      },
      getLoadState: function ()
      {
         return this ._loadState;
      },
      setCache: function (value)
      {
         this [_cache] = value;
      },
      getCache: function ()
      {
         return this [_cache];
      },
      requestImmediateLoad: function (cache = true)
      {
         if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
            return;

         if (!this ._load .getValue ())
            return;

         if (this ._url .length === 0)
            return;

         this .setCache (cache);
         this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

         // Buffer prevents double load of the scene if load and url field are set at the same time.
         this ._loadNow = this .getBrowser () .getCurrentTime ();
      },
      loadNow: function ()
      { },
      requestUnload: function ()
      {
         if (this .checkLoadState () === X3DConstants .NOT_STARTED_STATE || this .checkLoadState () === X3DConstants .FAILED_STATE)
            return;

         this .setLoadState (X3DConstants .NOT_STARTED_STATE);
         this .unloadNow ();
      },
      unloadNow: function ()
      { },
      setAutoRefreshTimer: function (autoRefreshInterval)
      {
         clearTimeout (this [_autoRefreshId]);

         if (this ._autoRefresh .getValue () <= 0)
            return;

         const autoRefreshTimeLimit = this ._autoRefreshTimeLimit .getValue ();

         if (autoRefreshTimeLimit !== 0)
         {
            if ((performance .now () - this [_autoRefreshStartTime]) / 1000 > autoRefreshTimeLimit - autoRefreshInterval)
               return;
         }

         this [_autoRefreshId] = setTimeout (this .performAutoRefresh .bind (this), autoRefreshInterval * 1000);
      },
      performAutoRefresh: function ()
      {
         this .setLoadState (X3DConstants .NOT_STARTED_STATE);
         this .requestImmediateLoad (false);
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue ())
            this .set_autoRefresh__ ();
         else
            clearTimeout (this [_autoRefreshId]);
      },
      set_load__: function ()
      {
         if (this ._load .getValue ())
            this .requestImmediateLoad ();
         else
            this .requestUnload ();
      },
      set_url__: function ()
      {
         if (!this ._load .getValue ())
            return;

         this .setLoadState (X3DConstants .NOT_STARTED_STATE);
         this .requestImmediateLoad ();
      },
      set_autoRefresh__: function ()
      {
         if (this .checkLoadState () !== X3DConstants .COMPLETE_STATE)
            return;

         const
            elapsedTime = (performance .now () - this [_autoRefreshCompleteTime]) / 1000,
            autoRefresh = this ._autoRefresh .getValue ();

         let autoRefreshInterval = autoRefresh - elapsedTime;

         if (autoRefreshInterval < 0)
            autoRefreshInterval = Math .ceil (elapsedTime / autoRefresh) * autoRefresh - elapsedTime;

         this .setAutoRefreshTimer (autoRefreshInterval);
      }
   };

   return X3DUrlObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DPrototypeInstance',[
   "x_ite/Base/X3DChildObject",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Execution/X3DExecutionContext",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (X3DChildObject,
          X3DNode,
          X3DExecutionContext,
          X3DConstants,
          Generator)
{
"use strict";

   const
      _protoNode        = Symbol (),
      _protoFields      = Symbol (),
      _fieldDefinitions = Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions"),
      _body             = Symbol ();

   function X3DPrototypeInstance (executionContext, protoNode)
   {
      this [_protoNode]        = protoNode;
      this [_protoFields]      = new Map (protoNode .getFields () .map (f => [f, f .getName ()]));
      this [_fieldDefinitions] = protoNode .getFieldDefinitions ();
      this [_body]             = null;

      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DPrototypeInstance);
   }

   X3DPrototypeInstance .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DPrototypeInstance,
      create: function (executionContext)
      {
         return new X3DPrototypeInstance (executionContext, this [_protoNode]);
      },
      getTypeName: function ()
      {
         return this [_protoNode] .getName ();
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DNode .prototype .initialize .call (this);

         this .setProtoNode (this [_protoNode]);
      },
      construct: function ()
      {
         if (this [_body])
            this [_body] .dispose ();

         const proto = this [_protoNode] .getProtoDeclaration ();

         if (!proto)
         {
            this [_body] = new X3DExecutionContext (this .getExecutionContext ());
            this [_body] .setOuterNode (this);
            this [_body] .setup ();

            if (this .isInitialized ())
               X3DChildObject .prototype .addEvent .call (this);

            return;
         }

         // If there is a proto the externproto is completely loaded.

         if (this [_protoNode] .isExternProto)
         {
            for (const protoField of proto .getUserDefinedFields ())
            {
               try
               {
                  const field = this .getField (protoField .getName ());

                  // Continue if something is wrong.
                  if (field .getAccessType () !== protoField .getAccessType ())
                     continue;

                  // Continue if something is wrong.
                  if (field .getType () !== protoField .getType ())
                     continue;

                  // Continue if field is eventIn or eventOut.
                  if (!field .isInitializable ())
                     continue;

                  // Is set during parse.
                  if (field .getModificationTime ())
                     continue;

                  // Has IS references.
                  if (field .hasReferences ())
                     continue;

                  if (field .equals (protoField))
                     continue;

                  // If default value of protoField is different from field, thus update default value for field.
                  field .assign (protoField);
               }
               catch (error)
               {
                  // Definition exists in proto but does not exist in extern proto.
                  this .addField (proto .getFieldDefinitions () .get (protoField .getName ()));
               }
            }
         }

         // Create execution context.

         this [_body] = new X3DExecutionContext (proto .getExecutionContext ());
         this [_body] .setOuterNode (this);

         // Copy proto.

         this .importExternProtos (proto .getBody () .externprotos);
         this .importProtos       (proto .getBody () .protos);
         this .copyRootNodes      (proto .getBody () .rootNodes);
         this .copyImportedNodes  (proto .getBody (), proto .getBody () .getImportedNodes ());
         this .copyRoutes         (proto .getBody (), proto .getBody () .routes);

         this [_body] .setup ();

         if (this .isInitialized ())
            X3DChildObject .prototype .addEvent .call (this);

         this [_protoNode] ._updateInstances .removeInterest ("construct", this);
         this [_protoNode] ._updateInstances .addInterest ("update", this);
      },
      update: function ()
      {
         // Remove old fields.

         const
            oldProtoFields = this [_protoFields],
            oldFields      = new Map (this .getFields () .map (f => [f .getName (), f]));

         for (const field of oldFields .values ())
            this .removeField (field .getName ());

         // Add new fields.

         this [_protoFields] = new Map (this [_protoNode] .getFields () .map (f => [f, f .getName ()]));

         for (const fieldDefinition of this .getFieldDefinitions ())
            this .addField (fieldDefinition);

         // Reuse old fields, and therefor routes.

         for (const protoField of this [_protoFields] .keys ())
         {
            const oldFieldName = oldProtoFields .get (protoField);

            if (!oldFieldName)
               continue;

            const
               newField = this .getFields () .get (protoField .getName ()),
               oldField = oldFields .get (oldFieldName);

            oldField .addParent (this);
            oldField .setAccessType (newField .getAccessType ());
            oldField .setName (newField .getName ());

            this .getPredefinedFields () .update (newField .getName (), newField .getName (), oldField);
            this .getFields ()           .update (newField .getName (), newField .getName (), oldField);

            if (!this .getPrivate ())
               oldField .addCloneCount (1);

            oldFields .delete (oldFieldName);
            newField .dispose ();
         }

         for (const oldField of oldFields .values ())
            oldField .dispose ();

         // Construct now.

         this .construct ();
      },
      getExtendedEventHandling: function ()
      {
         return false;
      },
      getProtoNode: function ()
      {
         return this [_protoNode];
      },
      setProtoNode: function (protoNode)
      {
         if (protoNode !== this [_protoNode])
         {
            // Disconnect old proto node.

            if (this [_protoNode])
            {
               const protoNode = this [_protoNode];

               protoNode ._name_changed .removeFieldInterest (this ._typeName_changed);
               protoNode ._updateInstances .removeInterest ("construct", this);
               protoNode ._updateInstances .removeInterest ("update",    this);
            }

            // Get field from new proto node.

            this [_protoFields]      = new Map (protoNode .getFields () .map (f => [f, f .getName ()]));
            this [_fieldDefinitions] = protoNode .getFieldDefinitions ();
         }

         this [_protoNode] = protoNode;

         protoNode ._name_changed .addFieldInterest (this ._typeName_changed);

         const X3DProtoDeclaration = require ("x_ite/Prototype/X3DProtoDeclaration");

         if (this .getExecutionContext () .getOuterNode () instanceof X3DProtoDeclaration)
            return;

         if (protoNode .isExternProto)
         {
            if (this [_protoNode] .checkLoadState () === X3DConstants .COMPLETE_STATE)
            {
               this .construct ();
            }
            else
            {
               protoNode ._updateInstances .addInterest ("construct", this);
               protoNode .requestImmediateLoad ();
            }
         }
         else
         {
            this .construct ();
         }
      },
      getBody: function ()
      {
         return this [_body];
      },
      getInnerNode: function ()
      {
         const rootNodes = this [_body] .getRootNodes () .getValue ();

         if (rootNodes .length)
         {
            const rootNode = rootNodes [0];

            if (rootNode)
               return rootNode .getValue () .getInnerNode ();
         }

         throw new Error ("Root node not available.");
      },
      importExternProtos: function (externprotos1)
      {
         const externprotos2 = this [_body] .externprotos;

         for (const externproto of externprotos1)
            externprotos2 .add (externproto .getName (), externproto);
      },
      importProtos: function (protos1)
      {
         const protos2 = this [_body] .protos;

         for (const proto of protos1)
            protos2 .add (proto .getName (), proto);
      },
      copyRootNodes: function (rootNodes1)
      {
         const rootNodes2 = this [_body] .getRootNodes ();

         for (const node of rootNodes1)
            rootNodes2 .push (node .copy (this));
      },
      copyImportedNodes: function (executionContext, importedNodes)
      {
         for (const importedNode of importedNodes)
         {
            try
            {
               const
                  inlineNode   = this [_body] .getNamedNode (importedNode .getInlineNode () .getName ()),
                  importedName = importedNode .getImportedName (),
                  exportedName = importedNode .getExportedName ();

               this [_body] .addImportedNode (inlineNode, exportedName, importedName);
            }
            catch (error)
            {
               console .error ("Bad IMPORT specification in copy: ", error);
            }
         }
      },
      copyRoutes: function (executionContext, routes)
      {
         for (const route of routes)
         {
            try
            {
               const
                  sourceNode      = this [_body] .getLocalNode (executionContext .getLocalName (route .sourceNode)),
                  destinationNode = this [_body] .getLocalNode (executionContext .getLocalName (route .destinationNode));

               this [_body] .addRoute (sourceNode, route .sourceField, destinationNode, route .destinationField);
            }
            catch (error)
            {
               console .error (error);
            }
         }
      },
      toXMLStream: function (stream)
      {
         const
            generator  = Generator .Get (stream),
            sharedNode = generator .IsSharedNode (this);

         generator .EnterScope ();

         const name = generator .Name (this);

         if (name .length)
         {
            if (generator .ExistsNode (this))
            {
               stream .string += generator .Indent ();
               stream .string += "<ProtoInstance";
               stream .string += " ";
               stream .string += "name='";
               stream .string += generator .XMLEncode (this .getTypeName ());
               stream .string += "'";
               stream .string += " ";
               stream .string += "USE='";
               stream .string += generator .XMLEncode (name);
               stream .string += "'";

               const containerField = generator .ContainerField ();

               if (containerField)
               {
                  if (containerField .getName () !== this .getContainerField ())
                  {
                     stream .string += " ";
                     stream .string += "containerField='";
                     stream .string += generator .XMLEncode (containerField .getName ());
                     stream .string += "'";
                  }
               }

               stream .string += "/>";

               generator .LeaveScope ();
               return;
            }
         }

         stream .string += generator .Indent ();
         stream .string += "<ProtoInstance";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (this .getTypeName ());
         stream .string += "'";

         if (name .length)
         {
            generator .AddNode (this);

            stream .string += " ";
            stream .string += "DEF='";
            stream .string += generator .XMLEncode (name);
            stream .string += "'";
         }

         const containerField = generator .ContainerField ();

         if (containerField)
         {
            if (containerField .getName () !== this .getContainerField ())
            {
               stream .string += " ";
               stream .string += "containerField='";
               stream .string += generator .XMLEncode (containerField .getName ());
               stream .string += "'";
            }
         }

         const fields = this .getChangedFields ();

         if (fields .length === 0)
         {
            stream .string += "/>";
         }
         else
         {
            stream .string += ">\n";

            generator .IncIndent ();

            const references = [ ];

            for (const field of fields)
            {
               // If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
               // for this field.

               let mustOutputValue = false;

               if (generator .ExecutionContext ())
               {
                  if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
                  {
                     let initializableReference = false;

                     field .getReferences () .forEach (function (fieldReference)
                     {
                        initializableReference = initializableReference || fieldReference .isInitializable ();
                     });

                     if (!initializableReference)
                        mustOutputValue = !this .isDefaultValue (field);
                  }
               }

               // If we have no execution context we are not in a proto and must not generate IS references the same is true
               // if the node is a shared node as the node does not belong to the execution context.

               if (field .getReferences () .size === 0 || !generator .ExecutionContext () || sharedNode || mustOutputValue)
               {
                  if (mustOutputValue)
                     references .push (field);

                  switch (field .getType ())
                  {
                     case X3DConstants .MFNode:
                     {
                        stream .string += generator .Indent ();
                        stream .string += "<fieldValue";
                        stream .string += " ";
                        stream .string += "name='";
                        stream .string += generator .XMLEncode (field .getName ());
                        stream .string += "'";

                        if (field .length === 0)
                        {
                           stream .string += "/>\n";
                        }
                        else
                        {
                           generator .PushContainerField (field);

                           stream .string += ">\n";

                           generator .IncIndent ();

                           field .toXMLStream (stream);

                           stream .string += "\n";

                           generator .DecIndent ();

                           stream .string += generator .Indent ();
                           stream .string += "</fieldValue>\n";

                           generator .PopContainerField ();
                        }

                        break;
                     }
                     case X3DConstants .SFNode:
                     {
                        if (field .getValue () !== null)
                        {
                           generator .PushContainerField (field);

                           stream .string += generator .Indent ();
                           stream .string += "<fieldValue";
                           stream .string += " ";
                           stream .string += "name='";
                           stream .string += generator .XMLEncode (field .getName ());
                           stream .string += "'";
                           stream .string += ">\n";

                           generator .IncIndent ();

                           field .toXMLStream (stream);

                           stream .string += "\n";

                           generator .DecIndent ();

                           stream .string += generator .Indent ();
                           stream .string += "</fieldValue>\n";

                           generator .PopContainerField ();
                           break;
                        }

                        // Proceed with next case.
                     }
                     default:
                     {
                        stream .string += generator .Indent ();
                        stream .string += "<fieldValue";
                        stream .string += " ";
                        stream .string += "name='";
                        stream .string += generator .XMLEncode (field .getName ());
                        stream .string += "'";
                        stream .string += " ";
                        stream .string += "value='";

                        field .toXMLStream (stream);

                        stream .string += "'";
                        stream .string += "/>\n";
                        break;
                     }
                  }
               }
               else
               {
                  references .push (field);
               }
            }

            if (references .length && !sharedNode)
            {
               stream .string += generator .Indent ();
               stream .string += "<IS>";
               stream .string += "\n";

               generator .IncIndent ();

               for (const field of references)
               {
                  const protoFields = field .getReferences ();

                  protoFields .forEach (function (protoField)
                  {
                     stream .string += generator .Indent ();
                     stream .string += "<connect";
                     stream .string += " ";
                     stream .string += "nodeField='";
                     stream .string += generator .XMLEncode (field .getName ());
                     stream .string += "'";
                     stream .string += " ";
                     stream .string += "protoField='";
                     stream .string += generator .XMLEncode (protoField .getName ());
                     stream .string += "'";
                     stream .string += "/>\n";
                  });
               }

               generator .DecIndent ();

               stream .string += generator .Indent ();
               stream .string += "</IS>\n";
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</ProtoInstance>";
         }

         generator .LeaveScope ();
      },
      dispose: function ()
      {
         this [_protoNode] ._updateInstances .removeInterest ("construct", this);
         this [_protoNode] ._updateInstances .removeInterest ("update",    this);

         if (this [_body])
            this [_body] .dispose ();

         X3DNode .prototype .dispose .call (this);
      },
   });

   return X3DPrototypeInstance;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DProtoDeclarationNode',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Core/X3DPrototypeInstance",
   "x_ite/Fields/SFNodeCache",
   "x_ite/Base/X3DConstants",
],
function (SupportedNodes,
          Fields,
          X3DBaseNode,
          X3DPrototypeInstance,
          SFNodeCache,
          X3DConstants)
{
"use strict";

   SupportedNodes .addAbstractType ("X3DProtoDeclarationNode", X3DProtoDeclarationNode);

   function X3DProtoDeclarationNode (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addType (X3DConstants .X3DProtoDeclarationNode);

      this .addChildObjects ("updateInstances", new Fields .SFTime ());
   }

   X3DProtoDeclarationNode .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DProtoDeclarationNode,
      canUserDefinedFields: function ()
      {
         return true;
      },
      createInstance: function (executionContext, setup = true)
      {
         if (setup === false)
         {
            return new X3DPrototypeInstance (executionContext, this);
         }
         else
         {
            const instance = new X3DPrototypeInstance (executionContext, this);

            instance .setup ();

            return SFNodeCache .get (instance);
         }
      },
      newInstance: function ()
      {
         return this .createInstance (this .getExecutionContext ());
      },
      requestUpdateInstances: function ()
      {
         this ._updateInstances = this .getBrowser () .getCurrentTime ();
      },
      updateInstances: function ()
      {
         this ._updateInstances .processEvent ();
      },
   });

   for (const key of Reflect .ownKeys (X3DProtoDeclarationNode .prototype))
      Object .defineProperty (X3DProtoDeclarationNode .prototype, key, { enumerable: false });

   return X3DProtoDeclarationNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DExternProtoDeclaration',[
   "jquery",
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Prototype/X3DProtoDeclarationNode",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function ($,
          SupportedNodes,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DUrlObject,
          X3DProtoDeclarationNode,
          X3DConstants,
          Generator)
{
"use strict";

   SupportedNodes .addAbstractType ("X3DExternProtoDeclaration", X3DExternProtoDeclaration);

   const
      _proto = Symbol (),
      _scene = Symbol ();

   function X3DExternProtoDeclaration (executionContext, url)
   {
      X3DProtoDeclarationNode .call (this, executionContext);
      X3DUrlObject            .call (this, executionContext);

      this .addType (X3DConstants .X3DExternProtoDeclaration)

      this .addChildObjects ("load",                 new Fields .SFBool (true),
                             "url",                  url .copy (), // Must be of type MFString.
                             "autoRefresh",          new Fields .SFTime (),
                             "autoRefreshTimeLimit", new Fields .SFTime (3600));
   }

   X3DExternProtoDeclaration .prototype = Object .assign (Object .create (X3DProtoDeclarationNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: X3DExternProtoDeclaration,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "X3DExternProtoDeclaration";
      },
      initialize: function ()
      {
         X3DProtoDeclarationNode .prototype .initialize .call (this);
         X3DUrlObject            .prototype .initialize .call (this);
      },
      set_live__: function ()
      {
         X3DUrlObject .prototype .set_live__ .call (this);

         if (this .checkLoadState () !== X3DConstants .COMPLETE_STATE)
            return;

         this [_scene] .setLive (this .isLive () .getValue ());
      },
      canUserDefinedFields: function ()
      {
         return true;
      },
      setProtoDeclaration: function (proto)
      {
         this [_proto] = proto;

         if (proto)
         {
            for (const field of this .getUserDefinedFields ())
               this .removeUserDefinedField (field .getName ())

            for (const field of proto .getUserDefinedFields ())
               this .addUserDefinedField (field .getAccessType (), field .getName (), field);
         }

         this .updateInstances ();
      },
      getProtoDeclaration: function ()
      {
         return this [_proto];
      },
      loadNow: function ()
      {
         // 7.73 — ExternProtoDeclaration function

         this .getScene () .addInitLoadCount (this);

         const FileLoader = require ("x_ite/InputOutput/FileLoader");

         new FileLoader (this) .createX3DFromURL (this ._url, null, this .setInternalSceneAsync .bind (this));
      },
      setInternalSceneAsync: function (value)
      {
         if (value)
            this .setInternalScene (value);

         else
            this .setError (new Error ("File could not be loaded."));

         this .getScene () .removeInitLoadCount (this);
      },
      setInternalScene: function (value)
      {
         this [_scene] = value;

         const
            protoName = decodeURIComponent (new URL (this [_scene] .getWorldURL ()) .hash .substr (1)),
            proto     = protoName ? this [_scene] .protos .get (protoName) : this [_scene] .protos [0];

         if (!proto)
            throw new Error ("PROTO not found");

         this [_scene] .setLive (this .isLive () .getValue ());
         this [_scene] .setPrivate (this .getScene () .getPrivate ());
         this [_scene] .setExecutionContext (this .getExecutionContext ());

         this .setLoadState (X3DConstants .COMPLETE_STATE);
         this .setProtoDeclaration (proto);
      },
      getInternalScene: function ()
      {
         ///  Returns the internal X3DScene of this extern proto, that is loaded from the url given.

         return this [_scene];
      },
      setError: function (error)
      {
         console .error ("Error loading extern prototype:", error);

         this [_scene] = this .getBrowser () .getPrivateScene ();

         this .setLoadState (X3DConstants .FAILED_STATE);
         this .setProtoDeclaration (null);
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "EXTERNPROTO";
         stream .string += " ";
         stream .string += this .getName ();
         stream .string += " ";
         stream .string += "[";

         const userDefinedFields = this .getUserDefinedFields ();

         let
            fieldTypeLength   = 0,
            accessTypeLength  = 0;

         if (userDefinedFields .length === 0)
         {
            stream .string += " ";
         }
         else
         {
            for (const field of userDefinedFields)
            {
               fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
               accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
            }

            stream .string += "\n";

            generator .IncIndent ();

            for (const field of userDefinedFields)
            {
               this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
               stream .string += "\n";
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
         }

         stream .string += "]";
         stream .string += "\n";

         stream .string += generator .Indent ();

         this ._url .toVRMLStream (stream);
      },
      toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
         stream .string += " ";
         stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
         stream .string += " ";
         stream .string += field .getName ();
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "<ExternProtoDeclare";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (this .getName ());
         stream .string += "'";
         stream .string += " ";
         stream .string += "url='";

         this ._url .toXMLStream (stream);

         stream .string += "'";
         stream .string += ">\n";

         generator .IncIndent ();

         const userDefinedFields = this .getUserDefinedFields ();

         for (const field of userDefinedFields)
         {
            stream .string += generator .Indent ();
            stream .string += "<field";
            stream .string += " ";
            stream .string += "accessType='";
            stream .string += generator .AccessType (field .getAccessType ());
            stream .string += "'";
            stream .string += " ";
            stream .string += "type='";
            stream .string += field .getTypeName ();
            stream .string += "'";
            stream .string += " ";
            stream .string += "name='";
            stream .string += generator .XMLEncode (field .getName ());
            stream .string += "'";
            stream .string += "/>\n";
         }

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</ExternProtoDeclare>";
      },
   });

   for (const key of Reflect .ownKeys (X3DExternProtoDeclaration .prototype))
      Object .defineProperty (X3DExternProtoDeclaration .prototype, key, { enumerable: false });

   Object .defineProperty (X3DExternProtoDeclaration .prototype, "name",
   {
      get: function () { return this .getName (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExternProtoDeclaration .prototype, "fields",
   {
      get: function () { return this .getFieldDefinitions (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExternProtoDeclaration .prototype, "isExternProto",
   {
      get: function () { return true; },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExternProtoDeclaration .prototype, "urls",
   {
      get: function () { return this ._url; },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DExternProtoDeclaration .prototype, "loadState",
   {
      get: function () { return this .checkLoadState (); },
      enumerable: true,
      configurable: false
   });

   return X3DExternProtoDeclaration;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DProtoDeclaration',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Execution/X3DExecutionContext",
   "x_ite/Prototype/X3DProtoDeclarationNode",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/Generator",
],
function (SupportedNodes,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DExecutionContext,
          X3DProtoDeclarationNode,
          X3DConstants,
          Generator)
{
"use strict";

   SupportedNodes .addAbstractType ("X3DProtoDeclaration", X3DProtoDeclaration);

   const
      _body = Symbol ();

   function X3DProtoDeclaration (executionContext)
   {
      X3DProtoDeclarationNode .call (this, executionContext);

      this .addType (X3DConstants .X3DProtoDeclaration)

      this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));

      this [_body] = new X3DExecutionContext (executionContext);
      this [_body] .setOuterNode (this);
      this [_body] .setLive (false);
      this .setLive (false);
   }

   X3DProtoDeclaration .prototype = Object .assign (Object .create (X3DProtoDeclarationNode .prototype),
   {
      constructor: X3DProtoDeclaration,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "X3DProtoDeclaration";
      },
      initialize: function ()
      {
         X3DProtoDeclarationNode .prototype .initialize .call (this);

         this [_body] .setup ();

         this ._loadState = X3DConstants .COMPLETE_STATE;
      },
      getProtoDeclaration: function ()
      {
         return this;
      },
      getBody: function ()
      {
         return this [_body];
      },
      checkLoadState: function ()
      {
         return this ._loadState .getValue ();
      },
      canUserDefinedFields: function ()
      {
         return true;
      },
      toVRMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "PROTO";
         stream .string += " ";
         stream .string += this .getName ();
         stream .string += " ";
         stream .string += "[";

         generator .EnterScope ();

         const userDefinedFields = this .getUserDefinedFields ();

         let
            fieldTypeLength  = 0,
            accessTypeLength = 0;

         if (userDefinedFields .length === 0)
         {
            stream .string += " ";
         }
         else
         {
            for (const field of userDefinedFields)
            {
               fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
               accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
            }

            stream .string += "\n";

            generator .IncIndent ();

            for (const field of userDefinedFields)
            {
               this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
               stream .string += "\n";
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
         }

         generator .LeaveScope ();

         stream .string += "]";
         stream .string += "\n";

         stream .string += generator .Indent ();
         stream .string += "{";
         stream .string += "\n";

         generator .IncIndent ();

         this [_body] .toVRMLStream (stream);

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "}";
      },
      toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
         stream .string += " ";
         stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
         stream .string += " ";
         stream .string += field .getName ();

         if (field .isInitializable ())
         {
            stream .string += " ";

            field .toVRMLStream (stream);
         }
      },
      toXMLStream: function (stream)
      {
         const generator = Generator .Get (stream);

         stream .string += generator .Indent ();
         stream .string += "<ProtoDeclare";
         stream .string += " ";
         stream .string += "name='";
         stream .string += generator .XMLEncode (this .getName ());
         stream .string += "'";
         stream .string += ">";
         stream .string += "\n";

         // <ProtoInterface>

         generator .EnterScope ();

         const userDefinedFields = this .getUserDefinedFields ();

         if (userDefinedFields .length !== 0)
         {
            generator .IncIndent ();

            stream .string += generator .Indent ();
            stream .string += "<ProtoInterface>\n";

            generator .IncIndent ();

            for (const field of userDefinedFields)
            {
               stream .string += generator .Indent ();
               stream .string += "<field";
               stream .string += " ";
               stream .string += "accessType='";
               stream .string += generator .AccessType (field .getAccessType ());
               stream .string += "'";
               stream .string += " ";
               stream .string += "type='";
               stream .string += field .getTypeName ();
               stream .string += "'";
               stream .string += " ";
               stream .string += "name='";
               stream .string += generator .XMLEncode (field .getName ());
               stream .string += "'";

               if (field .isDefaultValue ())
               {
                  stream .string += "/>\n";
               }
               else
               {
                  switch (field .getType ())
                  {
                     case X3DConstants .SFNode:
                     case X3DConstants .MFNode:
                     {
                        generator .PushContainerField (field);

                        stream .string += ">\n";

                        generator .IncIndent ();

                        field .toXMLStream (stream);

                        stream .string += "\n";

                        generator .DecIndent ();

                        stream .string += generator .Indent ();
                        stream .string += "</field>\n";

                        generator .PopContainerField ();
                        break;
                     }
                     default:
                     {
                        stream .string += " ";
                        stream .string += "value='";

                        field .toXMLStream (stream);

                        stream .string += "'";
                        stream .string += "/>\n";
                        break;
                     }
                  }
               }
            }

            generator .DecIndent ();

            stream .string += generator .Indent ();
            stream .string += "</ProtoInterface>\n";

            generator .DecIndent ();
         }

         generator .LeaveScope ();

         // </ProtoInterface>

         // <ProtoBody>

         generator .IncIndent ();

         stream .string += generator .Indent ();
         stream .string += "<ProtoBody>\n";

         generator .IncIndent ();

         this [_body] .toXMLStream (stream);

         generator .DecIndent ();

         stream .string += generator .Indent ();
         stream .string += "</ProtoBody>\n";

         generator .DecIndent ();

         // </ProtoBody>

         stream .string += generator .Indent ();
         stream .string += "</ProtoDeclare>";
      },
   });

   for (const key of Reflect .ownKeys (X3DProtoDeclaration .prototype))
      Object .defineProperty (X3DProtoDeclaration .prototype, key, { enumerable: false });

   Object .defineProperty (X3DProtoDeclaration .prototype, "name",
   {
      get: function () { return this .getName (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DProtoDeclaration .prototype, "fields",
   {
      get: function () { return this .getFieldDefinitions (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DProtoDeclaration .prototype, "isExternProto",
   {
      get: function () { return false; },
      enumerable: true,
      configurable: false
   });

   return X3DProtoDeclaration;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/VRMLParser',[
   "x_ite/Fields",
   "x_ite/Parser/X3DParser",
   "x_ite/Prototype/X3DExternProtoDeclaration",
   "x_ite/Prototype/X3DProtoDeclaration",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DParser,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          X3DConstants)
{
"use strict";

   function accessTypeToString (accessType)
   {
      switch (accessType)
      {
         case X3DConstants .inializeOnly:
            return "initializeOnly";
         case X3DConstants .inputOnly:
            return "inputOnly";
         case X3DConstants .outputOnly:
            return "outputOnly";
         case X3DConstants .inputOutput:
            return "inputOutput";
      }
   }

   /*
    *  Grammar
    */


//	Comment out scriptBody function fragments
//
//	// VRML lexical elements
//	var Grammar =
//	{
//		// General
//		Whitespaces: /^([\x20\n,\t\r]+)/,
//		Comment:     /^#(.*?)(?=[\n\r])/,
//
//		// Header
//		Header:	    /^#(VRML|X3D) V(.*?) (utf8)(?: (.*?))?[\n\r]/,
//
//		// Keywords
//		AS:          /^AS/,
//		COMPONENT:   /^COMPONENT/,
//		DEF:         /^DEF/,
//		EXPORT:      /^EXPORT/,
//		EXTERNPROTO: /^EXTERNPROTO/,
//		FALSE:       /^FALSE/,
//		false:       /^false/,
//		IMPORT:      /^IMPORT/,
//		IS:          /^IS/,
//		META:        /^META/,
//		NULL:        /^NULL/,
//		TRUE:        /^TRUE/,
//		true:        /^true/,
//		PROFILE:     /^PROFILE/,
//		PROTO:       /^PROTO/,
//		ROUTE:       /^ROUTE/,
//		TO:          /^TO/,
//		UNIT:        /^UNIT/,
//		USE:         /^USE/,
//
//		// Terminal symbols
//		OpenBrace:    /^\{/,
//		CloseBrace:   /^\}/,
//		OpenBracket:  /^\[/,
//		CloseBracket: /^\]/,
//		Period:       /^\./,
//		Colon:        /^\:/,
//
//		Id: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f]*)/,
//		ComponentNameId: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]*)/,
//
//		initializeOnly: /^initializeOnly/,
//		inputOnly:      /^inputOnly/,
//		outputOnly:     /^outputOnly/,
//		inputOutput:    /^inputOutput/,
//
//		field:        /^field/,
//		eventIn:      /^eventIn/,
//		eventOut:     /^eventOut/,
//		exposedField: /^exposedField/,
//
//		FieldType: /^(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)/,
//
//		// Values
//		int32:  /^((?:0[xX][\da-fA-F]+)|(?:[+-]?\d+))/,
//		double: /^([+-]?(?:(?:(?:\d*\.\d+)|(?:\d+(?:\.)?))(?:[eE][+-]?\d+)?))/,
//		string: /^"((?:[^"\\]|\\\\|\\")*)"/,
//
//		Inf:         /^[+]?inf/i,
//		NegativeInf: /^-inf/i,
//		NaN:         /^[+-]?nan/i,
//
//		// Misc
//		Break: /\r?\n/g,
//	};
//
//	function parse (parser)
//	{
//		this .lastIndex = 0;
//		parser .result  = this .exec (parser .input);
//
//		if (parser .result)
//		{
//			parser .input = parser .input .slice (parser .result [0] .length);
//			return true;
//		}
//
//		return false;
//	}


   // Comment out scriptBody function fragments
   //
   // VRML lexical elements
   var Grammar =
   {
      // General
      Whitespaces: new RegExp ('([\\x20\\n,\\t\\r]+)', 'gy'),
      Comment:     new RegExp ('#(.*?)(?=[\\n\\r])',   'gy'),

      // Header
      Header:	    new RegExp ("^#(VRML|X3D) V(.*?) (utf8)(?:[ \\t]+(.*?))?[ \\t]*[\\n\\r]", 'gy'),

      // Keywords
      AS:          new RegExp ('AS',          'gy'),
      COMPONENT:   new RegExp ('COMPONENT',   'gy'),
      DEF:         new RegExp ('DEF',         'gy'),
      EXPORT:      new RegExp ('EXPORT',      'gy'),
      EXTERNPROTO: new RegExp ('EXTERNPROTO', 'gy'),
      FALSE:       new RegExp ('FALSE|false', 'gy'),
      IMPORT:      new RegExp ('IMPORT',      'gy'),
      IS:          new RegExp ('IS',          'gy'),
      META:        new RegExp ('META',        'gy'),
      NULL:        new RegExp ('NULL',        'gy'),
      TRUE:        new RegExp ('TRUE|true',   'gy'),
      PROFILE:     new RegExp ('PROFILE',     'gy'),
      PROTO:       new RegExp ('PROTO',       'gy'),
      ROUTE:       new RegExp ('ROUTE',       'gy'),
      TO:          new RegExp ('TO',          'gy'),
      UNIT:        new RegExp ('UNIT',        'gy'),
      USE:         new RegExp ('USE',         'gy'),

      // Terminal symbols
      OpenBrace:    new RegExp ('\\{', 'gy'),
      CloseBrace:   new RegExp ('\\}', 'gy'),
      OpenBracket:  new RegExp ('\\[', 'gy'),
      CloseBracket: new RegExp ('\\]', 'gy'),
      Period:       new RegExp ('\\.', 'gy'),
      Colon:        new RegExp ('\\:', 'gy'),

      Id: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]*)', 'gy'),
      ComponentNameId: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]*)', 'gy'),

      initializeOnly: new RegExp ('initializeOnly', 'gy'),
      inputOnly:      new RegExp ('inputOnly',      'gy'),
      outputOnly:     new RegExp ('outputOnly',     'gy'),
      inputOutput:    new RegExp ('inputOutput',    'gy'),

      field:        new RegExp ('field', 'gy'),
      eventIn:      new RegExp ('eventIn', 'gy'),
      eventOut:     new RegExp ('eventOut', 'gy'),
      exposedField: new RegExp ('exposedField', 'gy'),

      FieldType: new RegExp ('(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)', 'gy'),

      // Values
      int32:  new RegExp ('((?:0[xX][\\da-fA-F]+)|(?:[+-]?\\d+))', 'gy'),
      double: new RegExp ('([+-]?(?:(?:(?:\\d*\\.\\d+)|(?:\\d+(?:\\.)?))(?:[eE][+-]?\\d+)?))', 'gy'),
      string: new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'gy'),

      Inf:         new RegExp ('[+]?(?:inf|Infinity)', 'gy'),
      NegativeInf: new RegExp ('-(?:inf|Infinity)',    'gy'),
      NaN:         new RegExp ('[+-]?(nan|NaN)',       'gy'),

      // Misc
      Break: new RegExp ('\\r?\\n', 'g'),
   };

   function parse (parser)
   {
      this .lastIndex = parser .lastIndex;

      parser .result = this .exec (parser .input);

      if (parser .result)
      {
         parser .lastIndex = this .lastIndex;
         return true;
      }

      return false;
   }

   for (var key in Grammar)
      Grammar [key] .parse = parse;

   /*
    *  Parser
    */

   function VRMLParser (scene)
   {
      X3DParser .call (this, scene);
   }

   VRMLParser .prototype = Object .assign (Object .create (X3DParser .prototype),
   {
      constructor: VRMLParser,
      accessTypes:
      {
         field:          X3DConstants .initializeOnly,
         eventIn:        X3DConstants .inputOnly,
         eventOut:       X3DConstants .outputOnly,
         exposedField:   X3DConstants .inputOutput,
         initializeOnly: X3DConstants .initializeOnly,
         inputOnly:      X3DConstants .inputOnly,
         outputOnly:     X3DConstants .outputOnly,
         inputOutput:    X3DConstants .inputOutput,
      },
      SFBool: new Fields .SFBool (),
      SFColor: new Fields .SFColor (),
      SFColorRGBA: new Fields .SFColorRGBA (),
      SFDouble: new Fields .SFDouble (),
      SFFloat: new Fields .SFFloat (),
      SFImage: new Fields .SFImage (),
      SFInt32: new Fields .SFInt32 (),
      SFMatrix3f: new Fields .SFMatrix3f (),
      SFMatrix3d: new Fields .SFMatrix3d (),
      SFMatrix4f: new Fields .SFMatrix4f (),
      SFMatrix4d: new Fields .SFMatrix4d (),
      SFNode: new Fields .SFNode (),
      SFRotation: new Fields .SFRotation (),
      SFString: new Fields .SFString (),
      SFTime: new Fields .SFTime (),
      SFVec2d: new Fields .SFVec2d (),
      SFVec2f: new Fields .SFVec2f (),
      SFVec3d: new Fields .SFVec3d (),
      SFVec3f: new Fields .SFVec3f (),
      SFVec4d: new Fields .SFVec4d (),
      SFVec4f: new Fields .SFVec4f (),
      MFBool: new Fields .MFBool (),
      MFColor: new Fields .MFColor (),
      MFColorRGBA: new Fields .MFColorRGBA (),
      MFDouble: new Fields .MFDouble (),
      MFFloat: new Fields .MFFloat (),
      MFImage: new Fields .MFImage (),
      MFInt32: new Fields .MFInt32 (),
      MFMatrix3d: new Fields .MFMatrix3d (),
      MFMatrix3f: new Fields .MFMatrix3f (),
      MFMatrix4d: new Fields .MFMatrix4d (),
      MFMatrix4f: new Fields .MFMatrix4f  (),
      MFNode: new Fields .MFNode (),
      MFRotation: new Fields .MFRotation (),
      MFString: new Fields .MFString (),
      MFTime: new Fields .MFTime (),
      MFVec2d: new Fields .MFVec2d (),
      MFVec2f: new Fields .MFVec2f (),
      MFVec3d: new Fields .MFVec3d (),
      MFVec3f: new Fields .MFVec3f (),
      MFVec4d: new Fields .MFVec4d (),
      MFVec4f: new Fields .MFVec4f (),
      isValid: function ()
      {
         return !! this .input .match (/^(?:#X3D|#VRML|(?:[\x20\n,\t\r]*|#.*?[\r\n])*(PROFILE|COMPONENT|META|UNIT|EXTERNPROTO|PROTO|DEF|NULL|IMPORT|EXPORT|ROUTE|\w+(?:[\x20\n,\t\r]*|#.*?[\r\n])\{|$))/);
      },
      getInput: function ()
      {
         return this .input;
      },
      setInput: function (vrmlSyntax)
      {
         this .input      = vrmlSyntax;
         this .lineNumber = 1;
         this .lastIndex  = 0;
      },
      parseIntoScene: function (success, error)
      {
         try
         {
            this .success = success;
            this .error   = error;

            this .getScene () .setEncoding ("VRML");
            this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));
            this .x3dScene ();
         }
         catch (error)
         {
            //console .error (error);
            throw new Error (this .getError (error));
         }
      },
      exception: function (string)
      {
         if (this .getBrowser () .isStrict ())
            throw new Error (string);

         console .warn (string);
      },
      getError: function (error)
      {
         //console .error (error);

         var string = error .message;

         var
            rest     = this .getLine (),
            line     = this .getLastLine (),
            lastLine = this .getLastLine (),
            linePos  = line .length - rest .length + 1;

         if (line .length > 80)
         {
            line     = line .substr (linePos - 40, 80);
            lastLine = "";
            linePos  = 40;
         }

         // Format error

         var message = "\n"
            + "********************************************************************************" + "\n"
            + "Parser error at line " + this .lineNumber + ":" + linePos  + "\n"
            + "in '" + this .getScene () .getWorldURL () + "'" + "\n"
            + "\n"
            + lastLine + "\n"
            + line + "\n"
            + Array (linePos) .join (" ") + "^" + "\n"
            + string + "\n"
            + "********************************************************************************"
            + "\n"
         ;

         return message;
      },
      getLine: function ()
      {
         var
            input     = this .input,
            lastIndex = this .lastIndex,
            line      = "";

         while (lastIndex < input .length && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
            line += input [lastIndex ++];

         this .lastIndex = lastIndex;

         return line;
      },
      getLastLine: function ()
      {
         var
            input     = this .input,
            lastIndex = this .lastIndex,
            line      = "";

         if (lastIndex < input .length && (input [lastIndex] !== "\n" || input [lastIndex] !== "\r"))
            -- lastIndex;

         while (lastIndex >= 0 && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
            line = input [lastIndex --] + line;

         this .lastIndex = lastIndex;

         return line;
      },
      comments: function ()
      {
         while (this .comment ())
            ;
      },
      comment: function ()
      {
         if (this .whitespaces ())
            return true;

         return Grammar .Comment .parse (this);
      },
      whitespaces: function ()
      {
         if (Grammar .Whitespaces .parse (this))
         {
            if (!this .xml)
               this .lines (this .result [1]);

            return true;
         }

         return false;
      },
      lines: function (string)
      {
         var match = string .match (Grammar .Break);

         if (match)
            this .lineNumber += match .length;
      },
      x3dScene: function ()
      {
         this .headerStatement ();
         this .profileStatement ();
         this .componentStatements ();
         this .unitStatements ();
         this .metaStatements ();

         try
         {
            this .setUnits (this .getScene () .getMetaData ("generator"));
         }
         catch (error)
         { }

         if (this .success)
         {
            require (this .getProviderUrls (),
            function ()
            {
               try
               {
                  this .statements ();

                  if (this .lastIndex < this .input .length)
                     throw new Error ("Unknown statement.");

                  this .success (this .getScene ());
               }
               catch (error)
               {
                  //console .error (error);
                  this .error (new Error (this .getError (error)));
               }
            }
            .bind (this),
            function (error)
            {
               this .error (error);
            }
            .bind (this));
         }
         else
         {
            this .statements ();

            if (this .lastIndex < this .input .length)
               throw new Error ("Unknown statement.");
         }
      },
      headerStatement: function ()
      {
         Grammar .Header .lastIndex = 0;

         var result = Grammar .Header .exec (this .input);

         if (result)
         {
            this .getScene () .setSpecificationVersion (result [2]);
            this .getScene () .setEncoding             ("VRML");
            return true;
         }

         return false;
      },
      profileStatement: function ()
      {
         this .comments ();

         if (Grammar .PROFILE .parse (this))
         {
            if (this .profileNameId ())
            {
               var profile = this .getBrowser () .getProfile (this .result [1]);

               this .getScene () .setProfile (profile);
               return;
            }

            throw new Error ("Expected a profile name.");
         }
      },
      componentStatements: function ()
      {
         var component = this .componentStatement ();

         while (component)
         {
            this .getScene () .addComponent (component);

            component = this .componentStatement ();
         }
      },
      componentStatement: function ()
      {
         this .comments ();

         if (Grammar .COMPONENT .parse (this))
         {
            if (this .componentNameId ())
            {
               var componentNameIdCharacters = this .result [1];

               this .comments ();

               if (Grammar .Colon .parse (this))
               {
                  if (this .componentSupportLevel ())
                  {
                     var componentSupportLevel = this .value;

                     return this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);
                  }

                  throw new Error ("Expected a component support level.");
               }

               throw new Error ("Expected a ':' after component name.");
            }

            throw new Error ("Expected a component name.");
         }

         return null;
      },
      componentSupportLevel: function ()
      {
         return this .int32 ();
      },
      unitStatements: function ()
      {
         while (this .unitStatement ())
            ;
      },
      unitStatement: function ()
      {
         this .comments ();

         if (Grammar .UNIT .parse (this))
         {
            if (this .categoryNameId ())
            {
               var categoryNameId = this .result [1];

               if (this .unitNameId ())
               {
                  var unitNameId = this .result [1];

                  if (this .unitConversionFactor ())
                  {
                     var unitConversionFactor = this .value;

                     try
                     {
                        this .getScene () .updateUnit (categoryNameId, unitNameId, unitConversionFactor);
                        return true;
                     }
                     catch (error)
                     {
                        console .log (error .message);
                        return true;
                     }
                  }

                  throw new Error ("Expected unit conversion factor.");
               }

               throw new Error ("Expected unit name identifier.");
            }

            throw new Error ("Expected category name identifier after UNIT statement.");
         }

         return false;
      },
      unitConversionFactor: function ()
      {
         return this .double ();
      },
      metaStatements: function ()
      {
         while (this .metaStatement ())
            ;
      },
      metaStatement: function ()
      {
         this .comments ();

         if (Grammar .META .parse (this))
         {
            if (this .metakey ())
            {
               var metakey = this .value;

               if (this .metavalue ())
               {
                  var metavalue = this .value;

                  this .getScene () .setMetaData (metakey, metavalue);
                  return true;
               }

               throw new Error ("Expected metadata value.");
            }

            throw new Error ("Expected metadata key.");
         }

         return false;
      },
      metakey: function ()
      {
         return this .string ();
      },
      metavalue: function ()
      {
         return this .string ();
      },
      exportStatement: function ()
      {
         this .comments ();

         if (Grammar .EXPORT .parse (this))
         {
            if (this .nodeNameId ())
            {
               var
                  localNodeNameId    = this .result [1],
                  exportedNodeNameId = "";

               this .comments ();

               var node = this .getScene () .getLocalNode (localNodeNameId);

               if (Grammar .AS .parse (this))
               {
                  if (this .exportedNodeNameId ())
                     exportedNodeNameId = this .result [1];
                  else
                     throw new Error ("No name given after AS.");
               }
               else
                  exportedNodeNameId = localNodeNameId;

               if (this .getScene () === this .getExecutionContext ())
               {
                  this .getScene () .updateExportedNode (exportedNodeNameId, node);
                  return true;
               }

               throw new Error ("Export statement not allowed here.");
            }

            throw new Error ("No name given after EXPORT.");
         }

         return false;
      },
      importStatement: function ()
      {
         this .comments ();

         if (Grammar .IMPORT .parse (this))
         {
            if (this .nodeNameId ())
            {
               var
                  inlineNodeNameId = this .result [1],
                  namedNode        = this .getExecutionContext () .getNamedNode (inlineNodeNameId);

               this .comments ();

               if (Grammar .Period .parse (this))
               {
                  if (this .exportedNodeNameId ())
                  {
                     var
                        exportedNodeNameId = this .result [1],
                        nodeNameId         = exportedNodeNameId;

                     this .comments ();

                     if (Grammar .AS .parse (this))
                     {
                        if (this .nodeNameId ())
                           nodeNameId = this .result [1];

                        else
                           throw new Error ("No name given after AS.");
                     }

                     this .getExecutionContext () .updateImportedNode (namedNode, exportedNodeNameId, nodeNameId);
                     return true;
                  }

                  throw new Error ("Expected exported node name.");
               }

               throw new Error ("Expected a '.' after exported node name.");
            }

            throw new Error ("No name given after IMPORT statement.");
         }
         return false;
      },
      statements: function ()
      {
         while (this .statement ())
            ;
      },
      statement: function ()
      {
         if (this .protoStatement ())
            return true;

         if (this .routeStatement ())
            return true;

         if (this .importStatement ())
            return true;

         if (this .exportStatement ())
            return true;

         var node = this .nodeStatement ();

         if (node !== false)
         {
            this .addRootNode (node);
            return true;
         }

         return false;
      },
      nodeStatement: function ()
      {
         this .comments ();

         if (Grammar .DEF .parse (this))
         {
            if (this .nodeNameId ())
               return this .node (this .result [1]);

            throw new Error ("No name given after DEF.");
         }

         if (Grammar .USE .parse (this))
         {
            if (this .nodeNameId ())
               return this .getExecutionContext () .getNamedNode (this .result [1]) .getValue ();

            throw new Error ("No name given after USE.");
         }

         if (Grammar .NULL .parse (this))
            return null;

         return this .node ("");
      },
      protoStatement: function ()
      {
         if (this .proto ())
            return true;

         if (this .externproto ())
            return true;

         return false;
      },
      protoStatements: function ()
      {
         while (this .protoStatement ())
            ;
      },
      proto: function ()
      {
         this .comments ();

         if (Grammar .PROTO .parse (this))
         {
            if (this .nodeTypeId ())
            {
               var nodeTypeId = this .result [1];

               this .comments ();

               if (Grammar .OpenBracket .parse (this))
               {
                  var interfaceDeclarations = this .interfaceDeclarations ();

                  this .comments ();

                  if (Grammar .CloseBracket .parse (this))
                  {
                     this .comments ();

                     if (Grammar .OpenBrace .parse (this))
                     {
                        var proto = new X3DProtoDeclaration (this .getExecutionContext ());

                        for (var i = 0, length = interfaceDeclarations .length; i < length; ++ i)
                        {
                           var field = interfaceDeclarations [i];

                           proto .addUserDefinedField (field .getAccessType (), field .getName (), field);
                        }

                        this .pushPrototype (proto);
                        this .pushExecutionContext (proto .getBody ());

                        this .protoBody ();

                        this .popExecutionContext ();
                        this .popPrototype ();

                        this .comments ();

                        if (Grammar .CloseBrace .parse (this))
                        {
                           proto .setup ();

                           try
                           {
                              const existingProto = this .getExecutionContext () .getProtoDeclaration (nodeTypeId);

                              this .getExecutionContext () .updateProtoDeclaration (this .getExecutionContext () .getUniqueProtoName (nodeTypeId), existingProto);
                           }
                           catch (error)
                           { }

                           this .getExecutionContext () .updateProtoDeclaration (nodeTypeId, proto);

                           return true;
                        }

                        throw new Error ("Expected a '}' at the end of PROTO body.");
                     }

                     throw new Error ("Expected a '{' at the beginning of PROTO body.");
                  }

                  throw new Error ("Expected a ']' at the end of PROTO interface declaration.");
               }

               throw new Error ("Expected a '[' at the beginning of PROTO interface declaration.");
            }

            throw new Error ("Invalid PROTO definition name.");
         }

         return false;
      },
      protoBody: function ()
      {
         this .protoStatements ();

         var rootNodeStatement = this .rootNodeStatement ();

         if (rootNodeStatement !== false)
            this .addRootNode (rootNodeStatement);

         this .statements ();
      },
      rootNodeStatement: function ()
      {
         this .comments ();

         if (Grammar .DEF .parse (this))
         {
            if (this .nodeNameId ())
            {
               var
                  nodeNameId = this .result [0],
                  baseNode   = this .node (nodeNameId);

               if (baseNode !== false)
                  return baseNode;

               throw new Error ("Expected node type name after DEF.");
            }

            throw new Error ("No name given after DEF.");
         }

         var baseNode = this .node ("");

         if (baseNode !== false)
            return baseNode;

         return false;
      },
      interfaceDeclarations: function ()
      {
         var
            interfaceDeclarations = [ ],
            field                 = this .interfaceDeclaration ();

         while (field)
         {
            interfaceDeclarations .push (field);

            field = this .interfaceDeclaration ();
         }

         return interfaceDeclarations;
      },
      restrictedInterfaceDeclaration: function ()
      {
         this .comments ();

         if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .inputOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .inputOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .outputOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .outputOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .initializeOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  if (this .fieldValue (field))
                  {
                     field .setAccessType (X3DConstants .initializeOnly);
                     field .setName (fieldId);
                     return field;
                  }

                  throw new Error ("Couldn't read value for field '" + fieldId + "'.");
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         return null;
      },
      interfaceDeclaration: function ()
      {
         var field = this .restrictedInterfaceDeclaration ();

         if (field)
            return field;

         this .comments ();

         if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .inputOutputId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  if (this .fieldValue (field))
                  {
                     field .setAccessType (X3DConstants .inputOutput);
                     field .setName (fieldId);
                     return field;
                  }

                  throw new Error ("Couldn't read value for field '" + fieldId + "'.");
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ();

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         return null;
      },
      externproto: function ()
      {
         this .comments ();

         if (Grammar .EXTERNPROTO .parse (this))
         {
            if (this .nodeTypeId ())
            {
               var nodeTypeId = this .result [1];

               this .comments ();

               if (Grammar .OpenBracket .parse (this))
               {
                  var externInterfaceDeclarations = this .externInterfaceDeclarations ();

                  this .comments ();

                  if (Grammar .CloseBracket .parse (this))
                  {
                     if (this .URLList (this .MFString))
                     {
                        var externproto = new X3DExternProtoDeclaration (this .getExecutionContext (), this .MFString);

                        for (var i = 0, length = externInterfaceDeclarations .length; i < length; ++ i)
                        {
                           var field = externInterfaceDeclarations [i];

                           externproto .addUserDefinedField (field .getAccessType (), field .getName (), field);
                        }

                        externproto .setup ();

                        try
                        {
                           const existingExternProto = this .getExecutionContext () .getExternProtoDeclaration (nodeTypeId);

                           this .getExecutionContext () .updateExternProtoDeclaration (this .getExecutionContext () .getUniqueExternProtoName (nodeTypeId), existingExternProto);
                        }
                        catch (error)
                        { }

                        this .getExecutionContext () .updateExternProtoDeclaration (nodeTypeId, externproto);
                        return true;
                     }

                     throw new Error ("Expected a URL list after EXTERNPROTO interface declaration '" + nodeTypeId + "'.");
                  }

                  throw new Error ("Expected a ']' at the end of EXTERNPROTO interface declaration.");
               }

               throw new Error ("Expected a '[' at the beginning of EXTERNPROTO interface declaration.");
            }

            throw new Error ("Invalid EXTERNPROTO definition name.");
         }

         return false;
      },
      externInterfaceDeclarations: function ()
      {
         var
            externInterfaceDeclarations = [ ],
            field                       = this .externInterfaceDeclaration ();

         while (field)
         {
            externInterfaceDeclarations .push (field);

            field = this .externInterfaceDeclaration ();
         }

         return externInterfaceDeclarations;
      },
      externInterfaceDeclaration: function ()
      {
         this .comments ();

         if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .inputOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .inputOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .outputOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .outputOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .initializeOnlyId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .initializeOnly);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
         {
            if (this .fieldType ())
            {
               var fieldType = this .result [1];

               if (this .inputOutputId ())
               {
                  var
                     fieldId = this .result [1],
                     field   = this [fieldType] .create ();

                  field .setAccessType (X3DConstants .inputOutput);
                  field .setName (fieldId);
                  return field;
               }

               throw new Error ("Expected a name for field.");
            }

            this .Id ()

            throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
         }

         return null;
      },
      URLList: function (field)
      {
         return this .mfstringValue (field);
      },
      routeStatement: function ()
      {
         this .comments ();

         if (Grammar .ROUTE .parse (this))
         {
            if (this .nodeNameId ())
            {
               var
                  fromNodeId = this .result [1],
                  fromNode   = this .getExecutionContext () .getLocalNode (fromNodeId);

               this .comments ();

               if (Grammar .Period .parse (this))
               {
                  if (this .outputOnlyId ())
                  {
                     var eventOutId = this .result [1];

                     this .comments ();

                     if (Grammar .TO .parse (this))
                     {
                        if (this .nodeNameId ())
                        {
                           var
                              toNodeId = this .result [1],
                              toNode   = this .getExecutionContext () .getLocalNode (toNodeId);

                           this .comments ();

                           if (Grammar .Period .parse (this))
                           {
                              if (this .inputOnlyId ())
                              {
                                 try
                                 {
                                    var eventInId = this .result [1];

                                    this .getExecutionContext () .addRoute (fromNode, eventOutId, toNode, eventInId);
                                    return true;
                                 }
                                 catch (error)
                                 {
                                    this .exception (error .message);

                                    return true;
                                 }
                              }

                              throw new Error ("Bad ROUTE specification: Expected a field name.");
                           }

                           throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
                        }

                        throw new Error ("Bad ROUTE specification: Expected a node name.");
                     }

                     throw new Error ("Bad ROUTE specification: Expected a 'TO'.");
                  }

                  throw new Error ("Bad ROUTE specification: Expected a field name.");
               }

               throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
            }

            throw new Error ("Bad ROUTE specification: Expected a node name.");
         }

         return false;
      },
      node: function (nodeNameId)
      {
         if (this .nodeTypeId ())
         {
            var
               nodeTypeId = this .result [1],
               baseNode   = this .getExecutionContext () .createNode (nodeTypeId, false);

            if (! baseNode)
            {
               baseNode = this .getExecutionContext () .createProto (nodeTypeId, false);

               if (! baseNode)
                  throw new Error ("Unknown node type or proto '" + nodeTypeId + "', you probably have insufficient component/profile statements.");
            }

            if (nodeNameId .length)
            {
               try
               {
                  var namedNode = this .getExecutionContext () .getNamedNode (nodeNameId);

                  this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (nodeNameId), namedNode);
               }
               catch (error)
               { }

               this .getExecutionContext () .updateNamedNode (nodeNameId, baseNode);
            }

            this .comments ();

            if (Grammar .OpenBrace .parse (this))
            {
               if (baseNode .canUserDefinedFields ())
                  this .scriptBody (baseNode);

               else
                  this .nodeBody (baseNode);

               this .comments ();

               if (Grammar .CloseBrace .parse (this))
               {
                  if (! this .isInsideProtoDefinition ())
                     baseNode .setup ();

                  return baseNode;
               }

               throw new Error ("Expected '}' at the end of node body.");
            }

            throw new Error ("Expected '{' at the beginning of node body.");
         }

         return false;
      },
      scriptBody: function (baseNode)
      {
         while (this .scriptBodyElement (baseNode))
            ;
      },
      scriptBodyElement: function (baseNode)
      {
         var
            lastIndex  = this .lastIndex,
            lineNumber = this .lineNumber;

//			var
//				input      = this .input,
//				lineNumber = this .lineNumber;

         if (this .Id ())
         {
            var accessType = this .accessTypes [this .result [1]];

            if (accessType)
            {
               if (this .fieldType ())
               {
                  var fieldType = this .result [1];

                  if (this .Id ())
                  {
                     var fieldId = this .result [1];

                     this .comments ();

                     if (Grammar .IS .parse (this))
                     {
                        if (this .isInsideProtoDefinition ())
                        {
                           if (this .Id ())
                           {
                              var isId = this .result [1];

                              try
                              {
                                 var reference = this .getPrototype () .getField (isId);
                              }
                              catch (error)
                              {
                                 this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getPrototype () .getName () + " interface declaration.");

                                 return true;
                              }

                              var supportedField = this [fieldType];

                              if (supportedField .getType () === reference .getType ())
                              {
                                 if (reference .isReference (accessType))
                                 {
                                    try
                                    {
                                       var field = baseNode .getField (fieldId);

                                       if (! (accessType === field .getAccessType () && reference .getType () === field .getType ()))
                                       {
                                          field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
                                       }
                                    }
                                    catch (error)
                                    {
                                       var field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
                                    }

                                    field .addReference (reference);
                                    return true;
                                 }

                                 throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getPrototype () .getName () + "' are incompatible as an IS mapping.");
                              }

                              throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getPrototype () .getName () + "' have different types.");
                           }

                           throw new Error ("No name give after IS statement.");
                        }

                        throw new Error ("IS statement outside PROTO definition.");
                     }
                  }
               }
            }
         }

         this .lastIndex  = lastIndex;
         this .lineNumber = lineNumber;

//			this .input      = input;
//			this .lineNumber = lineNumber;

         var field = this .interfaceDeclaration ();

         if (field)
         {
            try
            {
               if (field .getAccessType () === X3DConstants .inputOutput)
               {
                  var existingField = baseNode .getField (field .getName ());

                  if (existingField .getAccessType () === X3DConstants .inputOutput)
                  {
                     if (field .getType () === existingField .getType ())
                     {
                        existingField .setValue (field);
                        return true;
                     }
                  }
               }
            }
            catch (error)
            { }

            baseNode .addUserDefinedField (field .getAccessType (), field .getName (), field);
            return true;
         }

         return this .nodeBodyElement (baseNode);
      },
      createUserDefinedField: function (baseNode, accessType, fieldId, supportedField)
      {
         var field = supportedField .create ();

         baseNode .addUserDefinedField (accessType, fieldId, field);

         return field;
      },
      nodeBody: function (baseNode)
      {
         while (this .nodeBodyElement (baseNode))
            ;
      },
      nodeBodyElement: function (baseNode)
      {
         if (this .protoStatement ())
            return true;

         if (this .routeStatement ())
            return true;

         if (this .Id ())
         {
            var fieldId = this .result [1];

            try
            {
               var field = baseNode .getField (fieldId);
            }
            catch (error)
            {
               throw new Error ("Unknown field '" + fieldId + "' in class '" + baseNode .getTypeName () + "'.");
            }

            this .comments ();

            if (Grammar .IS .parse (this))
            {
               if (this .isInsideProtoDefinition ())
               {
                  if (this .Id ())
                  {
                     var isId = this .result [1];

                     try
                     {
                        var reference = this .getPrototype () .getField (isId);
                     }
                     catch (error)
                     {
                        this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getPrototype () .getName ());

                        return true;
                     }

                     if (field .getType () === reference .getType ())
                     {
                        if (reference .isReference (field .getAccessType ()))
                        {
                           field .addReference (reference);
                           return true;
                        }

                        throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getPrototype () . getName () + " are incompatible as an IS mapping.");
                     }

                     throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getPrototype () .getName () + " have different types.");
                  }

                  throw new Error("No name give after IS statement.");
               }

               throw new Error ("IS statement outside PROTO definition.");
            }

            if (field .isInitializable ())
            {
               if (this .fieldValue (field))
                  return true;

               throw new Error ("Couldn't read value for field '" + fieldId + "'.");
            }

            throw new Error ("Couldn't assign value to " + accessTypeToString (field .getAccessType ()) + " field '" + fieldId + "'.");
         }

         return false;
      },
      profileNameId: function () { return this .Id (); },
      componentNameId: function ()
      {
         this .comments ();

         return Grammar .ComponentNameId .parse (this);
      },
      categoryNameId: function () { return this .Id (); },
      unitNameId: function () { return this .Id (); },
      exportedNodeNameId: function () { return this .Id (); },
      nodeNameId: function () { return this .Id (); },
      nodeTypeId: function () { return this .Id (); },
      initializeOnlyId: function () { return this .Id (); },
      inputOnlyId: function () { return this .Id (); },
      outputOnlyId: function () { return this .Id (); },
      inputOutputId: function () { return this .Id (); },
      Id: function ()
      {
         this .comments ();

         return Grammar .Id .parse (this);
      },
      fieldType: function ()
      {
         this .comments ();

         return Grammar .FieldType .parse (this);
      },
      fieldValue: function (field)
      {
         return this .fieldTypes [field .getType ()] .call (this, field);
      },
      double: function ()
      {
         this .comments ();

         if (Grammar .double .parse (this))
         {
            this .value = parseFloat (this .result [1]);
            return true;
         }

         if (Grammar .Inf .parse (this))
         {
            this .value = Number .POSITIVE_INFINITY;
            return true;
         }

         if (Grammar .NegativeInf .parse (this))
         {
            this .value = Number .NEGATIVE_INFINITY;
            return true;
         }

         if (Grammar .NaN .parse (this))
         {
            this .value = Number .NaN;
            return true;
         }

         return false;
      },
      int32: function ()
      {
         this .comments ();

         if (Grammar .int32 .parse (this))
         {
            this .value = parseInt (this .result [1]);
            return true;
         }

         return false;
      },
      string: function ()
      {
         this .comments ();

         if (Grammar .string .parse (this))
         {
            this .value = Fields .SFString .unescape (this .result [1]);

            this .lines (this .value);

            return true;
         }

         return false;
      },
      sfboolValue: function (field)
      {
         this .comments ();

         if (Grammar .TRUE .parse (this))
         {
            field .setValue (true);
            return true;
         }

         if (Grammar .FALSE .parse (this))
         {
            field .setValue (false);
            return true;
         }

         return false;
      },
      mfboolValue: function (field)
      {
         field .length = 0;

         if (this .sfboolValue (this .SFBool))
         {
            field .push (this .SFBool);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfboolValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfboolValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfboolValue (this .SFBool))
         {
            field .push (this .SFBool);
         }
      },
      sfcolorValue: function (field)
      {
         if (this .double ())
         {
            var r = this .value;

            if (this .double ())
            {
               var g = this .value;

               if (this .double ())
               {
                  var b = this .value;

                  field .r = r;
                  field .g = g;
                  field .b = b;

                  return true;
               }
            }
         }

         return false;
      },
      mfcolorValue: function (field)
      {
         field .length = 0;

         if (this .sfcolorValue (this .SFColor))
         {
            field .push (this .SFColor);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfcolorValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfcolorValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfcolorValue (this .SFColor))
         {
            field .push (this .SFColor);
         }
      },
      sfcolorrgbaValue: function (field)
      {
         if (this .double ())
         {
            var r = this .value;

            if (this .double ())
            {
               var g = this .value;

               if (this .double ())
               {
                  var b = this .value;

                  if (this .double ())
                  {
                     var a = this .value;

                     field .r = r;
                     field .g = g;
                     field .b = b;
                     field .a = a;

                     return true;
                  }
               }
            }
         }

         return false;
      },
      mfcolorrgbaValue: function (field)
      {
         field .length = 0;

         if (this .sfcolorrgbaValue (this .SFColorRGBA))
         {
            field .push (this .SFColorRGBA);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfcolorrgbaValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfcolorrgbaValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfcolorrgbaValue (this .SFColorRGBA))
         {
            field .push (this .SFColorRGBA);
         }
      },
      sfdoubleValue: function (field)
      {
         if (this .double ())
         {
            field .setValue (this .fromUnit (field .getUnit (), this .value));
            return true;
         }

         return false;
      },
      mfdoubleValue: function (field)
      {
         field .length = 0;

         this .SFDouble .setUnit (field .getUnit ());

         if (this .sfdoubleValue (this .SFDouble))
         {
            field .push (this .SFDouble);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfdoubleValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfdoubleValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFDouble .setUnit (field .getUnit ());

         while (this .sfdoubleValue (this .SFDouble))
         {
            field .push (this .SFDouble);
         }
      },
      sffloatValue: function (field)
      {
         return this .sfdoubleValue (field);
      },
      mffloatValue: function (field)
      {
         field .length = 0;

         this .SFFloat .setUnit (field .getUnit ());

         if (this .sffloatValue (this .SFFloat))
         {
            field .push (this .SFFloat);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sffloatValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sffloatValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFFloat .setUnit (field .getUnit ());

         while (this .sffloatValue (this .SFFloat))
         {
            field .push (this .SFFloat);
         }
      },
      sfimageValue: function (field)
      {
         if (this .int32 ())
         {
            var width = this .value;

            if (this .int32 ())
            {
               var height = this .value;

               if (this .int32 ())
               {
                  var
                     comp  = this .value,
                     size  = width * height;

                  field .width  = width;
                  field .height = height;
                  field .comp   = comp;

                  var array = field .array;

                  for (var i = 0; i < size; ++ i)
                  {
                     if (this .int32 ())
                     {
                        array [i] = this .value;
                        continue;
                     }

                     return false;
                  }

                  return true;
               }
            }
         }

         return false;
      },
      mfimageValue: function (field)
      {
         field .length = 0;

         if (this .sfimageValue (this .SFImage))
         {
            field .push (this .SFImage);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfimageValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfimageValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfimageValue (this .SFImage))
         {
            field .push (this .SFImage);
         }
      },
      sfint32Value: function (field)
      {
         if (this .int32 ())
         {
            field .setValue (this .value);
            return true;
         }

         return false;
      },
      mfint32Value: function (field)
      {
         field .length = 0;

         if (this .sfint32Value (this .SFInt32))
         {
            field .push (this .SFInt32);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfint32Values (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfint32Values: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfint32Value (this .SFInt32))
         {
            field .push (this .SFInt32);
         }
      },
      sfmatrix3dValue: function (field)
      {
         if (this .double ())
         {
            var m00 = this .value;

            if (this .double ())
            {
               var m01 = this .value;

               if (this .double ())
               {
                  var m02 = this .value;

                     if (this .double ())
                     {
                        var m10 = this .value;

                        if (this .double ())
                        {
                           var m11 = this .value;

                           if (this .double ())
                           {
                              var m12 = this .value;

                              if (this .double ())
                              {
                                 var m20 = this .value;

                                 if (this .double ())
                                 {
                                    var m21 = this .value;

                                    if (this .double ())
                                    {
                                       var m22 = this .value;

                                       field [0] = m00;
                                       field [1] = m01;
                                       field [2] = m02;
                                       field [3] = m10;
                                       field [4] = m11;
                                       field [5] = m12;
                                       field [6] = m20;
                                       field [7] = m21;
                                       field [8] = m22;

                                       return true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }

         return false;
      },
      mfmatrix3dValue: function (field)
      {
         field .length = 0;

         if (this .sfmatrix3dValue (this .SFMatrix3d))
         {
            field .push (this .SFMatrix3d);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfmatrix3dValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfmatrix3dValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfmatrix3dValue (this .SFMatrix3d))
         {
            field .push (this .SFMatrix3d);
         }
      },
      sfmatrix3fValue: function (field)
      {
         return this .sfmatrix3dValue (field);
      },
      mfmatrix3fValue: function (field)
      {
         field .length = 0;

         if (this .sfmatrix3fValue (this .SFMatrix3f))
         {
            field .push (this .SFMatrix3f);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfmatrix3fValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfmatrix3fValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfmatrix3fValue (this .SFMatrix3f))
         {
            field .push (this .SFMatrix3f);
         }
      },
      sfmatrix4dValue: function (field)
      {
         if (this .double ())
         {
            var m00 = this .value;

            if (this .double ())
            {
               var m01 = this .value;

               if (this .double ())
               {
                  var m02 = this .value;

                  if (this .double ())
                  {
                     var m03 = this .value;

                     if (this .double ())
                     {
                        var m10 = this .value;

                        if (this .double ())
                        {
                           var m11 = this .value;

                           if (this .double ())
                           {
                              var m12 = this .value;

                              if (this .double ())
                              {
                                 var m13 = this .value;

                                 if (this .double ())
                                 {
                                    var m20 = this .value;

                                    if (this .double ())
                                    {
                                       var m21 = this .value;

                                       if (this .double ())
                                       {
                                          var m22 = this .value;

                                          if (this .double ())
                                          {
                                             var m23 = this .value;

                                             if (this .double ())
                                             {
                                                var m30 = this .value;

                                                if (this .double ())
                                                {
                                                   var m31 = this .value;

                                                   if (this .double ())
                                                   {
                                                      var m32 = this .value;

                                                      if (this .double ())
                                                      {
                                                         var m33 = this .value;

                                                         field [ 0] = m00;
                                                         field [ 1] = m01;
                                                         field [ 2] = m02;
                                                         field [ 3] = m03;
                                                         field [ 4] = m10;
                                                         field [ 5] = m11;
                                                         field [ 6] = m12;
                                                         field [ 7] = m13;
                                                         field [ 8] = m20;
                                                         field [ 9] = m21;
                                                         field [10] = m22;
                                                         field [11] = m23;
                                                         field [12] = m30;
                                                         field [13] = m31;
                                                         field [14] = m32;
                                                         field [15] = m33;

                                                         return true;
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }

         return false;
      },
      mfmatrix4dValue: function (field)
      {
         field .length = 0;

         if (this .sfmatrix4dValue (this .SFMatrix4d))
         {
            field .push (this .SFMatrix4d);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfmatrix4dValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfmatrix4dValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfmatrix4dValue (this .SFMatrix4d))
         {
            field .push (this .SFMatrix4d);
         }
      },
      sfmatrix4fValue: function (field)
      {
         return this .sfmatrix4dValue (field);
      },
      mfmatrix4fValue: function (field)
      {
         field .length = 0;

         if (this .sfmatrix4fValue (this .SFMatrix4f))
         {
            field .push (this .SFMatrix4f);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfmatrix4fValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfmatrix4fValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfmatrix4fValue (this .SFMatrix4f))
         {
            field .push (this .SFMatrix4f);
         }
      },
      sfnodeValue: function (field)
      {
         var baseNode = this .nodeStatement ();

         if (baseNode !== false)
         {
            field .setValue (baseNode);
            return true;
         }

         return false;
      },
      mfnodeValue: function (field)
      {
         field .length = 0;

         var node = this .nodeStatement ();

         if (node !== false)
         {
            field .push (node);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .nodeStatements (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      nodeStatements: function (field)
      {
         var node = this .nodeStatement ();

         while (node !== false)
         {
            field .push (node);

            node = this .nodeStatement ();
         }
      },
      sfrotationValue: function (field)
      {
         if (this .double ())
         {
            var x = this .value;

            if (this .double ())
            {
               var y = this .value;

               if (this .double ())
               {
                  var z = this .value;

                  if (this .double ())
                  {
                     var angle = this .value;

                     field .x     = x;
                     field .y     = y;
                     field .z     = z;
                     field .angle = this .fromUnit ("angle", angle);

                     return true;
                  }
               }
            }
         }

         return false;
      },
      mfrotationValue: function (field)
      {
         field .length = 0;

         if (this .sfrotationValue (this .SFRotation))
         {
            field .push (this .SFRotation);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfrotationValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfrotationValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfrotationValue (this .SFRotation))
         {
            field .push (this .SFRotation);
         }
      },
      sfstringValue: function (field)
      {
         if (this .string ())
         {
            field .setValue (this .value);
            return true;
         }

         return false;
      },
      mfstringValue: function (field)
      {
         field .length = 0;

         if (this .sfstringValue (this .SFString))
         {
            field .push (this .SFString);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfstringValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfstringValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sfstringValue (this .SFString))
         {
            field .push (this .SFString);
         }
      },
      sftimeValue: function (field)
      {
         return this .sfdoubleValue (field);
      },
      mftimeValue: function (field)
      {
         field .length = 0;

         if (this .sftimeValue (this .SFTime))
         {
            field .push (this .SFTime);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sftimeValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sftimeValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         while (this .sftimeValue (this .SFTime))
         {
            field .push (this .SFTime);
         }
      },
      sfvec2dValue: function (field)
      {
         if (this .double ())
         {
            var x = this .value;

            if (this .double ())
            {
               var
                  y        = this .value,
                  category = field .getUnit ();

               field .x = this .fromUnit (category, x);
               field .y = this .fromUnit (category, y);

               return true;
            }
         }

         return false;
      },
      mfvec2dValue: function (field)
      {
         field .length = 0;

         this .SFVec2d .setUnit (field .getUnit ());

         if (this .sfvec2dValue (this .SFVec2d))
         {
            field .push (this .SFVec2d);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec2dValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec2dValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec2d .setUnit (field .getUnit ());

         while (this .sfvec2dValue (this .SFVec2d))
         {
            field .push (this .SFVec2d);
         }
      },
      sfvec2fValue: function (field)
      {
         return this .sfvec2dValue (field);
      },
      mfvec2fValue: function (field)
      {
         field .length = 0;

         this .SFVec2f .setUnit (field .getUnit ());

         if (this .sfvec2fValue (this .SFVec2f))
         {
            field .push (this .SFVec2f);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec2fValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec2fValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec2f .setUnit (field .getUnit ());

         while (this .sfvec2fValue (this .SFVec2f))
         {
            field .push (this .SFVec2f);
         }
      },
      sfvec3dValue: function (field)
      {
         if (this .double ())
         {
            var x = this .value;

            if (this .double ())
            {
               var y = this .value;

               if (this .double ())
               {
                  var
                     z        = this .value,
                     category = field .getUnit ();

                  field .x = this .fromUnit (category, x);
                  field .y = this .fromUnit (category, y);
                  field .z = this .fromUnit (category, z);

                  return true;
               }
            }
         }

         return false;
      },
      mfvec3dValue: function (field)
      {
         field .length = 0;

         this .SFVec3d .setUnit (field .getUnit ());

         if (this .sfvec3dValue (this .SFVec3d))
         {
            field .push (this .SFVec3d);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec3dValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec3dValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec3d .setUnit (field .getUnit ());

         while (this .sfvec3dValue (this .SFVec3d))
         {
            field .push (this .SFVec3d);
         }
      },
      sfvec3fValue: function (field)
      {
         return this .sfvec3dValue (field);
      },
      mfvec3fValue: function (field)
      {
         field .length = 0;

         this .SFVec3f .setUnit (field .getUnit ());

         if (this .sfvec3fValue (this .SFVec3f))
         {
            field .push (this .SFVec3f);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec3fValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec3fValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec3f .setUnit (field .getUnit ());

         while (this .sfvec3fValue (this .SFVec3f))
         {
            field .push (this .SFVec3f);
         }
      },
      sfvec4dValue: function (field)
      {
         if (this .double ())
         {
            var x = this .value;

            if (this .double ())
            {
               var y = this .value;

               if (this .double ())
               {
                  var z = this .value;

                  if (this .double ())
                  {
                     var
                        w        = this .value,
                        category = field .getUnit ();

                     field .x = this .fromUnit (category, x);
                     field .y = this .fromUnit (category, y);
                     field .z = this .fromUnit (category, z);
                     field .w = this .fromUnit (category, w);

                     return true;
                  }
               }
            }
         }

         return false;
      },
      mfvec4dValue: function (field)
      {
         field .length = 0;

         this .SFVec4d .setUnit (field .getUnit ());

         if (this .sfvec4dValue (this .SFVec4d))
         {
            field .push (this .SFVec4d);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec4dValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec4dValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec4d .setUnit (field .getUnit ());

         while (this .sfvec4dValue (this .SFVec4d))
         {
            field .push (this .SFVec4d);
         }
      },
      sfvec4fValue: function (field)
      {
         return this .sfvec4dValue (field);
      },
      mfvec4fValue: function (field)
      {
         field .length = 0;

         this .SFVec4f .setUnit (field .getUnit ());

         if (this .sfvec4fValue (this .SFVec4f))
         {
            field .push (this .SFVec4f);
            return true;
         }

         if (Grammar .OpenBracket .parse (this))
         {
            this .sfvec4fValues (field);

            this .comments ();

            if (Grammar .CloseBracket .parse (this))
               return true;

            throw new Error ("Expected ']'.");
         }

         return false;
      },
      sfvec4fValues: function (field)
      {
         field .length = 0;
         field         = field .getTarget ();

         this .SFVec4f .setUnit (field .getUnit ());

         while (this .sfvec4fValue (this .SFVec4f))
         {
            field .push (this .SFVec4f);
         }
      },
   });

   VRMLParser .prototype .fieldTypes = [ ];
   VRMLParser .prototype .fieldTypes [X3DConstants .SFBool]      = VRMLParser .prototype .sfboolValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFColor]     = VRMLParser .prototype .sfcolorValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFColorRGBA] = VRMLParser .prototype .sfcolorrgbaValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFDouble]    = VRMLParser .prototype .sfdoubleValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFFloat]     = VRMLParser .prototype .sffloatValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFImage]     = VRMLParser .prototype .sfimageValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFInt32]     = VRMLParser .prototype .sfint32Value;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3f]  = VRMLParser .prototype .sfmatrix3dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3d]  = VRMLParser .prototype .sfmatrix3fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4f]  = VRMLParser .prototype .sfmatrix4dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4d]  = VRMLParser .prototype .sfmatrix4fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFNode]      = VRMLParser .prototype .sfnodeValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFRotation]  = VRMLParser .prototype .sfrotationValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFString]    = VRMLParser .prototype .sfstringValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFTime]      = VRMLParser .prototype .sftimeValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec2d]     = VRMLParser .prototype .sfvec2dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec2f]     = VRMLParser .prototype .sfvec2fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec3d]     = VRMLParser .prototype .sfvec3dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec3f]     = VRMLParser .prototype .sfvec3fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec4d]     = VRMLParser .prototype .sfvec4dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .SFVec4f]     = VRMLParser .prototype .sfvec4fValue;

   VRMLParser .prototype .fieldTypes [X3DConstants .MFBool]      = VRMLParser .prototype .mfboolValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFColor]     = VRMLParser .prototype .mfcolorValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFColorRGBA] = VRMLParser .prototype .mfcolorrgbaValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFDouble]    = VRMLParser .prototype .mfdoubleValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFFloat]     = VRMLParser .prototype .mffloatValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFImage]     = VRMLParser .prototype .mfimageValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFInt32]     = VRMLParser .prototype .mfint32Value;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3d]  = VRMLParser .prototype .mfmatrix3dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3f]  = VRMLParser .prototype .mfmatrix3fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4d]  = VRMLParser .prototype .mfmatrix4dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4f]  = VRMLParser .prototype .mfmatrix4fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFNode]      = VRMLParser .prototype .mfnodeValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFRotation]  = VRMLParser .prototype .mfrotationValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFString]    = VRMLParser .prototype .mfstringValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFTime]      = VRMLParser .prototype .mftimeValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec2d]     = VRMLParser .prototype .mfvec2dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec2f]     = VRMLParser .prototype .mfvec2fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec3d]     = VRMLParser .prototype .mfvec3dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec3f]     = VRMLParser .prototype .mfvec3fValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec4d]     = VRMLParser .prototype .mfvec4dValue;
   VRMLParser .prototype .fieldTypes [X3DConstants .MFVec4f]     = VRMLParser .prototype .mfvec4fValue;

   return VRMLParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/DataStorage',[],function ()
{
"use strict";

   const
      storages   = new WeakMap (),
      namespaces = new WeakMap (),
      defaults   = new WeakMap ();

   const handler =
   {
      get: function (target, key)
      {
         const property = target [key];

         if (property !== undefined)
            return property;

         const string = target .getStorage () [target .getNameSpace () + key];

         if (string === undefined || string === "undefined" || string === null)
            return target .getDefaultValue (key);

         const value = JSON .parse (string);

         return value;
      },
      set: function (target, key, value)
      {
         if (value === undefined)
            target .getStorage () .removeItem (target .getNameSpace () + key);

         else
            target .getStorage () [target .getNameSpace () + key] = JSON .stringify (value);

         return true;
      },
   };

   function DataStorage (storage, namespace)
   {
      this .target  = this;

      storages   .set (this, storage);
      namespaces .set (this, namespace);
      defaults   .set (this, { });

      return new Proxy (this, handler);
   }

   DataStorage .prototype = {
      constructor: DataStorage,
      getStorage: function ()
      {
         return storages .get (this .target);
      },
      getNameSpace: function ()
      {
         return namespaces .get (this .target);
      },
      addNameSpace: function (namespace)
      {
         return new DataStorage (this .getStorage (), this .getNameSpace () + namespace);
      },
      addDefaultValues: function (object)
      {
         Object .assign (defaults .get (this .target), object);
      },
      getDefaultValue (key)
      {
         const value = defaults .get (this .target) [key];

         return value === undefined ? undefined : JSON .parse (JSON .stringify (value));
      },
      clear: function ()
      {
         const
            storage   = this .getStorage (),
            namespace = this .getNameSpace ();

         for (const key of Object .keys (storage))
         {
            if (key .startsWith (namespace))
               storage .removeItem (key)
         }
      },
   }

   return DataStorage;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/X3DCoreContext',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Browser/Core/Context",
   "x_ite/Browser/Core/BrowserTimings",
   "x_ite/Browser/Core/BrowserOptions",
   "x_ite/Browser/Core/BrowserProperties",
   "x_ite/Browser/Core/RenderingProperties",
   "x_ite/Browser/Core/Notification",
   "x_ite/Browser/Core/ContextMenu",
   "x_ite/Execution/Scene",
   "x_ite/Parser/VRMLParser",
   "standard/Utility/DataStorage",
   "standard/Math/Numbers/Vector3",
   "locale/gettext",
],
function ($,
          Fields,
          Context,
          BrowserTimings,
          BrowserOptions,
          BrowserProperties,
          RenderingProperties,
          Notification,
          ContextMenu,
          Scene,
          VRMLParser,
          DataStorage,
          Vector3,
          _)
{
"use strict";

   const WEBGL_LATEST_VERSION = 2;

   const
      _number              = Symbol (),
      _element             = Symbol (),
      _shadow              = Symbol (),
      _surface             = Symbol (),
      _canvas              = Symbol (),
      _context             = Symbol (),
      _splashScreen        = Symbol (),
      _localStorage        = Symbol (),
      _mobile              = Symbol (),
      _browserTimings      = Symbol (),
      _browserOptions      = Symbol (),
      _browserProperties   = Symbol (),
      _renderingProperties = Symbol (),
      _notification        = Symbol (),
      _contextMenu         = Symbol (),
      _observer            = Symbol (),
      _privateScene        = Symbol (),
      _keydown             = Symbol (),
      _keyup               = Symbol (),
      _pixelPerPoint       = Symbol ();

   let browserNumber = 0;

   function X3DCoreContext (element)
   {
      // Get canvas & context.

      const
         shadow       = $(element .prop ("shadowRoot")),
         browser      = $("<div></div>") .addClass ("x_ite-private-browser"),
         surface      = $("<div></div>") .addClass ("x_ite-private-surface") .appendTo (browser),
         splashScreen = $("<div></div>") .hide () .addClass ("x_ite-private-splash-screen") .appendTo (browser),
         spinner      = $("<div></div>") .addClass ("x_ite-private-spinner") .appendTo (splashScreen),
         progress     = $("<div></div>") .addClass ("x_ite-private-progress") .appendTo (splashScreen);

      $("<div></div>") .addClass ("x_ite-private-x_ite") .html (this .getName () + "<span class='x_ite-private-x3d'>X3D</span>") .appendTo (progress);
      $("<div></div>") .addClass ("x_ite-private-progressbar")  .appendTo (progress) .append ($("<div></div>"));
      $("<div></div>") .addClass ("x_ite-private-spinner-text") .appendTo (progress);

      this [_number]       = ++ browserNumber;
      this [_element]      = element;
      this [_shadow]       = shadow .length ? shadow .append (browser .hide ()) : this [_element] .prepend (browser);
      this [_surface]      = surface;
      this [_canvas]       = $("<canvas></canvas>") .addClass ("x_ite-private-canvas") .prependTo (surface);
      this [_context]      = Context .create (this [_canvas] [0], WEBGL_LATEST_VERSION, element .attr ("preserveDrawingBuffer") === "true");
      this [_splashScreen] = splashScreen;

      if (shadow .length)
         shadow .prop ("loaded") .then (function () { browser .show (); });

      this [_localStorage] = new DataStorage (localStorage, "X_ITE.X3DBrowser(" + this [_number] + ").");
      this [_mobile]       = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i .test (navigator .userAgent);

      this [_browserTimings]      = new BrowserTimings      (this .getPrivateScene ());
      this [_browserOptions]      = new BrowserOptions      (this .getPrivateScene ());
      this [_browserProperties]   = new BrowserProperties   (this .getPrivateScene ());
      this [_renderingProperties] = new RenderingProperties (this .getPrivateScene ());
      this [_notification]        = new Notification        (this .getPrivateScene ());
      this [_contextMenu]         = new ContextMenu         (this .getPrivateScene ());

      const inches = $("<div></div>") .hide () .css ("height", "10in") .appendTo (this [_shadow]);
      this [_pixelPerPoint] = inches .height () / 720;
      inches .remove ();

      $(".x_ite-console") .empty ();

      this .addChildObjects ("controlKey",  new Fields .SFBool (),
                             "shiftKey",    new Fields .SFBool (),
                             "altKey",      new Fields .SFBool (),
                             "altGrKey",    new Fields .SFBool ());
   }

   X3DCoreContext .prototype =
   {
      initialize: function ()
      {
         // Setup browser nodes.

         this [_browserTimings]      .setup ();
         this [_browserOptions]      .setup ();
         this [_browserProperties]   .setup ();
         this [_renderingProperties] .setup ();
         this [_notification]        .setup ();
         this [_contextMenu]         .setup ();

         // Observe Element's attributes.

         this [_observer] = new MutationObserver (this .processMutations .bind (this));

         this [_observer] .observe (this [_element] [0], { attributes: true, childList: false, characterData: false, subtree: false });

         // Define src and url property.

         Object .defineProperty (this .getElement () .get (0), "src",
         {
            get: function ()
            {
               return this .getExecutionContext () .getWorldURL ();
            }
            .bind (this),
            set: function (value)
            {
               this .loadURL (new Fields .MFString (value), new Fields .MFString ());
            }
            .bind (this),
            enumerable: true,
            configurable: false,
         });

         Object .defineProperty (this .getElement () .get (0), "url",
         {
            get: function ()
            {
               const worldURL = this .getExecutionContext () .getWorldURL ();

               if (worldURL)
                  return new Fields .MFString (worldURL);
               else
                  return new Fields .MFString ();
            }
            .bind (this),
            set: function (value)
            {
               this .loadURL (value, new Fields .MFString ());
            }
            .bind (this),
            enumerable: true,
            configurable: false,
         });

         // Configure browser event handlers.

         this .setBrowserEventHandler ("onload");
         this .setBrowserEventHandler ("onshutdown");
         this .setBrowserEventHandler ("onerror");

         this .getElement () .bind ("keydown.X3DCoreContext", this [_keydown] .bind (this));
         this .getElement () .bind ("keyup.X3DCoreContext",   this [_keyup]   .bind (this));
      },
      getDebug: function ()
      {
         return this .getBrowserOptions () .getDebug ();
      },
      getNumber: function ()
      {
         return this [_number];
      },
      isStrict: function ()
      {
         return false;
      },
      getElement: function ()
      {
         return this [_element];
      },
      getShadow: function ()
      {
         return this [_shadow];
      },
      getSurface: function ()
      {
         return this [_surface];
      },
      getSplashScreen: function ()
      {
         return this [_splashScreen];
      },
      getCanvas: function ()
      {
         return this [_canvas];
      },
      getContext: function ()
      {
         return this [_context];
      },
      getMobile: function ()
      {
         return this [_mobile];
      },
      getLocalStorage: function ()
      {
         return this [_localStorage];
      },
      getBrowserTimings: function ()
      {
         return this [_browserTimings];
      },
      getBrowserOptions: function ()
      {
         return this [_browserOptions];
      },
      getBrowserProperties: function ()
      {
         return this [_browserProperties];
      },
      getRenderingProperties: function ()
      {
         return this [_renderingProperties];
      },
      getNotification: function ()
      {
         return this [_notification];
      },
      getContextMenu: function ()
      {
         return this [_contextMenu];
      },
      getPrivateScene: function ()
      {
         if (this [_privateScene])
            return this [_privateScene];

         // Scene for default nodes.

         this [_privateScene] = new Scene (this);

         this [_privateScene] .setPrivate (true);
         this [_privateScene] .setLive (true);
         this [_privateScene] .setup ();

         return this [_privateScene];
      },
      processMutations: function (mutations)
      {
         mutations .forEach (function (mutation)
         {
            this .processMutation (mutation);
         },
         this);
      },
      processMutation: function (mutation)
      {
         const element = mutation .target;

         switch (mutation .type)
         {
            case "attributes":
            {
               this .processAttribute (mutation, element);
               break;
            }
         }
      },
      processAttribute: function (mutation, element)
      {
         const attributeName = mutation .attributeName;

         switch (attributeName .toLowerCase ())
         {
            case "onerror":
            {
               this .setBrowserEventHandler ("onerror");
               break;
            }
            case "onload":
            {
               this .setBrowserEventHandler ("onload");
               break;
            }
            case "onshutdown":
            {
               this .setBrowserEventHandler ("onshutdown");
               break;
            }
            case "splashscreen":
            {
               this .getBrowserOptions () .setAttributeSplashScreen ();
               break;
            }
            case "src":
            {
               const urlCharacters = this .getElement () .attr ("src");

               this .load ('"' + urlCharacters + '"');
               break;
            }
            case "url":
            {
               this .load (this .getElement () .attr ("url"));
               break;
            }
         }
      },
      load: function (urlCharacters)
      {
         if (urlCharacters)
         {
            const
               parser    = new VRMLParser (this .getExecutionContext ()),
               url       = new Fields .MFString (),
               parameter = new Fields .MFString ();

            parser .setInput (urlCharacters);
            parser .sfstringValues (url);

            if (url .length)
               this .loadURL (url, parameter);
         }
         else
         {
            if (! this .getLoading ())
               this .getCanvas () .show ();
         }
      },
      setBrowserEventHandler: function (name)
      {
         const
            element      = this .getElement () .get (0),
            browserEvent = this .getElement () .attr (name);

         if (browserEvent)
            element [name] = new Function (browserEvent);
         else
            element [name] = Function .prototype;
      },
      callBrowserEventHandler: function (name)
      {
         const
            element             = this .getElement () .get (0),
            browserEventHandler = element [name];

         if (window .jQuery)
            window .jQuery (element) .trigger (name .substr (2));

         else if (browserEventHandler)
            browserEventHandler .call (element);
      },
      getShiftKey: function ()
      {
         return this ._shiftKey .getValue ();
      },
      getControlKey: function ()
      {
         return this ._controlKey .getValue ();
      },
      getAltKey: function ()
      {
         return this ._altKey .getValue ();
      },
      getAltGrKey: function ()
      {
         return this ._altGrKey .getValue ();
      },
      [_keydown]: function (event)
      {
         //console .log (event .keyCode);

         switch (event .keyCode)
         {
            case 16: // Shift
            {
               this ._shiftKey = true;
               break;
            }
            case 17: // Ctrl
            {
               this ._controlKey = true;
               break;
            }
            case 18: // Alt
            {
               this ._altKey = true;
               break;
            }
            case 49: // 1
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();
                     this .setBrowserOption ("Shading", "POINT");
                     this .getNotification () ._string = "Shading: Pointset";
                  }
               }

               break;
            }
            case 50: // 2
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();
                     this .setBrowserOption ("Shading", "WIREFRAME");
                     this .getNotification () ._string = "Shading: Wireframe";
                  }
               }

               break;
            }
            case 51: // 3
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();
                     this .setBrowserOption ("Shading", "FLAT");
                     this .getNotification () ._string = "Shading: Flat";
                  }
               }

               break;
            }
            case 52: // 4
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();
                     this .setBrowserOption ("Shading", "GOURAUD");
                     this .getNotification () ._string = "Shading: Gouraud";
                  }
               }

               break;
            }
            case 53: // 5
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();
                     this .setBrowserOption ("Shading", "PHONG");
                     this .getNotification () ._string = "Shading: Phong";
                  }
               }

               break;
            }
            case 83: // s
            {
               if (this .getDebug ())
               {
                  if (this .getControlKey ())
                  {
                     event .preventDefault ();

                     if (this .isLive () .getValue ())
                        this .endUpdate ();
                     else
                        this .beginUpdate ();

                     this .getNotification () ._string = this .isLive () .getValue () ? "Begin Update" : "End Update";
                  }
               }

               break;
            }
            case 225: // Alt Gr
            {
               this ._altGrKey = true;
               break;
            }
            case 171: // Plus // Firefox
            case 187: // Plus // Opera
            {
               if (this .getControlKey ())
               {
                  event .preventDefault ();
                  this .setBrowserOption ("Timings", !this .getBrowserOption ("Timings"));
               }

               break;
            }
            case 36: // Pos 1
            {
               event .preventDefault ();
               this .firstViewpoint ();
               break;
            }
            case 35: // End
            {
               event .preventDefault ();
               this .lastViewpoint ();
               break;
            }
            case 33: // Page Up
            {
               event .preventDefault ();
               this .previousViewpoint ();
               break;
            }
            case 34: // Page Down
            {
               event .preventDefault ();
               this .nextViewpoint ();
               break;
            }
            case 119: // F8
            {
               if (this .getShiftKey ())
               {
                  event .preventDefault ();

                  const viewpoint = this .getActiveViewpoint ();

                  if (!viewpoint)
                     break;

                  const vp = this .getPrivateScene () .createNode (viewpoint .getTypeName ());

                  switch (viewpoint .getTypeName ())
                  {
                     case "Viewpoint":
                     {
                        vp .position         = viewpoint .getUserPosition ();
                        vp .orientation      = viewpoint .getUserOrientation ();
                        vp .centerOfRotation = viewpoint .getUserCenterOfRotation ();
                        vp .fieldOfView      = viewpoint .getFieldOfView ();
                        break;
                     }
                     case "OrthoViewpoint":
                     {
                        vp .position         = viewpoint .getUserPosition ();
                        vp .orientation      = viewpoint .getUserOrientation ();
                        vp .centerOfRotation = viewpoint .getUserCenterOfRotation ();
                        vp .fieldOfView      = new Fields .MFFloat (viewpoint .getMinimumX (), viewpoint .getMinimumY (), viewpoint .getMaximumX (), viewpoint .getMaximumY ());
                        break;
                     }
                     case "GeoViewpoint":
                     {
                        const
                           geoOrigin = viewpoint ._geoOrigin,
                           geoCoord  = new Vector3 (0, 0, 0);

                        if (geoOrigin .getValue () && geoOrigin .getNodeTypeName () === "GeoOrigin")
                        {
                           const go = this .getPrivateScene () .createNode ("GeoOrigin");

                           vp .geoOrigin = go;
                           go .geoSystem = geoOrigin .geoSystem;
                           go .geoCoords = geoOrigin .geoCoords;
                           go .rotateYUp = geoOrigin .rotateYUp;
                        }

                        vp .geoSystem        = viewpoint ._geoSystem;
                        vp .position         = viewpoint .getGeoCoord (viewpoint .getUserPosition (), geoCoord);
                        vp .orientation      = viewpoint .getUserOrientation ();
                        vp .centerOfRotation = viewpoint .getGeoCoord (viewpoint .getUserCenterOfRotation (), geoCoord);
                        vp .fieldOfView      = viewpoint .getFieldOfView ();
                        break;
                     }
                  }

                  let text;

                  switch (this .getExecutionContext () .getEncoding ())
                  {
                     case "ASCII":
                     case "VRML": text = vp .toVRMLString (); break;
                     case "JSON": text = vp .toJSONString (); break;
                     default:     text = vp .toXMLString ();  break;
                  }

                  text += "\n";

                  this .copyToClipboard (text);
                  this .getNotification () ._string = _ ("Viewpoint is copied to clipboard.");

                  console .log ("Copied Viewpoint to Clipboard.");
                  console .debug (text);
               }

               break;
            }
         }
      },
      [_keyup]: function (event)
      {
         //console .log (event .which);

         switch (event .which)
         {
            case 16: // Shift
            {
               this ._shiftKey = false;
               break;
            }
            case 17: // Ctrl
            {
               this ._controlKey = false;
               break;
            }
            case 18: // Alt
            {
               this ._altKey = false;
               break;
            }
            case 225: // Alt Gr
            {
               this ._altGrKey = false;
               break;
            }
         }
      },
      copyToClipboard: function (text)
      {
         // The textarea must be visible to make copy work.
         const $temp = $("<textarea></textarea>");
         this .getShadow () .find (".x_ite-private-browser") .prepend ($temp);
         $temp .text (text) .select ();
         document .execCommand ("copy");
         $temp .remove ();
      },
      getPixelPerPoint: function ()
      {
         return this [_pixelPerPoint];
      },
   };

   return X3DCoreContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/X3DRoutingContext',[
],
function ()
{
"use strict";

   const
      _taintedFields     = Symbol (),
      _taintedFieldsTemp = Symbol (),
      _taintedNodes      = Symbol (),
      _taintedNodesTemp  = Symbol ();

   function X3DRoutingContext ()
   {
      this [_taintedFields]     = [ ];
      this [_taintedFieldsTemp] = [ ];
      this [_taintedNodes]      = [ ];
      this [_taintedNodesTemp]  = [ ];
   }

   X3DRoutingContext .prototype =
   {
      constructor: X3DRoutingContext,
      initialize: function () { },
      addTaintedField: function (field, event)
      {
         this [_taintedFields] .push (field, event);
      },
      addTaintedNode: function (node)
      {
         this [_taintedNodes] .push (node);
      },
      processEvents: function ()
      {
         do
         {
            // Process field events
            do
            {
               const taintedFields = this [_taintedFields];

               // Swap tainted fields.
               this [_taintedFields]         = this [_taintedFieldsTemp];
               this [_taintedFields] .length = 0;

               for (let i = 0, length = taintedFields .length; i < length; i += 2)
                  taintedFields [i] .processEvent (taintedFields [i + 1]);

               // Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
               this [_taintedFieldsTemp] = taintedFields;
            }
            while (this [_taintedFields] .length);

            // Process node events
            do
            {
               const taintedNodes = this [_taintedNodes];

               // Swap tainted nodes.
               this [_taintedNodes]         = this [_taintedNodesTemp];
               this [_taintedNodes] .length = 0;

               for (const taintedNode of taintedNodes)
                  taintedNode .processEvents ();

               // Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
               this [_taintedNodesTemp] = taintedNodes;
            }
            while (! this [_taintedFields] .length && this [_taintedNodes] .length);
         }
         while (this [_taintedFields] .length);
      },
   };

   return X3DRoutingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Scripting/X3DScriptingContext',[
],
function ()
{
"use strict";

   const _scripts = Symbol ();

   function X3DScriptingContext ()
   {
      this [_scripts] = [this];
   }

   X3DScriptingContext .prototype =
   {
      initialize: function ()
      { },
      isExternal: function ()
      {
         return this [_scripts] .length === 1;
      },
      getScriptStack: function ()
      {
         return this [_scripts];
      }
   };

   return X3DScriptingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

define ('x_ite/Browser/Networking/urls',[],function ()
{
"use strict";

   function URLs () { }

   URLs .prototype =
   {
      getProviderUrl: function (file)
      {
         if (file)
         {
            if (getScriptURL () .match (/\.min\.js$/))
               file += ".min";

            return new URL ("assets/components/" + file + ".js", getScriptURL ()) .href;
         }

         return "https://create3000.github.io/x_ite/";
      },
      getShaderUrl: function (file)
      {
         return new URL ("assets/shaders/" + file, getScriptURL ()) .href;
      },
      getFontsUrl: function (file)
      {
         return new URL ("assets/fonts/" + file, getScriptURL ()) .href;
      },
      getLinetypeUrl: function (index)
      {
         return new URL ("assets/linetype/" + index + ".png", getScriptURL ()) .href;
      },
      getHatchingUrl: function (index)
      {
         return new URL ("assets/hatching/" + index + ".png", getScriptURL ()) .href;
      },
   };

   return new URLs ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Networking/X3DNetworkingContext',[
   "x_ite/Fields",
   "x_ite/Browser/Networking/urls",
   "locale/gettext",
],
function (Fields,
          urls,
          _)
{
"use strict";

   const
      _loadingTotal   = Symbol (),
      _loadingObjects = Symbol (),
      _loading        = Symbol (),
      _location       = Symbol (),
      _defaultScene   = Symbol ();

   function getBaseURI (element)
   {
      let baseURI = element .baseURI;

      // Fix for Edge.
      if (baseURI .startsWith ("about:"))
         baseURI = document .baseURI;

      return baseURI;
   }

   function X3DNetworkingContext ()
   {
      this .addChildObjects ("loadCount", new Fields .SFInt32 ());

      this [_loadingTotal]   = 0;
      this [_loadingObjects] = new Set ();
      this [_loading]        = false;
      this [_location]       = getBaseURI (this .getElement () [0]);

      this .getCanvas () .hide ();

      if (this .getBrowserOptions () .getSplashScreen ())
      {
         this .getContextMenu () .hide ();
         this .getSplashScreen () .show ();
      }
   }

   X3DNetworkingContext .prototype =
   {
      initialize: function ()
      { },
      getProviderUrl: function ()
      {
         return urls .getProviderUrl ();
      },
      getLocation: function ()
      {
         return this [_location];
      },
      getDefaultScene: function ()
      {
         // Inline node's empty scene.

         this [_defaultScene] = this .createScene ();

         this [_defaultScene] .setPrivate (true);
         this [_defaultScene] .setLive (true);
         this [_defaultScene] .setup ();

         this .getDefaultScene = function () { return this [_defaultScene]; };

         Object .defineProperty (this, "getDefaultScene", { enumerable: false });

         return this [_defaultScene];
      },
      setBrowserLoading: function (value)
      {
         this [_loading] = value;

         if (value)
         {
            this .resetLoadCount ();

            this .getShadow () .find (".x_ite-private-world-info") .remove ();

            if (this .getBrowserOptions () .getSplashScreen ())
            {
               this .getContextMenu ()  .hide ();
               this .getCanvas ()       .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeOut (0);
               this .getSplashScreen () .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeIn (0);
            }
            else
            {
               this .getCanvas () .hide ();
            }
         }
         else
         {
            if (this .getBrowserOptions () .getSplashScreen ())
            {
               this .getSplashScreen () .stop (true, true) .show () .fadeOut (2000);
               this .getCanvas ()       .stop (true, true) .hide () .fadeIn  (2000);
            }
            else
            {
               this .getCanvas () .show ();
            }
         }
      },
      getLoading: function ()
      {
         return this [_loading];
      },
      addLoadCount: function (object)
      {
         if (this [_loadingObjects] .has (object))
            return;

         ++ this [_loadingTotal];

         this [_loadingObjects] .add (object);

         this .setLoadCount (this [_loadingObjects] .size);
         this .setCursor ("DEFAULT");
      },
      removeLoadCount: function (object)
      {
         if (! this [_loadingObjects] .has (object))
            return;

         this [_loadingObjects] .delete (object);

         this .setLoadCount (this [_loadingObjects] .size);
      },
      setLoadCount: function (value)
      {
         this ._loadCount = value;

         if (value)
         {
            var string = (value == 1 ? _ ("Loading %1 file") : _ ("Loading %1 files")) .replace ("%1", value);
         }
         else
         {
            var string = _("Loading done");
            this .setCursor ("DEFAULT");
         }

         if (! this [_loading])
            this .getNotification () ._string = string;

         this .getSplashScreen () .find (".x_ite-private-spinner-text") .text (string);
         this .getSplashScreen () .find (".x_ite-private-progressbar div") .css ("width", ((this [_loadingTotal] - value) * 100 / this [_loadingTotal]) + "%");
      },
      resetLoadCount: function ()
      {
         this ._loadCount     = 0;
         this [_loadingTotal] = 0;

         this [_loadingObjects] .clear ();
      },
   };

   return X3DNetworkingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DAppearanceChildNode',[
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
],
function (X3DNode,
          X3DConstants)
{
"use strict";

   function X3DAppearanceChildNode (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DAppearanceChildNode);
   }

   X3DAppearanceChildNode .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DAppearanceChildNode,
   });

   return X3DAppearanceChildNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DShaderNode',[
   "x_ite/Fields",
   "x_ite/Browser/Core/Shading",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Rendering/TraverseType",
],
function (Fields,
          Shading,
          X3DAppearanceChildNode,
          X3DConstants,
          TraverseType)
{
"use strict";

   function X3DShaderNode (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DShaderNode);

      this .addChildObjects ("activationTime", new Fields .SFTime ());

      this .valid    = false;
      this .selected = 0;
   }

   X3DShaderNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: X3DShaderNode,
      initialize: function ()
      {
         X3DAppearanceChildNode .prototype .initialize .call (this);

         this ._activate .addInterest ("set_activate__", this);
      },
      set_activate__: function ()
      {
         this ._activationTime = this .getBrowser () .getCurrentTime ();
      },
      setValid: function (value)
      {
         this ._isValid = this .valid = value;
      },
      isValid: function ()
      {
         return this .valid;
      },
      setShading: function (shading)
      {
         var gl = this .getBrowser () .getContext ();

         switch (shading)
         {
            case Shading .POINT:
            {
               this .primitiveMode = gl .POINTS;
               this .wireframe     = true;
               break;
            }
            case Shading .WIREFRAME:
            {
               this .primitiveMode = gl .LINE_LOOP;
               this .wireframe     = true;
               break;
            }
            default:
            {
               // case Shading .FLAT:
               // case Shading .GOURAUD:
               // case Shading .PHONG:

               this .primitiveMode = gl .TRIANGLES;
               this .wireframe     = false;
               break;
            }
         }
      },
      select: function ()
      {
         ++ this .selected;

         if (! this ._isSelected .getValue ())
            this ._isSelected = true;
      },
      deselect: function ()
      {
         -- this .selected;

         if (this .selected === 0)
         {
            if (this ._isSelected .getValue ())
               this ._isSelected = false;
         }
      },
      traverse: function (type, renderObject)
      {
         // TraverseType .DISPLAY

         renderObject .getShaders () .add (this);
      },
   });

   return X3DShaderNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/OrthoViewpoint',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Navigation/X3DViewpointNode",
   "x_ite/Components/Interpolation/ScalarInterpolator",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Camera",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewpointNode,
          ScalarInterpolator,
          X3DConstants,
          Camera,
          Vector2,
          Vector3,
          Matrix4)
{
"use strict";

   function OrthoViewpoint (executionContext)
   {
      X3DViewpointNode .call (this, executionContext);

      this .addType (X3DConstants .OrthoViewpoint);

      this .addChildObjects ("fieldOfViewOffset", new Fields .MFFloat (0, 0, 0, 0));

      this ._position         .setUnit ("length");
      this ._centerOfRotation .setUnit ("length");
      this ._fieldOfView      .setUnit ("length");

      this .projectionMatrix               = new Matrix4 ();
      this .fieldOfViewOffsetInterpolator0 = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
      this .fieldOfViewOffsetInterpolator1 = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
      this .fieldOfViewOffsetInterpolator2 = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
      this .fieldOfViewOffsetInterpolator3 = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
      this .fieldOfViewScaleInterpolator   = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   }

   OrthoViewpoint .prototype = Object .assign (Object .create (X3DViewpointNode .prototype),
   {
      constructor: OrthoViewpoint,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",          new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "position",          new Fields .SFVec3f (0, 0, 10)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "orientation",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "centerOfRotation",  new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fieldOfView",       new Fields .MFFloat (-1, -1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "jump",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",          new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "OrthoViewpoint";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DViewpointNode .prototype .initialize .call (this);

         this ._fieldOfView       .addInterest ("set_fieldOfView__", this);
         this ._fieldOfViewOffset .addInterest ("set_fieldOfView__", this);
         this ._fieldOfViewScale  .addInterest ("set_fieldOfView__", this);

         this .fieldOfViewOffsetInterpolator0 ._key = new Fields .MFFloat (0, 1);
         this .fieldOfViewOffsetInterpolator1 ._key = new Fields .MFFloat (0, 1);
         this .fieldOfViewOffsetInterpolator2 ._key = new Fields .MFFloat (0, 1);
         this .fieldOfViewOffsetInterpolator3 ._key = new Fields .MFFloat (0, 1);
         this .fieldOfViewScaleInterpolator   ._key = new Fields .MFFloat (0, 1);

         this .fieldOfViewOffsetInterpolator0 .setup ();
         this .fieldOfViewOffsetInterpolator1 .setup ();
         this .fieldOfViewOffsetInterpolator2 .setup ();
         this .fieldOfViewOffsetInterpolator3 .setup ();
         this .fieldOfViewScaleInterpolator   .setup ();

         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator0 ._set_fraction);
         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator1 ._set_fraction);
         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator2 ._set_fraction);
         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewOffsetInterpolator3 ._set_fraction);
         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewScaleInterpolator   ._set_fraction);

         this .fieldOfViewOffsetInterpolator0 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
         this .fieldOfViewOffsetInterpolator1 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
         this .fieldOfViewOffsetInterpolator2 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);
         this .fieldOfViewOffsetInterpolator3 ._value_changed .addInterest ("set_fieldOfViewOffset__", this);

         this .fieldOfViewScaleInterpolator ._value_changed .addFieldInterest (this ._fieldOfViewScale);

         this .set_fieldOfView__ ();
      },
      set_fieldOfView__: function ()
      {
         var
            length           = this ._fieldOfView .length,
            fieldOfViewScale = this ._fieldOfViewScale .getValue ();

         this .minimumX = ((length > 0 ? this ._fieldOfView [0] : -1) + this ._fieldOfViewOffset [0]) * fieldOfViewScale;
         this .minimumY = ((length > 1 ? this ._fieldOfView [1] : -1) + this ._fieldOfViewOffset [1]) * fieldOfViewScale;
         this .maximumX = ((length > 2 ? this ._fieldOfView [2] :  1) + this ._fieldOfViewOffset [2]) * fieldOfViewScale;
         this .maximumY = ((length > 3 ? this ._fieldOfView [3] :  1) + this ._fieldOfViewOffset [3]) * fieldOfViewScale;

         this .sizeX = this .maximumX - this .minimumX;
         this .sizeY = this .maximumY - this .minimumY;
      },
      set_fieldOfViewOffset__: function ()
      {
         this ._fieldOfViewOffset [0] = this .fieldOfViewOffsetInterpolator0 ._value_changed .getValue ();
         this ._fieldOfViewOffset [1] = this .fieldOfViewOffsetInterpolator1 ._value_changed .getValue ();
         this ._fieldOfViewOffset [2] = this .fieldOfViewOffsetInterpolator2 ._value_changed .getValue ();
         this ._fieldOfViewOffset [3] = this .fieldOfViewOffsetInterpolator3 ._value_changed .getValue ();
      },
      setInterpolators: function (fromViewpointNode, toViewpointNode)
      {
         if (fromViewpointNode .getType () .indexOf (X3DConstants .OrthoViewpoint) >= 0)
         {
            const
               toLength   = toViewpointNode   ._fieldOfView .length,
               fromLength = fromViewpointNode ._fieldOfView .length;

            const
               offset0 = (fromLength > 0 ? fromViewpointNode ._fieldOfView [0] : -1) - (toLength > 0 ? toViewpointNode ._fieldOfView [0] : -1),
               offset1 = (fromLength > 1 ? fromViewpointNode ._fieldOfView [1] : -1) - (toLength > 1 ? toViewpointNode ._fieldOfView [1] : -1),
               offset2 = (fromLength > 2 ? fromViewpointNode ._fieldOfView [2] :  1) - (toLength > 2 ? toViewpointNode ._fieldOfView [2] :  1),
               offset3 = (fromLength > 3 ? fromViewpointNode ._fieldOfView [3] :  1) - (toLength > 3 ? toViewpointNode ._fieldOfView [3] :  1);

            this .fieldOfViewOffsetInterpolator0 ._keyValue = new Fields .MFFloat (offset0, toViewpointNode ._fieldOfViewOffset [0]);
            this .fieldOfViewOffsetInterpolator1 ._keyValue = new Fields .MFFloat (offset1, toViewpointNode ._fieldOfViewOffset [1]);
            this .fieldOfViewOffsetInterpolator2 ._keyValue = new Fields .MFFloat (offset2, toViewpointNode ._fieldOfViewOffset [2]);
            this .fieldOfViewOffsetInterpolator3 ._keyValue = new Fields .MFFloat (offset3, toViewpointNode ._fieldOfViewOffset [3]);

            this .fieldOfViewScaleInterpolator ._keyValue = new Fields .MFFloat (fromViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewOffset [0] = offset0;
            this ._fieldOfViewOffset [1] = offset1;
            this ._fieldOfViewOffset [2] = offset2;
            this ._fieldOfViewOffset [3] = offset3;

            this ._fieldOfViewScale = fromViewpointNode ._fieldOfViewScale .getValue ();
         }
         else
         {
            this .fieldOfViewOffsetInterpolator0 ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewOffset [0], toViewpointNode ._fieldOfViewOffset [0]);
            this .fieldOfViewOffsetInterpolator1 ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewOffset [1], toViewpointNode ._fieldOfViewOffset [1]);
            this .fieldOfViewOffsetInterpolator2 ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewOffset [2], toViewpointNode ._fieldOfViewOffset [2]);
            this .fieldOfViewOffsetInterpolator3 ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewOffset [3], toViewpointNode ._fieldOfViewOffset [3]);

            this .fieldOfViewScaleInterpolator ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewOffset = toViewpointNode ._fieldOfViewOffset .getValue ();
            this ._fieldOfViewScale  = toViewpointNode ._fieldOfViewScale  .getValue ();
         }
      },
      getMinimumX: function ()
      {
         return this .minimumX;
      },
      getMinimumY: function ()
      {
         return this .minimumY;
      },
      getMaximumX: function ()
      {
         return this .maximumX;
      },
      getMaximumY: function ()
      {
         return this .maximumY;
      },
      getSizeX: function ()
      {
         return this .sizeX;
      },
      getSizeY: function ()
      {
         return this .sizeY;
      },
      getMaxFarValue: function ()
      {
         return 1e5;
      },
      getScreenScale: (function ()
      {
         var screenScale = new Vector3 (0, 0, 0);

         return function (point, viewport)
         {
            var
               width  = viewport [2],
               height = viewport [3],
               sizeX  = this .sizeX,
               sizeY  = this .sizeY,
               aspect = width / height;

            if (aspect > sizeX / sizeY)
            {
               var s = sizeY / height;

               return screenScale .set (s, s, s);
            }

            var s = sizeX / width;

            return screenScale .set (s, s, s);
         };
      })(),
      getViewportSize: (function ()
      {
         var viewportSize = new Vector2 (0, 0);

         return function (viewport, nearValue)
         {
            var
               width  = viewport [2],
               height = viewport [3],
               sizeX  = this .sizeX,
               sizeY  = this .sizeY,
               aspect = width / height;

            if (aspect > sizeX / sizeY)
               return viewportSize .set (sizeY * aspect, sizeY);

            return viewportSize .set (sizeX, sizeX / aspect);
         };
      })(),
      getLookAtDistance: function (bbox)
      {
         return bbox .size .abs () / 2 + 10;
      },
      getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
      {
         var
            width  = viewport [2],
            height = viewport [3],
            aspect = width / height,
            sizeX  = this .sizeX,
            sizeY  = this .sizeY;

         if (aspect > sizeX / sizeY)
         {
            var
               center  = (this .minimumX + this .maximumX) / 2,
               size1_2 = (sizeY * aspect) / 2;

            return Camera .ortho (center - size1_2, center + size1_2, this .minimumY, this .maximumY, nearValue, farValue, this .projectionMatrix);
         }

         var
            center  = (this .minimumY + this .maximumY) / 2,
            size1_2 = (sizeX / aspect) / 2;

         return Camera .ortho (this .minimumX, this .maximumX, center - size1_2, center + size1_2, nearValue, farValue, this .projectionMatrix);
      },
   });

   return OrthoViewpoint;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DProgrammableShaderObject',[
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "x_ite/Components/Navigation/OrthoViewpoint",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Matrix4",
],
function (X3DCast,
          X3DConstants,
          OrthoViewpoint,
          Matrix3,
          Matrix4)
{
"use strict";

   const _uniformLocation = Symbol .for ("X3DField.uniformLocation");

   function X3DProgrammableShaderObject (executionContext)
   {
      this .addType (X3DConstants .X3DProgrammableShaderObject);

      this .uniforms = [ ];

      this .x3d_ClipPlane                           = [ ];
      this .x3d_LightType                           = [ ];
      this .x3d_LightOn                             = [ ];
      this .x3d_LightColor                          = [ ];
      this .x3d_LightIntensity                      = [ ];
      this .x3d_LightAmbientIntensity               = [ ];
      this .x3d_LightAttenuation                    = [ ];
      this .x3d_LightLocation                       = [ ];
      this .x3d_LightDirection                      = [ ];
      this .x3d_LightBeamWidth                      = [ ];
      this .x3d_LightCutOffAngle                    = [ ];
      this .x3d_LightRadius                         = [ ];
      this .x3d_LightMatrix                         = [ ];
      this .x3d_ShadowIntensity                     = [ ];
      this .x3d_ShadowColor                         = [ ];
      this .x3d_ShadowBias                          = [ ];
      this .x3d_ShadowMatrix                        = [ ];
      this .x3d_ShadowMapSize                       = [ ];
      this .x3d_ShadowMap                           = [ ];
      this .x3d_Textures                            = [ ];
      this .x3d_MultiTextureMode                    = [ ];
      this .x3d_MultiTextureAlphaMode               = [ ];
      this .x3d_MultiTextureSource                  = [ ];
      this .x3d_MultiTextureFunction                = [ ];
      this .x3d_TextureCoordinateGeneratorMode      = [ ];
      this .x3d_TextureCoordinateGeneratorParameter = [ ];
      this .x3d_ProjectiveTexture                   = [ ];
      this .x3d_ProjectiveTextureMatrix             = [ ];
      this .x3d_ProjectiveTextureLocation           = [ ];
      this .x3d_TexCoord                            = [ ];
      this .x3d_TextureMatrix                       = [ ];

      this .numClipPlanes               = 0;
      this .fogNode                     = null;
      this .numLights                   = 0;
      this .numGlobalLights             = 0;
      this .lightNodes                  = [ ];
      this .numProjectiveTextures       = 0;
      this .numGlobalProjectiveTextures = 0;
      this .projectiveTextureNodes      = [ ];
      this .textures                    = new Set ();
   }

   X3DProgrammableShaderObject .prototype =
   {
      constructor: X3DProgrammableShaderObject,
      initialize: function ()
      {
         const browser = this .getBrowser ();

         this .x3d_MaxClipPlanes = browser .getMaxClipPlanes ();
         this .x3d_MaxLights     = browser .getMaxLights ();
         this .x3d_MaxTextures   = browser .getMaxTextures ();
      },
      canUserDefinedFields: function ()
      {
         return true;
      },
      setUniforms: function (value)
      {
         this .uniforms = value;
      },
      getDefaultUniformsAndAttributes: function (program)
      {
         // Get uniforms and attributes.

         const
            browser = this .getBrowser (),
            gl      = browser .getContext ();

         gl .useProgram (program);

         for (const name of this .uniforms)
            this [name] = gl .getUniformLocation (program, name);

         /*
          * Uniforms.
          */

         this .x3d_LogarithmicFarFactor1_2 = gl .getUniformLocation (program, "x3d_LogarithmicFarFactor1_2");

         this .x3d_GeometryType  = gl .getUniformLocation (program, "x3d_GeometryType");
         this .x3d_NumClipPlanes = gl .getUniformLocation (program, "x3d_NumClipPlanes");

         this .x3d_ClipPlanes = gl .getUniformLocation (program, "x3d_ClipPlane");

         for (let i = 0; i < this .x3d_MaxClipPlanes; ++ i)
            this .x3d_ClipPlane [i] = gl .getUniformLocation (program, "x3d_ClipPlane[" + i + "]");

         this .x3d_FogType            = this .getUniformLocation (gl, program, "x3d_Fog.type",            "x3d_FogType");
         this .x3d_FogColor           = this .getUniformLocation (gl, program, "x3d_Fog.color",           "x3d_FogColor");
         this .x3d_FogVisibilityRange = this .getUniformLocation (gl, program, "x3d_Fog.visibilityRange", "x3d_FogVisibilityRange");
         this .x3d_FogMatrix          = this .getUniformLocation (gl, program, "x3d_Fog.matrix",          "x3d_FogMatrix");
         this .x3d_FogCoord           = this .getUniformLocation (gl, program, "x3d_Fog.fogCoord",        "x3d_FogCoord");

         this .x3d_AlphaCutoff = gl .getUniformLocation (program, "x3d_AlphaCutoff");

         this .x3d_PointPropertiesPointSizeScaleFactor = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeScaleFactor");
         this .x3d_PointPropertiesPointSizeMinValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMinValue");
         this .x3d_PointPropertiesPointSizeMaxValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMaxValue");
         this .x3d_PointPropertiesPointSizeAttenuation = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeAttenuation");

         this .x3d_LinePropertiesApplied              = gl .getUniformLocation (program, "x3d_LineProperties.applied");
         this .x3d_LinePropertiesLinewidthScaleFactor = this .getUniformLocation (gl, program, "x3d_LineProperties.linewidthScaleFactor", "x3d_LinewidthScaleFactor");
         this .x3d_LineStippleScale                   = gl .getUniformLocation (program, "x3d_LineProperties.lineStippleScale");
         this .x3d_LinePropertiesLinetype             = gl .getUniformLocation (program, "x3d_LineProperties.linetype");

         this .x3d_FillPropertiesFilled     = gl .getUniformLocation (program, "x3d_FillProperties.filled");
         this .x3d_FillPropertiesHatched    = gl .getUniformLocation (program, "x3d_FillProperties.hatched");
         this .x3d_FillPropertiesHatchColor = gl .getUniformLocation (program, "x3d_FillProperties.hatchColor");
         this .x3d_FillPropertiesHatchStyle = gl .getUniformLocation (program, "x3d_FillProperties.hatchStyle");

         this .x3d_ColorMaterial = gl .getUniformLocation (program, "x3d_ColorMaterial");
         this .x3d_NumLights     = gl .getUniformLocation (program, "x3d_NumLights");

         for (let i = 0; i < this .x3d_MaxLights; ++ i)
         {
            this .x3d_LightType [i]             = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].type",             "x3d_LightType[" + i + "]");
            this .x3d_LightColor [i]            = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].color",            "x3d_LightColor[" + i + "]");
            this .x3d_LightAmbientIntensity [i] = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].ambientIntensity", "x3d_LightAmbientIntensity[" + i + "]");
            this .x3d_LightIntensity [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].intensity",        "x3d_LightIntensity[" + i + "]");
            this .x3d_LightAttenuation [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].attenuation",      "x3d_LightAttenuation[" + i + "]");
            this .x3d_LightLocation [i]         = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].location",         "x3d_LightLocation[" + i + "]");
            this .x3d_LightDirection [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].direction",        "x3d_LightDirection[" + i + "]");
            this .x3d_LightBeamWidth [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].beamWidth",        "x3d_LightBeamWidth[" + i + "]");
            this .x3d_LightCutOffAngle [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].cutOffAngle",      "x3d_LightCutOffAngle[" + i + "]");
            this .x3d_LightRadius [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].radius",           "x3d_LightRadius[" + i + "]");
            this .x3d_LightMatrix [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].matrix",           "x3d_LightMatrix[" + i + "]");

            this .x3d_ShadowIntensity [i] = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowIntensity");
            this .x3d_ShadowColor [i]     = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowColor");
            this .x3d_ShadowBias [i]      = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowBias");
            this .x3d_ShadowMatrix [i]    = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMatrix");
            this .x3d_ShadowMapSize [i]   = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMapSize");
            this .x3d_ShadowMap [i]       = gl .getUniformLocation (program, "x3d_ShadowMap[" + i + "]");
         }

         this .x3d_AmbientIntensity  = this .getUniformLocation (gl, program, "x3d_Material.ambientIntensity", "x3d_FrontMaterial.ambientIntensity");
         this .x3d_DiffuseColor      = this .getUniformLocation (gl, program, "x3d_Material.diffuseColor",     "x3d_FrontMaterial.diffuseColor");
         this .x3d_SpecularColor     = this .getUniformLocation (gl, program, "x3d_Material.specularColor",    "x3d_FrontMaterial.specularColor");
         this .x3d_EmissiveColor     = this .getUniformLocation (gl, program, "x3d_Material.emissiveColor",    "x3d_FrontMaterial.emissiveColor");
         this .x3d_Shininess         = this .getUniformLocation (gl, program, "x3d_Material.shininess",        "x3d_FrontMaterial.shininess");
         this .x3d_BaseColor         = gl .getUniformLocation (program, "x3d_Material.baseColor");
         this .x3d_Metallic          = gl .getUniformLocation (program, "x3d_Material.metallic");
         this .x3d_Roughness         = gl .getUniformLocation (program, "x3d_Material.roughness");
         this .x3d_OcclusionStrength = gl .getUniformLocation (program, "x3d_Material.occlusionStrength");
         this .x3d_NormalScale       = gl .getUniformLocation (program, "x3d_Material.normalScale");
         this .x3d_Transparency      = this .getUniformLocation (gl, program, "x3d_Material.transparency",     "x3d_FrontMaterial.transparency");

         const materialTextures = [
            "x3d_AmbientTexture",
            "x3d_DiffuseTexture",
            "x3d_SpecularTexture",
            "x3d_EmissiveTexture",
            "x3d_ShininessTexture",
            "x3d_BaseTexture",
            "x3d_MetallicRoughnessTexture",
            "x3d_OcclusionTexture",
            "x3d_NormalTexture",
         ];

         for (const materialTexture of materialTextures)
         {
            this [materialTexture] = {
               textureTransformMapping:  gl .getUniformLocation (program, materialTexture + ".textureTransformMapping"),
               textureCoordinateMapping: gl .getUniformLocation (program, materialTexture + ".textureCoordinateMapping"),
               texture2D:                gl .getUniformLocation (program, materialTexture + ".texture2D"),
               texture3D:                gl .getUniformLocation (program, materialTexture + ".texture3D"),
               textureCube:              gl .getUniformLocation (program, materialTexture + ".textureCube"),
            };
         }

         this .x3d_NumTextures           = gl .getUniformLocation (program, "x3d_NumTextures");
         this .x3d_NumProjectiveTextures = gl .getUniformLocation (program, "x3d_NumProjectiveTextures");
         this .x3d_MultiTextureColor     = gl .getUniformLocation (program, "x3d_MultiTextureColor");

         this .x3d_TexCoord .length = 0;

         for (let i = 0; i < this .x3d_MaxTextures; ++ i)
         {
            this .x3d_Textures [i] = {
               textureType: gl .getUniformLocation (program, "x3d_TextureType[" + i + "]"),
               texture2D: gl .getUniformLocation (program, "x3d_Texture2D[" + i + "]"),
               texture3D: gl .getUniformLocation (program, "x3d_Texture3D[" + i + "]"),
               textureCube: this .getUniformLocation (gl, program, "x3d_TextureCube[" + i + "]", "x3d_CubeMapTexture[" + i + "]"),
            }

            this .x3d_MultiTextureMode [i]      = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].mode");
            this .x3d_MultiTextureAlphaMode [i] = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].alphaMode");
            this .x3d_MultiTextureSource [i]    = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].source");
            this .x3d_MultiTextureFunction [i]  = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].function");

            this .x3d_TextureCoordinateGeneratorMode [i]      = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].mode");
            this .x3d_TextureCoordinateGeneratorParameter [i] = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].parameter");

            this .x3d_ProjectiveTexture [i]         = gl .getUniformLocation (program, "x3d_ProjectiveTexture[" + i + "]");
            this .x3d_ProjectiveTextureMatrix [i]   = gl .getUniformLocation (program, "x3d_ProjectiveTextureMatrix[" + i + "]");
            this .x3d_ProjectiveTextureLocation [i] = gl .getUniformLocation (program, "x3d_ProjectiveTextureLocation[" + i + "]");

            this .x3d_TextureMatrix [i] = gl .getUniformLocation (program, "x3d_TextureMatrix[" + i + "]");

            // Attribute

            const x3d_TexCoord = this .getAttribLocation (gl, program, "x3d_TexCoord" + i, i ? "" : "x3d_TexCoord");

            if (x3d_TexCoord !== -1)
               this .x3d_TexCoord .push ([i, x3d_TexCoord]);
         }

         this .x3d_TexCoordRamp = gl .getUniformLocation (program, "x3d_TexCoordRamp");

         this .x3d_Viewport          = gl .getUniformLocation (program, "x3d_Viewport");
         this .x3d_ProjectionMatrix  = gl .getUniformLocation (program, "x3d_ProjectionMatrix");
         this .x3d_ModelViewMatrix   = gl .getUniformLocation (program, "x3d_ModelViewMatrix");
         this .x3d_NormalMatrix      = gl .getUniformLocation (program, "x3d_NormalMatrix");
         this .x3d_CameraSpaceMatrix = gl .getUniformLocation (program, "x3d_CameraSpaceMatrix");

         /*
          * Attributes.
          */

         const attributes = [
            "FogDepth",
            "Color",
            "Normal",
            "Vertex",
            "Particle",
            "ParticleMatrix",
         ];

         for (const name of attributes)
         {
            const attribute = gl .getAttribLocation (program, `x3d_${name}`);

            this [`x3d_${name}`] = attribute;

            if (attribute < 0)
            {
               this [`enable${name}Attribute`]            = Function .prototype;
               this [`${lcfirst (name)}AttributeDivisor`] = Function .prototype;
            }
            else
            {
               delete this [`enable${name}Attribute`];
               delete this [`${lcfirst (name)}AttributeDivisor`];
            }
         }

         if (this .x3d_TexCoord .length === 0)
         {
            this .enableTexCoordAttribute  = Function .prototype;
            this .texCoordAttributeDivisor = Function .prototype;
         }
         else
         {
            delete this .enableTexCoordAttribute;
            delete this .texCoordAttributeDivisor;
         }

         /*
          * Fill uniforms with defaults.
          */

         gl .uniform1f (this .x3d_LineStippleScale, browser .getLineStippleScale ());

         // Fill special uniforms with default values, textures for units are created in X3DTexturingContext.

         gl .uniform1i  (this .x3d_LinePropertiesLinetype,   browser .getDefaultTexture2DUnit ());
         gl .uniform1i  (this .x3d_FillPropertiesHatchStyle, browser .getDefaultTexture2DUnit ());

         for (const materialTexture of materialTextures)
         {
            gl .uniform1i (this [materialTexture] .texture2D,   browser .getDefaultTexture2DUnit ());
            gl .uniform1i (this [materialTexture] .texture3D,   browser .getDefaultTexture3DUnit ());
            gl .uniform1i (this [materialTexture] .textureCube, browser .getDefaultTextureCubeUnit ());
         }

         gl .uniform1i (this .x3d_NumTextures, 0);

         for (const uniforms of this .x3d_Textures)
         {
            gl .uniform1i (uniforms .texture2D, browser .getDefaultTexture2DUnit ());

            if (gl .getVersion () >= 2)
               gl .uniform1i (uniforms .texture3D, browser .getDefaultTexture3DUnit ());

            gl .uniform1i (uniforms .textureCube, browser .getDefaultTextureCubeUnit ());
         }

         for (const uniform of this .x3d_ShadowMap)
            gl .uniform1i (uniform, browser .getDefaultTexture2DUnit ());

         if (browser .getProjectiveTextureMapping ())
         {
            for (const uniform of this .x3d_ProjectiveTexture)
               gl .uniform1i (uniform, browser .getDefaultTexture2DUnit ());
         }

         gl .uniform1i  (this .x3d_TexCoordRamp, browser .getDefaultTexture2DUnit ());

         /*
          * Check x3d_Vertex.
          */

         // if (this .x3d_Vertex < 0)
         // {
         //    if (gl .getVersion () >= 2)
         //      console .warn ("Missing »in vec4 x3d_Vertex;«.");
         //    else
         //       console .warn ("Missing »attribute vec4 x3d_Vertex;«.");
         // }
      },
      getUniformLocation: function (gl, program, name, depreciated)
      {
         // Legacy function to get uniform location.

         let location = gl .getUniformLocation (program, name);

         if (location)
            return location;

         // Look for depreciated location.

         if (depreciated)
         {
            location = gl .getUniformLocation (program, depreciated);

            if (location)
            {
               console .warn (this .getTypeName (), this .getName (), "Using uniform location name »" + depreciated + "« is depreciated, use »" + name + "«. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
            }

            return location;
         }

         return 0;
      },
      getAttribLocation: function (gl, program, name, depreciated)
      {
         // Legacy function to get uniform location.

         let location = gl .getAttribLocation (program, name);

         if (location >= 0)
            return location;

         // Look for depreciated location.

         if (depreciated)
         {
            location = gl .getAttribLocation (program, depreciated);

            if (location >= 0)
            {
               console .warn (this .getTypeName (), this .getName (), "Using attribute location name »" + depreciated + "« is depreciated, use »" + name + "«. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
            }

            return location;
         }

         return -1;
      },
      addShaderFields: function (program)
      {
         const gl = this .getBrowser () .getContext ();

         gl .useProgram (program);

         this .textures .clear ();

         for (const field of this .getUserDefinedFields ())
         {
            const location = gl .getUniformLocation (program, field .getName ());

            if (location)
            {
               switch (field .getType ())
               {
                  case X3DConstants .SFImage:
                  {
                     location .array = new Int32Array (3 + field .array .length);
                     break;
                  }
                  case X3DConstants .SFMatrix3d:
                  case X3DConstants .SFMatrix3f:
                  case X3DConstants .SFRotation:
                  {
                     location .array = new Float32Array (9);
                     break;
                  }
                  case X3DConstants .SFMatrix4d:
                  case X3DConstants .SFMatrix4f:
                  {
                     location .array = new Float32Array (16);
                     break;
                  }
                  case X3DConstants .SFNode:
                  {
                     break;
                  }
                  case X3DConstants .MFBool:
                  case X3DConstants .MFInt32:
                  {
                     location .array = new Int32Array (this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFFloat:
                  case X3DConstants .MFDouble:
                  case X3DConstants .MFTime:
                  {
                     location .array = new Float32Array (this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFImage:
                  {
                     location .array = new Int32Array (this .getImagesLength (field));
                     break;
                  }
                  case X3DConstants .MFMatrix3d:
                  case X3DConstants .MFMatrix3f:
                  case X3DConstants .MFRotation:
                  {
                     location .array = new Float32Array (9 * this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFMatrix4d:
                  case X3DConstants .MFMatrix4f:
                  {
                     location .array = new Float32Array (16 * this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFNode:
                  {
                     const locations = location .locations = [ ];

                     for (let i = 0;; ++ i)
                     {
                        const l = gl .getUniformLocation (program, field .getName () + "[" + i + "]");

                        if (! l)
                           break;

                        locations .push (l);
                     }

                     break;
                  }
                  case X3DConstants .MFVec2d:
                  case X3DConstants .MFVec2f:
                  {
                     location .array = new Float32Array (2 * this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFVec3d:
                  case X3DConstants .MFVec3f:
                  case X3DConstants .MFColor:
                  {
                     location .array = new Float32Array (3 * this .getLocationLength (gl, program, field));
                     break;
                  }
                  case X3DConstants .MFVec4d:
                  case X3DConstants .MFVec4f:
                  case X3DConstants .MFColorRGBA:
                  {
                     location .array = new Float32Array (4 * this .getLocationLength (gl, program, field));
                     break;
                  }
               }

               if (location .array)
                  field [_uniformLocation] = location .array .length ? location : null;
               else
                  field [_uniformLocation] = location;

               field .addInterest ("set_field__", this);

               this .set_field__ (field, program);
            }
         }
      },
      removeShaderFields: function ()
      {
         for (const field of this .getUserDefinedFields ())
            field .removeInterest ("set_field__", this);
      },
      set_field__: (function ()
      {
         const matrix3 = new Matrix3 ();

         return function (field, program)
         {
            const
               gl       = this .getBrowser () .getContext (),
               location = field [_uniformLocation];

            gl .useProgram (program);

            if (location)
            {
               switch (field .getType ())
               {
                  case X3DConstants .SFBool:
                  case X3DConstants .SFInt32:
                  {
                     gl .uniform1i (location, field .getValue ());
                     return;
                  }
                  case X3DConstants .SFColor:
                  {
                     const value = field .getValue ();
                     gl .uniform3f (location, value .r, value .g, value .b);
                     return;
                  }
                  case X3DConstants .SFColorRGBA:
                  {
                     const value = field .getValue ();
                     gl .uniform4f (location, value .r, value .g, value .b, value .a);
                     return;
                  }
                  case X3DConstants .SFDouble:
                  case X3DConstants .SFFloat:
                  case X3DConstants .SFTime:
                  {
                     gl .uniform1f (location, field .getValue ());
                     return;
                  }
                  case X3DConstants .SFImage:
                  {
                     let array = location .array;

                     const
                        pixels = field .array,
                        length = 3 + pixels .length;

                     if (length !== array .length)
                        array = location .array = new Int32Array (length);

                     array [0] = field .width;
                     array [1] = field .height;
                     array [2] = field .comp;

                     for (let a = 3, p = 0, pl = pixels .length; p < pl; ++ p, ++ a)
                        array [a] = pixels [p];

                     gl .uniform1iv (location, array);
                     return;
                  }
                  case X3DConstants .SFMatrix3d:
                  case X3DConstants .SFMatrix3f:
                  {
                     location .array .set (field .getValue ());

                     gl .uniformMatrix3fv (location, false, location .array);
                     return;
                  }
                  case X3DConstants .SFMatrix4d:
                  case X3DConstants .SFMatrix4f:
                  {
                     location .array .set (field .getValue ());

                     gl .uniformMatrix4fv (location, false, location .array);
                     return;
                  }
                  case X3DConstants .SFNode:
                  {
                     const texture = X3DCast (X3DConstants .X3DTextureNode, field);

                     if (texture)
                     {
                        location .name    = field .getName ();
                        location .texture = texture;

                        this .textures .add (location);
                     }
                     else
                     {
                        this .textures .delete (location);
                     }

                     return;
                  }
                  case X3DConstants .SFRotation:
                  {
                     field .getValue () .getMatrix (location .array);

                     gl .uniformMatrix3fv (location, false, location .array);
                     return;
                  }
                  case X3DConstants .SFString:
                  {
                     return;
                  }
                  case X3DConstants .SFVec2d:
                  case X3DConstants .SFVec2f:
                  {
                     const value = field .getValue ();
                     gl .uniform2f (location, value .x, value .y);
                     return;
                  }
                  case X3DConstants .SFVec3d:
                  case X3DConstants .SFVec3f:
                  {
                     const value = field .getValue ();
                     gl .uniform3f (location, value .x, value .y, value .z);
                     return;
                  }
                  case X3DConstants .SFVec4d:
                  case X3DConstants .SFVec4f:
                  {
                     const value = field .getValue ();
                     gl .uniform4f (location, value .x, value .y, value .z, value .w);
                     return;
                  }
                  case X3DConstants .MFBool:
                  case X3DConstants .MFInt32:
                  {
                     const array = location .array;

                     for (var i = 0, length = field .length; i < length; ++ i)
                        array [i] = field [i];

                     for (let length = array .length; i < length; ++ i)
                        array [i] = 0;

                     gl .uniform1iv (location, array);
                     return;
                  }
                  case X3DConstants .MFColor:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const color = field [i];

                        array [k++] = color .r;
                        array [k++] = color .g;
                        array [k++] = color .b;
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniform3fv (location, array);
                     return;
                  }
                  case X3DConstants .MFColorRGBA:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const color = field [i];

                        array [k++] = color .r;
                        array [k++] = color .g;
                        array [k++] = color .b;
                        array [k++] = color .a;
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniform4fv (location, array);
                     return;
                  }
                  case X3DConstants .MFDouble:
                  case X3DConstants .MFFloat:
                  case X3DConstants .MFTime:
                  {
                     const array = location .array;

                     for (var i = 0, length = field .length; i < length; ++ i)
                        array [i] = field [i];

                     for (let length = array .length; i < length; ++ i)
                        array [i] = 0;

                     gl .uniform1fv (location, array);
                     return;
                  }
                  case X3DConstants .MFImage:
                  {
                     const array = location .array;

                     for (let i = 0, a = 0, length = field .length; i < length; ++ i)
                     {
                        const
                           value  = field [i],
                           pixels = value .array;

                        array [a ++] = value .width;
                        array [a ++] = value .height;
                        array [a ++] = value .comp;

                        for (let p = 0, pl = pixels .length; p < pl; ++ p)
                           array [a ++] = pixels [p];
                     }

                     gl .uniform1iv (location, array);
                     return;
                  }
                  case X3DConstants .MFMatrix3d:
                  case X3DConstants .MFMatrix3f:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const matrix = field [i];

                        for (let m = 0; m < 9; ++ m)
                           array [k++] = matrix [m];
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniformMatrix3fv (location, false, array);
                     return;
                  }
                  case X3DConstants .MFMatrix4d:
                  case X3DConstants .MFMatrix4f:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const matrix = field [i];

                        for (let m = 0; m < 16; ++ m)
                           array [k++] = matrix [m];
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniformMatrix4fv (location, false, array);
                     return;
                  }
                  case X3DConstants .MFNode:
                  {
                     const locations = location .locations;

                     for (let i = 0, length = field .length; i < length; ++ i)
                     {
                        const texture = X3DCast (X3DConstants .X3DTextureNode, field [i]);

                        if (texture)
                        {
                           locations [i] .name    = field .getName ();
                           locations [i] .texture = texture;

                           this .textures .add (locations [i]);
                        }
                        else
                        {
                           this .textures .delete (locations [i]);
                        }
                     }

                     return;
                  }
                  case X3DConstants .MFRotation:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const matrix = field [i] .getValue () .getMatrix (matrix3);

                        array [k++] = matrix [0];
                        array [k++] = matrix [1];
                        array [k++] = matrix [2];
                        array [k++] = matrix [3];
                        array [k++] = matrix [4];
                        array [k++] = matrix [5];
                        array [k++] = matrix [6];
                        array [k++] = matrix [7];
                        array [k++] = matrix [8];
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniformMatrix3fv (location, false, array);
                     return;
                  }
                  case X3DConstants .MFString:
                  {
                     return;
                  }
                  case X3DConstants .MFVec2d:
                  case X3DConstants .MFVec2f:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const vector = field [i];

                        array [k++] = vector .x;
                        array [k++] = vector .y;
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniform2fv (location, array);
                     return;
                  }
                  case X3DConstants .MFVec3d:
                  case X3DConstants .MFVec3f:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const vector = field [i];

                        array [k++] = vector .x;
                        array [k++] = vector .y;
                        array [k++] = vector .z;
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniform3fv (location, array);
                     return;
                  }
                  case X3DConstants .MFVec4d:
                  case X3DConstants .MFVec4f:
                  {
                     const array = location .array;

                     for (var i = 0, k = 0, length = field .length; i < length; ++ i)
                     {
                        const vector = field [i];

                        array [k++] = vector .x;
                        array [k++] = vector .y;
                        array [k++] = vector .z;
                        array [k++] = vector .w;
                     }

                     for (let length = array .length; k < length; ++ k)
                        array [k] = 0;

                     gl .uniform4fv (location, array);
                     return;
                  }
               }
            }
         };
      })(),
      getImagesLength: function (field)
      {
         const images = field .getValue ();

         let length = 3 * images .length;

         for (const image of images)
            length += image .array .length;

         return length;
      },
      getLocationLength: function (gl, program, field)
      {
         const name = field .getName ();

         for (let i = 0; ; ++ i)
         {
            const location = gl .getUniformLocation (program, name + "[" + i + "]");

            if (! location)
               return i;
         }
      },
      hasFog: function (fogNode)
      {
         if (this .fogNode === fogNode)
            return true;

         this .fogNode = fogNode;

         return false;
      },
      hasLight: function (i, lightNode)
      {
         if (this .lightNodes [i] === lightNode)
            return true;

         this .lightNodes [i] = lightNode;

         return false;
      },
      hasTextureProjector: function (i, textureProjectorNode)
      {
         if (this .projectiveTextureNodes [i] === textureProjectorNode)
            return true;

         this .projectiveTextureNodes [i] = textureProjectorNode;

         return false;
      },
      setLocalObjects: function (gl, localObjects)
      {
         // Clip planes and local lights

         this .numClipPlanes                  = 0;
         this .numLights                      = 0;
         this .numProjectiveTextures          = 0;
         this .lightNodes .length             = 0;
         this .projectiveTextureNodes .length = 0;

         for (const localObject of localObjects)
            localObject .setShaderUniforms (gl, this);

         gl .uniform1i (this .x3d_NumClipPlanes,         Math .min (this .numClipPlanes,         this .x3d_MaxClipPlanes));
         gl .uniform1i (this .x3d_NumLights,             Math .min (this .numLights,             this .x3d_MaxLights));
         gl .uniform1i (this .x3d_NumProjectiveTextures, Math .min (this .numProjectiveTextures, this .x3d_MaxTextures));
      },
      setGlobalUniforms: function (gl, program, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray)
      {
         const globalObjects = renderObject .getGlobalObjects ();

         gl .useProgram (program);

         // Set viewport

         gl .uniform4iv (this .x3d_Viewport, viewportArray);

         // Set projection matrix

         gl .uniformMatrix4fv (this .x3d_ProjectionMatrix,  false, projectionMatrixArray);
         gl .uniformMatrix4fv (this .x3d_CameraSpaceMatrix, false, cameraSpaceMatrixArray);

         // Fog

         this .fogNode = null;

         // Set global lights and global texture projectors

         this .numLights                      = 0;
         this .numProjectiveTextures          = 0;
         this .lightNodes .length             = 0;
         this .projectiveTextureNodes .length = 0;

         for (const globalObject of globalObjects)
            globalObject .setShaderUniforms (gl, this, renderObject);

         this .numGlobalLights             = this .numLights;
         this .numGlobalProjectiveTextures = this .numProjectiveTextures;

         // Logarithmic depth buffer support.

         const
            viewpoint      = renderObject .getViewpoint (),
            navigationInfo = renderObject .getNavigationInfo ();

         if (viewpoint instanceof OrthoViewpoint)
            gl .uniform1f (this .x3d_LogarithmicFarFactor1_2, -1);
         else
            gl .uniform1f (this .x3d_LogarithmicFarFactor1_2, 1 / Math .log2 (navigationInfo .getFarValue (viewpoint) + 1));
      },
      setLocalUniforms: function (gl, context, front = true)
      {
         const
            renderObject    = context .renderer,
            shapeNode       = context .shapeNode,
            geometryNode    = context .geometryContext || shapeNode .getGeometry (),
            geometryType    = geometryNode .geometryType,
            appearanceNode  = shapeNode .getAppearance (),
            materialNode    = front ? appearanceNode .materialNode : appearanceNode .backMaterialNode,
            textureNode     = context .textureNode || appearanceNode .textureNode,
            modelViewMatrix = context .modelViewMatrix;

         // Model view matrix

         gl .uniformMatrix4fv (this .x3d_ModelViewMatrix, false, modelViewMatrix);

         // Geometry type

         gl .uniform1i (this .x3d_GeometryType, geometryType);

         // Clip planes and local lights

         this .numClipPlanes         = 0;
         this .numLights             = this .numGlobalLights;
         this .numProjectiveTextures = this .numGlobalProjectiveTextures;

         for (const localObject of context .localObjects)
            localObject .setShaderUniforms (gl, this, renderObject);

         gl .uniform1i (this .x3d_NumClipPlanes,         Math .min (this .numClipPlanes,         this .x3d_MaxClipPlanes));
         gl .uniform1i (this .x3d_NumLights,             Math .min (this .numLights,             this .x3d_MaxLights));
         gl .uniform1i (this .x3d_NumProjectiveTextures, Math .min (this .numProjectiveTextures, this .x3d_MaxTextures));

         // Fog, there is always one

         context .fogNode .setShaderUniforms (gl, this);
         gl .uniform1i (this .x3d_FogCoord, geometryNode .fogCoords);

         // Alpha

         gl .uniform1f (this .x3d_AlphaCutoff, appearanceNode .alphaCutoff);

         // Style

         appearanceNode .stylePropertiesNode [geometryType] .setShaderUniforms (gl, this);

         // Material

         gl .uniform1i (this .x3d_ColorMaterial, geometryNode .colorMaterial);
         materialNode .setShaderUniforms (gl, this, renderObject, appearanceNode .textureTransformMapping, geometryNode .textureCoordinateMapping, front);

         // Normal matrix

         gl .uniformMatrix3fv (this .x3d_NormalMatrix, false, this .getNormalMatrix (modelViewMatrix));

         // Texture

         if (textureNode)
            textureNode .setShaderUniforms (gl, this, renderObject);
         else
            gl .uniform1i (this .x3d_NumTextures, 0);

         appearanceNode .textureTransformNode .setShaderUniforms (gl, this);
         geometryNode .textureCoordinateNode .setShaderUniforms (gl, this);
      },
      getNormalMatrix: (function ()
      {
         const normalMatrix = new Float32Array (9);

         return function (modelViewMatrix)
         {
            normalMatrix [0] = modelViewMatrix [0]; normalMatrix [3] = modelViewMatrix [1]; normalMatrix [6] = modelViewMatrix [ 2];
            normalMatrix [1] = modelViewMatrix [4]; normalMatrix [4] = modelViewMatrix [5]; normalMatrix [7] = modelViewMatrix [ 6];
            normalMatrix [2] = modelViewMatrix [8]; normalMatrix [5] = modelViewMatrix [9]; normalMatrix [8] = modelViewMatrix [10];

            Matrix3 .prototype .inverse .call (normalMatrix);

            return normalMatrix;
         };
      })(),
      enable: function (gl, program)
      {
         const browser = this .getBrowser ();

         gl .useProgram (program);

         for (const location of this .textures)
         {
            const
               texture     = location .texture,
               textureUnit = browser .getTextureUnit (texture .getTextureType ());

            if (textureUnit === undefined)
            {
               console .warn ("Not enough combined texture units for uniform variable '" + location .name + "' available.");
               return;
            }

            gl .activeTexture (gl .TEXTURE0 + textureUnit);
            gl .bindTexture (texture .getTarget (), texture .getTexture ());
            gl .uniform1i (location, textureUnit);
         }
      },
      enableFloatAttrib: function (gl, name, buffer, components, stride, offset)
      {
         const location = gl .getAttribLocation (this .getProgram (), name);

         if (location === -1)
            return;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, components, gl .FLOAT, false, stride, offset);
      },
      enableMatrix3Attrib: function (gl, name, buffer, stride, offset)
      {
         const location0 = gl .getAttribLocation (this .getProgram (), name);

         if (location0 === -1)
            return;

         stride = stride || 36;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

         for (let i = 0; i < 3; ++ i)
         {
            const location = location0 + i;

            gl .enableVertexAttribArray (location);
            gl .vertexAttribPointer (location, 3, gl .FLOAT, false, stride, offset + 12 * i);
         }
      },
      enableMatrix4Attrib: function (gl, name, buffer, stride, offset)
      {
         const location0 = gl .getAttribLocation (this .getProgram (), name);

         if (location0 === -1)
            return;

         stride = stride || 64;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

         for (let i = 0; i < 4; ++ i)
         {
            const location = location0 + i;

            gl .enableVertexAttribArray (location);
            gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset + 16 * i);
         }
      },
      enableFogDepthAttribute: function (gl, buffer, stride, offset)
      {
         const location = this .x3d_FogDepth;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 1, gl .FLOAT, false, stride, offset);
      },
      enableColorAttribute: function (gl, buffer, stride, offset)
      {
         const location = this .x3d_Color;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
      },
      colorAttributeDivisor: function (gl, divisor)
      {
         gl .vertexAttribDivisor (this .x3d_Color, divisor);
      },
      enableTexCoordAttribute: function (gl, buffers, stride, offset)
      {
         for (const [i, location] of this .x3d_TexCoord)
         {
            gl .bindBuffer (gl .ARRAY_BUFFER, buffers [i]);
            gl .enableVertexAttribArray (location);
            gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
         }
      },
      texCoordAttributeDivisor: function (gl, divisor)
      {
         for (const [i, location] of this .x3d_TexCoord)
         {
            gl .vertexAttribDivisor (location, divisor);
         }
      },
      enableNormalAttribute: function (gl, buffer, stride, offset)
      {
         const location = this .x3d_Normal;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 3, gl .FLOAT, false, stride, offset);
      },
      normalAttributeDivisor: function (gl, divisor)
      {
         gl .vertexAttribDivisor (this .x3d_Normal, divisor);
      },
      enableVertexAttribute: function (gl, buffer, stride, offset)
      {
         const location = this .x3d_Vertex;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
      },
      vertexAttributeDivisor: function (gl, divisor)
      {
         gl .vertexAttribDivisor (this .x3d_Vertex, divisor);
      },
      enableParticleAttribute: function (gl, buffer, stride, offset, divisor)
      {
         const location = this .x3d_Particle;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
         gl .enableVertexAttribArray (location);
         gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset);
         gl .vertexAttribDivisor (location, divisor);
      },
      enableParticleMatrixAttribute: function (gl, buffer, stride, offset, divisor)
      {
         const location0 = this .x3d_ParticleMatrix;

         stride = stride || 64;

         gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

         for (let i = 0; i < 4; ++ i)
         {
            const location = location0 + i;

            gl .enableVertexAttribArray (location);
            gl .vertexAttribPointer (location, 4, gl .FLOAT, false, stride, offset + 16 * i);
            gl .vertexAttribDivisor (location, divisor);
         }
      },
      getProgramInfo: function ()
      {
         function cmp (lhs, rhs) { return lhs < rhs ? -1 : lhs > rhs ? 1 : 0; }

         const
            gl      = this .getBrowser () .getContext (),
            program = this .getProgram ();

         const
            result = {
               attributes: [ ],
               uniforms: [ ],
               attributeCount: 0,
               uniformCount: 0,
            },
            activeUniforms   = gl .getProgramParameter (program, gl .ACTIVE_UNIFORMS),
            activeAttributes = gl .getProgramParameter (program, gl .ACTIVE_ATTRIBUTES);

         // Taken from the WebGl spec:
         // http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14
         const enums = {
            0x8B50: 'vec2',
            0x8B51: 'vec3',
            0x8B52: 'vec4',
            0x8B53: 'ivec2',
            0x8B54: 'ivec3',
            0x8B55: 'ivec4',
            0x8B56: 'bool',
            0x8B57: 'bvec2',
            0x8B58: 'bvec3',
            0x8B59: 'bvec4',
            0x8B5A: 'mat2',
            0x8B5B: 'mat3',
            0x8B5C: 'mat4',
            0x8B5E: 'sampler2D',
            0x8B60: 'samplerCube',
            0x1400: 'byte',
            0x1401: 'ubyte',
            0x1402: 'short',
            0x1403: 'ushort',
            0x1404: 'int',
            0x1405: 'uint',
            0x1406: 'float',
         };

         // Loop through active uniforms
         for (let i = 0; i < activeUniforms; ++ i)
         {
            const uniform = gl .getActiveUniform (program, i);
            uniform .typeName = enums [uniform.type];
            result .uniforms .push (Object .assign ({ }, uniform));
            result .uniformCount += uniform .size;
         }

         // Loop through active attributes
         for (let i = 0; i < activeAttributes; ++ i)
         {
            const attribute = gl .getActiveAttrib (program, i);
            attribute .typeName = enums [attribute .type];
            result .attributes .push (Object .assign ({ }, attribute));
            result .attributeCount += attribute .size;
         }

         result .uniforms   .sort (function (a, b) { return cmp (a .name, b .name); });
         result .attributes .sort (function (a, b) { return cmp (a .name, b .name); });

         return result;
      },
      printProgramInfo: function ()
      {
         const programInfo = this .getProgramInfo ();

         console .log (this .getName ());
         console .table (programInfo .attributes);
         console .log (this .getName (), "attributeCount", programInfo .attributeCount);
         console .log (this .getName ());
         console .table (programInfo .uniforms);
         console .log (this .getName (), "uniformCount", programInfo .uniformCount);
      },
   };

   function lcfirst (string)
   {
      return string [0] .toLowerCase () + string .slice (1);
   }

   return X3DProgrammableShaderObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/X3DNetworkSensorNode',[
   "x_ite/Components/Core/X3DSensorNode",
   "x_ite/Base/X3DConstants",
],
function (X3DSensorNode,
          X3DConstants)
{
"use strict";

   function X3DNetworkSensorNode (executionContext)
   {
      X3DSensorNode .call (this, executionContext);

      this .addType (X3DConstants .X3DNetworkSensorNode);
   }

   X3DNetworkSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
   {
      constructor: X3DNetworkSensorNode,
   });

   return X3DNetworkSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/LoadSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Networking/X3DNetworkSensorNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNetworkSensorNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function LoadSensor (executionContext)
   {
      X3DNetworkSensorNode .call (this, executionContext);

      this .addType (X3DConstants .LoadSensor);

      this .urlObjects = [ ];
      this .aborted    = false;
      this .timeOutId  = undefined;
   }

   LoadSensor .prototype = Object .assign (Object .create (X3DNetworkSensorNode .prototype),
   {
      constructor: LoadSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",   new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "timeOut",   new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",  new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isLoaded",  new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "progress",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "loadTime",  new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "watchList", new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "LoadSensor";
      },
      getComponentName: function ()
      {
         return "Networking";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DNetworkSensorNode .prototype .initialize .call (this);

         this ._enabled   .addInterest ("set_enabled__", this);
         this ._timeOut   .addInterest ("set_timeOut__", this);
         this ._watchList .addInterest ("set_watchList__", this);

         this ._watchList .addEvent ();
      },
      set_enabled__: function ()
      {
         if (this ._enabled .getValue ())
            this .reset ();

         else
         {
            this .abort ();
            this .remove ();
         }
      },
      set_timeOut__: function ()
      {
         if (this ._isActive .getValue ())
         {
            this .clearTimeout ();

            this .aborted = false;

            if (this ._timeOut .getValue () > 0)
               this .timeOutId = setTimeout (this .abort .bind (this), this ._timeOut .getValue () * 1000);
         }
      },
      set_watchList__: function ()
      {
         this .reset ();
      },
      set_loadState__: function (urlObject)
      {
         switch (urlObject .checkLoadState ())
         {
            case X3DConstants .NOT_STARTED_STATE:
               break;
            case X3DConstants .IN_PROGRESS_STATE:
            case X3DConstants .COMPLETE_STATE:
            case X3DConstants .FAILED_STATE:
            {
               this .count ();
               break;
            }
         }
      },
      count: function ()
      {
         var
            complete   = 0,
            failed     = 0,
            urlObjects = this .urlObjects;

         for (var i = 0, length = urlObjects .length; i < length; ++ i)
         {
            var urlObject = urlObjects [i];

            complete += urlObject .checkLoadState () == X3DConstants .COMPLETE_STATE;
            failed   += urlObject .checkLoadState () == X3DConstants .FAILED_STATE;
         }

         var
            loaded   = complete == urlObjects .length,
            progress = complete / urlObjects .length;

         if (this .aborted || failed || loaded)
         {
            this .clearTimeout ();

            this ._isActive = false;
            this ._isLoaded = loaded;
            this ._progress = progress;

            if (loaded)
               this ._loadTime = this .getBrowser () .getCurrentTime ();
         }
         else
         {
            if (this ._isActive .getValue ())
            {
               this ._progress = progress;
            }
            else
            {
               this ._isActive = true;

               this ._progress = progress;

               this .set_timeOut__ ();
            }
         }
      },
      abort: function ()
      {
         this .clearTimeout ();

         this .aborted = true;

         if (this ._enabled .getValue ())
            this .count ();
      },
      reset: function ()
      {
         this .remove ();

         if (this ._enabled .getValue ())
         {
            var
               watchList  = this ._watchList .getValue (),
               urlObjects = this .urlObjects;

            for (var i = 0, length = watchList .length; i < length; ++ i)
            {
               var urlObject = X3DCast (X3DConstants .X3DUrlObject, watchList [i]);

               if (urlObject)
               {
                  urlObjects .push (urlObject);

                  urlObject ._loadState .addInterest ("set_loadState__", this, urlObject);
               }
            }

            this .count ();
         }
      },
      remove: function ()
      {
         this .clearTimeout ();

         var urlObjects = this .urlObjects;

         for (var i = 0, length = urlObjects .length; i < length; ++ i)
            urlObjects [i] ._loadState .removeInterest ("set_loadState__", this);

         urlObjects .length = 0;
      },
      clearTimeout: function ()
      {
         clearTimeout (this .timeOutId);
         this .timeOutId = undefined;
      },
   });

   return LoadSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ComposedShader',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DShaderNode",
   "x_ite/Components/Shaders/X3DProgrammableShaderObject",
   "x_ite/Components/Networking/LoadSensor",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShaderNode,
          X3DProgrammableShaderObject,
          LoadSensor,
          X3DCast,
          X3DConstants)
{
"use strict";

   function ComposedShader (executionContext)
   {
      X3DShaderNode               .call (this, executionContext);
      X3DProgrammableShaderObject .call (this, executionContext);

      this .addType (X3DConstants .ComposedShader);

      this .loadSensor                = new LoadSensor (executionContext);
      this .transformFeedbackVaryings = [ ];
   }

   ComposedShader .prototype = Object .assign (Object .create (X3DShaderNode .prototype),
      X3DProgrammableShaderObject .prototype,
   {
      constructor: ComposedShader,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "activate",   new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isSelected", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isValid",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "language",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "parts",      new Fields .MFNode ()),
      ]),
      wireframe: false,
      getTypeName: function ()
      {
         return "ComposedShader";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "shaders";
      },
      initialize: function ()
      {
         X3DShaderNode               .prototype .initialize .call (this);
         X3DProgrammableShaderObject .prototype .initialize .call (this);

         const gl = this .getBrowser () .getContext ();

         this .primitiveMode = gl .TRIANGLES;

         this .isLive () .addInterest ("set_live__", this);

         this ._parts .addFieldInterest (this .loadSensor ._watchList);

         this .loadSensor ._isLoaded .addInterest ("set_loaded__", this);
         this .loadSensor ._watchList = this ._parts;
         this .loadSensor .setPrivate (true);
         this .loadSensor .setup ();

         //Must not call set_live__.
      },
      addUserDefinedField: function (accessType, name, field)
      {
         if (this .isInitialized () && this .isLive () .getValue () && this .isValid ())
            this .removeShaderFields ();

         X3DShaderNode .prototype .addUserDefinedField .call (this, accessType, name, field);

         if (this .isInitialized () && this .isLive () .getValue () && this .isValid ())
            this .addShaderFields (this .program);
      },
      removeUserDefinedField: function (name)
      {
         if (this .isInitialized () && this .isLive () .getValue () && this .isValid ())
            this .removeShaderFields ();

         X3DShaderNode .prototype .removeUserDefinedField .call (this, name);

         if (this .isInitialized () && this .isLive () .getValue () && this .isValid ())
            this .addShaderFields (this .program);
      },
      setTransformFeedbackVaryings: function (value)
      {
         this .transformFeedbackVaryings = value;
      },
      getProgram: function ()
      {
         return this .program;
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue ())
         {
            if (this .isValid ())
               this .addShaderFields (this .program);
         }
         else
         {
            if (this .isValid ())
               this .removeShaderFields ();
         }
      },
      set_loaded__: function ()
      {
         if (this .loadSensor ._isLoaded .getValue ())
         {
            const
               gl      = this .getBrowser () .getContext (),
               program = gl .createProgram ();

            if (this .isValid ())
               this .removeShaderFields ();

            gl .deleteProgram (this .program);

            this .program = program;

            for (const node of this ._parts)
            {
               const partNode = X3DCast (X3DConstants .ShaderPart, node);

               if (partNode)
                  gl .attachShader (program, partNode .getShader ());
            }

            if (this .transformFeedbackVaryings .length)
               gl .transformFeedbackVaryings (program, this .transformFeedbackVaryings, gl .INTERLEAVED_ATTRIBS);

            gl .linkProgram (program);

            if (gl .getProgramParameter (program, gl .LINK_STATUS))
            {
               this .getDefaultUniformsAndAttributes (program);
               this .setValid (true);
            }
            else
            {
               if (this ._parts .length)
               {
                  console .warn ("Couldn't initialize " + this .getTypeName () + " '" + this .getName () + "': " + gl .getProgramInfoLog (program));
               }

               this .setValid (false);
            }

            if (this .isValid ())
               this .addShaderFields (this .program);
         }
         else
         {
            this .setValid (false);
         }
      },
      set_field__: function (field)
      {
         if (this .isValid ())
            X3DProgrammableShaderObject .prototype .set_field__ .call (this, field, this .program);
      },
      setGlobalUniforms: function (gl, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray)
      {
         if (this .isValid ())
         {
            X3DProgrammableShaderObject .prototype .setGlobalUniforms .call (this, gl, this .program, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray);
         }
      },
      enable: function (gl)
      {
         X3DProgrammableShaderObject .prototype .enable .call (this, gl, this .program);
      },
   });

   return ComposedShader;
});














































define('text!assets/shaders/Types.glsl',[],function () { return 'struct x3d_FogParameters {\n   mediump int   type;\n   mediump vec3  color;\n   mediump float visibilityRange;\n   mediump mat3  matrix;\n   bool          fogCoord;\n};\n\n//uniform x3d_FogParameters x3d_Fog;\n\nstruct x3d_LightSourceParameters {\n   mediump int   type;\n   mediump vec3  color;\n   mediump float intensity;\n   mediump float ambientIntensity;\n   mediump vec3  attenuation;\n   mediump vec3  location;\n   mediump vec3  direction;\n   mediump float radius;\n   mediump float beamWidth;\n   mediump float cutOffAngle;\n   mediump mat3  matrix;\n   #ifdef X3D_SHADOWS\n   mediump vec3  shadowColor;\n   mediump float shadowIntensity;\n   mediump float shadowBias;\n   mediump mat4  shadowMatrix;\n   mediump int   shadowMapSize;\n   #endif\n};\n\n//uniform x3d_LightSourceParameters x3d_LightSource [x3d_MaxLights];\n\nstruct x3d_PointPropertiesParameters\n{\n   mediump float pointSizeScaleFactor;\n   mediump float pointSizeMinValue;\n   mediump float pointSizeMaxValue;\n   mediump vec3  pointSizeAttenuation;\n};\n\n//uniform x3d_PointPropertiesParameters x3d_PointProperties;\n\nstruct x3d_LinePropertiesParameters\n{\n   bool          applied;\n   mediump float linewidthScaleFactor;\n   mediump float lineStippleScale;\n   sampler2D     linetype;\n};\n\n//uniform x3d_LinePropertiesParameters x3d_LineProperties;\n\nstruct x3d_FillPropertiesParameters\n{\n   bool         filled;\n   bool         hatched;\n   mediump vec3 hatchColor;\n   sampler2D    hatchStyle;\n};\n\n//uniform x3d_FillPropertiesParameters x3d_FillProperties;\n\nstruct x3d_UnlitMaterialParameters\n{\n   mediump vec3  emissiveColor;\n   mediump float normalScale;\n   mediump float transparency;\n};\n\n//uniform x3d_UnlitMaterialParameters x3d_Material;\n\nstruct x3d_MaterialParameters\n{\n   mediump float ambientIntensity;\n   mediump vec3  diffuseColor;\n   mediump vec3  specularColor;\n   mediump vec3  emissiveColor;\n   mediump float shininess;\n   mediump float occlusionStrength;\n   mediump float normalScale;\n   mediump float transparency;\n};\n\n//uniform x3d_MaterialParameters x3d_Material;\n\nstruct x3d_PhysicalMaterialParameters\n{\n   mediump vec3  baseColor;\n   mediump vec3  emissiveColor;\n   mediump float metallic;\n   mediump float roughness;\n   mediump float occlusionStrength;\n   mediump float normalScale;\n   mediump float transparency;\n};\n\n//uniform x3d_PhysicalMaterialParameters x3d_Material;\n\n#ifdef X3D_MATERIAL_TEXTURES\n\nstruct x3d_AmbientTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_AMBIENT_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_AMBIENT_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_AMBIENT_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_AmbientTextureParameters x3d_AmbientTexture;\n\nstruct x3d_DiffuseTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_DIFFUSE_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_DIFFUSE_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_DIFFUSE_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_DiffuseTextureParameters x3d_DiffuseTexture;\n\nstruct x3d_SpecularTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_SPECULAR_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_SPECULAR_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_SPECULAR_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_SpecularTextureParameters x3d_SpecularTexture;\n\nstruct x3d_EmissiveTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_EMISSIVE_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_EMISSIVE_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_EMISSIVE_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_EmissiveTextureParameters x3d_EmissiveTexture;\n\nstruct x3d_ShininessTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_SHININESS_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_SHININESS_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_SHININESS_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_ShininessTextureParameters x3d_ShininessTexture;\n\nstruct x3d_BaseTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_BASE_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_BASE_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_BASE_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_BaseTextureParameters x3d_BaseTexture;\n\nstruct x3d_MetallicRoughnessTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_METALLIC_ROUGHNESS_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_METALLIC_ROUGHNESS_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_METALLIC_ROUGHNESS_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_MetallicRoughnessTextureParameters x3d_MetallicRoughnessTexture;\n\nstruct x3d_OcclusionTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_OCCLUSION_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_OCCLUSION_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_OCCLUSION_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_OcclusionTextureParameters x3d_OcclusionTexture;\n\nstruct x3d_NormalTextureParameters\n{\n   mediump int         textureTransformMapping;\n   mediump int         textureCoordinateMapping;\n   #ifdef X3D_NORMAL_TEXTURE_2D\n   mediump sampler2D   texture2D;\n   #endif\n   #if defined(X3D_NORMAL_TEXTURE_3D) && __VERSION__ != 100\n   mediump sampler3D   texture3D;\n   #endif\n   #ifdef X3D_NORMAL_TEXTURE_CUBE\n   mediump samplerCube textureCube;\n   #endif\n};\n\n//uniform x3d_NormalTextureParameters x3d_NormalTexture;\n\n#endif // X3D_MATERIAL_TEXTURES\n\nstruct x3d_MultiTextureParameters\n{\n   mediump int mode;\n   mediump int alphaMode;\n   mediump int source;\n   mediump int function;\n};\n\n//uniform x3d_MultiTextureParameters x3d_MultiTexture [x3d_MaxTextures];\n\nstruct x3d_TextureCoordinateGeneratorParameters\n{\n   mediump int   mode;\n   mediump float parameter [6];\n};\n\n//uniform x3d_TextureCoordinateGeneratorParameters x3d_TextureCoordinateGenerator [x3d_MaxTextures];\n';});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureModeType',[],function ()
{
"use strict";

   let i = 0;

   const ModeType =
   {
      REPLACE:                   i ++,
      MODULATE:                  i ++,
      MODULATE2X:                i ++,
      MODULATE4X:                i ++,
      ADD:                       i ++,
      ADDSIGNED:                 i ++,
      ADDSIGNED2X:               i ++,
      ADDSMOOTH:                 i ++,
      SUBTRACT:                  i ++,
      BLENDDIFFUSEALPHA:         i ++,
      BLENDTEXTUREALPHA:         i ++,
      BLENDFACTORALPHA:          i ++,
      BLENDCURRENTALPHA:         i ++,
      MODULATEALPHA_ADDCOLOR:    i ++,
      MODULATEINVALPHA_ADDCOLOR: i ++,
      MODULATEINVCOLOR_ADDALPHA: i ++,
      DOTPRODUCT3:               i ++,
      SELECTARG1:                i ++,
      SELECTARG2:                i ++,
      OFF:                       i ++,
   };

   return ModeType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureSourceType',[],function ()
{
"use strict";

   let i = 0;

   const SourceType =
   {
      DEFAULT:  i ++,
      DIFFUSE:  i ++,
      SPECULAR: i ++,
      FACTOR:   i ++,
   };

   return SourceType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureFunctionType',[],function ()
{
"use strict";

   let i = 0;

   const FunctionType =
   {
      DEFAULT:        i ++,
      COMPLEMENT:     i ++,
      ALPHAREPLICATE: i ++,
   };

   return FunctionType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType',[],function ()
{
"use strict";

   let i = 0;

   const ModeType =
   {
      NONE:                        i ++,
      SPHERE:                      i ++,
      CAMERASPACENORMAL:           i ++,
      CAMERASPACEPOSITION:         i ++,
      CAMERASPACEREFLECTIONVECTOR: i ++,
      SPHERE_LOCAL:                i ++,
      COORD:                       i ++,
      COORD_EYE:                   i ++,
      NOISE:                       i ++,
      NOISE_EYE:                   i ++,
      SPHERE_REFLECT:              i ++,
      SPHERE_REFLECT_LOCAL:        i ++,
   };

   return ModeType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/Shader',[
   "x_ite/Browser/Shaders/ShaderSource",
   "text!assets/shaders/Types.glsl",
   "x_ite/Browser/Texturing/MultiTextureModeType",
   "x_ite/Browser/Texturing/MultiTextureSourceType",
   "x_ite/Browser/Texturing/MultiTextureFunctionType",
   "x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType",
],
function (ShaderSource,
          Types,
          MultiTextureModeType,
          MultiTextureSourceType,
          MultiTextureFunctionType,
          TextureCoordinateGeneratorModeType)
{
"use strict";

   const Shader =
   {
      getShaderSource: function (browser, name, source, options)
      {
         const gl = browser .getContext ();

         source = ShaderSource .get (gl, source);

			const
				COMMENTS     = "\\s+|/\\*[\\s\\S]*?\\*/|//.*?\\n",
				LINE         = "#line\\s+.*?\\n",
				IF           = "#if\\s+.*?\\n",
				ELIF         = "#elif\\s+.*?\\n",
				IFDEF        = "#ifdef\\s+.*?\\n",
				IFNDEF       = "#ifndef\\s+.*?\\n",
				ELSE         = "#else.*?\\n",
				ENDIF        = "#endif.*?\\n",
				DEFINE       = "#define\\s+(?:[^\\n\\\\]|\\\\[^\\r\\n]|\\\\\\r?\\n)*\\n",
				UNDEF        = "#undef\\s+.*?\\n",
				PRAGMA       = "#pragma\\s+.*?\\n",
				PREPROCESSOR =  LINE + "|" + IF + "|" + ELIF + "|" + IFDEF + "|" + IFNDEF + "|" + ELSE + "|" + ENDIF + "|" + DEFINE + "|" + UNDEF + "|" + PRAGMA,
				VERSION      = "#version\\s+.*?\\n",
				EXTENSION    = "#extension\\s+.*?\\n",
				ANY          = "[\\s\\S]*";

			const
				GLSL  = new RegExp ("^((?:" + COMMENTS + "|" + PREPROCESSOR + ")*(?:" + VERSION + ")?(?:" + COMMENTS + "|" + PREPROCESSOR + "|" + EXTENSION + ")*)(" + ANY + ")$"),
				match = source .match (GLSL);

         // const
         //    COMMENTS = "\\s+|/\\*[^]*?\\*/|//.*?\\n",
         //    VERSION  = "#version\\s+.*?\\n",
         //    ANY      = "[^]*";

         // const
         //    GLSL  = new RegExp ("^((?:" + COMMENTS + ")?(?:" + VERSION + ")?)(" + ANY + ")$"),
         //    match = source .match (GLSL);

         if (! match)
            return source;

         let constants = "";

         constants += "#define X_ITE\n";

         if (browser .getRenderingProperty ("LogarithmicDepthBuffer"))
            constants += "#define X3D_LOGARITHMIC_DEPTH_BUFFER\n";

         if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
            constants += "#define X3D_DEPTH_TEXTURE\n";

         if (browser .getMultiTexturing ())
            constants += "#define X3D_MULTI_TEXTURING\n";

         if (browser .getProjectiveTextureMapping ())
            constants += "#define X3D_PROJECTIVE_TEXTURE_MAPPING\n";

         for (const option of options)
            constants += "#define " + option + "\n";

         let definitions = "";

         definitions += "#define x3d_None 0\n";

         definitions += "#define x3d_Points      0\n";
         definitions += "#define x3d_Lines       1\n";
         definitions += "#define x3d_Geometry2D  2\n";
         definitions += "#define x3d_Geometry3D  3\n";

         definitions += "#define x3d_MaxClipPlanes  " + browser .getMaxClipPlanes () + "\n";

         definitions += "#define x3d_LinearFog        1\n";
         definitions += "#define x3d_ExponentialFog   2\n";
         definitions += "#define x3d_Exponential2Fog  3\n";

         definitions += "#define x3d_MaxLights         " + browser .getMaxLights () + "\n";
         definitions += "#define x3d_DirectionalLight  1\n";
         definitions += "#define x3d_PointLight        2\n";
         definitions += "#define x3d_SpotLight         3\n";

         definitions += "#define x3d_MaxTextures      " + browser .getMaxTextures () + "\n";
         definitions += "#define x3d_TextureType2D    2\n";
         definitions += "#define x3d_TextureType3D    3\n";
         definitions += "#define x3d_TextureTypeCube  4\n";

         definitions += "#define x3d_Replace                   " + MultiTextureModeType .REPLACE                   + "\n";
         definitions += "#define x3d_Modulate                  " + MultiTextureModeType .MODULATE                  + "\n";
         definitions += "#define x3d_Modulate2X                " + MultiTextureModeType .MODULATE2X                + "\n";
         definitions += "#define x3d_Modulate4X                " + MultiTextureModeType .MODULATE4X                + "\n";
         definitions += "#define x3d_Add                       " + MultiTextureModeType .ADD                       + "\n";
         definitions += "#define x3d_AddSigned                 " + MultiTextureModeType .ADDSIGNED                 + "\n";
         definitions += "#define x3d_AddSigned2X               " + MultiTextureModeType .ADDSIGNED2X               + "\n";
         definitions += "#define x3d_AddSmooth                 " + MultiTextureModeType .ADDSMOOTH                 + "\n";
         definitions += "#define x3d_Subtract                  " + MultiTextureModeType .SUBTRACT                  + "\n";
         definitions += "#define x3d_BlendDiffuseAlpha         " + MultiTextureModeType .BLENDDIFFUSEALPHA         + "\n";
         definitions += "#define x3d_BlendTextureAlpha         " + MultiTextureModeType .BLENDTEXTUREALPHA         + "\n";
         definitions += "#define x3d_BlendFactorAlpha          " + MultiTextureModeType .BLENDFACTORALPHA          + "\n";
         definitions += "#define x3d_BlendCurrentAlpha         " + MultiTextureModeType .BLENDCURRENTALPHA         + "\n";
         definitions += "#define x3d_ModulateAlphaAddColor     " + MultiTextureModeType .MODULATEALPHA_ADDCOLOR    + "\n";
         definitions += "#define x3d_ModulateInvAlphaAddColor  " + MultiTextureModeType .MODULATEINVALPHA_ADDCOLOR + "\n";
         definitions += "#define x3d_ModulateInvColorAddAlpha  " + MultiTextureModeType .MODULATEINVCOLOR_ADDALPHA + "\n";
         definitions += "#define x3d_DotProduct3               " + MultiTextureModeType .DOTPRODUCT3               + "\n";
         definitions += "#define x3d_SelectArg1                " + MultiTextureModeType .SELECTARG1                + "\n";
         definitions += "#define x3d_SelectArg2                " + MultiTextureModeType .SELECTARG2                + "\n";
         definitions += "#define x3d_Off                       " + MultiTextureModeType .OFF                       + "\n";

         definitions += "#define x3d_Diffuse  " + MultiTextureSourceType .DIFFUSE  + "\n";
         definitions += "#define x3d_Specular " + MultiTextureSourceType .SPECULAR + "\n";
         definitions += "#define x3d_Factor   " + MultiTextureSourceType .FACTOR   + "\n";

         definitions += "#define x3d_Complement     " + MultiTextureFunctionType .COMPLEMENT     + "\n";
         definitions += "#define x3d_AlphaReplicate " + MultiTextureFunctionType .ALPHAREPLICATE + "\n";

         definitions += "#define x3d_Sphere                      " + TextureCoordinateGeneratorModeType .SPHERE                      + "\n";
         definitions += "#define x3d_CameraSpaceNormal           " + TextureCoordinateGeneratorModeType .CAMERASPACENORMAL           + "\n";
         definitions += "#define x3d_CameraSpacePosition         " + TextureCoordinateGeneratorModeType .CAMERASPACEPOSITION         + "\n";
         definitions += "#define x3d_CameraSpaceReflectionVector " + TextureCoordinateGeneratorModeType .CAMERASPACEREFLECTIONVECTOR + "\n";
         definitions += "#define x3d_SphereLocal                 " + TextureCoordinateGeneratorModeType .SPHERE_LOCAL                + "\n";
         definitions += "#define x3d_Coord                       " + TextureCoordinateGeneratorModeType .COORD                       + "\n";
         definitions += "#define x3d_CoordEye                    " + TextureCoordinateGeneratorModeType .COORD_EYE                   + "\n";
         definitions += "#define x3d_Noise                       " + TextureCoordinateGeneratorModeType .NOISE                       + "\n";
         definitions += "#define x3d_NoiseEye                    " + TextureCoordinateGeneratorModeType .NOISE_EYE                   + "\n";
         definitions += "#define x3d_SphereReflect               " + TextureCoordinateGeneratorModeType .SPHERE_REFLECT              + "\n";
         definitions += "#define x3d_SphereReflectLocal          " + TextureCoordinateGeneratorModeType .SPHERE_REFLECT_LOCAL        + "\n";

         // Legacy
         definitions += "#define x3d_GeometryPoints  0\n";
         definitions += "#define x3d_GeometryLines   1\n";
         definitions += "#define x3d_NoneClipPlane   vec4 (88.0, 51.0, 68.0, 33.0)\n"; // ASCII »X3D!«
         definitions += "#define x3d_NoneFog         0\n";
         definitions += "#define x3d_NoneLight       0\n";
         definitions += "#define x3d_NoneTexture     0\n";

         depreciatedWarning (source, "x3d_GeometryPoints", "x3d_Points");
         depreciatedWarning (source, "x3d_GeometryLines",  "x3d_Lines");
         depreciatedWarning (source, "x3d_NoneClipPlane",  "x3d_NumClipPlanes");
         depreciatedWarning (source, "x3d_NoneFog",        "x3d_None");
         depreciatedWarning (source, "x3d_NoneLight",      "x3d_NumLights");
         depreciatedWarning (source, "x3d_NoneTexture",    "x3d_NumTextures");

         // Adjust precision of struct types;

         const
            matchFloat       = source .match (/\s*precision\s+(lowp|mediump|highp)\s+float\s*;/),
            matchInt         = source .match (/\s*precision\s+(lowp|mediump|highp)\s+int\s*;/),
            precisionFloat   = matchFloat ? matchFloat [1] : "mediump",
            precisionInt     = matchInt   ? matchInt   [1] : "mediump";

         const types = Types
            .replace (/mediump\s+(float|vec2|vec3|mat3|mat4)/g, precisionFloat + " $1")
            .replace (/mediump\s+(int)/g,                       precisionInt   + " $1");

         const lines = (match [1] .match (/\n/g) || [ ]) .length + 1;

         return match [1] + constants + definitions + types + "#line " + lines + "\n" + match [2];
      },
   };

   function depreciatedWarning (source, depreciated, current)
   {
      if (source .indexOf (depreciated) === -1)
         return;

      console .warn ("Use of '" + depreciated + "' is depreciated, use '" + current + "' instead. See https://create3000.github.io/x_ite/Custom-Shaders.html.");
   }

   return Shader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/XMLParser',[
   "jquery",
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Core/X3DPrototypeInstance",
   "x_ite/Fields",
   "x_ite/Parser/X3DParser",
   "x_ite/Parser/VRMLParser",
   "x_ite/Parser/HTMLSupport",
   "x_ite/Prototype/X3DExternProtoDeclaration",
   "x_ite/Prototype/X3DProtoDeclaration",
   "x_ite/Base/X3DConstants",
],
function ($,
          X3DField,
          X3DBaseNode,
          X3DPrototypeInstance,
          Fields,
          X3DParser,
          VRMLParser,
          HTMLSupport,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          X3DConstants)
{
"use strict";

   const _dom = Symbol .for ("X_ITE.dom");

   const AccessType =
   {
      initializeOnly: X3DConstants .initializeOnly,
      inputOnly:      X3DConstants .inputOnly,
      outputOnly:     X3DConstants .outputOnly,
      inputOutput:    X3DConstants .inputOutput,
   };

   function XMLParser (scene)
   {
      X3DParser .call (this, scene);

      this .protoDeclarations = [ ];
      this .parents           = [ ];
      this .parser            = new VRMLParser (scene);
      this .url               = new Fields .MFString ();

      try
      {
         this .setUnits (this .getScene () .getMetaData ("generator"));
         this .parser .setUnits (this .getUnits ());
      }
      catch (error)
      { }
   }

   XMLParser .prototype = Object .assign (Object .create (X3DParser .prototype),
   {
      constructor: XMLParser,
      isValid: function ()
      {
         return (this .input instanceof XMLDocument) || (this .input instanceof HTMLElement) || (this .input === null);
      },
      getInput: function ()
      {
         return this .input;
      },
      setInput (xmlElement)
      {
         try
         {
            if (typeof xmlElement === "string")
               xmlElement = $.parseXML (xmlElement);

            this .input = xmlElement;
         }
         catch (error)
         {
            this .input = undefined;
         }
      },
      parseIntoScene: function (success, error)
      {
         this .scene [_dom] = this .input;
         this .success      = success;
         this .error        = error;

         this .getScene () .setEncoding ("XML");
         this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));

         this .xmlElement (this .input);
      },
      parseIntoNode: function (node, xmlElement)
      {
         this .pushExecutionContext (node .getExecutionContext ());
         this .pushParent (node);

         this .childElement (xmlElement);

         this .popParent ();
         this .popExecutionContext ();
      },
      xmlElement: function (xmlElement)
      {
         if (xmlElement === null)
         {
            if (this .success)
               return this .success (this .getScene ());
         }

         switch (xmlElement .nodeName)
         {
            case "#document":
            {
               var X3D = $(xmlElement) .children ("X3D");

               if (X3D .length)
               {
                  for (var i = 0; i < X3D .length; ++ i)
                     this .x3dElement (X3D [i]);
               }
               else
               {
                  if (this .success)
                  {
                     require (this .getProviderUrls (),
                     function ()
                     {
                        try
                        {
                           this .childrenElements (xmlElement);
                           this .success (this .getScene ());
                        }
                        catch (error)
                        {
                           if (this .error)
                              this .error (error);
                        }
                     }
                     .bind (this),
                     function (error)
                     {
                        if (this .error)
                           this .error (error);
                     }
                     .bind (this));
                  }
                  else
                  {
                     this .childrenElements (xmlElement);
                  }
               }

               break;
            }
            case "X3D":
            {
               this .x3dElement (xmlElement);
               break;
            }
            case "Scene":
            case "SCENE":
            {
               if (this .success)
               {
                  require (this .getProviderUrls (),
                  function ()
                  {
                     try
                     {
                        this .sceneElement (xmlElement);
                        this .success (this .getScene ());
                     }
                     catch (error)
                     {
                        if (this .error)
                           this .error (error);
                     }
                  }
                  .bind (this),
                  function (error)
                  {
                     if (this .error)
                        this .error (error);
                  }
                  .bind (this));
               }
               else
               {
                  this .sceneElement (xmlElement);
               }

               break;
            }
            default:
            {
               if (this .success)
               {
                  require (this .getProviderUrls (),
                  function ()
                  {
                     try
                     {
                        this .childrenElements (xmlElement);
                        this .success (this .getScene ());
                     }
                     catch (error)
                     {
                        if (this .error)
                           this .error (error);
                     }
                  }
                  .bind (this),
                  function (error)
                  {
                     if (this .error)
                        this .error (error);
                  }
                  .bind (this));
               }
               else
               {
                  this .childrenElements (xmlElement);
               }

               break;
            }
         }
      },
      x3dElement: function (xmlElement)
      {
         try
         {
            // Profile

            var
               profileNameId = xmlElement .getAttribute ("profile"),
               profile       = this .getBrowser () .getProfile (profileNameId || "Full");

            this .getScene () .setProfile (profile);
         }
         catch (error)
         {
            console .error (error);
         }

         // Specification version

         var specificationVersion = xmlElement .getAttribute ("version");

         if (specificationVersion)
            this .getScene () .setSpecificationVersion (specificationVersion);

         // Process child nodes

         var childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
            this .x3dElementChildHead (childNodes [i])

         if (this .success)
         {
            require (this .getProviderUrls (),
            function ()
            {
               try
               {
                  for (var i = 0; i < childNodes .length; ++ i)
                     this .x3dElementChildScene (childNodes [i])

                  this .success (this .getScene ());
               }
               catch (error)
               {
                  if (this .error)
                     this .error (error);
               }
            }
            .bind (this),
            function (error)
            {
               if (this .error)
                  this .error (error);
            }
            .bind (this));
         }
         else
         {
            for (var i = 0; i < childNodes .length; ++ i)
               this .x3dElementChildScene (childNodes [i])
         }
      },
      x3dElementChildHead: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "head":
            case "HEAD":
               this .headElement (xmlElement);
               return;
         }
      },
      x3dElementChildScene: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "Scene":
            case "SCENE":
               this .sceneElement (xmlElement);
               return;
         }
      },
      headElement: function (xmlElement)
      {
         var childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
            this .headElementChild (childNodes [i]);

         try
         {
            this .setUnits (this .getScene () .getMetaData ("generator"));
            this .parser .setUnits (this .getUnits ());
         }
         catch (error)
         { }
      },
      headElementChild: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "component":
            case "COMPONENT":
               this .componentElement (xmlElement);
               return;
            case "unit":
            case "UNIT":
               this .unitElement (xmlElement);
               return;
            case "meta":
            case "META":
               this .metaElement (xmlElement);
               return;
         }
      },
      componentElement: function (xmlElement)
      {
         try
         {
            var
               componentNameIdCharacters = xmlElement .getAttribute ("name"),
               componentSupportLevel = parseInt (xmlElement .getAttribute ("level"));

            if (componentNameIdCharacters === null)
               return console .warn ("XML Parser Error: Bad component statement: Expected name attribute.");

            if (componentSupportLevel === null)
               return console .warn ("XML Parser Error: Bad component statement: Expected level attribute.");

            var component = this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);

            this .getScene () .addComponent (component);
         }
         catch (error)
         {
            console .log (error .message);
         }
      },
      unitElement: function (xmlElement)
      {
         var
            category         = xmlElement .getAttribute ("category"),
            name             = xmlElement .getAttribute ("name"),
            conversionFactor = xmlElement .getAttribute ("conversionFactor"); //works for html5 as well

         if (category === null)
            return console .warn ("XML Parser Error: Bad unit statement: Expected category attribute.");

         if (name === null)
            return console .warn ("XML Parser Error: Bad unit statement: Expected name attribute.");

         if (conversionFactor === null)
            return console .warn ("XML Parser Error: Bad unit statement: Expected conversionFactor attribute.");

         this .getScene () .updateUnit (category, name, parseFloat (conversionFactor));
      },
      metaElement: function (xmlElement)
      {
         var
            metakey   = xmlElement .getAttribute ("name"),
            metavalue = xmlElement .getAttribute ("content");

         if (metakey === null)
            return console .warn ("XML Parser Error: Bad meta statement: Expected name attribute.");

         if (metavalue === null)
            return console .warn ("XML Parser Error: Bad meta statement: Expected content attribute.");

         this .getScene () .setMetaData (metakey, metavalue);
      },
      sceneElement: function (xmlElement)
      {
         this .childrenElements (xmlElement);
      },
      childrenElements: function (xmlElement)
      {
         var childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
            this .childElement (childNodes [i]);
      },
      childElement: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "#comment":
            case "#text":
               return;

            case "#cdata-section":
               this .cdataNode (xmlElement);
               return;

            case "ExternProtoDeclare":
            case "EXTERNPROTODECLARE":
               this .externProtoDeclareElement (xmlElement);
               return;

            case "ProtoDeclare":
            case "PROTODECLARE":
               this .protoDeclareElement (xmlElement);
               return;

            case "IS":
               this .isElement (xmlElement);
               return;

            case "ProtoInstance":
            case "PROTOINSTANCE":
               this .protoInstanceElement (xmlElement);
               return;

            case "fieldValue":
            case "FIELDVALUE":
               this .fieldValueElement (xmlElement);
               return;

            case "field":
            case "FIELD":
               this .fieldElement (xmlElement);
               return;

            case "ROUTE":
               this .routeElement (xmlElement);
               return;

            case "IMPORT":
               this .importElement (xmlElement);
               return;

            case "EXPORT":
               this .exportElement (xmlElement);
               return;

            default:
               this .nodeElement (xmlElement);
               return;
         }
      },
      externProtoDeclareElement: function (xmlElement)
      {
         var name = xmlElement .getAttribute ("name");

         if (this .id (name))
         {
            var url = xmlElement .getAttribute ("url");

            if (url === null)
               return console .warn ("XML Parser Error: Bad ExternProtoDeclare statement: Expected url attribute.");

            this .parser .setInput (url);
            VRMLParser .prototype .sfstringValues .call (this .parser, this .url);

            var externproto = new X3DExternProtoDeclaration (this .getExecutionContext (), this .url);

            this .pushParent (externproto);
            this .protoInterfaceElement (xmlElement); // parse fields
            this .popParent ();

            externproto .setup ();

            try
            {
               const existingExternProto = this .getExecutionContext () .getExternProtoDeclaration (name);

               this .getExecutionContext () .updateExternProtoDeclaration (this .getExecutionContext () .getUniqueExternProtoName (name), existingExternProto);
            }
            catch (error)
            { }

            this .getExecutionContext () .updateExternProtoDeclaration (name, externproto);
         }
      },
      protoDeclareElement: function (xmlElement)
      {
         var name = xmlElement .getAttribute ("name");

         if (this .id (name))
         {
            var
               proto      = new X3DProtoDeclaration (this .getExecutionContext ()),
               childNodes = xmlElement .childNodes;

            for (var i = 0; i < childNodes .length; ++ i)
            {
               var child = childNodes [i];

               switch (child .nodeName)
               {
                  case "ProtoInterface":
                  case "PROTOINTERFACE":
                  {
                     this .pushParent (proto);
                     this .protoInterfaceElement (child);
                     this .popParent ();
                     break;
                  }
                  default:
                     continue;
               }

               break;
            }

            for (var i = 0; i < childNodes .length; ++ i)
            {
               var child = childNodes [i];

               switch (child .nodeName)
               {
                  case "ProtoBody":
                  case "PROTOBODY":
                  {
                     this .pushPrototype (proto);
                     this .pushExecutionContext (proto .getBody ());
                     this .pushParent (proto);
                     this .protoBodyElement (child);
                     this .popParent ();
                     this .popExecutionContext ();
                     this .popPrototype ();
                     break;
                  }
                  default:
                     continue;
               }

               break;
            }

            proto .setup ();

            try
            {
               const existingProto = this .getExecutionContext () .getProtoDeclaration (name);

               this .getExecutionContext () .updateProtoDeclaration (this .getExecutionContext () .getUniqueProtoName (name), existingProto);
            }
            catch (error)
            { }

            this .getExecutionContext () .updateProtoDeclaration (name, proto);
         }
      },
      protoInterfaceElement: function (xmlElement)
      {
         var childNodes = xmlElement .childNodes;

         for (var i = 0; i < childNodes .length; ++ i)
            this .protoInterfaceElementChild (childNodes [i]);
      },
      protoInterfaceElementChild: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "field": // User-defined field
            case "FIELD": // User-defined field
               this .fieldElement (xmlElement);
               return;
         }
      },
      fieldElement: function (xmlElement)
      {
         try
         {
            if (this .getParents () .length === 0)
               return;

            var node = this .getParent ();

            if (! (node instanceof X3DBaseNode))
               return;

            if (! node .canUserDefinedFields ())
               return;

            var accessType = AccessType [xmlElement .getAttribute ("accessType")];

            if (accessType === undefined)
               accessType = X3DConstants .initializeOnly;

            var type = Fields [xmlElement .getAttribute ("type")];

            if (type === undefined)
               return;

            var name = xmlElement .getAttribute ("name");

            if (! this .id (name))
               return;

            var field = new type ();

            if (accessType & X3DConstants .initializeOnly)
            {
               this .fieldValue (field, xmlElement .getAttribute ("value"));

               this .pushParent (field);
               this .childrenElements (xmlElement);
               this .popParent ();
            }

            node .addUserDefinedField (accessType, name, field);
         }
         catch (error)
         {
            //console .error (error);
         }
      },
      protoBodyElement: function (xmlElement)
      {
         this .childrenElements (xmlElement);
      },
      isElement: function (xmlElement)
      {
         if (this .isInsideProtoDefinition ())
         {
            var childNodes = xmlElement .childNodes;

            for (var i = 0; i < childNodes .length; ++ i)
               this .isElementChild (childNodes [i]);
         }
      },
      isElementChild: function (xmlElement)
      {
         switch (xmlElement .nodeName)
         {
            case "connect":
            case "CONNECT":
               this .connectElement (xmlElement);
               return;
         }
      },
      connectElement: function (xmlElement)
      {
         var
            nodeFieldName  = xmlElement .getAttribute ("nodeField"),
            protoFieldName = xmlElement .getAttribute ("protoField");

         if (nodeFieldName === null)
            return console .warn ("XML Parser Error: Bad connect statement: Expected nodeField attribute.");

         if (protoFieldName === null)
            return console .warn ("XML Parser Error: Bad connect statement: Expected protoField attribute.");

         try
         {
            if (this .getParents () .length === 0)
               return;

            var
               node  = this .getParent (),
               proto = this .getPrototype ();

            if (! (node instanceof X3DBaseNode))
               return;

            var
               nodeField  = node .getField (nodeFieldName),
               protoField = proto .getField (protoFieldName);

            if (nodeField .getType () === protoField .getType ())
            {
               if (protoField .isReference (nodeField .getAccessType ()))
                  nodeField .addReference (protoField);
               else
                  throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + proto .getName () + " are incompatible as an IS mapping.");
            }
            else
               throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + this .proto .getName () + " have different types.");
         }
         catch (error)
         {
            console .warn ("XML Parser Error: Couldn't create IS reference: " + error .message);
         }
      },
      protoInstanceElement: function (xmlElement)
      {
         try
         {
            if (this .useAttribute (xmlElement))
               return;

            var name = xmlElement .getAttribute ("name");

            if (this .id (name))
            {
               var node = this .getExecutionContext () .createProto (name, false);

               if (! node)
                  throw new Error ("Unknown proto or externproto type '" + name + "'.");

               //AP: attach node to DOM xmlElement for access from DOM.
               xmlElement .x3d = node;

               this .defAttribute (xmlElement, node);
               this .addNode (xmlElement, node);
               this .pushParent (node);
               this .childrenElements (xmlElement);

               if (! this .isInsideProtoDefinition ())
                  node .setup ();

               this .popParent ();
            }
         }
         catch (error)
         {
            console .warn ("XML Parser Error: ", error .message);
            //console .error (error);
         }
      },
      fieldValueElement: function (xmlElement)
      {
         try
         {
            if (this .getParents () .length === 0)
               return;

            var
               node = this .getParent (),
               name = xmlElement .getAttribute ("name");

            if (! (node instanceof X3DPrototypeInstance))
               return;

            if (! this .id (name))
               return;

            var
               field      = node .getField (name),
               accessType = field .getAccessType ();

            if (accessType & X3DConstants .initializeOnly)
            {
               if (field .getType () === X3DConstants .MFNode)
               {
                  field .length = 0
               }

               this .fieldValue (field, xmlElement .getAttribute ("value"));

               this .pushParent (field);
               this .childrenElements (xmlElement);
               this .popParent ();
            }
         }
         catch (error)
         {
            console .warn ("XML Parser Error: Couldn't assign field value: " + error .message);
         }
      },
      nodeElement: function (xmlElement)
      {
         try
         {
            if (this .useAttribute (xmlElement))
               return;

            var node = this .getExecutionContext () .createNode (this .nodeNameToCamelCase (xmlElement .nodeName), false);

            if (! node)
               throw new Error ("Unknown node type '" + xmlElement .nodeName + "', you probably have insufficient component/profile statements.");

            //AP: attach node to DOM xmlElement for access from DOM.
            xmlElement .x3d = node;

            this .defAttribute (xmlElement, node);
            this .addNode (xmlElement, node);
            this .pushParent (node);
            this .nodeAttributes (xmlElement, node);
            this .childrenElements (xmlElement);

            if (! this .isInsideProtoDefinition ())
               node .setup ();

            this .popParent ();
         }
         catch (error)
         {
            // NULL

            if (xmlElement .nodeName == "NULL")
            {
               this .addNode (xmlElement, null);
               return;
            }

            console .error (error);

            console .error ("XML Parser Error: " + error .message);
         }
      },
      routeElement: function (xmlElement)
      {
         try
         {
            var
               sourceNodeName      = xmlElement .getAttribute ("fromNode"),
               sourceField         = xmlElement .getAttribute ("fromField"),
               destinationNodeName = xmlElement .getAttribute ("toNode"),
               destinationField    = xmlElement .getAttribute ("toField");

            if (sourceNodeName === null)
               throw new Error ("Bad ROUTE statement: Expected fromNode attribute.");

            if (sourceField === null)
               throw new Error ("Bad ROUTE statement: Expected fromField attribute.");

            if (destinationNodeName === null)
               throw new Error ("Bad ROUTE statement: Expected toNode attribute.");

            if (destinationField === null)
               throw new Error ("Bad ROUTE statement: Expected toField attribute.");

            var
               executionContext = this .getExecutionContext (),
               sourceNode       = executionContext .getLocalNode (sourceNodeName),
               destinationNode  = executionContext .getLocalNode (destinationNodeName),
               route            = executionContext .addRoute (sourceNode, sourceField, destinationNode, destinationField);

            xmlElement .x3d = route;
         }
         catch (error)
         {
            console .error (error);
            console .warn ("XML Parser Error: " + error .message);
         }
      },
      importElement: function (xmlElement)
      {
         try
         {
            var
               inlineNodeName   = xmlElement .getAttribute ("inlineDEF"),
               exportedNodeName = xmlElement .getAttribute ("importedDEF") || xmlElement .getAttribute ("exportedDEF"),
               localNodeName    = xmlElement .getAttribute ("AS");

            if (inlineNodeName === null)
               throw new Error ("Bad IMPORT statement: Expected inlineDEF attribute.");

            if (exportedNodeName === null)
               throw new Error ("Bad IMPORT statement: Expected importedDEF attribute.");

            if (! localNodeName)
               localNodeName = exportedNodeName;

            var inlineNode = this .getExecutionContext () .getNamedNode (inlineNodeName);

            this .getExecutionContext () .updateImportedNode (inlineNode, exportedNodeName, localNodeName);
         }
         catch (error)
         {
            console .warn ("XML Parser Error: " + error .message);
         }
      },
      exportElement: function (xmlElement)
      {
         try
         {
            if (this .getScene () !== this .getExecutionContext ())
            {
               console .warn ("XML Parser Error: Export statement not allowed here.");
               return;
            }

            var
               localNodeName    = xmlElement .getAttribute ("localDEF"),
               exportedNodeName = xmlElement .getAttribute ("AS");

            if (localNodeName === null)
               throw new Error ("Bad EXPORT statement: Expected localDEF attribute.");

            if (! exportedNodeName)
               exportedNodeName = localNodeName;

            var localNode = this .getExecutionContext () .getLocalNode (localNodeName);

            this .getScene () .updateExportedNode (exportedNodeName, localNode);
         }
         catch (error)
         {
            console .warn ("XML Parser Error: " + error .message);
         }
      },
      cdataNode: function (xmlElement)
      {
         if (this .getParents () .length === 0)
            return;

         var node = this .getParent ();

         if (node instanceof X3DBaseNode)
         {
            var field = node .getSourceText ();

            if (field)
            {
               field .push (xmlElement .data);
            }
         }
      },
      useAttribute: function (xmlElement)
      {
         try
         {
            var name = xmlElement .getAttribute ("USE");

            if (this .id (name))
            {
               var node = this .getExecutionContext () .getNamedNode (name);

               this .addNode (xmlElement, node .getValue ());
               return true;
            }
         }
         catch (error)
         {
            console .warn ("Invalid USE name: " + error .message);
         }

         return false;
      },
      defAttribute: function (xmlElement, node)
      {
         try
         {
            var name = xmlElement .getAttribute ("DEF");

            if (name)
            {
               try
               {
                  var namedNode = this .getExecutionContext () .getNamedNode (name);

                  this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (name), namedNode);
               }
               catch (error)
               { }

               this .getExecutionContext () .updateNamedNode (name, node);
            }
         }
         catch (error)
         {
            console .warn ("Invalid DEF name: " + error .message);
         }
      },
      nodeAttributes: function (xmlElement, node)
      {
         var xmlAttributes = xmlElement .attributes;

         for (var i = 0; i < xmlAttributes .length; ++ i)
            this .nodeAttribute (xmlAttributes [i], node);
      },
      nodeAttribute: function (xmlAttribute, node)
      {
         try
         {
            var
               field      = node .getField (this .attributeToCamelCase (xmlAttribute .name)),
               accessType = field .getAccessType ();

            if (accessType & X3DConstants .initializeOnly)
               this .fieldValue (field, xmlAttribute .value);
         }
         catch (error)
         {
            //console .error (error);
         }
      },
      fieldValue: function (field, value)
      {
         if (value === null)
            return;

         this .parser .pushExecutionContext (this .getExecutionContext ());

         this .parser .setInput (value);
         this .fieldTypes [field .getType ()] .call (this .parser, field);

         this .parser .popExecutionContext ();
      },
      addNode: function (xmlElement, node)
      {
         if (this .parents .length === 0 || this .getParent () instanceof X3DProtoDeclaration)
         {
            this .getExecutionContext () .rootNodes .push (node);
            return;
         }

         var parent = this .getParent ();

         if (parent instanceof X3DField)
         {
            switch (parent .getType ())
            {
               case X3DConstants .SFNode:
                  parent .setValue (node);
                  return;

               case X3DConstants .MFNode:
                  parent .push (node);
                  return;
            }

            return;
         }

         // parent is a node.

         try
         {
            var containerField = xmlElement .getAttribute ("containerField");

            if (! containerField)
            {
               if (node)
                  containerField = node .getContainerField ();
               else
                  throw new Error ("NULL node must have a container field attribute.");
            }

            var field = parent .getField (containerField);

            switch (field .getType ())
            {
               case X3DConstants .SFNode:
                  field .setValue (node);
                  return;

               case X3DConstants .MFNode:
                  field .push (node);
                  return;
            }
         }
         catch (error)
         {
            //console .warn (error .message);
         }
      },
      getParents: function ()
      {
         return this .parents;
      },
      getParent: function ()
      {
         return this .parents .at (-1);
      },
      pushParent: function (parent)
      {
         return this .parents .push (parent);
      },
      popParent: function ()
      {
         this .parents .pop ();
      },
      id: function (string)
      {
         if (string === null)
            return false;

         if (string .length === 0)
            return false;

         return true;
      },
      nodeNameToCamelCase: function (nodeName)
      {
         // Function also needed by X_ITE DOM.
         return HTMLSupport .getNodeTypeName (nodeName);
      },
      attributeToCamelCase: function (name)
      {
         // Function also needed by X_ITE DOM.
         return HTMLSupport .getFieldName (name);
      },
   });

   XMLParser .prototype .fieldTypes = [ ];
   XMLParser .prototype .fieldTypes [X3DConstants .SFBool]      = VRMLParser .prototype .sfboolValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFColor]     = VRMLParser .prototype .sfcolorValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFColorRGBA] = VRMLParser .prototype .sfcolorrgbaValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFDouble]    = VRMLParser .prototype .sfdoubleValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFFloat]     = VRMLParser .prototype .sffloatValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFImage]     = VRMLParser .prototype .sfimageValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFInt32]     = VRMLParser .prototype .sfint32Value;
   XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3f]  = VRMLParser .prototype .sfmatrix3dValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3d]  = VRMLParser .prototype .sfmatrix3fValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4f]  = VRMLParser .prototype .sfmatrix4dValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4d]  = VRMLParser .prototype .sfmatrix4fValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFNode]      = function (field) { field .setValue (null); };
   XMLParser .prototype .fieldTypes [X3DConstants .SFRotation]  = VRMLParser .prototype .sfrotationValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFString]    = function (field) { field .setValue (Fields .SFString .unescape (this .input)); };
   XMLParser .prototype .fieldTypes [X3DConstants .SFTime]      = VRMLParser .prototype .sftimeValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec2d]     = VRMLParser .prototype .sfvec2dValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec2f]     = VRMLParser .prototype .sfvec2fValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec3d]     = VRMLParser .prototype .sfvec3dValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec3f]     = VRMLParser .prototype .sfvec3fValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec4d]     = VRMLParser .prototype .sfvec4dValue;
   XMLParser .prototype .fieldTypes [X3DConstants .SFVec4f]     = VRMLParser .prototype .sfvec4fValue;

   XMLParser .prototype .fieldTypes [X3DConstants .MFBool]      = VRMLParser .prototype .sfboolValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFColor]     = VRMLParser .prototype .sfcolorValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFColorRGBA] = VRMLParser .prototype .sfcolorrgbaValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFDouble]    = VRMLParser .prototype .sfdoubleValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFFloat]     = VRMLParser .prototype .sffloatValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFImage]     = VRMLParser .prototype .sfimageValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFInt32]     = VRMLParser .prototype .sfint32Values;
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3d]  = VRMLParser .prototype .sfmatrix3dValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3f]  = VRMLParser .prototype .sfmatrix3fValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4d]  = VRMLParser .prototype .sfmatrix4dValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4f]  = VRMLParser .prototype .sfmatrix4fValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFNode]      = function (field) { field .length = 0; };
   XMLParser .prototype .fieldTypes [X3DConstants .MFRotation]  = VRMLParser .prototype .sfrotationValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFString]    = VRMLParser .prototype .sfstringValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFTime]      = VRMLParser .prototype .sftimeValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec2d]     = VRMLParser .prototype .sfvec2dValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec2f]     = VRMLParser .prototype .sfvec2fValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec3d]     = VRMLParser .prototype .sfvec3dValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec3f]     = VRMLParser .prototype .sfvec3fValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec4d]     = VRMLParser .prototype .sfvec4dValues;
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec4f]     = VRMLParser .prototype .sfvec4fValues;

   /*
    * Lazy parse functions.
    */

   var
      infs            = /\binf\b/g,
      nans            = /\bnan\b/g,
      trimWhitespaces = /^[\x20\n,\t\r"]+|[\x20\n,\t\r"]+$/g,
      whitespaces     = /[\x20\n,\t\r"]+/,
      strings         = new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'g');

   function prepareBools (string)
   {
      return string .replace (trimWhitespaces, "") .split (whitespaces);
   }

   function prepareFloats (string)
   {
      return (string
         .replace (infs, "Infinity")
         .replace (nans, "NaN")
         .replace (trimWhitespaces, "")
         .split (whitespaces));
   }

   function prepareInts (string)
   {
      return string .replace (trimWhitespaces, "") .split (whitespaces);
   }

   function prepareStrings (string)
   {
      var
         match = null,
         array = [ ];

      while (match = strings .exec (string))
         array .push (match [1]);

      return array .map (Fields .SFString .unescape);
   }

   // Unitless fields.

   XMLParser .prototype .fieldTypes [X3DConstants .MFColor] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFColorRGBA] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3d] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3f] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4d] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4f] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec4d] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec4f] = function (field)
   {
      field .setValue (prepareFloats (this .getInput ()) .map (function (value)
      {
         return parseFloat (value);
      }));
   };

   XMLParser .prototype .fieldTypes [X3DConstants .MFBool] = function (field)
   {
      field .setValue (prepareBools (this .getInput ()) .map (function (value)
      {
         if (value === "true" || value === "TRUE")
            return true;

         return false;
      }));
   };

   XMLParser .prototype .fieldTypes [X3DConstants .MFInt32] = function (field)
   {
      field .setValue (prepareInts (this .getInput ()) .map (function (value)
      {
         return parseInt (value);
      }));
   };

   // Unit fields.

   XMLParser .prototype .fieldTypes [X3DConstants .MFDouble] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFFloat] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec2d] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec2f] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec3d] =
   XMLParser .prototype .fieldTypes [X3DConstants .MFVec3f] = function (field)
   {
      var category = field .getUnit ();

      field .setValue (prepareFloats (this .getInput ()) .map (function (value)
      {
         return this .fromUnit (category, parseFloat (value));
      },
      this));
   };

   XMLParser .prototype .fieldTypes [X3DConstants .MFString] = function (field)
   {
      field .setValue (prepareStrings (this .getInput ()));
   };

   return XMLParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 * X3DJSONLD Copyright John Carlson, USA 2016-2017
 * https://coderextreme.net/X3DJSONLD/
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the Cobweb Project.
 *
 * Cobweb is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * Cobweb is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with Cobweb.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/JSONParser',[
   "x_ite/Parser/XMLParser",
   "x_ite/Parser/X3DParser",
],
function (XMLParser,
          X3DParser)
{
"use strict";

   function JSONParser (scene)
   {
      X3DParser .call (this, scene);

      this .x3djsonNS = "http://www.web3d.org/specifications/x3d-namespace";
   }

   JSONParser .prototype = Object .assign (Object .create (X3DParser .prototype),
   {
      constructor: JSONParser,
      isValid: function ()
      {
         return this .input instanceof Object;
      },
      getInput: function ()
      {
         return this .input;
      },
      setInput: function (json)
      {
         try
         {
            if (typeof json === "string")
               json = JSON .parse (json)

            this .input = json;
         }
         catch (error)
         {
            this .input = undefined;
         }
      },
      parseIntoScene: function (success, error)
      {
         /**
          * Load X3D JSON into an element.
          * json - the JavaScript object to convert to DOM.
          */

         const child = this .createElement ("X3D");

         this .convertToDOM (this .input, "", child);

         // Call the DOM parser.

         const parser = new XMLParser (this .getScene ());

         parser .setInput (child);
         parser .parseIntoScene (success, error);

         return child;
      },
      elementSetAttribute: function (element, key, value)
      {
         /**
          * Yet another way to set an attribute on an element.  does not allow you to
          * set JSON schema or encoding.
          */

         switch (key)
         {
            case "SON schema":
            {
               // JSON Schema
               break;
            }
            case "ncoding":
            {
               // encoding, UTF-8, UTF-16 or UTF-32
               break;
            }
            default:
            {
               if (typeof element .setAttribute === "function")
                  element .setAttribute (key, value);

               break;
            }
         }
      },
      convertChildren: function (parentkey, object, element)
      {
         /**
          * converts children of object to DOM.
          */

         for (const key in object)
         {
            if (typeof object [key] === "object")
            {
               if (isNaN (parseInt (key)))
                  this .convertObject (key, object, element, parentkey .substr (1));

               else
                  this .convertToDOM (object[ key], key, element, parentkey .substr (1));
            }
         }
      },
      createElement: function (key, containerField)
      {
         /**
          * a method to create and element with tagnam key to DOM in a namespace.  If
          * containerField is set, then the containerField is set in the elemetn.
          */

         if (typeof this .x3djsonNS === "undefined")
         {
            var child = document .createElement (key);
         }
         else
         {
            var child = document .createElementNS (this .x3djsonNS, key);

            if (child === null || typeof child === "undefined")
            {
               console .error ("Trouble creating element for", key);

               child = document .createElement(key);
            }
         }

         if (typeof containerField !== "undefined")
            this .elementSetAttribute (child, "containerField", containerField);

         return child;
      },
      createCDATA: function (document, element, str)
      {
         /**
          * a way to create a CDATA function or script in HTML, by using a DOM parser.
          */

         let y = str .trim ()
            .replace (/\\"/g, "\\\"")
            .replace (/&lt;/g, "<")
            .replace (/&gt;/g, ">")
            .replace (/&amp;/g, "&");

         do
         {
            str = y;
            y   = str .replace (/'([^'\r\n]*)\n([^']*)'/g, "'$1\\n$2'");

            if (str !== y)
               console .log ("CDATA Replacing", str, "with", y);
         }
         while (y !== str);

         const
            domParser = new DOMParser(),
            cdataStr  = "<script> <![CDATA[ " + y + " ]]> </script>", // has to be wrapped into an element
            scriptDoc = domParser .parseFromString (cdataStr, "application/xml"),
            cdata     = scriptDoc .children [0] .childNodes [1]; // space after script is childNode[0]

         element .appendChild (cdata);
      },
      convertObject: function (key, object, element, containerField)
      {
         /**
          * convert the object at object[key] to DOM.
          */

         if (object !== null && typeof object [key] === "object")
         {
            if (key .substr (0, 1) === "@")
            {
               this .convertToDOM (object [key], key, element);
            }
            else if (key .substr (0, 1) === "-")
            {
               this .convertChildren (key, object [key], element);
            }
            else if (key === "#comment")
            {
               for (const c in object [key])
               {
                  const child = document .createComment (this .commentStringToXML (object [key] [c]));

                  element .appendChild (child);
               }
            }
            else if (key === "#sourceCode" || key === "@sourceCode" || key === "#sourceText")
            {
               this .createCDATA (document, element, object [key] .join ("\r\n") + "\r\n");
            }
            else
            {
               if (key === "connect" || key === "fieldValue" || key === "field" || key === "meta" || key === "component")
               {
                  for (const childkey in object [key])
                  {
                     // for each field
                     if (typeof object [key] [childkey] === "object")
                     {
                        const child = this .createElement (key, containerField);

                        this .convertToDOM (object [key] [childkey], childkey, child);

                        element .appendChild (child);
                        element .appendChild (document .createTextNode ("\n"));
                     }
                  }
               }
               else
               {
                  const child = this .createElement (key, containerField);

                  this .convertToDOM (object [key], key, child);

                  element .appendChild (child);
                  element .appendChild (document .createTextNode ("\n"));
               }
            }
         }
      },
      commentStringToXML: function (str)
      {
         /**
          * convert a comment string in JavaScript to XML.  Pass the string
          */

         let y = str;

         str = str .replace (/\\\\/g, "\\");

         if (y !== str)
            console .log ("X3DJSONLD <!-> replacing", y, "with", str);

         return str;
      },
      SFStringToXML: function (str)
      {
         /**
          * convert an SFString to XML.
          */

         const y = str;

         /*
         str = (""+str).replace(/\\\\/g, "\\\\");
         str = str.replace(/\\\\\\\\/g, "\\\\");
         str = str.replace(/(\\+)"/g, "\\"");
         */

         str = str .replace (/\\/g, "\\\\");
         str = str .replace (/"/g, "\\\"");

         if (y !== str)
            console .log ("X3DJSONLD [] replacing", y, "with", str);

         return str;
      },
      JSONStringToXML: function (str)
      {
         /**
          * convert a JSON String to XML.
          */

         const y = str;

         str = str .replace (/\\/g, "\\\\");
         str = str .replace (/\n/g, "\\n");

         if (y !== str)
            console .log ("X3DJSONLD replacing", y, "with", str);

         return str;
      },
      convertToDOM: function(object, parentkey, element, containerField)
      {
         /**
          * main routine for converting a JavaScript object to DOM.
          * object is the object to convert.
          * parentkey is the key of the object in the parent.
          * element is the parent element.
          * containerField is a possible containerField.
          */

         let
            isArray        = false,
            localArray     = [ ],
            arrayOfStrings = false;

         for (const key in object)
         {
            isArray = !isNaN (parseInt (key));

            if (isArray)
            {
               switch (typeof object [key])
               {
                  case "number":
                  {
                     localArray .push (object [key]);
                     break;
                  }
                  case "string":
                  {
                     localArray .push (object [key]);

                     arrayOfStrings = true;
                     break;
                  }
                  case "boolean":
                  {
                     localArray .push (object [key]);
                     break;
                  }
                  case "object":
                  {
                     /*
                     if (object[key] != null && typeof object[key].join === "function") {
                        localArray.push(object[key].join(" "));
                     }
                     */
                     this .convertToDOM (object [key], key, element);
                     break;
                  }
                  case "undefined":
                  {
                     break;
                  }
                  default:
                  {
                     console .error ("Unknown type found in array " + typeof object [key]);
                  }
               }
            }
            else
            {
               switch (typeof object [key])
               {
                  case "object":
                  {
                     // This is where the whole thing starts

                     if (key === "X3D")
                        this .convertToDOM (object [key], key, element);

                     else
                        this .convertObject (key, object, element, containerField);

                     break;
                  }
                  case "number":
                  {
                     this .elementSetAttribute (element, key .substr (1), object [key]);
                     break;
                  }
                  case "string":
                  {
                     if (key !== "#comment")
                     {
                        // ordinary string attributes
                        this .elementSetAttribute (element, key .substr (1), this .JSONStringToXML (object [key]));
                     }
                     else
                     {
                        const child = document .createComment (this .commentStringToXML (object [key]));

                        element .appendChild (child);
                     }

                     break;
                  }
                  case "boolean":
                  {
                     this .elementSetAttribute (element, key .substr (1), object [key]);
                     break;
                  }
                  case "undefined":
                  {
                     break;
                  }
                  default:
                  {
                     console .error ("Unknown type found in object " + typeof object [key]);
                     console .error (object);
                  }
               }
            }
         }

         if (isArray)
         {
            if (parentkey .substr (0,1) === "@")
            {
               if (arrayOfStrings)
               {
                  arrayOfStrings = false;

                  for (const str in localArray)
                     localArray [str] = this .SFStringToXML (localArray [str]);

                  this .elementSetAttribute (element, parentkey .substr (1), '"' + localArray .join ('" "') + '"');
               }
               else
               {
                  // if non string array
                  this .elementSetAttribute (element, parentkey .substr (1), localArray .join (" "));
               }
            }

            isArray = false;
         }

         return element;
      },
   });

   return JSONParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Parser/GoldenGate',[
   "x_ite/Parser/X3DParser",
   "x_ite/Parser/JSONParser",
   "x_ite/Parser/VRMLParser",
   "x_ite/Parser/XMLParser",
],
function (X3DParser,
          JSONParser,
          VRMLParser,
          XMLParser)
{
"use strict";

   function GoldenGate (scene)
   {
      X3DParser .call (this, scene);
   }

   GoldenGate .prototype = Object .assign (Object .create (X3DParser .prototype),
   {
      constructor: GoldenGate,
      parseIntoScene: function (x3dSyntax, success, error)
      {
         for (const Parser of GoldenGate .Parser)
         {
            try
            {
               const parser = new Parser (this .getScene ());

               parser .setInput (x3dSyntax);

               if (parser .isValid ())
               {
                  parser .pushExecutionContext (this .getExecutionContext ());
                  parser .parseIntoScene (success, error);
                  parser .popExecutionContext ();
                  return
               }
            }
            catch (exception)
            {
               if (error)
                  error (exception);
               else
                  throw exception;

               return;
            }
         }

         if (this .getScene () .worldURL .startsWith ("data:"))
            throw new Error ("Couldn't parse X3D. No suitable file handler found for 'data:' URL.");
         else
            throw new Error ("Couldn't parse X3D. No suitable file handler found for '" + this .getScene () .worldURL + "'.");
      },
   });

   GoldenGate .Parser = [
      XMLParser,
      JSONParser,
      VRMLParser,
   ];

   return GoldenGate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Plane3',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (Vector3,
          Matrix4)
{
"use strict";

   const
      normal    = new Vector3 (0, 0, 0),
      point     = new Vector3 (0, 0, 0),
      invMatrix = new Matrix4 ();

   function Plane3 (point, normal)
   {
      this .normal             = normal .copy ();
      this .distanceFromOrigin = normal .dot (point);
   }

   Plane3 .prototype =
   {
      constructor: Plane3,
      copy: function ()
      {
         const copy = Object .create (Plane3 .prototype);
         copy .normal             = this .normal .copy ();
         copy .distanceFromOrigin = this .distanceFromOrigin;
         return copy;
      },
      assign: function (plane)
      {
         this .normal .assign (plane .normal);
         this .distanceFromOrigin = plane .distanceFromOrigin;
         return this;
      },
      set: function (point, normal)
      {
         this .normal .assign (normal);
         this .distanceFromOrigin = normal .dot (point);
         return this;
      },
      multRight: function (matrix)
      {
         // Taken from Inventor:

         // Find the point on the plane along the normal from the origin
         point .assign (this .normal) .multiply (this .distanceFromOrigin);

         // Transform the plane normal by the matrix
         // to get the new normal. Use the inverse transpose
         // of the matrix so that normals are not scaled incorrectly.
         // n' = n * !~m = ~m * n
         invMatrix .assign (matrix) .inverse ();
         invMatrix .multMatrixDir (normal .assign (this .normal)) .normalize ();

         // Transform the point by the matrix
         matrix .multVecMatrix (point);

         // The new distance is the projected distance of the vector to the
         // transformed point onto the (unit) transformed normal. This is
         // just a dot product.
         this .normal .assign (normal);
         this .distanceFromOrigin = normal .dot (point);

         return this;
      },
      multLeft: function (matrix)
      {
         // Taken from Inventor:

         // Find the point on the plane along the normal from the origin
         point .assign (this .normal) .multiply (this .distanceFromOrigin);

         // Transform the plane normal by the matrix
         // to get the new normal. Use the inverse transpose
         // of the matrix so that normals are not scaled incorrectly.
         // n' = !~m * n = n * ~m
         invMatrix .assign (matrix) .inverse ();
         invMatrix .multDirMatrix (normal .assign (this .normal)) .normalize ();

         // Transform the point by the matrix
         matrix .multMatrixVec (point);

         // The new distance is the projected distance of the vector to the
         // transformed point onto the (unit) transformed normal. This is
         // just a dot product.
         this .normal .assign (normal);
         this .distanceFromOrigin = normal .dot (point);

         return this;
      },
      getDistanceToPoint: function (point)
      {
         return Vector3 .dot (point, this .normal) - this .distanceFromOrigin;
      },
      intersectsLine: function (line, intersection)
      {
         const
            point     = line .point,
            direction = line .direction;

         // Check if the line is parallel to the plane.
         const theta = direction .dot (this .normal);

         // Plane and line are parallel.
         if (theta === 0)
            return false;

         // Plane and line are not parallel. The intersection point can be calculated now.
         const t = (this .distanceFromOrigin - this .normal .dot (point)) / theta;

         intersection .x = point .x + direction .x * t;
         intersection .y = point .y + direction .y * t;
         intersection .z = point .z + direction .z * t;

         return true;
      },
      toString: function ()
      {
         return this .normal .toString () + " " + this .distanceFromOrigin;
      },
   };

   return Plane3;
});

/**
 * @license
 * Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
 * Copyright 2015, Google Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Original Code. The Original Code is: OpenGL Sample Implementation,
 * Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
 * Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
 * Copyright in any portions created by third parties is as indicated
 * elsewhere herein. All Rights Reserved.
 */
/**
 * @author ericv@cs.stanford.edu (Eric Veach)
 * @author bckenny@google.com (Brendan Kenny)
 */

/**
 * Base namespace.
 * @const
 */
var libtess = {};

/**
 * Whether to run asserts and extra debug checks.
 * @define {boolean}
 */
libtess.DEBUG = false;

/**
 * Checks if the condition evaluates to true if libtess.DEBUG is true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @throws {Error} Assertion failed, the condition evaluates to false.
 */
libtess.assert = function(condition, opt_message) {
  if (libtess.DEBUG && !condition) {
    throw new Error('Assertion failed' +
        (opt_message ? ': ' + opt_message : ''));
  }
};

/**
 * The maximum vertex coordinate size, 1e150. Anything larger will trigger a
 * GLU_TESS_COORD_TOO_LARGE error callback and the vertex will be clamped to
 * this value for all tessellation calculations.
 * @const {number}
 */
libtess.GLU_TESS_MAX_COORD = 1e150;
// NOTE(bckenny): value from glu.pl generator

/**
 * Normally the polygon is projected to a plane perpendicular to one of the
 * three coordinate axes before tessellating in 2d. This helps numerical
 * accuracy by forgoing a transformation step by simply dropping one coordinate
 * dimension.
 *
 * However, this can affect the placement of intersection points for non-axis-
 * aligned polygons. Setting TRUE_PROJECT to true will instead project onto a
 * plane actually perpendicular to the polygon's normal.
 *
 * NOTE(bckenny): I can find no instances on the internet in which this mode has
 * been used, but it's difficult to search for. This was a compile-time setting
 * in the original, so setting this as constant. If this is exposed in the
 * public API, remove the ignore coverage directives on
 * libtess.normal.projectPolygon and libtess.normal.normalize_.
 * @const {boolean}
 */
libtess.TRUE_PROJECT = false;

/**
 * The default tolerance for merging features, 0, meaning vertices are only
 * merged if they are exactly coincident
 * If a higher tolerance is needed, significant rewriting will need to occur.
 * See libtess.sweep.TOLERANCE_NONZERO_ as a starting place.
 * @const {number}
 */
libtess.GLU_TESS_DEFAULT_TOLERANCE = 0;

/**
 * The input contours parition the plane into regions. A winding
 * rule determines which of these regions are inside the polygon.
 *
 * For a single contour C, the winding number of a point x is simply
 * the signed number of revolutions we make around x as we travel
 * once around C (where CCW is positive). When there are several
 * contours, the individual winding numbers are summed. This
 * procedure associates a signed integer value with each point x in
 * the plane. Note that the winding number is the same for all
 * points in a single region.
 *
 * The winding rule classifies a region as "inside" if its winding
 * number belongs to the chosen category (odd, nonzero, positive,
 * negative, or absolute value of at least two). The current GLU
 * tesselator implements the "odd" rule. The "nonzero" rule is another
 * common way to define the interior. The other three rules are
 * useful for polygon CSG operations.
 * @enum {number}
 */
libtess.windingRule = {
  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_WINDING_ODD: 100130,
  GLU_TESS_WINDING_NONZERO: 100131,
  GLU_TESS_WINDING_POSITIVE: 100132,
  GLU_TESS_WINDING_NEGATIVE: 100133,
  GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
};

/**
 * The type of primitive return from a "begin" callback. GL_LINE_LOOP is only
 * returned when GLU_TESS_BOUNDARY_ONLY is true. GL_TRIANGLE_STRIP and
 * GL_TRIANGLE_FAN are no longer returned since 1.1.0 (see release notes).
 * @enum {number}
 */
libtess.primitiveType = {
  GL_LINE_LOOP: 2,
  GL_TRIANGLES: 4,
  GL_TRIANGLE_STRIP: 5,
  GL_TRIANGLE_FAN: 6
};

/**
 * The types of errors provided in the error callback.
 * @enum {number}
 */
libtess.errorType = {
  // TODO(bckenny) doc types
  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
  GLU_TESS_MISSING_END_POLYGON: 100153,
  GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
  GLU_TESS_MISSING_END_CONTOUR: 100154,
  GLU_TESS_COORD_TOO_LARGE: 100155,
  GLU_TESS_NEED_COMBINE_CALLBACK: 100156
};

/**
 * Enum values necessary for providing settings and callbacks. See the readme
 * for details.
 * @enum {number}
 */
libtess.gluEnum = {
  // TODO(bckenny): rename so not always typing libtess.gluEnum.*?

  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_BEGIN: 100100,
  GLU_TESS_VERTEX: 100101,
  GLU_TESS_END: 100102,
  GLU_TESS_ERROR: 100103,
  GLU_TESS_EDGE_FLAG: 100104,
  GLU_TESS_COMBINE: 100105,
  GLU_TESS_BEGIN_DATA: 100106,
  GLU_TESS_VERTEX_DATA: 100107,
  GLU_TESS_END_DATA: 100108,
  GLU_TESS_ERROR_DATA: 100109,
  GLU_TESS_EDGE_FLAG_DATA: 100110,
  GLU_TESS_COMBINE_DATA: 100111,

  GLU_TESS_MESH: 100112,  //  NOTE(bckenny): from tess.c
  GLU_TESS_TOLERANCE: 100142,
  GLU_TESS_WINDING_RULE: 100140,
  GLU_TESS_BOUNDARY_ONLY: 100141,

  // TODO(bckenny): move this to libtess.errorType?
  GLU_INVALID_ENUM: 100900,
  GLU_INVALID_VALUE: 100901
};

/** @typedef {number} */
libtess.PQHandle;

/* global libtess */

/** @const */
libtess.geom = {};

/**
 * Returns whether vertex u and vertex v are equal.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.vertEq = function(u, v) {
  return u.s === v.s && u.t === v.t;
};

/**
 * Returns whether vertex u is lexicographically less than or equal to vertex v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.vertLeq = function(u, v) {
  return (u.s < v.s) || (u.s === v.s && u.t <= v.t);
};

/**
 * Given three vertices u,v,w such that geom.vertLeq(u,v) && geom.vertLeq(v,w),
 * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
 * Returns v.t - (uw)(v.s), ie. the signed distance from uw to v.
 * If uw is vertical (and thus passes thru v), the result is zero.
 *
 * The calculation is extremely accurate and stable, even when v
 * is very close to u or w.  In particular if we set v.t = 0 and
 * let r be the negated result (this evaluates (uw)(v.s)), then
 * r is guaranteed to satisfy MIN(u.t,w.t) <= r <= MAX(u.t,w.t).
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.edgeEval = function(u, v, w) {

  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0) {
    if (gapL < gapR) {
      return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
    } else {
      return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
    }
  }

  // vertical line
  return 0;
};

/**
 * Returns a number whose sign matches geom.edgeEval(u,v,w) but which
 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
 * as v is above, on, or below the edge uw.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.edgeSign = function(u, v, w) {

  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0) {
    return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
  }

  // vertical line
  return 0;
};

/**
 * Version of VertLeq with s and t transposed.
 * Returns whether vertex u is lexicographically less than or equal to vertex v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.transLeq = function(u, v) {
  return (u.t < v.t) || (u.t === v.t && u.s <= v.s);
};

/**
 * Version of geom.edgeEval with s and t transposed.
 * Given three vertices u,v,w such that geom.transLeq(u,v) &&
 * geom.transLeq(v,w), evaluates the t-coord of the edge uw at the s-coord of
 * the vertex v. Returns v.s - (uw)(v.t), ie. the signed distance from uw to v.
 * If uw is vertical (and thus passes thru v), the result is zero.
 *
 * The calculation is extremely accurate and stable, even when v
 * is very close to u or w.  In particular if we set v.s = 0 and
 * let r be the negated result (this evaluates (uw)(v.t)), then
 * r is guaranteed to satisfy MIN(u.s,w.s) <= r <= MAX(u.s,w.s).
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.transEval = function(u, v, w) {

  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0) {
    if (gapL < gapR) {
      return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
    } else {
      return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
    }
  }

  // vertical line
  return 0;
};

/**
 * Version of geom.edgeSign with s and t transposed.
 * Returns a number whose sign matches geom.transEval(u,v,w) but which
 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
 * as v is above, on, or below the edge uw.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.transSign = function(u, v, w) {

  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0) {
    return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
  }

  // vertical line
  return 0;
};

/**
 * Returns whether edge is directed from right to left.
 * @param {libtess.GluHalfEdge} e
 * @return {boolean}
 */
libtess.geom.edgeGoesLeft = function(e) {
  return libtess.geom.vertLeq(e.dst(), e.org);
};

/**
 * Returns whether edge is directed from left to right.
 * @param {libtess.GluHalfEdge} e
 * @return {boolean}
 */
libtess.geom.edgeGoesRight = function(e) {
  return libtess.geom.vertLeq(e.org, e.dst());
};

/**
 * Calculates the L1 distance between vertices u and v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {number}
 */
libtess.geom.vertL1dist = function(u, v) {
  return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};

// NOTE(bckenny): vertCCW is called nowhere in libtess and isn't part of the
// public API.
/* istanbul ignore next */
/**
 * For almost-degenerate situations, the results are not reliable.
 * Unless the floating-point arithmetic can be performed without
 * rounding errors, *any* implementation will give incorrect results
 * on some degenerate inputs, so the client must have some way to
 * handle this situation.
 * @param {!libtess.GluVertex} u
 * @param {!libtess.GluVertex} v
 * @param {!libtess.GluVertex} w
 * @return {boolean}
 */
libtess.geom.vertCCW = function(u, v, w) {
  return (u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t)) >= 0;
};

/**
 * Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
 * or (x+y)/2 if a==b==0. It requires that a,b >= 0, and enforces
 * this in the rare case that one argument is slightly negative.
 * The implementation is extremely stable numerically.
 * In particular it guarantees that the result r satisfies
 * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
 * even when a and b differ greatly in magnitude.
 * @private
 * @param {number} a
 * @param {number} x
 * @param {number} b
 * @param {number} y
 * @return {number}
 */
libtess.geom.interpolate_ = function(a, x, b, y) {
  // from Macro RealInterpolate:
  //(a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))))
  a = (a < 0) ? 0 : a;
  b = (b < 0) ? 0 : b;

  if (a <= b) {
    if (b === 0) {
      return (x + y) / 2;
    } else {
      return x + (y - x) * (a / (a + b));
    }
  } else {
    return y + (x - y) * (b / (a + b));
  }
};

/**
 * Given edges (o1,d1) and (o2,d2), compute their point of intersection.
 * The computed point is guaranteed to lie in the intersection of the
 * bounding rectangles defined by each edge.
 * @param {!libtess.GluVertex} o1
 * @param {!libtess.GluVertex} d1
 * @param {!libtess.GluVertex} o2
 * @param {!libtess.GluVertex} d2
 * @param {!libtess.GluVertex} v
 */
libtess.geom.edgeIntersect = function(o1, d1, o2, d2, v) {
  // This is certainly not the most efficient way to find the intersection
  // of two line segments, but it is very numerically stable.

  // Strategy: find the two middle vertices in the VertLeq ordering,
  // and interpolate the intersection s-value from these. Then repeat
  // using the TransLeq ordering to find the intersection t-value.
  var z1;
  var z2;
  var tmp;
  if (!libtess.geom.vertLeq(o1, d1)) {
    // Swap(o1, d1);
    tmp = o1;
    o1 = d1;
    d1 = tmp;
  }
  if (!libtess.geom.vertLeq(o2, d2)) {
    // Swap(o2, d2);
    tmp = o2;
    o2 = d2;
    d2 = tmp;
  }
  if (!libtess.geom.vertLeq(o1, o2)) {
    // Swap(o1, o2);
    tmp = o1;
    o1 = o2;
    o2 = tmp;
    // Swap(d1, d2);
    tmp = d1;
    d1 = d2;
    d2 = tmp;
  }

  if (!libtess.geom.vertLeq(o2, d1)) {
    // Technically, no intersection -- do our best
    v.s = (o2.s + d1.s) / 2;

  } else if (libtess.geom.vertLeq(d1, d2)) {
    // Interpolate between o2 and d1
    z1 = libtess.geom.edgeEval(o1, o2, d1);
    z2 = libtess.geom.edgeEval(o2, d1, d2);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d1.s);

  } else {
    // Interpolate between o2 and d2
    z1 = libtess.geom.edgeSign(o1, o2, d1);
    z2 = -libtess.geom.edgeSign(o1, d2, d1);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d2.s);
  }

  // Now repeat the process for t
  if (!libtess.geom.transLeq(o1, d1)) {
    // Swap(o1, d1);
    tmp = o1;
    o1 = d1;
    d1 = tmp;
  }
  if (!libtess.geom.transLeq(o2, d2)) {
    // Swap(o2, d2);
    tmp = o2;
    o2 = d2;
    d2 = tmp;
  }
  if (!libtess.geom.transLeq(o1, o2)) {
    // Swap(o1, o2);
    tmp = o1;
    o1 = o2;
    o2 = tmp;
    // Swap(d1, d2);
    tmp = d1;
    d1 = d2;
    d2 = tmp;
  }

  if (!libtess.geom.transLeq(o2, d1)) {
    // Technically, no intersection -- do our best
    v.t = (o2.t + d1.t) / 2;

  } else if (libtess.geom.transLeq(d1, d2)) {
    // Interpolate between o2 and d1
    z1 = libtess.geom.transEval(o1, o2, d1);
    z2 = libtess.geom.transEval(o2, d1, d2);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d1.t);

  } else {
    // Interpolate between o2 and d2
    z1 = libtess.geom.transSign(o1, o2, d1);
    z2 = -libtess.geom.transSign(o1, d2, d1);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d2.t);
  }
};

/* global libtess */

// TODO(bckenny): could maybe merge GluMesh and mesh.js since these are
// operations on the mesh

/** @const */
libtess.mesh = {};

/****************** Basic Edge Operations **********************/


/**
 * makeEdge creates one edge, two vertices, and a loop (face).
 * The loop consists of the two new half-edges.
 *
 * @param {libtess.GluMesh} mesh [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.makeEdge = function(mesh) {
  // TODO(bckenny): probably move to GluMesh, but needs Make* methods with it

  var e = libtess.mesh.makeEdgePair_(mesh.eHead);

  // complete edge with vertices and face (see mesh.makeEdgePair_)
  libtess.mesh.makeVertex_(e, mesh.vHead);
  libtess.mesh.makeVertex_(e.sym, mesh.vHead);
  libtess.mesh.makeFace_(e, mesh.fHead);

  return e;
};


/**
 * meshSplice(eOrg, eDst) is the basic operation for changing the
 * mesh connectivity and topology. It changes the mesh so that
 *  eOrg.oNext <- OLD( eDst.oNext )
 *  eDst.oNext <- OLD( eOrg.oNext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg.org != eDst.org, the two vertices are merged together
 *  - if eOrg.org == eDst.org, the origin is split into two vertices
 * In both cases, eDst.org is changed and eOrg.org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg.lFace == eDst.lFace, one loop is split into two
 *  - if eOrg.lFace != eDst.lFace, two distinct loops are joined into one
 * In both cases, eDst.lFace is changed and eOrg.lFace is unaffected.
 *
 * Some special cases:
 * If eDst == eOrg, the operation has no effect.
 * If eDst == eOrg.lNext, the new face will have a single edge.
 * If eDst == eOrg.lPrev(), the old face will have a single edge.
 * If eDst == eOrg.oNext, the new vertex will have a single edge.
 * If eDst == eOrg.oPrev(), the old vertex will have a single edge.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @param {libtess.GluHalfEdge} eDst [description].
 */
libtess.mesh.meshSplice = function(eOrg, eDst) {
  // TODO: more descriptive name?

  var joiningLoops = false;
  var joiningVertices = false;

  if (eOrg === eDst) {
    return;
  }

  if (eDst.org !== eOrg.org) {
    // We are merging two disjoint vertices -- destroy eDst.org
    joiningVertices = true;
    libtess.mesh.killVertex_(eDst.org, eOrg.org);
  }

  if (eDst.lFace !== eOrg.lFace) {
    // We are connecting two disjoint loops -- destroy eDst.lFace
    joiningLoops = true;
    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
  }

  // Change the edge structure
  libtess.mesh.splice_(eDst, eOrg);

  if (!joiningVertices) {
    // We split one vertex into two -- the new vertex is eDst.org.
    // Make sure the old vertex points to a valid half-edge.
    libtess.mesh.makeVertex_(eDst, eOrg.org);
    eOrg.org.anEdge = eOrg;
  }

  if (!joiningLoops) {
    // We split one loop into two -- the new loop is eDst.lFace.
    // Make sure the old face points to a valid half-edge.
    libtess.mesh.makeFace_(eDst, eOrg.lFace);
    eOrg.lFace.anEdge = eOrg;
  }
};


/**
 * deleteEdge(eDel) removes the edge eDel. There are several cases:
 * if (eDel.lFace != eDel.rFace()), we join two loops into one; the loop
 * eDel.lFace is deleted. Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel.dst(). If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * This function could be implemented as two calls to __gl_meshSplice
 * plus a few calls to memFree, but this would allocate and delete
 * unnecessary vertices and faces.
 *
 * @param {libtess.GluHalfEdge} eDel [description].
 */
libtess.mesh.deleteEdge = function(eDel) {
  var eDelSym = eDel.sym;
  var joiningLoops = false;

  // First step: disconnect the origin vertex eDel.org.  We make all
  // changes to get a consistent mesh in this "intermediate" state.
  if (eDel.lFace !== eDel.rFace()) {
    // We are joining two loops into one -- remove the left face
    joiningLoops = true;
    libtess.mesh.killFace_(eDel.lFace, eDel.rFace());
  }

  if (eDel.oNext === eDel) {
    libtess.mesh.killVertex_(eDel.org, null);

  } else {
    // Make sure that eDel.org and eDel.rFace() point to valid half-edges
    eDel.rFace().anEdge = eDel.oPrev();
    eDel.org.anEdge = eDel.oNext;

    libtess.mesh.splice_(eDel, eDel.oPrev());

    if (!joiningLoops) {
      // We are splitting one loop into two -- create a new loop for eDel.
      libtess.mesh.makeFace_(eDel, eDel.lFace);
    }
  }

  // Claim: the mesh is now in a consistent state, except that eDel.org
  // may have been deleted.  Now we disconnect eDel.dst().
  if (eDelSym.oNext === eDelSym) {
    libtess.mesh.killVertex_(eDelSym.org, null);
    libtess.mesh.killFace_(eDelSym.lFace, null);

  } else {
    // Make sure that eDel.dst() and eDel.lFace point to valid half-edges
    eDel.lFace.anEdge = eDelSym.oPrev();
    eDelSym.org.anEdge = eDelSym.oNext;
    libtess.mesh.splice_(eDelSym, eDelSym.oPrev());
  }

  // Any isolated vertices or faces have already been freed.
  libtess.mesh.killEdge_(eDel);
};

/******************** Other Edge Operations **********************/

/* All these routines can be implemented with the basic edge
 * operations above.  They are provided for convenience and efficiency.
 */


/**
 * addEdgeVertex(eOrg) creates a new edge eNew such that
 * eNew == eOrg.lNext, and eNew.dst() is a newly created vertex.
 * eOrg and eNew will have the same left face.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.addEdgeVertex = function(eOrg) {
  // TODO(bckenny): why is it named this?

  var eNew = libtess.mesh.makeEdgePair_(eOrg);
  var eNewSym = eNew.sym;

  // Connect the new edge appropriately
  libtess.mesh.splice_(eNew, eOrg.lNext);

  // Set the vertex and face information
  eNew.org = eOrg.dst();

  libtess.mesh.makeVertex_(eNewSym, eNew.org);

  eNew.lFace = eNewSym.lFace = eOrg.lFace;

  return eNew;
};


/**
 * splitEdge(eOrg) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg.lNext. The new vertex is eOrg.dst() == eNew.org.
 * eOrg and eNew will have the same left face.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @return {!libtess.GluHalfEdge} [description].
 */
libtess.mesh.splitEdge = function(eOrg) {
  var tempHalfEdge = libtess.mesh.addEdgeVertex(eOrg);
  var eNew = tempHalfEdge.sym;

  // Disconnect eOrg from eOrg.dst() and connect it to eNew.org
  libtess.mesh.splice_(eOrg.sym, eOrg.sym.oPrev());
  libtess.mesh.splice_(eOrg.sym, eNew);

  // Set the vertex and face information
  eOrg.sym.org = eNew.org; // NOTE(bckenny): assignment to dst
  eNew.dst().anEdge = eNew.sym;  // may have pointed to eOrg.sym
  eNew.sym.lFace = eOrg.rFace(); // NOTE(bckenny): assignment to rFace
  eNew.winding = eOrg.winding;  // copy old winding information
  eNew.sym.winding = eOrg.sym.winding;

  return eNew;
};


/**
 * connect(eOrg, eDst) creates a new edge from eOrg.dst()
 * to eDst.org, and returns the corresponding half-edge eNew.
 * If eOrg.lFace == eDst.lFace, this splits one loop into two,
 * and the newly created loop is eNew.lFace. Otherwise, two disjoint
 * loops are merged into one, and the loop eDst.lFace is destroyed.
 *
 * If (eOrg == eDst), the new face will have only two edges.
 * If (eOrg.lNext == eDst), the old face is reduced to a single edge.
 * If (eOrg.lNext.lNext == eDst), the old face is reduced to two edges.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @param {libtess.GluHalfEdge} eDst [description].
 * @return {!libtess.GluHalfEdge} [description].
 */
libtess.mesh.connect = function(eOrg, eDst) {
  var joiningLoops = false;
  var eNew = libtess.mesh.makeEdgePair_(eOrg);
  var eNewSym = eNew.sym;

  if (eDst.lFace !== eOrg.lFace) {
    // We are connecting two disjoint loops -- destroy eDst.lFace
    joiningLoops = true;
    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
  }

  // Connect the new edge appropriately
  libtess.mesh.splice_(eNew, eOrg.lNext);
  libtess.mesh.splice_(eNewSym, eDst);

  // Set the vertex and face information
  eNew.org = eOrg.dst();
  eNewSym.org = eDst.org;
  eNew.lFace = eNewSym.lFace = eOrg.lFace;

  // Make sure the old face points to a valid half-edge
  eOrg.lFace.anEdge = eNewSym;

  if (!joiningLoops) {
    // We split one loop into two -- the new loop is eNew.lFace
    libtess.mesh.makeFace_(eNew, eOrg.lFace);
  }
  return eNew;
};

/******************** Other Operations **********************/


/**
 * zapFace(fZap) destroys a face and removes it from the
 * global face list. All edges of fZap will have a null pointer as their
 * left face. Any edges which also have a null pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order. Zapped faces cannot be used in further mesh operations!
 *
 * @param {libtess.GluFace} fZap [description].
 */
libtess.mesh.zapFace = function(fZap) {
  var eStart = fZap.anEdge;

  // walk around face, deleting edges whose right face is also NULL
  var eNext = eStart.lNext;
  var e;
  do {
    e = eNext;
    eNext = e.lNext;

    e.lFace = null;
    if (e.rFace() === null) {
      // delete the edge -- see mesh.deleteEdge above
      if (e.oNext === e) {
        libtess.mesh.killVertex_(e.org, null);

      } else {
        // Make sure that e.org points to a valid half-edge
        e.org.anEdge = e.oNext;
        libtess.mesh.splice_(e, e.oPrev());
      }

      var eSym = e.sym;

      if (eSym.oNext === eSym) {
        libtess.mesh.killVertex_(eSym.org, null);

      } else {
        // Make sure that eSym.org points to a valid half-edge
        eSym.org.anEdge = eSym.oNext;
        libtess.mesh.splice_(eSym, eSym.oPrev());
      }
      libtess.mesh.killEdge_(e);
    }
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var fPrev = fZap.prev;
  var fNext = fZap.next;
  fNext.prev = fPrev;
  fPrev.next = fNext;

  // TODO(bckenny): memFree( fZap );
  // TODO(bckenny): probably null at callsite
};

// TODO(bckenny): meshUnion isn't called within libtess and isn't part of the
// public API. Could be useful if more mesh manipulation functions are exposed.
/* istanbul ignore next */
/**
 * meshUnion() forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 *
 * @param {!libtess.GluMesh} mesh1
 * @param {!libtess.GluMesh} mesh2
 * @return {!libtess.GluMesh}
 */
libtess.mesh.meshUnion = function(mesh1, mesh2) {
  // TODO(bceknny): probably move to GluMesh method
  var f1 = mesh1.fHead;
  var v1 = mesh1.vHead;
  var e1 = mesh1.eHead;

  var f2 = mesh2.fHead;
  var v2 = mesh2.vHead;
  var e2 = mesh2.eHead;

  // Add the faces, vertices, and edges of mesh2 to those of mesh1
  if (f2.next !== f2) {
    f1.prev.next = f2.next;
    f2.next.prev = f1.prev;
    f2.prev.next = f1;
    f1.prev = f2.prev;
  }

  if (v2.next !== v2) {
    v1.prev.next = v2.next;
    v2.next.prev = v1.prev;
    v2.prev.next = v1;
    v1.prev = v2.prev;
  }

  if (e2.next !== e2) {
    e1.sym.next.sym.next = e2.next;
    e2.next.sym.next = e1.sym.next;
    e2.sym.next.sym.next = e1;
    e1.sym.next = e2.sym.next;
  }

  // TODO(bckenny): memFree(mesh2);
  // TODO(bckenny): If function is kept, remove mesh2's data to enforce.
  return mesh1;
};


/**
 * deleteMesh(mesh) will free all storage for any valid mesh.
 * @param {libtess.GluMesh} mesh [description].
 */
libtess.mesh.deleteMesh = function(mesh) {
  // TODO(bckenny): unnecessary, I think.
  // TODO(bckenny): might want to explicitly null at callsite
  // lots of memFrees. see also DELETE_BY_ZAPPING
};

/************************ Utility Routines ************************/


/**
 * Creates a new pair of half-edges which form their own loop.
 * No vertex or face structures are allocated, but these must be assigned
 * before the current edge operation is completed.
 *
 * TODO(bckenny): warning about eNext strictly being first of pair? (see code)
 *
 * @private
 * @param {libtess.GluHalfEdge} eNext [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.makeEdgePair_ = function(eNext) {
  var e = new libtess.GluHalfEdge();
  var eSym = new libtess.GluHalfEdge();

  // TODO(bckenny): how do we ensure this? see above comment in jsdoc
  // Make sure eNext points to the first edge of the edge pair
  // if (eNext->Sym < eNext ) { eNext = eNext->Sym; }

  // NOTE(bckenny): check this for bugs in current implementation!

  // Insert in circular doubly-linked list before eNext.
  // Note that the prev pointer is stored in sym.next.
  var ePrev = eNext.sym.next;
  eSym.next = ePrev;
  ePrev.sym.next = e;
  e.next = eNext;
  eNext.sym.next = eSym;

  e.sym = eSym;
  e.oNext = e;
  e.lNext = eSym;

  eSym.sym = e;
  eSym.oNext = eSym;
  eSym.lNext = e;

  return e;
};


/**
 * splice_ is best described by the Guibas/Stolfi paper or the
 * CS348a notes. Basically, it modifies the mesh so that
 * a.oNext and b.oNext are exchanged. This can have various effects
 * depending on whether a and b belong to different face or vertex rings.
 * For more explanation see mesh.meshSplice below.
 *
 * @private
 * @param {libtess.GluHalfEdge} a [description].
 * @param {libtess.GluHalfEdge} b [description].
 */
libtess.mesh.splice_ = function(a, b) {
  var aONext = a.oNext;
  var bONext = b.oNext;

  aONext.sym.lNext = b;
  bONext.sym.lNext = a;
  a.oNext = bONext;
  b.oNext = aONext;
};


/**
 * makeVertex_(eOrig, vNext) attaches a new vertex and makes it the
 * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
 * a place to insert the new vertex in the global vertex list.  We insert
 * the new vertex *before* vNext so that algorithms which walk the vertex
 * list will not see the newly created vertices.
 *
 * NOTE: unlike original, acutally allocates new vertex.
 *
 * @private
 * @param {libtess.GluHalfEdge} eOrig [description].
 * @param {libtess.GluVertex} vNext [description].
 */
libtess.mesh.makeVertex_ = function(eOrig, vNext) {
  // insert in circular doubly-linked list before vNext
  var vPrev = vNext.prev;
  var vNew = new libtess.GluVertex(vNext, vPrev);
  vPrev.next = vNew;
  vNext.prev = vNew;

  vNew.anEdge = eOrig;
  // leave coords, s, t undefined
  // TODO(bckenny): does above line mean 0 specifically, or does it matter?

  // fix other edges on this vertex loop
  var e = eOrig;
  do {
    e.org = vNew;
    e = e.oNext;
  } while (e !== eOrig);
};


/**
 * makeFace_(eOrig, fNext) attaches a new face and makes it the left
 * face of all edges in the face loop to which eOrig belongs. "fNext" gives
 * a place to insert the new face in the global face list.  We insert
 * the new face *before* fNext so that algorithms which walk the face
 * list will not see the newly created faces.
 *
 * NOTE: unlike original, acutally allocates new face.
 *
 * @private
 * @param {libtess.GluHalfEdge} eOrig [description].
 * @param {libtess.GluFace} fNext [description].
 */
libtess.mesh.makeFace_ = function(eOrig, fNext) {
  // insert in circular doubly-linked list before fNext
  var fPrev = fNext.prev;
  var fNew = new libtess.GluFace(fNext, fPrev);
  fPrev.next = fNew;
  fNext.prev = fNew;

  fNew.anEdge = eOrig;

  // The new face is marked "inside" if the old one was.  This is a
  // convenience for the common case where a face has been split in two.
  fNew.inside = fNext.inside;

  // fix other edges on this face loop
  var e = eOrig;
  do {
    e.lFace = fNew;
    e = e.lNext;
  } while (e !== eOrig);
};


/**
 * killEdge_ destroys an edge (the half-edges eDel and eDel.sym),
 * and removes from the global edge list.
 *
 * @private
 * @param {libtess.GluHalfEdge} eDel [description].
 */
libtess.mesh.killEdge_ = function(eDel) {
  // TODO(bckenny): in this case, no need to worry(?), but check when checking mesh.makeEdgePair_
  // Half-edges are allocated in pairs, see EdgePair above
  // if (eDel->Sym < eDel ) { eDel = eDel->Sym; }

  // delete from circular doubly-linked list
  var eNext = eDel.next;
  var ePrev = eDel.sym.next;
  eNext.sym.next = ePrev;
  ePrev.sym.next = eNext;

  // TODO(bckenny): memFree( eDel ); (which also frees eDel.sym)
  // TODO(bckenny): need to null at callsites?
};


/**
 * killVertex_ destroys a vertex and removes it from the global
 * vertex list. It updates the vertex loop to point to a given new vertex.
 *
 * @private
 * @param {libtess.GluVertex} vDel [description].
 * @param {libtess.GluVertex} newOrg [description].
 */
libtess.mesh.killVertex_ = function(vDel, newOrg) {
  var eStart = vDel.anEdge;

  // change the origin of all affected edges
  var e = eStart;
  do {
    e.org = newOrg;
    e = e.oNext;
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var vPrev = vDel.prev;
  var vNext = vDel.next;
  vNext.prev = vPrev;
  vPrev.next = vNext;

  // TODO(bckenny): memFree( vDel );
  // TODO(bckenny): need to null at callsites?
};


/**
 * killFace_ destroys a face and removes it from the global face
 * list. It updates the face loop to point to a given new face.
 *
 * @private
 * @param {libtess.GluFace} fDel [description].
 * @param {libtess.GluFace} newLFace [description].
 */
libtess.mesh.killFace_ = function(fDel, newLFace) {
  var eStart = fDel.anEdge;

  // change the left face of all affected edges
  var e = eStart;
  do {
    e.lFace = newLFace;
    e = e.lNext;
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var fPrev = fDel.prev;
  var fNext = fDel.next;
  fNext.prev = fPrev;
  fPrev.next = fNext;

  // TODO(bckenny): memFree( fDel );
  // TODO(bckenny): need to null at callsites?
};

/* global libtess */

/** @const */
libtess.normal = {};

// TODO(bckenny): Integrate SLANTED_SWEEP somehow?
/* The "feature merging" is not intended to be complete. There are
 * special cases where edges are nearly parallel to the sweep line
 * which are not implemented. The algorithm should still behave
 * robustly (ie. produce a reasonable tesselation) in the presence
 * of such edges, however it may miss features which could have been
 * merged. We could minimize this effect by choosing the sweep line
 * direction to be something unusual (ie. not parallel to one of the
 * coordinate axes).
 * #if defined(SLANTED_SWEEP)
 * #define S_UNIT_X  0.50941539564955385 // Pre-normalized
 * #define S_UNIT_Y  0.86052074622010633
 * #endif
 */

/**
 * X coordinate of local basis for polygon projection.
 * @private {number}
 * @const
 */
libtess.normal.S_UNIT_X_ = 1.0;

/**
 * Y coordinate of local basis for polygon projection.
 * @private {number}
 * @const
 */
libtess.normal.S_UNIT_Y_ = 0.0;

/**
 * Determines a polygon normal and projects vertices onto the plane of the
 * polygon. A pre-computed normal for the data may be provided, or set to the
 * zero vector if one should be computed from it.
 * @param {!libtess.GluTesselator} tess
 * @param {number} normalX
 * @param {number} normalY
 * @param {number} normalZ
 */
libtess.normal.projectPolygon = function(tess, normalX, normalY, normalZ) {
  var computedNormal = false;

  var norm = [
    normalX,
    normalY,
    normalZ
  ];
  if (normalX === 0 && normalY === 0 && normalZ === 0) {
    libtess.normal.computeNormal_(tess, norm);
    computedNormal = true;
  }

  var i = libtess.normal.longAxis_(norm);
  var vHead = tess.mesh.vHead;
  var v;

  // NOTE(bckenny): This branch is never taken. See comment on
  // libtess.TRUE_PROJECT.
  /* istanbul ignore if */
  if (libtess.TRUE_PROJECT) {
    // Choose the initial sUnit vector to be approximately perpendicular
    // to the normal.
    libtess.normal.normalize_(norm);

    var sUnit = [0, 0, 0];
    var tUnit = [0, 0, 0];

    sUnit[i] = 0;
    sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
    sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_;

    // Now make it exactly perpendicular
    var w = libtess.normal.dot_(sUnit, norm);
    sUnit[0] -= w * norm[0];
    sUnit[1] -= w * norm[1];
    sUnit[2] -= w * norm[2];
    libtess.normal.normalize_(sUnit);

    // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame
    tUnit[0] = norm[1] * sUnit[2] - norm[2] * sUnit[1];
    tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2];
    tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0];
    libtess.normal.normalize_(tUnit);

    // Project the vertices onto the sweep plane
    for (v = vHead.next; v !== vHead; v = v.next) {
      v.s = libtess.normal.dot_(v.coords, sUnit);
      v.t = libtess.normal.dot_(v.coords, tUnit);
    }

  } else {
    // Project perpendicular to a coordinate axis -- better numerically
    var sAxis = (i + 1) % 3;
    var tAxis = (i + 2) % 3;
    var tNegate = norm[i] > 0 ? 1 : -1;

    // Project the vertices onto the sweep plane
    for (v = vHead.next; v !== vHead; v = v.next) {
      v.s = v.coords[sAxis];
      v.t = tNegate * v.coords[tAxis];
    }
  }

  if (computedNormal) {
    libtess.normal.checkOrientation_(tess);
  }
};

// NOTE(bckenny): libtess.normal.dot_ is no longer called in code without
// libtess.TRUE_PROJECT defined.
/* istanbul ignore next */
/**
 * Computes the dot product of vectors u and v.
 * @private
 * @param {!Array<number>} u
 * @param {!Array<number>} v
 * @return {number}
 */
libtess.normal.dot_ = function(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
};

// NOTE(bckenny): only called from within libtess.normal.projectPolygon's
// TRUE_PROJECT branch, so ignoring for code coverage.
/* istanbul ignore next */
/**
 * Normalize vector v.
 * @private
 * @param {!Array<number>} v
 */
libtess.normal.normalize_ = function(v) {
  var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];

  len = Math.sqrt(len);
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
};

/**
 * Returns the index of the longest component of vector v.
 * @private
 * @param {!Array<number>} v
 * @return {number}
 */
libtess.normal.longAxis_ = function(v) {
  var i = 0;

  if (Math.abs(v[1]) > Math.abs(v[0])) {
    i = 1;
  }
  if (Math.abs(v[2]) > Math.abs(v[i])) {
    i = 2;
  }

  return i;
};

/**
 * Compute an approximate normal of the polygon from the vertices themselves.
 * Result returned in norm.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!Array<number>} norm
 */
libtess.normal.computeNormal_ = function(tess, norm) {
  var maxVal = [
    -2 * libtess.GLU_TESS_MAX_COORD,
    -2 * libtess.GLU_TESS_MAX_COORD,
    -2 * libtess.GLU_TESS_MAX_COORD
  ];
  var minVal = [
    2 * libtess.GLU_TESS_MAX_COORD,
    2 * libtess.GLU_TESS_MAX_COORD,
    2 * libtess.GLU_TESS_MAX_COORD
  ];
  var maxVert = [];
  var minVert = [];

  var v;
  var vHead = tess.mesh.vHead;
  for (v = vHead.next; v !== vHead; v = v.next) {
    for (var i = 0; i < 3; ++i) {
      var c = v.coords[i];
      if (c < minVal[i]) { minVal[i] = c; minVert[i] = v; }
      if (c > maxVal[i]) { maxVal[i] = c; maxVert[i] = v; }
    }
  }

  // Find two vertices separated by at least 1/sqrt(3) of the maximum
  // distance between any two vertices
  var index = 0;
  if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) { index = 1; }
  if (maxVal[2] - minVal[2] > maxVal[index] - minVal[index]) { index = 2; }
  if (minVal[index] >= maxVal[index]) {
    // All vertices are the same -- normal doesn't matter
    norm[0] = 0; norm[1] = 0; norm[2] = 1;
    return;
  }

  // Look for a third vertex which forms the triangle with maximum area
  // (Length of normal == twice the triangle area)
  var maxLen2 = 0;
  var v1 = minVert[index];
  var v2 = maxVert[index];
  var tNorm = [0, 0, 0];
  var d1 = [
    v1.coords[0] - v2.coords[0],
    v1.coords[1] - v2.coords[1],
    v1.coords[2] - v2.coords[2]
  ];
  var d2 = [0, 0, 0];
  for (v = vHead.next; v !== vHead; v = v.next) {
    d2[0] = v.coords[0] - v2.coords[0];
    d2[1] = v.coords[1] - v2.coords[1];
    d2[2] = v.coords[2] - v2.coords[2];
    tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
    tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
    tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
    var tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];
    if (tLen2 > maxLen2) {
      maxLen2 = tLen2;
      norm[0] = tNorm[0];
      norm[1] = tNorm[1];
      norm[2] = tNorm[2];
    }
  }

  if (maxLen2 <= 0) {
    // All points lie on a single line -- any decent normal will do
    norm[0] = norm[1] = norm[2] = 0;
    norm[libtess.normal.longAxis_(d1)] = 1;
  }
};

/**
 * Check that the sum of the signed area of all projected contours is
 * non-negative. If not, negate the t-coordinates to reverse the orientation and
 * make it so.
 * @private
 * @param {!libtess.GluTesselator} tess
 */
libtess.normal.checkOrientation_ = function(tess) {
  var area = 0;
  var fHead = tess.mesh.fHead;
  for (var f = fHead.next; f !== fHead; f = f.next) {
    var e = f.anEdge;
    if (e.winding <= 0) { continue; }
    do {
      area += (e.org.s - e.dst().s) * (e.org.t + e.dst().t);
      e = e.lNext;
    } while (e !== f.anEdge);
  }

  if (area < 0) {
    // Reverse the orientation by flipping all the t-coordinates
    var vHead = tess.mesh.vHead;
    for (var v = vHead.next; v !== vHead; v = v.next) {
      v.t = -v.t;
    }
  }
};

/* global libtess */

/** @const */
libtess.render = {};

/**
 * Takes a mesh, breaks it into separate triangles, and renders them. The
 * rendering output is provided as callbacks (see the API). Set flagEdges to
 * true to get edgeFlag callbacks (tess.flagBoundary in original libtess).
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluMesh} mesh
 * @param {boolean} flagEdges
 */
libtess.render.renderMesh = function(tess, mesh, flagEdges) {
  var beginCallbackCalled = false;

  // TODO(bckenny): edgeState needs to be boolean, but !== on first call
  // force edge state output for first vertex
  var edgeState = -1;

  // We examine all faces in an arbitrary order. Whenever we find
  // an inside triangle f, we render f.
  // NOTE(bckenny): go backwards through face list to match original libtess
  // triangle order
  for (var f = mesh.fHead.prev; f !== mesh.fHead; f = f.prev) {
    if (f.inside) {
      // We're going to emit a triangle, so call begin callback once
      if (!beginCallbackCalled) {
        tess.callBeginCallback(libtess.primitiveType.GL_TRIANGLES);
        beginCallbackCalled = true;
      }

      // check that face has only three edges
      var e = f.anEdge;
      // Loop once for each edge (there will always be 3 edges)
      do {
        if (flagEdges) {
          // Set the "edge state" to true just before we output the
          // first vertex of each edge on the polygon boundary.
          var newState = !e.rFace().inside ? 1 : 0; // TODO(bckenny): total hack to get edgeState working. fix me.
          if (edgeState !== newState) {
            edgeState = newState;
            // TODO(bckenny): edgeState should be boolean now
            tess.callEdgeFlagCallback(!!edgeState);
          }
        }

        // emit vertex
        tess.callVertexCallback(e.org.data);

        e = e.lNext;
      } while (e !== f.anEdge);
    }
  }

  // only call end callback if begin was called
  if (beginCallbackCalled) {
    tess.callEndCallback();
  }
};

/**
 * Takes a mesh, and outputs one contour for each face marked "inside". The
 * rendering output is provided as callbacks (see the API).
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluMesh} mesh
 */
libtess.render.renderBoundary = function(tess, mesh) {
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
    if (f.inside) {
      tess.callBeginCallback(libtess.primitiveType.GL_LINE_LOOP);

      var e = f.anEdge;
      do {
        tess.callVertexCallback(e.org.data);
        e = e.lNext;
      } while (e !== f.anEdge);

      tess.callEndCallback();
    }
  }
};

/* global libtess */

// TODO(bckenny): a number of these never return null (as opposed to original) and should be typed appropriately

/*
 * Invariants for the Edge Dictionary.
 * - each pair of adjacent edges e2=succ(e1) satisfies edgeLeq_(e1,e2)
 *   at any valid location of the sweep event
 * - if edgeLeq_(e2,e1) as well (at any valid sweep event), then e1 and e2
 *   share a common endpoint
 * - for each e, e.dst() has been processed, but not e.org
 * - each edge e satisfies vertLeq(e.dst(),event) && vertLeq(event,e.org)
 *   where "event" is the current sweep line event.
 * - no edge e has zero length
 *
 * Invariants for the Mesh (the processed portion).
 * - the portion of the mesh left of the sweep line is a planar graph,
 *   ie. there is *some* way to embed it in the plane
 * - no processed edge has zero length
 * - no two processed vertices have identical coordinates
 * - each "inside" region is monotone, ie. can be broken into two chains
 *   of monotonically increasing vertices according to VertLeq(v1,v2)
 *   - a non-invariant: these chains may intersect (very slightly)
 *
 * Invariants for the Sweep.
 * - if none of the edges incident to the event vertex have an activeRegion
 *   (ie. none of these edges are in the edge dictionary), then the vertex
 *   has only right-going edges.
 * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
 *   by ConnectRightVertex), then it is the only right-going edge from
 *   its associated vertex.  (This says that these edges exist only
 *   when it is necessary.)
 */

/** @const */
libtess.sweep = {};


/**
 * Make the sentinel coordinates big enough that they will never be
 * merged with real input features.  (Even with the largest possible
 * input contour and the maximum tolerance of 1.0, no merging will be
 * done with coordinates larger than 3 * libtess.GLU_TESS_MAX_COORD).
 * @private
 * @const
 * @type {number}
 */
libtess.sweep.SENTINEL_COORD_ = 4 * libtess.GLU_TESS_MAX_COORD;


/**
 * Because vertices at exactly the same location are merged together
 * before we process the sweep event, some degenerate cases can't occur.
 * However if someone eventually makes the modifications required to
 * merge features which are close together, the cases below marked
 * TOLERANCE_NONZERO will be useful.  They were debugged before the
 * code to merge identical vertices in the main loop was added.
 * @private
 * @const
 * @type {boolean}
 */
libtess.sweep.TOLERANCE_NONZERO_ = false;


/**
 * computeInterior(tess) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions. Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess.windingRule.
 * Each interior region is guaranteed be monotone.
 *
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.computeInterior = function(tess) {
  tess.fatalError = false;

  // Each vertex defines an event for our sweep line. Start by inserting
  // all the vertices in a priority queue. Events are processed in
  // lexicographic order, ie.
  // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
  libtess.sweep.removeDegenerateEdges_(tess);
  libtess.sweep.initPriorityQ_(tess);
  libtess.sweep.initEdgeDict_(tess);

  var v;
  while ((v = tess.pq.extractMin()) !== null) {
    for (;;) {
      var vNext = tess.pq.minimum();
      if (vNext === null || !libtess.geom.vertEq(vNext, v)) {
        break;
      }

      /* Merge together all vertices at exactly the same location.
       * This is more efficient than processing them one at a time,
       * simplifies the code (see connectLeftDegenerate), and is also
       * important for correct handling of certain degenerate cases.
       * For example, suppose there are two identical edges A and B
       * that belong to different contours (so without this code they would
       * be processed by separate sweep events).  Suppose another edge C
       * crosses A and B from above.  When A is processed, we split it
       * at its intersection point with C.  However this also splits C,
       * so when we insert B we may compute a slightly different
       * intersection point.  This might leave two edges with a small
       * gap between them.  This kind of error is especially obvious
       * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
       */
      vNext = tess.pq.extractMin();
      libtess.sweep.spliceMergeVertices_(tess, v.anEdge, vNext.anEdge);
    }
    libtess.sweep.sweepEvent_(tess, v);
  }

  // TODO(bckenny): what does the next comment mean? can we eliminate event except when debugging?
  // Set tess.event for debugging purposes
  var minRegion = tess.dict.getMin().getKey();
  tess.event = minRegion.eUp.org;
  libtess.sweep.doneEdgeDict_(tess);
  libtess.sweep.donePriorityQ_(tess);

  libtess.sweep.removeDegenerateFaces_(tess.mesh);
  tess.mesh.checkMesh();
};


/**
 * When we merge two edges into one, we need to compute the combined
 * winding of the new edge.
 * @private
 * @param {libtess.GluHalfEdge} eDst [description].
 * @param {libtess.GluHalfEdge} eSrc [description].
 */
libtess.sweep.addWinding_ = function(eDst, eSrc) {
  // NOTE(bckenny): from AddWinding macro
  eDst.winding += eSrc.winding;
  eDst.sym.winding += eSrc.sym.winding;
};


/**
 * Both edges must be directed from right to left (this is the canonical
 * direction for the upper edge of each region).
 *
 * The strategy is to evaluate a "t" value for each edge at the
 * current sweep line position, given by tess.event.  The calculations
 * are designed to be very stable, but of course they are not perfect.
 *
 * Special case: if both edge destinations are at the sweep event,
 * we sort the edges by slope (they would otherwise compare equally).
 *
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.ActiveRegion} reg1
 * @param {!libtess.ActiveRegion} reg2
 * @return {boolean}
 */
libtess.sweep.edgeLeq_ = function(tess, reg1, reg2) {
  var event = tess.event;
  var e1 = reg1.eUp;
  var e2 = reg2.eUp;

  if (e1.dst() === event) {
    if (e2.dst() === event) {
      // Two edges right of the sweep line which meet at the sweep event.
      // Sort them by slope.
      if (libtess.geom.vertLeq(e1.org, e2.org)) {
        return libtess.geom.edgeSign(e2.dst(), e1.org, e2.org) <= 0;
      }

      return libtess.geom.edgeSign(e1.dst(), e2.org, e1.org) >= 0;
    }

    return libtess.geom.edgeSign(e2.dst(), event, e2.org) <= 0;
  }

  if (e2.dst() === event) {
    return libtess.geom.edgeSign(e1.dst(), event, e1.org) >= 0;
  }

  // General case - compute signed distance *from* e1, e2 to event
  var t1 = libtess.geom.edgeEval(e1.dst(), event, e1.org);
  var t2 = libtess.geom.edgeEval(e2.dst(), event, e2.org);
  return (t1 >= t2);
};


/**
 * [deleteRegion_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.deleteRegion_ = function(tess, reg) {
  if (reg.fixUpperEdge) {
    // It was created with zero winding number, so it better be
    // deleted with zero winding number (ie. it better not get merged
    // with a real edge).
  }

  reg.eUp.activeRegion = null;

  tess.dict.deleteNode(reg.nodeUp);
  reg.nodeUp = null;

  // memFree( reg ); TODO(bckenny)
  // TODO(bckenny): may need to null at callsite
};


/**
 * Replace an upper edge which needs fixing (see connectRightVertex).
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @param {libtess.GluHalfEdge} newEdge [description].
 */
libtess.sweep.fixUpperEdge_ = function(reg, newEdge) {
  libtess.mesh.deleteEdge(reg.eUp);

  reg.fixUpperEdge = false;
  reg.eUp = newEdge;
  newEdge.activeRegion = reg;
};


/**
 * Find the region above the uppermost edge with the same origin.
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @return {libtess.ActiveRegion} [description].
 */
libtess.sweep.topLeftRegion_ = function(reg) {
  var org = reg.eUp.org;

  // Find the region above the uppermost edge with the same origin
  do {
    reg = reg.regionAbove();
  } while (reg.eUp.org === org);

  // If the edge above was a temporary edge introduced by connectRightVertex,
  // now is the time to fix it.
  if (reg.fixUpperEdge) {
    var e = libtess.mesh.connect(reg.regionBelow().eUp.sym, reg.eUp.lNext);
    libtess.sweep.fixUpperEdge_(reg, e);
    reg = reg.regionAbove();
  }

  return reg;
};


/**
 * Find the region above the uppermost edge with the same destination.
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @return {libtess.ActiveRegion} [description].
 */
libtess.sweep.topRightRegion_ = function(reg) {
  var dst = reg.eUp.dst();

  do {
    reg = reg.regionAbove();
  } while (reg.eUp.dst() === dst);

  return reg;
};


/**
 * Add a new active region to the sweep line, *somewhere* below "regAbove"
 * (according to where the new edge belongs in the sweep-line dictionary).
 * The upper edge of the new region will be "eNewUp".
 * Winding number and "inside" flag are not updated.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regAbove [description].
 * @param {libtess.GluHalfEdge} eNewUp [description].
 * @return {libtess.ActiveRegion} regNew.
 */
libtess.sweep.addRegionBelow_ = function(tess, regAbove, eNewUp) {
  var regNew = new libtess.ActiveRegion();

  regNew.eUp = eNewUp;
  regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew);
  eNewUp.activeRegion = regNew;

  return regNew;
};


/**
 * [isWindingInside_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {number} n int.
 * @return {boolean} [description].
 */
libtess.sweep.isWindingInside_ = function(tess, n) {
  switch (tess.windingRule) {
    case libtess.windingRule.GLU_TESS_WINDING_ODD:
      return ((n & 1) !== 0);
    case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
      return (n !== 0);
    case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
      return (n > 0);
    case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
      return (n < 0);
    case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
      return (n >= 2) || (n <= -2);
  }

  // TODO(bckenny): not reached
  return false;
};


/**
 * [computeWinding_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.computeWinding_ = function(tess, reg) {
  reg.windingNumber = reg.regionAbove().windingNumber + reg.eUp.winding;
  reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);
};


/**
 * Delete a region from the sweep line. This happens when the upper
 * and lower chains of a region meet (at a vertex on the sweep line).
 * The "inside" flag is copied to the appropriate mesh face (we could
 * not do this before -- since the structure of the mesh is always
 * changing, this face may not have even existed until now).
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.finishRegion_ = function(tess, reg) {
  // TODO(bckenny): may need to null reg at callsite

  var e = reg.eUp;
  var f = e.lFace;

  f.inside = reg.inside;
  f.anEdge = e;   // optimization for tessmono.tessellateMonoRegion() // TODO(bckenny): how so?
  libtess.sweep.deleteRegion_(tess, reg);
};


/**
 * We are given a vertex with one or more left-going edges. All affected
 * edges should be in the edge dictionary. Starting at regFirst.eUp,
 * we walk down deleting all regions where both edges have the same
 * origin vOrg. At the same time we copy the "inside" flag from the
 * active region to the face, since at this point each face will belong
 * to at most one region (this was not necessarily true until this point
 * in the sweep). The walk stops at the region above regLast; if regLast
 * is null we walk as far as possible. At the same time we relink the
 * mesh if necessary, so that the ordering of edges around vOrg is the
 * same as in the dictionary.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regFirst [description].
 * @param {libtess.ActiveRegion} regLast [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.sweep.finishLeftRegions_ = function(tess, regFirst, regLast) {
  var regPrev = regFirst;
  var ePrev = regFirst.eUp;
  while (regPrev !== regLast) {
    // placement was OK
    regPrev.fixUpperEdge = false;
    var reg = regPrev.regionBelow();
    var e = reg.eUp;
    if (e.org !== ePrev.org) {
      if (!reg.fixUpperEdge) {
        /* Remove the last left-going edge. Even though there are no further
         * edges in the dictionary with this origin, there may be further
         * such edges in the mesh (if we are adding left edges to a vertex
         * that has already been processed). Thus it is important to call
         * finishRegion rather than just deleteRegion.
         */
        libtess.sweep.finishRegion_(tess, regPrev);
        break;
      }

      // If the edge below was a temporary edge introduced by
      // connectRightVertex, now is the time to fix it.
      e = libtess.mesh.connect(ePrev.lPrev(), e.sym);
      libtess.sweep.fixUpperEdge_(reg, e);
    }

    // Relink edges so that ePrev.oNext === e
    if (ePrev.oNext !== e) {
      libtess.mesh.meshSplice(e.oPrev(), e);
      libtess.mesh.meshSplice(ePrev, e);
    }

    // may change reg.eUp
    libtess.sweep.finishRegion_(tess, regPrev);
    ePrev = reg.eUp;
    regPrev = reg;
  }

  return ePrev;
};


/**
 * Purpose: insert right-going edges into the edge dictionary, and update
 * winding numbers and mesh connectivity appropriately. All right-going
 * edges share a common origin vOrg. Edges are inserted CCW starting at
 * eFirst; the last edge inserted is eLast.oPrev. If vOrg has any
 * left-going edges already processed, then eTopLeft must be the edge
 * such that an imaginary upward vertical segment from vOrg would be
 * contained between eTopLeft.oPrev and eTopLeft; otherwise eTopLeft
 * should be null.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluHalfEdge} eFirst [description].
 * @param {libtess.GluHalfEdge} eLast [description].
 * @param {libtess.GluHalfEdge} eTopLeft [description].
 * @param {boolean} cleanUp [description].
 */
libtess.sweep.addRightEdges_ = function(tess, regUp, eFirst, eLast, eTopLeft,
    cleanUp) {

  var firstTime = true;

  // Insert the new right-going edges in the dictionary
  var e = eFirst;
  do {
    libtess.sweep.addRegionBelow_(tess, regUp, e.sym);
    e = e.oNext;
  } while (e !== eLast);

  // Walk *all* right-going edges from e.org, in the dictionary order,
  // updating the winding numbers of each region, and re-linking the mesh
  // edges to match the dictionary ordering (if necessary).
  if (eTopLeft === null) {
    eTopLeft = regUp.regionBelow().eUp.rPrev();
  }
  var regPrev = regUp;
  var ePrev = eTopLeft;
  var reg;
  for (;;) {
    reg = regPrev.regionBelow();
    e = reg.eUp.sym;
    if (e.org !== ePrev.org) {
      break;
    }

    if (e.oNext !== ePrev) {
      // Unlink e from its current position, and relink below ePrev
      libtess.mesh.meshSplice(e.oPrev(), e);
      libtess.mesh.meshSplice(ePrev.oPrev(), e);
    }
    // Compute the winding number and "inside" flag for the new regions
    reg.windingNumber = regPrev.windingNumber - e.winding;
    reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);

    // Check for two outgoing edges with same slope -- process these
    // before any intersection tests (see example in libtess.sweep.computeInterior).
    regPrev.dirty = true;
    if (!firstTime && libtess.sweep.checkForRightSplice_(tess, regPrev)) {
      libtess.sweep.addWinding_(e, ePrev);
      libtess.sweep.deleteRegion_(tess, regPrev); // TODO(bckenny): need to null regPrev anywhere else?
      libtess.mesh.deleteEdge(ePrev);
    }
    firstTime = false;
    regPrev = reg;
    ePrev = e;
  }

  regPrev.dirty = true;

  if (cleanUp) {
    // Check for intersections between newly adjacent edges.
    libtess.sweep.walkDirtyRegions_(tess, regPrev);
  }
};


/**
 * Set up data for and call GLU_TESS_COMBINE callback on GluTesselator.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluVertex} isect A raw vertex at the intersection.
 * @param {!Array<Object>} data The vertices of the intersecting edges.
 * @param {!Array<number>} weights The linear combination coefficients for this intersection.
 * @param {boolean} needed Whether a returned vertex is necessary in this case.
 */
libtess.sweep.callCombine_ = function(tess, isect, data, weights, needed) {
  // Copy coord data in case the callback changes it.
  var coords = [
    isect.coords[0],
    isect.coords[1],
    isect.coords[2]
  ];

  isect.data = null;
  isect.data = tess.callCombineCallback(coords, data, weights);
  if (isect.data === null) {
    if (!needed) {
      // not needed, so just use data from first vertex
      isect.data = data[0];

    } else if (!tess.fatalError) {
      // The only way fatal error is when two edges are found to intersect,
      // but the user has not provided the callback necessary to handle
      // generated intersection points.
      tess.callErrorCallback(libtess.errorType.GLU_TESS_NEED_COMBINE_CALLBACK);
      tess.fatalError = true;
    }
  }
};


/**
 * Two vertices with idential coordinates are combined into one.
 * e1.org is kept, while e2.org is discarded.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.GluHalfEdge} e1 [description].
 * @param {libtess.GluHalfEdge} e2 [description].
 */
libtess.sweep.spliceMergeVertices_ = function(tess, e1, e2) {
  // TODO(bckenny): better way to init these? save them?
  var data = [null, null, null, null];
  var weights = [0.5, 0.5, 0, 0];

  data[0] = e1.org.data;
  data[1] = e2.org.data;
  libtess.sweep.callCombine_(tess, e1.org, data, weights, false);
  libtess.mesh.meshSplice(e1, e2);
};


/**
 * Find some weights which describe how the intersection vertex is
 * a linear combination of org and dst. Each of the two edges
 * which generated "isect" is allocated 50% of the weight; each edge
 * splits the weight between its org and dst according to the
 * relative distance to "isect".
 *
 * @private
 * @param {libtess.GluVertex} isect [description].
 * @param {libtess.GluVertex} org [description].
 * @param {libtess.GluVertex} dst [description].
 * @param {Array.<number>} weights [description].
 * @param {number} weightIndex Index into weights for first weight to supply.
 */
libtess.sweep.vertexWeights_ = function(isect, org, dst, weights, weightIndex) {
  // TODO(bckenny): think through how we can use L1dist here and be correct for coords
  var t1 = libtess.geom.vertL1dist(org, isect);
  var t2 = libtess.geom.vertL1dist(dst, isect);

  // TODO(bckenny): introduced weightIndex to mimic addressing in original
  // 1) document (though it is private and only used from getIntersectData)
  // 2) better way? manually inline into getIntersectData? supply two two-length tmp arrays?
  var i0 = weightIndex;
  var i1 = weightIndex + 1;
  weights[i0] = 0.5 * t2 / (t1 + t2);
  weights[i1] = 0.5 * t1 / (t1 + t2);
  isect.coords[0] += weights[i0] * org.coords[0] + weights[i1] * dst.coords[0];
  isect.coords[1] += weights[i0] * org.coords[1] + weights[i1] * dst.coords[1];
  isect.coords[2] += weights[i0] * org.coords[2] + weights[i1] * dst.coords[2];
};


/**
 * We've computed a new intersection point, now we need a "data" pointer
 * from the user so that we can refer to this new vertex in the
 * rendering callbacks.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.GluVertex} isect [description].
 * @param {libtess.GluVertex} orgUp [description].
 * @param {libtess.GluVertex} dstUp [description].
 * @param {libtess.GluVertex} orgLo [description].
 * @param {libtess.GluVertex} dstLo [description].
 */
libtess.sweep.getIntersectData_ = function(tess, isect, orgUp, dstUp, orgLo,
    dstLo) {

  // TODO(bckenny): called for every intersection event, should these be from a pool?
  // TODO(bckenny): better way to init these?
  var weights = [0, 0, 0, 0];
  var data = [
    orgUp.data,
    dstUp.data,
    orgLo.data,
    dstLo.data
  ];

  // TODO(bckenny): it appears isect is a reappropriated vertex, so does need to be zeroed.
  // double check this.
  isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;

  // TODO(bckenny): see note in libtess.sweep.vertexWeights_ for explanation of weightIndex. fix?
  libtess.sweep.vertexWeights_(isect, orgUp, dstUp, weights, 0);
  libtess.sweep.vertexWeights_(isect, orgLo, dstLo, weights, 2);

  libtess.sweep.callCombine_(tess, isect, data, weights, true);
};


/**
 * Check the upper and lower edge of regUp, to make sure that the
 * eUp.org is above eLo, or eLo.org is below eUp (depending on which
 * origin is leftmost).
 *
 * The main purpose is to splice right-going edges with the same
 * dest vertex and nearly identical slopes (ie. we can't distinguish
 * the slopes numerically). However the splicing can also help us
 * to recover from numerical errors. For example, suppose at one
 * point we checked eUp and eLo, and decided that eUp.org is barely
 * above eLo. Then later, we split eLo into two edges (eg. from
 * a splice operation like this one). This can change the result of
 * our test so that now eUp.org is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants.
 *
 * One possibility is to check these edges for intersection again
 * (i.e. checkForIntersect). This is what we do if possible. However
 * checkForIntersect requires that tess.event lies between eUp and eLo,
 * so that it has something to fall back on when the intersection
 * calculation gives us an unusable answer. So, for those cases where
 * we can't check for intersection, this routine fixes the problem
 * by just splicing the offending vertex into the other edge.
 * This is a guaranteed solution, no matter how degenerate things get.
 * Basically this is a combinatorial solution to a numerical problem.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForRightSplice_ = function(tess, regUp) {
  // TODO(bckenny): fully learn how these two checks work

  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;

  if (libtess.geom.vertLeq(eUp.org, eLo.org)) {
    if (libtess.geom.edgeSign(eLo.dst(), eUp.org, eLo.org) > 0) {
      return false;
    }

    // eUp.org appears to be below eLo
    if (!libtess.geom.vertEq(eUp.org, eLo.org)) {
      // Splice eUp.org into eLo
      libtess.mesh.splitEdge(eLo.sym);
      libtess.mesh.meshSplice(eUp, eLo.oPrev());
      regUp.dirty = regLo.dirty = true;

    } else if (eUp.org !== eLo.org) {
      // merge the two vertices, discarding eUp.org
      tess.pq.remove(eUp.org.pqHandle);
      libtess.sweep.spliceMergeVertices_(tess, eLo.oPrev(), eUp);
    }

  } else {
    if (libtess.geom.edgeSign(eUp.dst(), eLo.org, eUp.org) < 0) {
      return false;
    }

    // eLo.org appears to be above eUp, so splice eLo.org into eUp
    regUp.regionAbove().dirty = regUp.dirty = true;
    libtess.mesh.splitEdge(eUp.sym);
    libtess.mesh.meshSplice(eLo.oPrev(), eUp);
  }

  return true;
};


/**
 * Check the upper and lower edge of regUp to make sure that the
 * eUp.dst() is above eLo, or eLo.dst() is below eUp (depending on which
 * destination is rightmost).
 *
 * Theoretically, this should always be true. However, splitting an edge
 * into two pieces can change the results of previous tests. For example,
 * suppose at one point we checked eUp and eLo, and decided that eUp.dst()
 * is barely above eLo. Then later, we split eLo into two edges (eg. from
 * a splice operation like this one). This can change the result of
 * the test so that now eUp.dst() is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants
 * (otherwise new edges might get inserted in the wrong place in the
 * dictionary, and bad stuff will happen).
 *
 * We fix the problem by just splicing the offending vertex into the
 * other edge.
 *
 * @private
 * @param {libtess.GluTesselator} tess description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForLeftSplice_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var e;

  if (libtess.geom.vertLeq(eUp.dst(), eLo.dst())) {
    if (libtess.geom.edgeSign(eUp.dst(), eLo.dst(), eUp.org) < 0) {
      return false;
    }

    // eLo.dst() is above eUp, so splice eLo.dst() into eUp
    regUp.regionAbove().dirty = regUp.dirty = true;
    e = libtess.mesh.splitEdge(eUp);
    libtess.mesh.meshSplice(eLo.sym, e);
    e.lFace.inside = regUp.inside;

  } else {
    if (libtess.geom.edgeSign(eLo.dst(), eUp.dst(), eLo.org) > 0) {
      return false;
    }

    // eUp.dst() is below eLo, so splice eUp.dst() into eLo
    regUp.dirty = regLo.dirty = true;
    e = libtess.mesh.splitEdge(eLo);
    libtess.mesh.meshSplice(eUp.lNext, eLo.sym);
    e.rFace().inside = regUp.inside;
  }

  return true;
};


/**
 * Check the upper and lower edges of the given region to see if
 * they intersect. If so, create the intersection and add it
 * to the data structures.
 *
 * Returns true if adding the new intersection resulted in a recursive
 * call to addRightEdges_(); in this case all "dirty" regions have been
 * checked for intersections, and possibly regUp has been deleted.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForIntersect_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var orgUp = eUp.org;
  var orgLo = eLo.org;
  var dstUp = eUp.dst();
  var dstLo = eLo.dst();

  var isect = new libtess.GluVertex();

  if (orgUp === orgLo) {
    // right endpoints are the same
    return false;
  }

  var tMinUp = Math.min(orgUp.t, dstUp.t);
  var tMaxLo = Math.max(orgLo.t, dstLo.t);
  if (tMinUp > tMaxLo) {
    // t ranges do not overlap
    return false;
  }

  if (libtess.geom.vertLeq(orgUp, orgLo)) {
    if (libtess.geom.edgeSign(dstLo, orgUp, orgLo) > 0) {
      return false;
    }
  } else {
    if (libtess.geom.edgeSign(dstUp, orgLo, orgUp) < 0) {
      return false;
    }
  }

  // At this point the edges intersect, at least marginally
  libtess.geom.edgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);

  // The following properties are guaranteed:

  if (libtess.geom.vertLeq(isect, tess.event)) {
    /* The intersection point lies slightly to the left of the sweep line,
     * so move it until it's slightly to the right of the sweep line.
     * (If we had perfect numerical precision, this would never happen
     * in the first place). The easiest and safest thing to do is
     * replace the intersection by tess.event.
     */
    isect.s = tess.event.s;
    isect.t = tess.event.t;
  }

  // TODO(bckenny): try to find test54.d
  /* Similarly, if the computed intersection lies to the right of the
   * rightmost origin (which should rarely happen), it can cause
   * unbelievable inefficiency on sufficiently degenerate inputs.
   * (If you have the test program, try running test54.d with the
   * "X zoom" option turned on).
   */
  var orgMin = libtess.geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;
  if (libtess.geom.vertLeq(orgMin, isect)) {
    isect.s = orgMin.s;
    isect.t = orgMin.t;
  }

  if (libtess.geom.vertEq(isect, orgUp) || libtess.geom.vertEq(isect, orgLo)) {
    // Easy case -- intersection at one of the right endpoints
    libtess.sweep.checkForRightSplice_(tess, regUp);
    return false;
  }

  // TODO(bckenny): clean this up; length is distracting
  if ((!libtess.geom.vertEq(dstUp, tess.event) &&
      libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) ||
      (!libtess.geom.vertEq(dstLo, tess.event) &&
      libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0)) {

    /* Very unusual -- the new upper or lower edge would pass on the
     * wrong side of the sweep event, or through it. This can happen
     * due to very small numerical errors in the intersection calculation.
     */
    if (dstLo === tess.event) {
      // Splice dstLo into eUp, and process the new region(s)
      libtess.mesh.splitEdge(eUp.sym);
      libtess.mesh.meshSplice(eLo.sym, eUp);
      regUp = libtess.sweep.topLeftRegion_(regUp);
      eUp = regUp.regionBelow().eUp;
      libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
      libtess.sweep.addRightEdges_(tess, regUp, eUp.oPrev(), eUp, eUp, true);
      return true;
    }

    if (dstUp === tess.event) {
      // Splice dstUp into eLo, and process the new region(s)
      libtess.mesh.splitEdge(eLo.sym);
      libtess.mesh.meshSplice(eUp.lNext, eLo.oPrev());
      regLo = regUp;
      regUp = libtess.sweep.topRightRegion_(regUp);
      var e = regUp.regionBelow().eUp.rPrev();
      regLo.eUp = eLo.oPrev();
      eLo = libtess.sweep.finishLeftRegions_(tess, regLo, null);
      libtess.sweep.addRightEdges_(tess, regUp, eLo.oNext, eUp.rPrev(), e,
          true);
      return true;
    }

    /* Special case: called from connectRightVertex. If either
     * edge passes on the wrong side of tess.event, split it
     * (and wait for connectRightVertex to splice it appropriately).
     */
    if (libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) {
      regUp.regionAbove().dirty = regUp.dirty = true;
      libtess.mesh.splitEdge(eUp.sym);
      eUp.org.s = tess.event.s;
      eUp.org.t = tess.event.t;
    }

    if (libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0) {
      regUp.dirty = regLo.dirty = true;
      libtess.mesh.splitEdge(eLo.sym);
      eLo.org.s = tess.event.s;
      eLo.org.t = tess.event.t;
    }

    // leave the rest for connectRightVertex
    return false;
  }

  /* General case -- split both edges, splice into new vertex.
   * When we do the splice operation, the order of the arguments is
   * arbitrary as far as correctness goes. However, when the operation
   * creates a new face, the work done is proportional to the size of
   * the new face. We expect the faces in the processed part of
   * the mesh (ie. eUp.lFace) to be smaller than the faces in the
   * unprocessed original contours (which will be eLo.oPrev.lFace).
   */
  libtess.mesh.splitEdge(eUp.sym);
  libtess.mesh.splitEdge(eLo.sym);
  libtess.mesh.meshSplice(eLo.oPrev(), eUp);
  eUp.org.s = isect.s;
  eUp.org.t = isect.t;
  eUp.org.pqHandle = tess.pq.insert(eUp.org);
  libtess.sweep.getIntersectData_(tess, eUp.org, orgUp, dstUp, orgLo, dstLo);
  regUp.regionAbove().dirty = regUp.dirty = regLo.dirty = true;

  return false;
};


/**
 * When the upper or lower edge of any region changes, the region is
 * marked "dirty". This routine walks through all the dirty regions
 * and makes sure that the dictionary invariants are satisfied
 * (see the comments at the beginning of this file). Of course,
 * new dirty regions can be created as we make changes to restore
 * the invariants.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 */
libtess.sweep.walkDirtyRegions_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();

  for (;;) {
    // Find the lowest dirty region (we walk from the bottom up).
    while (regLo.dirty) {
      regUp = regLo;
      regLo = regLo.regionBelow();
    }
    if (!regUp.dirty) {
      regLo = regUp;
      regUp = regUp.regionAbove();
      if (regUp === null || !regUp.dirty) {
        // We've walked all the dirty regions
        return;
      }
    }

    regUp.dirty = false;
    var eUp = regUp.eUp;
    var eLo = regLo.eUp;

    if (eUp.dst() !== eLo.dst()) {
      // Check that the edge ordering is obeyed at the dst vertices.
      if (libtess.sweep.checkForLeftSplice_(tess, regUp)) {
        // If the upper or lower edge was marked fixUpperEdge, then
        // we no longer need it (since these edges are needed only for
        // vertices which otherwise have no right-going edges).
        if (regLo.fixUpperEdge) {
          libtess.sweep.deleteRegion_(tess, regLo);
          libtess.mesh.deleteEdge(eLo);
          regLo = regUp.regionBelow();
          eLo = regLo.eUp;

        } else if (regUp.fixUpperEdge) {
          libtess.sweep.deleteRegion_(tess, regUp);
          libtess.mesh.deleteEdge(eUp);
          regUp = regLo.regionAbove();
          eUp = regUp.eUp;
        }
      }
    }

    if (eUp.org !== eLo.org) {
      if (eUp.dst() !== eLo.dst() && !regUp.fixUpperEdge &&
          !regLo.fixUpperEdge &&
          (eUp.dst() === tess.event || eLo.dst() === tess.event)) {
        /* When all else fails in checkForIntersect(), it uses tess.event
         * as the intersection location. To make this possible, it requires
         * that tess.event lie between the upper and lower edges, and also
         * that neither of these is marked fixUpperEdge (since in the worst
         * case it might splice one of these edges into tess.event, and
         * violate the invariant that fixable edges are the only right-going
         * edge from their associated vertex).
         */
        if (libtess.sweep.checkForIntersect_(tess, regUp)) {
          // walkDirtyRegions() was called recursively; we're done
          return;
        }

      } else {
        // Even though we can't use checkForIntersect(), the org vertices
        // may violate the dictionary edge ordering. Check and correct this.
        libtess.sweep.checkForRightSplice_(tess, regUp);
      }
    }

    if (eUp.org === eLo.org && eUp.dst() === eLo.dst()) {
      // A degenerate loop consisting of only two edges -- delete it.
      libtess.sweep.addWinding_(eLo, eUp);
      libtess.sweep.deleteRegion_(tess, regUp);
      libtess.mesh.deleteEdge(eUp);
      regUp = regLo.regionAbove();
    }
  }
};


/**
 * Purpose: connect a "right" vertex vEvent (one where all edges go left)
 * to the unprocessed portion of the mesh. Since there are no right-going
 * edges, two regions (one above vEvent and one below) are being merged
 * into one. regUp is the upper of these two regions.
 *
 * There are two reasons for doing this (adding a right-going edge):
 *  - if the two regions being merged are "inside", we must add an edge
 *    to keep them separated (the combined region would not be monotone).
 *  - in any case, we must leave some record of vEvent in the dictionary,
 *    so that we can merge vEvent with features that we have not seen yet.
 *    For example, maybe there is a vertical edge which passes just to
 *    the right of vEvent; we would like to splice vEvent into this edge.
 *
 * However, we don't want to connect vEvent to just any vertex. We don't
 * want the new edge to cross any other edges; otherwise we will create
 * intersection vertices even when the input data had no self-intersections.
 * (This is a bad thing; if the user's input data has no intersections,
 * we don't want to generate any false intersections ourselves.)
 *
 * Our eventual goal is to connect vEvent to the leftmost unprocessed
 * vertex of the combined region (the union of regUp and regLo).
 * But because of unseen vertices with all right-going edges, and also
 * new vertices which may be created by edge intersections, we don't
 * know where that leftmost unprocessed vertex is. In the meantime, we
 * connect vEvent to the closest vertex of either chain, and mark the region
 * as "fixUpperEdge". This flag says to delete and reconnect this edge
 * to the next processed vertex on the boundary of the combined region.
 * Quite possibly the vertex we connected to will turn out to be the
 * closest one, in which case we won't need to make any changes.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluHalfEdge} eBottomLeft [description].
 */
libtess.sweep.connectRightVertex_ = function(tess, regUp, eBottomLeft) {
  var eTopLeft = eBottomLeft.oNext;
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var degenerate = false;

  if (eUp.dst() !== eLo.dst()) {
    libtess.sweep.checkForIntersect_(tess, regUp);
  }

  // Possible new degeneracies: upper or lower edge of regUp may pass
  // through vEvent, or may coincide with new intersection vertex
  if (libtess.geom.vertEq(eUp.org, tess.event)) {
    libtess.mesh.meshSplice(eTopLeft.oPrev(), eUp);
    regUp = libtess.sweep.topLeftRegion_(regUp);
    eTopLeft = regUp.regionBelow().eUp;
    libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
    degenerate = true;
  }
  if (libtess.geom.vertEq(eLo.org, tess.event)) {
    libtess.mesh.meshSplice(eBottomLeft, eLo.oPrev());
    eBottomLeft = libtess.sweep.finishLeftRegions_(tess, regLo, null);
    degenerate = true;
  }
  if (degenerate) {
    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
        eTopLeft, true);
    return;
  }

  // Non-degenerate situation -- need to add a temporary, fixable edge.
  // Connect to the closer of eLo.org, eUp.org.
  var eNew;
  if (libtess.geom.vertLeq(eLo.org, eUp.org)) {
    eNew = eLo.oPrev();
  } else {
    eNew = eUp;
  }
  eNew = libtess.mesh.connect(eBottomLeft.lPrev(), eNew);

  // Prevent cleanup, otherwise eNew might disappear before we've even
  // had a chance to mark it as a temporary edge.
  libtess.sweep.addRightEdges_(tess, regUp, eNew, eNew.oNext, eNew.oNext,
      false);
  eNew.sym.activeRegion.fixUpperEdge = true;
  libtess.sweep.walkDirtyRegions_(tess, regUp);
};


/**
 * The event vertex lies exacty on an already-processed edge or vertex.
 * Adding the new vertex involves splicing it into the already-processed
 * part of the mesh.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.connectLeftDegenerate_ = function(tess, regUp, vEvent) {
  var e = regUp.eUp;
  /* istanbul ignore if */
  if (libtess.geom.vertEq(e.org, vEvent)) {
    // NOTE(bckenny): this code is unreachable but remains for a hypothetical
    // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
    // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
    // Compiler eliminate dead code.
    // e.org is an unprocessed vertex - just combine them, and wait
    // for e.org to be pulled from the queue
    if (libtess.sweep.TOLERANCE_NONZERO_) {
      libtess.sweep.spliceMergeVertices_(tess, e, vEvent.anEdge);
    }
    return;
  }

  if (!libtess.geom.vertEq(e.dst(), vEvent)) {
    // General case -- splice vEvent into edge e which passes through it
    libtess.mesh.splitEdge(e.sym);

    if (regUp.fixUpperEdge) {
      // This edge was fixable -- delete unused portion of original edge
      libtess.mesh.deleteEdge(e.oNext);
      regUp.fixUpperEdge = false;
    }

    libtess.mesh.meshSplice(vEvent.anEdge, e);

    // recurse
    libtess.sweep.sweepEvent_(tess, vEvent);
    return;
  }

  // NOTE(bckenny): this code is unreachable but remains for a hypothetical
  // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
  // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
  // Compiler eliminate dead code.
  // vEvent coincides with e.dst(), which has already been processed.
  // Splice in the additional right-going edges.
  /* istanbul ignore next */

  /* istanbul ignore next */
  if (libtess.sweep.TOLERANCE_NONZERO_) {
    regUp = libtess.sweep.topRightRegion_(regUp);
    var reg = regUp.regionBelow();
    var eTopRight = reg.eUp.sym;
    var eTopLeft = eTopRight.oNext;
    var eLast = eTopLeft;

    if (reg.fixUpperEdge) {
      // Here e.dst() has only a single fixable edge going right.
      // We can delete it since now we have some real right-going edges.

      // there are some left edges too
      libtess.sweep.deleteRegion_(tess, reg); // TODO(bckenny): something to null?
      libtess.mesh.deleteEdge(eTopRight);
      eTopRight = eTopLeft.oPrev();
    }

    libtess.mesh.meshSplice(vEvent.anEdge, eTopRight);
    if (!libtess.geom.edgeGoesLeft(eTopLeft)) {
      // e.dst() had no left-going edges -- indicate this to addRightEdges()
      eTopLeft = null;
    }

    libtess.sweep.addRightEdges_(tess, regUp, eTopRight.oNext, eLast, eTopLeft,
        true);
  }
};


/**
 * Connect a "left" vertex (one where both edges go right)
 * to the processed portion of the mesh. Let R be the active region
 * containing vEvent, and let U and L be the upper and lower edge
 * chains of R. There are two possibilities:
 *
 * - the normal case: split R into two regions, by connecting vEvent to
 *   the rightmost vertex of U or L lying to the left of the sweep line
 *
 * - the degenerate case: if vEvent is close enough to U or L, we
 *   merge vEvent into that edge chain. The subcases are:
 *  - merging with the rightmost vertex of U or L
 *  - merging with the active edge of U or L
 *  - merging with an already-processed portion of U or L
 *
 * @private
 * @param {libtess.GluTesselator} tess   [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.connectLeftVertex_ = function(tess, vEvent) {
  // TODO(bckenny): tmp only used for sweep. better to keep tmp across calls?
  var tmp = new libtess.ActiveRegion();

  // NOTE(bckenny): this was commented out in the original
  // libtess.assert(vEvent.anEdge.oNext.oNext === vEvent.anEdge);

  // Get a pointer to the active region containing vEvent
  tmp.eUp = vEvent.anEdge.sym;
  var regUp = tess.dict.search(tmp).getKey();
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;

  // try merging with U or L first
  if (libtess.geom.edgeSign(eUp.dst(), vEvent, eUp.org) === 0) {
    libtess.sweep.connectLeftDegenerate_(tess, regUp, vEvent);
    return;
  }

  // Connect vEvent to rightmost processed vertex of either chain.
  // e.dst() is the vertex that we will connect to vEvent.
  var reg = libtess.geom.vertLeq(eLo.dst(), eUp.dst()) ? regUp : regLo;
  var eNew;
  if (regUp.inside || reg.fixUpperEdge) {
    if (reg === regUp) {
      eNew = libtess.mesh.connect(vEvent.anEdge.sym, eUp.lNext);

    } else {
      var tempHalfEdge = libtess.mesh.connect(eLo.dNext(), vEvent.anEdge);
      eNew = tempHalfEdge.sym;
    }

    if (reg.fixUpperEdge) {
      libtess.sweep.fixUpperEdge_(reg, eNew);

    } else {
      libtess.sweep.computeWinding_(tess,
          libtess.sweep.addRegionBelow_(tess, regUp, eNew));
    }
    libtess.sweep.sweepEvent_(tess, vEvent);

  } else {
    // The new vertex is in a region which does not belong to the polygon.
    // We don''t need to connect this vertex to the rest of the mesh.
    libtess.sweep.addRightEdges_(tess, regUp, vEvent.anEdge, vEvent.anEdge,
        null, true);
  }
};


/**
 * Does everything necessary when the sweep line crosses a vertex.
 * Updates the mesh and the edge dictionary.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.sweepEvent_ = function(tess, vEvent) {
  tess.event = vEvent; // for access in edgeLeq_ // TODO(bckenny): wuh?

  /* Check if this vertex is the right endpoint of an edge that is
   * already in the dictionary.  In this case we don't need to waste
   * time searching for the location to insert new edges.
   */
  var e = vEvent.anEdge;
  while (e.activeRegion === null) {
    e = e.oNext;
    if (e === vEvent.anEdge) {
      // All edges go right -- not incident to any processed edges
      libtess.sweep.connectLeftVertex_(tess, vEvent);
      return;
    }
  }

  /* Processing consists of two phases: first we "finish" all the
   * active regions where both the upper and lower edges terminate
   * at vEvent (ie. vEvent is closing off these regions).
   * We mark these faces "inside" or "outside" the polygon according
   * to their winding number, and delete the edges from the dictionary.
   * This takes care of all the left-going edges from vEvent.
   */
  var regUp = libtess.sweep.topLeftRegion_(e.activeRegion);
  var reg = regUp.regionBelow();
  var eTopLeft = reg.eUp;
  var eBottomLeft = libtess.sweep.finishLeftRegions_(tess, reg, null);

  /* Next we process all the right-going edges from vEvent. This
   * involves adding the edges to the dictionary, and creating the
   * associated "active regions" which record information about the
   * regions between adjacent dictionary edges.
   */
  if (eBottomLeft.oNext === eTopLeft) {
    // No right-going edges -- add a temporary "fixable" edge
    libtess.sweep.connectRightVertex_(tess, regUp, eBottomLeft);

  } else {
    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
        eTopLeft, true);
  }
};


/**
 * We add two sentinel edges above and below all other edges,
 * to avoid special cases at the top and bottom.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {number} t [description].
 */
libtess.sweep.addSentinel_ = function(tess, t) {
  var reg = new libtess.ActiveRegion();

  var e = libtess.mesh.makeEdge(tess.mesh);

  e.org.s = libtess.sweep.SENTINEL_COORD_;
  e.org.t = t;
  e.dst().s = -libtess.sweep.SENTINEL_COORD_;
  e.dst().t = t;
  tess.event = e.dst(); //initialize it

  reg.eUp = e;
  reg.windingNumber = 0;
  reg.inside = false;
  reg.fixUpperEdge = false;
  reg.sentinel = true;
  reg.dirty = false;
  reg.nodeUp = tess.dict.insert(reg);
};


/**
 * We maintain an ordering of edge intersections with the sweep line.
 * This order is maintained in a dynamic dictionary.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.initEdgeDict_ = function(tess) {
  tess.dict = new libtess.Dict(tess, libtess.sweep.edgeLeq_);

  libtess.sweep.addSentinel_(tess, -libtess.sweep.SENTINEL_COORD_);
  libtess.sweep.addSentinel_(tess, libtess.sweep.SENTINEL_COORD_);
};


/**
 * [doneEdgeDict_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.doneEdgeDict_ = function(tess) {
  // NOTE(bckenny): fixedEdges is only used in the assert below, so ignore so
  // when asserts are removed jshint won't error.
  /* jshint unused:false */
  var fixedEdges = 0;

  var reg;
  while ((reg = tess.dict.getMin().getKey()) !== null) {
    // At the end of all processing, the dictionary should contain
    // only the two sentinel edges, plus at most one "fixable" edge
    // created by connectRightVertex().
    if (!reg.sentinel) {
    }
    libtess.sweep.deleteRegion_(tess, reg);
  }

  // NOTE(bckenny): see tess.dict.deleteDict_() for old delete dict function
  tess.dict = null;
};


/**
 * Remove zero-length edges, and contours with fewer than 3 vertices.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.removeDegenerateEdges_ = function(tess) {
  var eHead = tess.mesh.eHead;

  var eNext;
  for (var e = eHead.next; e !== eHead; e = eNext) {
    eNext = e.next;
    var eLNext = e.lNext;

    if (libtess.geom.vertEq(e.org, e.dst()) && e.lNext.lNext !== e) {
      // Zero-length edge, contour has at least 3 edges
      libtess.sweep.spliceMergeVertices_(tess, eLNext, e); // deletes e.org
      libtess.mesh.deleteEdge(e); // e is a self-loop TODO(bckenny): does this comment really apply here?
      e = eLNext;
      eLNext = e.lNext;
    }

    if (eLNext.lNext === e) {
      // Degenerate contour (one or two edges)
      if (eLNext !== e) {
        if (eLNext === eNext || eLNext === eNext.sym) {
          eNext = eNext.next;
        }
        libtess.mesh.deleteEdge(eLNext);
      }

      if (e === eNext || e === eNext.sym) {
        eNext = eNext.next;
      }
      libtess.mesh.deleteEdge(e);
    }
  }
};


/**
 * Construct priority queue and insert all vertices into it, which determines
 * the order in which vertices cross the sweep line.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.initPriorityQ_ = function(tess) {
  var pq = new libtess.PriorityQ();
  tess.pq = pq;

  var vHead = tess.mesh.vHead;
  var v;
  for (v = vHead.next; v !== vHead; v = v.next) {
    v.pqHandle = pq.insert(v);
  }

  pq.init();
};


/**
 * [donePriorityQ_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.donePriorityQ_ = function(tess) {
  // TODO(bckenny): probably don't need deleteQ. check that function for comment
  tess.pq.deleteQ();
  tess.pq = null;
};


/**
 * Delete any degenerate faces with only two edges. walkDirtyRegions()
 * will catch almost all of these, but it won't catch degenerate faces
 * produced by splice operations on already-processed edges.
 * The two places this can happen are in finishLeftRegions(), when
 * we splice in a "temporary" edge produced by connectRightVertex(),
 * and in checkForLeftSplice(), where we splice already-processed
 * edges to ensure that our dictionary invariants are not violated
 * by numerical errors.
 *
 * In both these cases it is *very* dangerous to delete the offending
 * edge at the time, since one of the routines further up the stack
 * will sometimes be keeping a pointer to that edge.
 *
 * @private
 * @param {libtess.GluMesh} mesh [description].
 */
libtess.sweep.removeDegenerateFaces_ = function(mesh) {
  var fNext;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {
    fNext = f.next;
    var e = f.anEdge;

    if (e.lNext.lNext === e) {
      // A face with only two edges
      libtess.sweep.addWinding_(e.oNext, e);
      libtess.mesh.deleteEdge(e);
    }
  }
};

/* global libtess */

/** @const */
libtess.tessmono = {};

/**
 * Tessellates a monotone region (what else would it do??). The region must
 * consist of a single loop of half-edges (see mesh.js) oriented CCW. "Monotone"
 * in this case means that any vertical line intersects the interior of the
 * region in a single interval.
 *
 * Tessellation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 * @private
 * @param {!libtess.GluFace} face
 */
libtess.tessmono.tessellateMonoRegion_ = function(face) {
  /* The basic idea is explained in Preparata and Shamos (which I don't
   * have handy right now), although their implementation is more
   * complicated than this one. The are two edge chains, an upper chain
   * and a lower chain. We process all vertices from both chains in order,
   * from right to left.
   *
   * The algorithm ensures that the following invariant holds after each
   * vertex is processed: the untessellated region consists of two
   * chains, where one chain (say the upper) is a single edge, and
   * the other chain is concave. The left vertex of the single edge
   * is always to the left of all vertices in the concave chain.
   *
   * Each step consists of adding the rightmost unprocessed vertex to one
   * of the two chains, and forming a fan of triangles from the rightmost
   * of two chain endpoints. Determining whether we can add each triangle
   * to the fan is a simple orientation test. By making the fan as large
   * as possible, we restore the invariant (check it yourself).
   *
   * All edges are oriented CCW around the boundary of the region.
   * First, find the half-edge whose origin vertex is rightmost.
   * Since the sweep goes from left to right, face.anEdge should
   * be close to the edge we want.
   */
  var up = face.anEdge;

  for (; libtess.geom.vertLeq(up.dst(), up.org); up = up.lPrev()) { }
  for (; libtess.geom.vertLeq(up.org, up.dst()); up = up.lNext) { }

  var lo = up.lPrev();

  var tempHalfEdge;
  while (up.lNext !== lo) {
    if (libtess.geom.vertLeq(up.dst(), lo.org)) {
      // up.dst() is on the left. It is safe to form triangles from lo.org.
      // The edgeGoesLeft test guarantees progress even when some triangles
      // are CW, given that the upper and lower chains are truly monotone.
      while (lo.lNext !== up && (libtess.geom.edgeGoesLeft(lo.lNext) ||
          libtess.geom.edgeSign(lo.org, lo.dst(), lo.lNext.dst()) <= 0)) {

        tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
        lo = tempHalfEdge.sym;
      }
      lo = lo.lPrev();

    } else {
      // lo.org is on the left. We can make CCW triangles from up.dst().
      while (lo.lNext !== up && (libtess.geom.edgeGoesRight(up.lPrev()) ||
          libtess.geom.edgeSign(up.dst(), up.org, up.lPrev().org) >= 0)) {

        tempHalfEdge = libtess.mesh.connect(up, up.lPrev());
        up = tempHalfEdge.sym;
      }
      up = up.lNext;
    }
  }

  // Now lo.org == up.dst() == the leftmost vertex. The remaining region
  // can be tessellated in a fan from this leftmost vertex.
  while (lo.lNext.lNext !== up) {
    tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
    lo = tempHalfEdge.sym;
  }
};

/**
 * Tessellates each region of the mesh which is marked "inside" the polygon.
 * Each such region must be monotone.
 * @param {!libtess.GluMesh} mesh
 */
libtess.tessmono.tessellateInterior = function(mesh) {
  var next;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
    // Make sure we don't try to tessellate the new triangles.
    next = f.next;
    if (f.inside) {
      libtess.tessmono.tessellateMonoRegion_(f);
    }
  }
};

/**
 * Zaps (i.e. sets to null) all faces which are not marked "inside" the polygon.
 * Since further mesh operations on null faces are not allowed, the main purpose
 * is to clean up the mesh so that exterior loops are not represented in the
 * data structure.
 * @param {!libtess.GluMesh} mesh
 */
libtess.tessmono.discardExterior = function(mesh) {
  var next;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
    // Since f will be destroyed, save its next pointer.
    next = f.next;
    if (!f.inside) {
      libtess.mesh.zapFace(f);
    }
  }
};

/**
 * Resets the winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside have a winding
 * number of 0.
 *
 * If keepOnlyBoundary is true, it also deletes all edges which do not separate
 * an interior region from an exterior one.
 *
 * @param {!libtess.GluMesh} mesh
 * @param {number} value
 * @param {boolean} keepOnlyBoundary
 */
libtess.tessmono.setWindingNumber = function(mesh, value, keepOnlyBoundary) {
  var eNext;
  for (var e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {
    eNext = e.next;

    if (e.rFace().inside !== e.lFace.inside) {
      // This is a boundary edge (one side is interior, one is exterior).
      e.winding = (e.lFace.inside) ? value : -value;

    } else {
      // Both regions are interior, or both are exterior.
      if (!keepOnlyBoundary) {
        e.winding = 0;

      } else {
        libtess.mesh.deleteEdge(e);
      }
    }
  }
};

/* global libtess */

/**
 * A list of edges crossing the sweep line, sorted from top to bottom.
 * Implementation is a doubly-linked list, sorted by the injected edgeLeq
 * comparator function. Here it is a simple ordering, but see libtess.sweep for
 * the list of invariants on the edge dictionary this ordering creates.
 * @constructor
 * @struct
 * @param {!libtess.GluTesselator} frame
 * @param {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean} leq
 */
libtess.Dict = function(frame, leq) {

  /**
   * The head of the doubly-linked DictNode list. At creation time, links back
   * and forward only to itself.
   * @private {!libtess.DictNode}
   */
  this.head_ = new libtess.DictNode();

  /**
   * The GluTesselator used as the frame for edge/event comparisons.
   * @private {!libtess.GluTesselator}
   */
  this.frame_ = frame;

  /**
   * Comparison function to maintain the invariants of the Dict. See
   * libtess.sweep.edgeLeq_ for source.
   * @private
   * @type {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean}
   */
  this.leq_ = leq;
};

/* istanbul ignore next */
/**
 * Formerly used to delete the dict.
 * NOTE(bckenny): No longer called but left for memFree documentation. Nulled at
 * former callsite instead (sweep.doneEdgeDict_)
 * @private
 */
libtess.Dict.prototype.deleteDict_ = function() {
  // for (var node = this.head_.next; node !== this.head_; node = node.next) {
  //   memFree(node);
  // }
  // memFree(dict);
};

/**
 * Insert the supplied key into the edge list and return its new node.
 * @param {libtess.DictNode} node
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.insertBefore = function(node, key) {
  do {
    node = node.prev;
  } while (node.key !== null && !this.leq_(this.frame_, node.key, key));

  // insert the new node and update the surrounding nodes to point to it
  var newNode = new libtess.DictNode(key, node.next, node);
  node.next.prev = newNode;
  node.next = newNode;

  return newNode;
};

/**
 * Insert key into the dict and return the new node that contains it.
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.insert = function(key) {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.insertBefore(this.head_, key);
};

/**
 * Remove node from the list.
 * @param {libtess.DictNode} node
 */
libtess.Dict.prototype.deleteNode = function(node) {
  node.next.prev = node.prev;
  node.prev.next = node.next;

  // NOTE(bckenny): nulled at callsite (sweep.deleteRegion_)
  // memFree( node );
};

/**
 * Search returns the node with the smallest key greater than or equal
 * to the given key. If there is no such key, returns a node whose
 * key is null. Similarly, max(d).getSuccessor() has a null key, etc.
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.search = function(key) {
  var node = this.head_;

  do {
    node = node.next;
  } while (node.key !== null && !this.leq_(this.frame_, key, node.key));

  return node;
};

/**
 * Return the node with the smallest key.
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.getMin = function() {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.head_.next;
};

// NOTE(bckenny): libtess.Dict.getMax isn't called within libtess and isn't part
// of the public API. For now, leaving in but ignoring for coverage.
/* istanbul ignore next */
/**
 * Returns the node with the greatest key.
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.getMax = function() {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.head_.prev;
};

/* global libtess */

/**
 * A doubly-linked-list node with a libtess.ActiveRegion payload.
 * The key for this node and the next and previous nodes in the parent Dict list
 * can be provided to insert it into an existing list (or all can be omitted if
 * this is to be the founding node of the list).
 * @param {!libtess.ActiveRegion=} opt_key
 * @param {!libtess.DictNode=} opt_nextNode
 * @param {!libtess.DictNode=} opt_prevNode
 * @constructor
 * @struct
 */
libtess.DictNode = function(opt_key, opt_nextNode, opt_prevNode) {
  /**
   * The ActiveRegion key for this node, or null if the head of the list.
   * @type {libtess.ActiveRegion}
   */
  this.key = opt_key || null;

  /**
   * Link to next DictNode in parent list or to self if this is the first node.
   * @type {!libtess.DictNode}
   */
  this.next = opt_nextNode || this;

  /**
   * Link to previous DictNode in parent list or to self if this is the first
   * node.
   * @type {!libtess.DictNode}
   */
  this.prev = opt_prevNode || this;
};

/**
 * Get the key from this node.
 * @return {libtess.ActiveRegion}
 */
libtess.DictNode.prototype.getKey = function() {
  return this.key;
};

/**
 * Get the successor node to this one.
 * @return {!libtess.DictNode}
 */
libtess.DictNode.prototype.getSuccessor = function() {
  return this.next;
};

/**
 * Get the predecessor node to this one.
 * @return {!libtess.DictNode}
 */
libtess.DictNode.prototype.getPredecessor = function() {
  return this.prev;
};

/* global libtess */

// TODO(bckenny): create more javascript-y API, e.g. make gluTessEndPolygon
// async, don't require so many temp objects created

/**
 * The tesselator main class, providing the public API.
 * @constructor
 * @struct
 */
libtess.GluTesselator = function() {
  // Only initialize fields which can be changed by the api. Other fields
  // are initialized where they are used.

  /*** state needed for collecting the input data ***/

  /**
   * Tesselator state, tracking what begin/end calls have been seen.
   * @private {libtess.GluTesselator.tessState_}
   */
  this.state_ = libtess.GluTesselator.tessState_.T_DORMANT;

  /**
   * lastEdge_.org is the most recent vertex
   * @private {libtess.GluHalfEdge}
   */
  this.lastEdge_ = null;

  /**
   * stores the input contours, and eventually the tessellation itself
   * @type {libtess.GluMesh}
   */
  this.mesh = null;

  /**
   * Error callback.
   * @private {?function((libtess.errorType|libtess.gluEnum), Object=)}
   */
  this.errorCallback_ = null;

  /*** state needed for projecting onto the sweep plane ***/

  /**
   * user-specified normal (if provided)
   * @private {!Array<number>}
   */
  this.normal_ = [0, 0, 0];

  /*** state needed for the line sweep ***/

  /**
   * rule for determining polygon interior
   * @type {libtess.windingRule}
   */
  this.windingRule = libtess.windingRule.GLU_TESS_WINDING_ODD;

  /**
   * fatal error: needed combine callback
   * @type {boolean}
   */
  this.fatalError = false;

  /**
   * edge dictionary for sweep line
   * @type {libtess.Dict}
   */
  this.dict = null;
  // NOTE(bckenny): dict initialized in sweep.initEdgeDict_, removed in sweep.doneEdgeDict_

  /**
   * priority queue of vertex events
   * @type {libtess.PriorityQ}
   */
  this.pq = null;
  // NOTE(bckenny): pq initialized in sweep.initPriorityQ

  /**
   * current sweep event being processed
   * @type {libtess.GluVertex}
   */
  this.event = null;

  /**
   * Combine callback.
   * @private {?function(Array<number>, Array<Object>, Array<number>, Object=): Object}
   */
  this.combineCallback_ = null;

  /*** state needed for rendering callbacks (see render.js) ***/

  /**
   * Extract contours, not triangles
   * @private {boolean}
   */
  this.boundaryOnly_ = false;

  /**
   * Begin callback.
   * @private {?function(libtess.primitiveType, Object=)}
   */
  this.beginCallback_ = null;

  /**
   * Edge flag callback.
   * @private {?function(boolean, Object=)}
   */
  this.edgeFlagCallback_ = null;

  /**
   * Vertex callback.
   * @private {?function(Object, Object=)}
   */
  this.vertexCallback_ = null;

  /**
   * End callback.
   * @private {?function(Object=)}
   */
  this.endCallback_ = null;

  /**
   * Mesh callback.
   * @private {?function(libtess.GluMesh)}
   */
  this.meshCallback_ = null;

  /**
   * client data for current polygon
   * @private {Object}
   */
  this.polygonData_ = null;
};

/**
 * The begin/end calls must be properly nested. We keep track of the current
 * state to enforce the ordering.
 * @enum {number}
 * @private
 */
libtess.GluTesselator.tessState_ = {
  T_DORMANT: 0,
  T_IN_POLYGON: 1,
  T_IN_CONTOUR: 2
};

/**
 * Destory the tesselator object. See README.
 */
libtess.GluTesselator.prototype.gluDeleteTess = function() {
  // TODO(bckenny): This does nothing but assert that it isn't called while
  // building the polygon since we rely on GC to handle memory. *If* the public
  // API changes, this should go.
  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);
  // memFree(tess); TODO(bckenny)
};

/**
 * Set properties for control over tesselation. See README.
 * @param {libtess.gluEnum} which [description].
 * @param {number|boolean} value [description].
 */
libtess.GluTesselator.prototype.gluTessProperty = function(which, value) {
  // TODO(bckenny): split into more setters?
  // TODO(bckenny): in any case, we can do better than this switch statement

  switch (which) {
    case libtess.gluEnum.GLU_TESS_TOLERANCE:
      // NOTE(bckenny): libtess has never supported any tolerance but 0.
      return;

    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
      var windingRule = /** @type {libtess.windingRule} */(value);

      switch (windingRule) {
        case libtess.windingRule.GLU_TESS_WINDING_ODD:
        case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
        case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
        case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
        case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
          this.windingRule = windingRule;
          return;
        default:
      }
      break;

    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
      this.boundaryOnly_ = !!value;
      return;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      return;
  }
  this.callErrorCallback(libtess.gluEnum.GLU_INVALID_VALUE);
};

/**
 * Returns tessellator property
 * @param {libtess.gluEnum} which [description].
 * @return {number|boolean} [description].
 */
libtess.GluTesselator.prototype.gluGetTessProperty = function(which) {
  // TODO(bckenny): as above, split into more getters? and improve on switch statement
  // why are these being asserted in getter but not setter?

  switch (which) {
    case libtess.gluEnum.GLU_TESS_TOLERANCE:
      return 0;

    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
      var rule = this.windingRule;
      return rule;

    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
      return this.boundaryOnly_;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      break;
  }
  return false;
};

/**
 * Lets the user supply the polygon normal, if known. All input data is
 * projected into a plane perpendicular to the normal before tesselation. All
 * output triangles are oriented CCW with respect to the normal (CW orientation
 * can be obtained by reversing the sign of the supplied normal). For example,
 * if you know that all polygons lie in the x-y plane, call
 * `tess.gluTessNormal(0.0, 0.0, 1.0)` before rendering any polygons.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 */
libtess.GluTesselator.prototype.gluTessNormal = function(x, y, z) {
  this.normal_[0] = x;
  this.normal_[1] = y;
  this.normal_[2] = z;
};

/**
 * Specify callbacks. See README for callback descriptions. A null or undefined
 * opt_fn removes current callback.
 * @param {libtess.gluEnum} which The callback-type gluEnum value.
 * @param {?Function=} opt_fn
 */
libtess.GluTesselator.prototype.gluTessCallback = function(which, opt_fn) {
  var fn = !opt_fn ? null : opt_fn;
  // TODO(bckenny): better opt_fn typing?
  // TODO(bckenny): should add documentation that references in callback are volatile (or make a copy)

  switch (which) {
    case libtess.gluEnum.GLU_TESS_BEGIN:
    case libtess.gluEnum.GLU_TESS_BEGIN_DATA:
      this.beginCallback_ = /** @type {?function(libtess.primitiveType, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_EDGE_FLAG:
    case libtess.gluEnum.GLU_TESS_EDGE_FLAG_DATA:
      this.edgeFlagCallback_ = /** @type {?function(boolean, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_VERTEX:
    case libtess.gluEnum.GLU_TESS_VERTEX_DATA:
      this.vertexCallback_ = /** @type {?function(Object, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_END:
    case libtess.gluEnum.GLU_TESS_END_DATA:
      this.endCallback_ = /** @type {?function(Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_ERROR:
    case libtess.gluEnum.GLU_TESS_ERROR_DATA:
      this.errorCallback_ = /** @type {?function((libtess.errorType|libtess.gluEnum), Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_COMBINE:
    case libtess.gluEnum.GLU_TESS_COMBINE_DATA:
      this.combineCallback_ = /** @type {?function(Array<number>, Array<Object>, Array<number>, Object=): Object} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_MESH:
      this.meshCallback_ = /** @type {?function(libtess.GluMesh)} */ (fn);
      return;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      return;
  }
};

/**
 * Specify a vertex and associated data. Must be within calls to
 * beginContour/endContour. See README.
 * @param {!Array<number>} coords
 * @param {Object} data
 */
libtess.GluTesselator.prototype.gluTessVertex = function(coords, data) {
  var tooLarge = false;

  // TODO(bckenny): pool allocation?
  var clamped = [0, 0, 0];

  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);

  for (var i = 0; i < 3; ++i) {
    var x = coords[i];
    if (x < -libtess.GLU_TESS_MAX_COORD) {
      x = -libtess.GLU_TESS_MAX_COORD;
      tooLarge = true;
    }
    if (x > libtess.GLU_TESS_MAX_COORD) {
      x = libtess.GLU_TESS_MAX_COORD;
      tooLarge = true;
    }
    clamped[i] = x;
  }

  if (tooLarge) {
    this.callErrorCallback(libtess.errorType.GLU_TESS_COORD_TOO_LARGE);
  }

  this.addVertex_(clamped, data);
};

/**
 * [gluTessBeginPolygon description]
 * @param {Object} data Client data for current polygon.
 */
libtess.GluTesselator.prototype.gluTessBeginPolygon = function(data) {
  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);

  this.state_ = libtess.GluTesselator.tessState_.T_IN_POLYGON;

  this.mesh = new libtess.GluMesh();

  this.polygonData_ = data;
};

/**
 * [gluTessBeginContour description]
 */
libtess.GluTesselator.prototype.gluTessBeginContour = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);

  this.state_ = libtess.GluTesselator.tessState_.T_IN_CONTOUR;
  this.lastEdge_ = null;
};

/**
 * [gluTessEndContour description]
 */
libtess.GluTesselator.prototype.gluTessEndContour = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);
  this.state_ = libtess.GluTesselator.tessState_.T_IN_POLYGON;
};

/**
 * [gluTessEndPolygon description]
 */
libtess.GluTesselator.prototype.gluTessEndPolygon = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);
  this.state_ = libtess.GluTesselator.tessState_.T_DORMANT;

  // Determine the polygon normal and project vertices onto the plane
  // of the polygon.
  libtess.normal.projectPolygon(this, this.normal_[0], this.normal_[1],
      this.normal_[2]);

  // computeInterior(tess) computes the planar arrangement specified
  // by the given contours, and further subdivides this arrangement
  // into regions. Each region is marked "inside" if it belongs
  // to the polygon, according to the rule given by this.windingRule.
  // Each interior region is guaranteed be monotone.
  libtess.sweep.computeInterior(this);

  if (!this.fatalError) {
    // If the user wants only the boundary contours, we throw away all edges
    // except those which separate the interior from the exterior.
    // Otherwise we tessellate all the regions marked "inside".
    // NOTE(bckenny): we know this.mesh has been initialized, so help closure out.
    var mesh = /** @type {!libtess.GluMesh} */(this.mesh);
    if (this.boundaryOnly_) {
      libtess.tessmono.setWindingNumber(mesh, 1, true);
    } else {
      libtess.tessmono.tessellateInterior(mesh);
    }

    this.mesh.checkMesh();

    if (this.beginCallback_ || this.endCallback_ || this.vertexCallback_ ||
        this.edgeFlagCallback_) {

      if (this.boundaryOnly_) {
        // output boundary contours
        libtess.render.renderBoundary(this, this.mesh);

      } else {
        // output triangles (with edge callback if one is set)
        var flagEdges = !!this.edgeFlagCallback_;
        libtess.render.renderMesh(this, this.mesh, flagEdges);
      }
    }

    if (this.meshCallback_) {
      // Throw away the exterior faces, so that all faces are interior.
      // This way the user doesn't have to check the "inside" flag,
      // and we don't need to even reveal its existence. It also leaves
      // the freedom for an implementation to not generate the exterior
      // faces in the first place.
      libtess.tessmono.discardExterior(this.mesh);
      // user wants the mesh itself
      this.meshCallback_(this.mesh);

      this.mesh = null;
      this.polygonData_ = null;
      return;
    }
  }

  libtess.mesh.deleteMesh(this.mesh);
  this.polygonData_ = null;
  this.mesh = null;
};

/**
 * Change the tesselator state.
 * @private
 * @param {libtess.GluTesselator.tessState_} state
 */
libtess.GluTesselator.prototype.requireState_ = function(state) {
  if (this.state_ !== state) {
    this.gotoState_(state);
  }
};

/**
 * Change the current tesselator state one level at a time to get to the
 * desired state. Only triggered when the API is not called in the correct order
 * so an error callback is made, however the tesselator will always attempt to
 * recover afterwards (see README).
 * @private
 * @param {libtess.GluTesselator.tessState_} newState
 */
libtess.GluTesselator.prototype.gotoState_ = function(newState) {
  while (this.state_ !== newState) {
    if (this.state_ < newState) {
      switch (this.state_) {
        case libtess.GluTesselator.tessState_.T_DORMANT:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_BEGIN_POLYGON);
          this.gluTessBeginPolygon(null);
          break;

        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_BEGIN_CONTOUR);
          this.gluTessBeginContour();
          break;
      }

    } else {
      switch (this.state_) {
        case libtess.GluTesselator.tessState_.T_IN_CONTOUR:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_END_CONTOUR);
          this.gluTessEndContour();
          break;

        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_END_POLYGON);
          // NOTE(bckenny): libtess originally reset the tesselator, even though
          // the README claims it should spit out the tessellated results at
          // this point.
          // (see http://cgit.freedesktop.org/mesa/glu/tree/src/libtess/tess.c#n180)
          this.gluTessEndPolygon();
          break;
      }
    }
  }
};

/**
 * [addVertex_ description]
 * @private
 * @param {!Array<number>} coords [description].
 * @param {Object} data [description].
 */
libtess.GluTesselator.prototype.addVertex_ = function(coords, data) {
  var e = this.lastEdge_;
  if (e === null) {
    // Make a self-loop (one vertex, one edge).
    e = libtess.mesh.makeEdge(this.mesh);
    libtess.mesh.meshSplice(e, e.sym);

  } else {
    // Create a new vertex and edge which immediately follow e
    // in the ordering around the left face.
    libtess.mesh.splitEdge(e);
    e = e.lNext;
  }

  // The new vertex is now e.org.
  e.org.data = data;
  e.org.coords[0] = coords[0];
  e.org.coords[1] = coords[1];
  e.org.coords[2] = coords[2];

  // The winding of an edge says how the winding number changes as we
  // cross from the edge''s right face to its left face.  We add the
  // vertices in such an order that a CCW contour will add +1 to
  // the winding number of the region inside the contour.
  e.winding = 1;
  e.sym.winding = -1;

  this.lastEdge_ = e;
};

/**
 * Call callback to indicate the start of a primitive, to be followed by emitted
 * vertices, if any. In libtess.js, `type` will always be `GL_TRIANGLES`.
 * @param {libtess.primitiveType} type
 */
libtess.GluTesselator.prototype.callBeginCallback = function(type) {
  if (this.beginCallback_) {
    this.beginCallback_(type, this.polygonData_);
  }
};

/**
 * Call callback to emit a vertex of the tessellated polygon.
 * @param {Object} data
 */
libtess.GluTesselator.prototype.callVertexCallback = function(data) {
  if (this.vertexCallback_) {
    this.vertexCallback_(data, this.polygonData_);
  }
};

/**
 * Call callback to indicate whether the vertices to follow begin edges which
 * lie on a polygon boundary.
 * @param {boolean} flag
 */
libtess.GluTesselator.prototype.callEdgeFlagCallback = function(flag) {
  if (this.edgeFlagCallback_) {
    this.edgeFlagCallback_(flag, this.polygonData_);
  }
};

/**
 * Call callback to indicate the end of tessellation.
 */
libtess.GluTesselator.prototype.callEndCallback = function() {
  if (this.endCallback_) {
    this.endCallback_(this.polygonData_);
  }
};

/* jscs:disable maximumLineLength */
/**
 * Call callback for combining vertices at edge intersection requiring the
 * creation of a new vertex.
 * @param {!Array<number>} coords Intersection coordinates.
 * @param {!Array<Object>} data Array of vertex data, one per edge vertices.
 * @param {!Array<number>} weight Coefficients used for the linear combination of vertex coordinates that gives coords.
 * @return {?Object} Interpolated vertex.
 */
libtess.GluTesselator.prototype.callCombineCallback = function(coords, data, weight) {
  if (this.combineCallback_) {
    return this.combineCallback_(coords, data, weight, this.polygonData_) ||
        null;
  }

  return null;
};
/* jscs:enable maximumLineLength */

/**
 * Call error callback, if specified, with errno.
 * @param {(libtess.errorType|libtess.gluEnum)} errno
 */
libtess.GluTesselator.prototype.callErrorCallback = function(errno) {
  if (this.errorCallback_) {
    this.errorCallback_(errno, this.polygonData_);
  }
};

/* global libtess */

/**
 * Each face has a pointer to the next and previous faces in the
 * circular list, and a pointer to a half-edge with this face as
 * the left face (null if this is the dummy header). There is also
 * a field "data" for client data.
 *
 * @param {libtess.GluFace=} opt_nextFace
 * @param {libtess.GluFace=} opt_prevFace
 * @constructor
 * @struct
 */
libtess.GluFace = function(opt_nextFace, opt_prevFace) {
  // TODO(bckenny): reverse order of params?

  /**
   * next face (never null)
   * @type {!libtess.GluFace}
   */
  this.next = opt_nextFace || this;

  /**
   * previous face (never NULL)
   * @type {!libtess.GluFace}
   */
  this.prev = opt_prevFace || this;

  /**
   * A half edge with this left face.
   * @type {libtess.GluHalfEdge}
   */
  this.anEdge = null;

  /**
   * room for client's data
   * @type {Object}
   */
  this.data = null;

  /**
   * This face is in the polygon interior.
   * @type {boolean}
   */
  this.inside = false;
};

/* global libtess */

/**
 * The fundamental data structure is the "half-edge". Two half-edges
 * go together to make an edge, but they point in opposite directions.
 * Each half-edge has a pointer to its mate (the "symmetric" half-edge sym),
 * its origin vertex (org), the face on its left side (lFace), and the
 * adjacent half-edges in the CCW direction around the origin vertex
 * (oNext) and around the left face (lNext). There is also a "next"
 * pointer for the global edge list (see below).
 *
 * The notation used for mesh navigation:
 *  sym   = the mate of a half-edge (same edge, but opposite direction)
 *  oNext = edge CCW around origin vertex (keep same origin)
 *  dNext = edge CCW around destination vertex (keep same dest)
 *  lNext = edge CCW around left face (dest becomes new origin)
 *  rNext = edge CCW around right face (origin becomes new dest)
 *
 * "prev" means to substitute CW for CCW in the definitions above.
 *
 * The circular edge list is special; since half-edges always occur
 * in pairs (e and e.sym), each half-edge stores a pointer in only
 * one direction. Starting at eHead and following the e.next pointers
 * will visit each *edge* once (ie. e or e.sym, but not both).
 * e.sym stores a pointer in the opposite direction, thus it is
 * always true that e.sym.next.sym.next === e.
 *
 * @param {libtess.GluHalfEdge=} opt_nextEdge
 * @constructor
 * @struct
 */
libtess.GluHalfEdge = function(opt_nextEdge) {
  // TODO(bckenny): are these the right defaults? (from gl_meshNewMesh requirements)

  /**
   * doubly-linked list (prev==sym->next)
   * @type {!libtess.GluHalfEdge}
   */
  this.next = opt_nextEdge || this;

  // TODO(bckenny): how can this be required if created in pairs? move to factory creation only?
  /**
   * same edge, opposite direction
   * @type {libtess.GluHalfEdge}
   */
  this.sym = null;

  /**
   * next edge CCW around origin
   * @type {libtess.GluHalfEdge}
   */
  this.oNext = null;

  /**
   * next edge CCW around left face
   * @type {libtess.GluHalfEdge}
   */
  this.lNext = null;

  /**
   * origin vertex (oVertex too long)
   * @type {libtess.GluVertex}
   */
  this.org = null;

  /**
   * left face
   * @type {libtess.GluFace}
   */
  this.lFace = null;

  // Internal data (keep hidden)
  // NOTE(bckenny): can't be private, though...

  /**
   * a region with this upper edge (see sweep.js)
   * @type {libtess.ActiveRegion}
   */
  this.activeRegion = null;

  /**
   * change in winding number when crossing from the right face to the left face
   * @type {number}
   */
  this.winding = 0;
};

// NOTE(bckenny): the following came from macros in mesh
// TODO(bckenny): using methods as aliases for sym connections for now.
// not sure about this approach. getters? renames?


/**
 * [rFace description]
 * @return {libtess.GluFace} [description].
 */
libtess.GluHalfEdge.prototype.rFace = function() {
  return this.sym.lFace;
};


/**
 * [dst description]
 * @return {libtess.GluVertex} [description].
 */
libtess.GluHalfEdge.prototype.dst = function() {
  return this.sym.org;
};


/**
 * [oPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.oPrev = function() {
  return this.sym.lNext;
};


/**
 * [lPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.lPrev = function() {
  return this.oNext.sym;
};

// NOTE(bckenny): libtess.GluHalfEdge.dPrev is called nowhere in libtess and
// isn't part of the current public API. It could be useful for mesh traversal
// and manipulation if made public, however.
/* istanbul ignore next */
/**
 * The edge clockwise around destination vertex (keep same dest).
 * @return {libtess.GluHalfEdge}
 */
libtess.GluHalfEdge.prototype.dPrev = function() {
  return this.lNext.sym;
};


/**
 * [rPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.rPrev = function() {
  return this.sym.oNext;
};


/**
 * [dNext description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.dNext = function() {
  return this.rPrev().sym;
};


// NOTE(bckenny): libtess.GluHalfEdge.rNext is called nowhere in libtess and
// isn't part of the current public API. It could be useful for mesh traversal
// and manipulation if made public, however.
/* istanbul ignore next */
/**
 * The edge CCW around the right face (origin of this becomes new dest).
 * @return {libtess.GluHalfEdge}
 */
libtess.GluHalfEdge.prototype.rNext = function() {
  return this.oPrev().sym;
};

/* global libtess */

/**
 * Creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 *
 * @constructor
 * @struct
 */
libtess.GluMesh = function() {
  /**
   * dummy header for vertex list
   * @type {libtess.GluVertex}
   */
  this.vHead = new libtess.GluVertex();

  /**
   * dummy header for face list
   * @type {libtess.GluFace}
   */
  this.fHead = new libtess.GluFace();

  /**
   * dummy header for edge list
   * @type {libtess.GluHalfEdge}
   */
  this.eHead = new libtess.GluHalfEdge();

  /**
   * and its symmetric counterpart
   * @type {libtess.GluHalfEdge}
   */
  this.eHeadSym = new libtess.GluHalfEdge();

  // TODO(bckenny): better way to pair these?
  this.eHead.sym = this.eHeadSym;
  this.eHeadSym.sym = this.eHead;
};


// TODO(bckenny): #ifndef NDEBUG
/**
 * Checks mesh for self-consistency.
 */
libtess.GluMesh.prototype.checkMesh = function() {
  if (!libtess.DEBUG) {
    return;
  }

  var fHead = this.fHead;
  var vHead = this.vHead;
  var eHead = this.eHead;

  var e;

  // faces
  var f;
  var fPrev = fHead;
  for (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {
    e = f.anEdge;
    do {
      e = e.lNext;
    } while (e !== f.anEdge);
  }

  // vertices
  var v;
  var vPrev = vHead;
  for (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {
    e = v.anEdge;
    do {
      e = e.oNext;
    } while (e !== v.anEdge);
  }

  // edges
  var ePrev = eHead;
  for (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {
  }
};

/* global libtess */

/**
 * Each vertex has a pointer to next and previous vertices in the
 * circular list, and a pointer to a half-edge with this vertex as
 * the origin (null if this is the dummy header). There is also a
 * field "data" for client data.
 * @param {libtess.GluVertex=} opt_nextVertex Optional reference to next vertex in the vertex list.
 * @param {libtess.GluVertex=} opt_prevVertex Optional reference to previous vertex in the vertex list.
 * @constructor
 * @struct
 */
libtess.GluVertex = function(opt_nextVertex, opt_prevVertex) {
  /**
   * Next vertex (never null).
   * @type {!libtess.GluVertex}
   */
  this.next = opt_nextVertex || this;

  /**
   * Previous vertex (never null).
   * @type {!libtess.GluVertex}
   */
  this.prev = opt_prevVertex || this;

  /**
   * A half-edge with this origin.
   * @type {libtess.GluHalfEdge}
   */
  this.anEdge = null;

  /**
   * The client's data.
   * @type {Object}
   */
  this.data = null;

  /**
   * The vertex location in 3D.
   * @type {!Array.<number>}
   */
  this.coords = [0, 0, 0];
  // TODO(bckenny): we may want to rethink coords, either eliminate (using s
  // and t and user data) or index into contiguous storage?

  /**
   * Component of projection onto the sweep plane.
   * @type {number}
   */
  this.s = 0;

  /**
   * Component of projection onto the sweep plane.
   * @type {number}
   */
  this.t = 0;

  /**
   * Handle to allow deletion from priority queue, or 0 if not yet inserted into
   * queue.
   * @type {libtess.PQHandle}
   */
  this.pqHandle = 0;
};

/* global libtess */

/**
 * A priority queue of vertices, ordered by libtess.geom.vertLeq, implemented
 * with a sorted array. Used for initial insertion of vertices (see
 * libtess.sweep.initPriorityQ_), sorted once, then it uses an internal
 * libtess.PriorityQHeap for any subsequently created vertices from
 * intersections.
 * @constructor
 * @struct
 */
libtess.PriorityQ = function() {
  /**
   * An unordered list of vertices that have been inserted in the queue, with
   * null in empty slots.
   * @private {Array<libtess.GluVertex>}
   */
  this.verts_ = [];

  /**
   * Array of indices into this.verts_, sorted by vertLeq over the addressed
   * vertices.
   * @private {Array<number>}
   */
  this.order_ = null;

  /**
   * The size of this queue, not counting any vertices stored in heap_.
   * @private {number}
   */
  this.size_ = 0;

  /**
   * Indicates that the queue has been initialized via init. If false, inserts
   * are fast insertions at the end of the verts_ array. If true, the verts_
   * array is sorted and subsequent inserts are done in the heap.
   * @private {boolean}
   */
  this.initialized_ = false;

  /**
   * A priority queue heap, used for faster insertions of vertices after verts_
   * has been sorted.
   * @private {libtess.PriorityQHeap}
   */
  this.heap_ = new libtess.PriorityQHeap();
};

/**
 * Release major storage memory used by priority queue.
 */
libtess.PriorityQ.prototype.deleteQ = function() {
  // TODO(bckenny): could instead clear most of these.
  this.heap_ = null;
  this.order_ = null;
  this.verts_ = null;
  // NOTE(bckenny): nulled at callsite (sweep.donePriorityQ_)
};

/**
 * Sort vertices by libtess.geom.vertLeq. Must be called before any method other
 * than insert is called to ensure correctness when removing or querying.
 */
libtess.PriorityQ.prototype.init = function() {
  // TODO(bckenny): reuse. in theory, we don't have to empty this, as access is
  // dictated by this.size_, but array.sort doesn't know that
  this.order_ = [];

  // Create an array of indirect pointers to the verts, so that
  // the handles we have returned are still valid.
  // TODO(bckenny): valid for when? it appears we can just store indexes into
  // verts_, but what did this mean?
  for (var i = 0; i < this.size_; i++) {
    this.order_[i] = i;
  }

  // sort the indirect pointers in descending order of the verts themselves
  // TODO(bckenny): make sure it's ok that verts[a] === verts[b] returns 1
  // TODO(bckenny): unstable sort means we may get slightly different polys in
  // different browsers, but only when passing in equal points
  // TODO(bckenny): make less awkward closure?
  var comparator = (function(verts) {
    return function(a, b) {
      return libtess.geom.vertLeq(verts[a], verts[b]) ? 1 : -1;
    };
  })(this.verts_);
  this.order_.sort(comparator);

  this.initialized_ = true;
  this.heap_.init();

  // NOTE(bckenny): debug assert of ordering of the verts_ array.
  if (libtess.DEBUG) {
    var p = 0;
    var r = p + this.size_ - 1;
    for (i = p; i < r; ++i) {
    }
  }
};

/**
 * Insert a vertex into the priority queue. Returns a PQHandle to refer to it,
 * which will never be 0.
 * @param {libtess.GluVertex} vert
 * @return {libtess.PQHandle}
 */
libtess.PriorityQ.prototype.insert = function(vert) {
  // NOTE(bckenny): originally returned LONG_MAX as alloc failure signal. no
  // longer does.
  if (this.initialized_) {
    return this.heap_.insert(vert);
  }

  var curr = this.size_++;

  this.verts_[curr] = vert;

  // Negative handles index the sorted array.
  return -(curr + 1);
};

/**
 * Removes the minimum vertex from the queue and returns it. If the queue is
 * empty, null will be returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQ.prototype.extractMin = function() {
  if (this.size_ === 0) {
    return this.heap_.extractMin();
  }

  var sortMin = this.verts_[this.order_[this.size_ - 1]];
  if (!this.heap_.isEmpty()) {
    var heapMin = this.heap_.minimum();
    if (libtess.geom.vertLeq(heapMin, sortMin)) {
      return this.heap_.extractMin();
    }
  }

  do {
    --this.size_;
  } while (this.size_ > 0 && this.verts_[this.order_[this.size_ - 1]] === null);

  return sortMin;
};

/**
 * Returns the minimum vertex in the queue. If the queue is empty, null will be
 * returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQ.prototype.minimum = function() {
  if (this.size_ === 0) {
    return this.heap_.minimum();
  }

  var sortMin = this.verts_[this.order_[this.size_ - 1]];
  if (!this.heap_.isEmpty()) {
    var heapMin = this.heap_.minimum();
    if (libtess.geom.vertLeq(heapMin, sortMin)) {
      return heapMin;
    }
  }

  return sortMin;
};

/**
 * Remove vertex with handle removeHandle from queue.
 * @param {libtess.PQHandle} removeHandle
 */
libtess.PriorityQ.prototype.remove = function(removeHandle) {
  if (removeHandle >= 0) {
    this.heap_.remove(removeHandle);
    return;
  }
  removeHandle = -(removeHandle + 1);

  this.verts_[removeHandle] = null;
  while (this.size_ > 0 && this.verts_[this.order_[this.size_ - 1]] === null) {
    --this.size_;
  }
};

/* global libtess */

/**
 * A priority queue of vertices, ordered by libtess.geom.vertLeq, implemented
 * with a binary heap. Used only within libtess.PriorityQ for prioritizing
 * vertices created by intersections (see libtess.sweep.checkForIntersect_).
 * @constructor
 * @struct
 */
libtess.PriorityQHeap = function() {
  /**
   * The heap itself. Active nodes are stored in the range 1..size, with the
   * minimum at 1. Each node stores only an index into verts_ and handles_.
   * @private {!Array<number>}
   */
  this.heap_ = libtess.PriorityQHeap.reallocNumeric_([0],
      libtess.PriorityQHeap.INIT_SIZE_ + 1);

  /**
   * An unordered list of vertices in the heap, with null in empty slots.
   * @private {!Array<libtess.GluVertex>}
   */
  this.verts_ = [null, null];

  /**
   * An unordered list of indices mapping vertex handles into the heap. An entry
   * at index i will map the vertex at i in verts_ to its place in the heap
   * (i.e. heap_[handles_[i]] === i).
   * Empty slots below size_ are a free list chain starting at freeList_.
   * @private {!Array<number>}
   */
  this.handles_ = [0, 0];

  /**
   * The size of the queue.
   * @private {number}
   */
  this.size_ = 0;

  /**
   * The queue's current allocated space.
   * @private {number}
   */
  this.max_ = libtess.PriorityQHeap.INIT_SIZE_;

  /**
   * The index of the next free hole in the verts_ array. That slot in handles_
   * has the next index in the free list. If there are no holes, freeList_ === 0
   * and a new vertex must be appended to the list.
   * @private {libtess.PQHandle}
   */
  this.freeList_ = 0;

  /**
   * Indicates that the heap has been initialized via init. If false, inserts
   * are fast insertions at the end of a list. If true, all inserts will now be
   * correctly ordered in the queue before returning.
   * @private {boolean}
   */
  this.initialized_ = false;

  // Point the first index at the first (currently null) vertex.
  this.heap_[1] = 1;
};

/**
 * The initial allocated space for the queue.
 * @const
 * @private {number}
 */
libtess.PriorityQHeap.INIT_SIZE_ = 32;

/**
 * Allocate a numeric index array of size size. oldArray's contents are copied
 * to the beginning of the new array. The rest of the array is filled with
 * zeroes.
 * @private
 * @param {!Array<number>} oldArray
 * @param {number} size
 * @return {!Array<number>}
 */
libtess.PriorityQHeap.reallocNumeric_ = function(oldArray, size) {
  var newArray = new Array(size);

  // NOTE(bckenny): V8 likes this significantly more than simply growing the
  // array element-by-element or expanding the existing array all at once, so,
  // for now, emulating realloc.
  for (var index = 0; index < oldArray.length; index++) {
    newArray[index] = oldArray[index];
  }

  for (; index < size; index++) {
    newArray[index] = 0;
  }

  return newArray;
};

/**
 * Initializing ordering of the heap. Must be called before any method other
 * than insert is called to ensure correctness when removing or querying.
 */
libtess.PriorityQHeap.prototype.init = function() {
  // This method of building a heap is O(n), rather than O(n lg n).
  for (var i = this.size_; i >= 1; --i) {
    // TODO(bckenny): since init is called before anything is inserted (see
    // PriorityQ.init), this will always be empty. Better to lazily init?
    this.floatDown_(i);
  }

  this.initialized_ = true;
};

/**
 * Insert a new vertex into the heap.
 * @param {libtess.GluVertex} vert The vertex to insert.
 * @return {libtess.PQHandle} A handle that can be used to remove the vertex.
 */
libtess.PriorityQHeap.prototype.insert = function(vert) {
  var endIndex = ++this.size_;

  // If the heap overflows, double its size.
  if ((endIndex * 2) > this.max_) {
    this.max_ *= 2;

    this.handles_ = libtess.PriorityQHeap.reallocNumeric_(this.handles_,
        this.max_ + 1);
  }

  var newVertSlot;
  if (this.freeList_ === 0) {
    // No free slots, append vertex.
    newVertSlot = endIndex;
  } else {
    // Put vertex in free slot, update freeList_ to next free slot.
    newVertSlot = this.freeList_;
    this.freeList_ = this.handles_[this.freeList_];
  }

  this.verts_[newVertSlot] = vert;
  this.handles_[newVertSlot] = endIndex;
  this.heap_[endIndex] = newVertSlot;

  if (this.initialized_) {
    this.floatUp_(endIndex);
  }
  return newVertSlot;
};

/**
 * @return {boolean} Whether the heap is empty.
 */
libtess.PriorityQHeap.prototype.isEmpty = function() {
  return this.size_ === 0;
};

/**
 * Returns the minimum vertex in the heap. If the heap is empty, null will be
 * returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQHeap.prototype.minimum = function() {
  return this.verts_[this.heap_[1]];
};

/**
 * Removes the minimum vertex from the heap and returns it. If the heap is
 * empty, null will be returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQHeap.prototype.extractMin = function() {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var minHandle = heap[1];
  var minVertex = verts[minHandle];

  if (this.size_ > 0) {
    // Replace min with last vertex.
    heap[1] = heap[this.size_];
    handles[heap[1]] = 1;

    // Clear min vertex and put slot at front of freeList_.
    verts[minHandle] = null;
    handles[minHandle] = this.freeList_;
    this.freeList_ = minHandle;

    // Restore heap.
    if (--this.size_ > 0) {
      this.floatDown_(1);
    }
  }

  return minVertex;
};

/**
 * Remove vertex with handle removeHandle from heap.
 * @param {libtess.PQHandle} removeHandle
 */
libtess.PriorityQHeap.prototype.remove = function(removeHandle) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var heapIndex = handles[removeHandle];

  // Replace with last vertex.
  heap[heapIndex] = heap[this.size_];
  handles[heap[heapIndex]] = heapIndex;

  // Restore heap.
  if (heapIndex <= --this.size_) {
    if (heapIndex <= 1) {
      this.floatDown_(heapIndex);
    } else {
      var vert = verts[heap[heapIndex]];
      var parentVert = verts[heap[heapIndex >> 1]];
      if (libtess.geom.vertLeq(parentVert, vert)) {
        this.floatDown_(heapIndex);
      } else {
        this.floatUp_(heapIndex);
      }
    }
  }

  // Clear vertex and put slot at front of freeList_.
  verts[removeHandle] = null;
  handles[removeHandle] = this.freeList_;
  this.freeList_ = removeHandle;
};

/**
 * Restore heap by moving the vertex at index in the heap downwards to a valid
 * slot.
 * @private
 * @param {libtess.PQHandle} index
 */
libtess.PriorityQHeap.prototype.floatDown_ = function(index) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var currIndex = index;
  var currHandle = heap[currIndex];
  for (;;) {
    // The children of node i are nodes 2i and 2i+1.
    var childIndex = currIndex << 1;
    if (childIndex < this.size_) {
      // Set child to the index of the child with the minimum vertex.
      if (libtess.geom.vertLeq(verts[heap[childIndex + 1]],
          verts[heap[childIndex]])) {
        childIndex = childIndex + 1;
      }
    }

    var childHandle = heap[childIndex];
    if (childIndex > this.size_ ||
        libtess.geom.vertLeq(verts[currHandle], verts[childHandle])) {
      // Heap restored.
      heap[currIndex] = currHandle;
      handles[currHandle] = currIndex;
      return;
    }

    // Swap current node and child; repeat from childIndex.
    heap[currIndex] = childHandle;
    handles[childHandle] = currIndex;
    currIndex = childIndex;
  }
};

/**
 * Restore heap by moving the vertex at index in the heap upwards to a valid
 * slot.
 * @private
 * @param {libtess.PQHandle} index
 */
libtess.PriorityQHeap.prototype.floatUp_ = function(index) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var currIndex = index;
  var currHandle = heap[currIndex];
  for (;;) {
    // The parent of node i is node floor(i/2).
    var parentIndex = currIndex >> 1;
    var parentHandle = heap[parentIndex];

    if (parentIndex === 0 ||
        libtess.geom.vertLeq(verts[parentHandle], verts[currHandle])) {
      // Heap restored.
      heap[currIndex] = currHandle;
      handles[currHandle] = currIndex;
      return;
    }

    // Swap current node and parent; repeat from parentIndex.
    heap[currIndex] = parentHandle;
    handles[parentHandle] = currIndex;
    currIndex = parentIndex;
  }
};

/* global libtess */

// TODO(bckenny): apparently only visible outside of sweep for debugging routines.
// find out if we can hide

/**
 * For each pair of adjacent edges crossing the sweep line, there is
 * an ActiveRegion to represent the region between them. The active
 * regions are kept in sorted order in a dynamic dictionary. As the
 * sweep line crosses each vertex, we update the affected regions.
 * @constructor
 * @struct
 */
libtess.ActiveRegion = function() {
  // TODO(bckenny): I *think* eUp and nodeUp could be passed in as constructor params

  /**
   * The upper edge of the region, directed right to left
   * @type {libtess.GluHalfEdge}
   */
  this.eUp = null;

  /**
   * Dictionary node corresponding to eUp edge.
   * @type {libtess.DictNode}
   */
  this.nodeUp = null;

  /**
   * Used to determine which regions are inside the polygon.
   * @type {number}
   */
  this.windingNumber = 0;

  /**
   * Whether this region is inside the polygon.
   * @type {boolean}
   */
  this.inside = false;

  /**
   * Marks fake edges at t = +/-infinity.
   * @type {boolean}
   */
  this.sentinel = false;

  /**
   * Marks regions where the upper or lower edge has changed, but we haven't
   * checked whether they intersect yet.
   * @type {boolean}
   */
  this.dirty = false;

  /**
   * marks temporary edges introduced when we process a "right vertex" (one
   * without any edges leaving to the right)
   * @type {boolean}
   */
  this.fixUpperEdge = false;
};

/**
 * Returns the ActiveRegion below this one.
 * @return {libtess.ActiveRegion}
 */
libtess.ActiveRegion.prototype.regionBelow = function() {
  return this.nodeUp.getPredecessor().getKey();
};

/**
 * Returns the ActiveRegion above this one.
 * @return {libtess.ActiveRegion}
 */
libtess.ActiveRegion.prototype.regionAbove = function() {
  return this.nodeUp.getSuccessor().getKey();
};

/* global libtess, module */

/**
 * node.js export for non-compiled source
 */
if (typeof module !== 'undefined') {
  module.exports = libtess;
}
;
define('libtess', ['libtess/libtess.cat'], function (main) { return main; });

define("libtess/libtess.cat", function(){});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Triangle3',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "libtess",
],
function (Vector3,
          libtess_)
{
"use strict";

   return {
      area: (function ()
      {
         const
            B = new Vector3 (0, 0, 0),
            C = new Vector3 (0, 0, 0);

         return function (a, b, c)
         {
            return B .assign (b) .subtract (a) .cross (C .assign (c) .subtract (a)) .abs () / 2;
         };
      })(),
      normal: function (v1, v2, v3, normal)
      {
         const
            x1 = v3 .x - v2 .x,
            y1 = v3 .y - v2 .y,
            z1 = v3 .z - v2 .z,
            x2 = v1 .x - v2 .x,
            y2 = v1 .y - v2 .y,
            z2 = v1 .z - v2 .z;

         normal .set (y1 * z2 - z1 * y2,
                      z1 * x2 - x1 * z2,
                      x1 * y2 - y1 * x2);

         return normal .normalize ();
      },
      quadNormal: function (v1, v2, v3, v4, normal)
      {
         const
            x1 = v3 .x - v1 .x,
            y1 = v3 .y - v1 .y,
            z1 = v3 .z - v1 .z,
            x2 = v4 .x - v2 .x,
            y2 = v4 .y - v2 .y,
            z2 = v4 .z - v2 .z;

         normal .set (y1 * z2 - z1 * y2,
                      z1 * x2 - x1 * z2,
                      x1 * y2 - y1 * x2);

         return normal .normalize ();
      },
      triangulatePolygon: (function ()
      {
         const tessy = (function ()
         {
            // Function called for each vertex of tesselator output.
            function vertexCallback (data, polyVertArray)
            {
               //console .log (data);
               polyVertArray [polyVertArray .length] = data;
            }

            function beginCallback (type)
            {
               if (type !== libtess .primitiveType .GL_TRIANGLES)
                  console .log ('expected TRIANGLES but got type: ' + type);
            }

            function errorCallback (errno)
            {
               console .log ('error callback');
               console .log ('error number: ' + errno);
            }

            // Callback for when segments intersect and must be split.
            function combineCallback (coords, data, weight)
            {
               //console.log ('combine callback');
               return data [0];
            }

            function edgeCallback (flag)
            {
               // Don't really care about the flag, but need no-strip/no-fan behavior.
               // console .log ('edge flag: ' + flag);
            }

            const tessy = new libtess .GluTesselator ();

            tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_VERTEX_DATA,  vertexCallback);
            tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_BEGIN,        beginCallback);
            tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_ERROR,        errorCallback);
            tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_COMBINE,      combineCallback);
            tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_EDGE_FLAG,    edgeCallback);
            tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_TOLERANCE,    0);
            tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_WINDING_RULE, libtess .windingRule .GLU_TESS_WINDING_ODD);

            return tessy;
         })();

         return function (/* contour, [ contour, ..., ] triangles */)
         {
            const triangles = arguments [arguments .length - 1];

            tessy .gluTessBeginPolygon (triangles);

            for (let i = 0, length = arguments .length - 1; i < length; ++ i)
            {
               tessy .gluTessBeginContour ();

               for (const contour of arguments [i])
               {
                  tessy .gluTessVertex (contour, contour);
               }

               tessy .gluTessEndContour ();
            }

            tessy .gluTessEndPolygon ();

            return triangles;
         };
      })(),
      triangulateConvexPolygon: function (vertices, triangles)
      {
         // Fallback: Very simple triangulation for convex polygons.
         for (let i = 1, length = vertices .length - 1; i < length; ++ i)
            triangles .push (vertices [0], vertices [i], vertices [i + 1]);
      },
      getPolygonNormal: function (vertices, normal)
      {
         // Determine polygon normal.
         // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

         normal .set (0, 0, 0);

         var next = vertices [0];

         for (let i = 0, length = vertices .length; i < length; ++ i)
         {
            var
               current = next,
               next    = vertices [(i + 1) % length];

            normal .x += (current .y - next .y) * (current .z + next .z);
            normal .y += (current .z - next .z) * (current .x + next .x);
            normal .z += (current .x - next .x) * (current .y + next .y);
         }

         return normal .normalize ();
      },
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/SAT',[],function ()
{
"use strict";

   const
      extents1 = { min: 0, max: 0 },
      extents2 = { min: 0, max: 0 };

   /**
    *  Class to represent the Separating Axis Theorem.
    */
   function SAT () { }

   SAT .isSeparated = function (axes, points1, points2)
   {
      // http://gamedev.stackexchange.com/questions/25397/obb-vs-obb-collision-detection

      for (const axis of axes)
      {
         project (points1, axis, extents1);
         project (points2, axis, extents2);

         if (overlaps (extents1 .min, extents1 .max, extents2 .min, extents2 .max))
            continue;

         return true;
      }

      return false;
   };

   ///  Projects @a points to @a axis and returns the minimum and maximum bounds.
   function project (points, axis, extents)
   {
      extents .min = Number .POSITIVE_INFINITY;
      extents .max = Number .NEGATIVE_INFINITY;

      for (const point of points)
      {
         // Just dot it to get the min and max along this axis.
         // NOTE: the axis must be normalized to get accurate projections to calculate the MTV, but if it is only needed to
         // know whether it overlaps, every axis can be used.

         const dotVal = point .dot (axis);

         if (dotVal < extents .min)
            extents .min = dotVal;

         if (dotVal > extents .max)
            extents .max = dotVal;
      }
   }

   ///  Returns true if both ranges overlap, otherwise false.
   function overlaps (min1, max1, min2, max2)
   {
      return is_between (min2, min1, max1) || is_between (min1, min2, max2);
   }

   ///  Returns true if @a value is between @a lowerBound and @a upperBound, otherwise false.
   function is_between (value, lowerBound, upperBound)
   {
      return lowerBound <= value && value <= upperBound;
   }

   return SAT;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/ViewVolume',[
   "standard/Math/Geometry/Plane3",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithms/SAT",
],
function (Plane3,
          Triangle3,
          Vector3,
          Vector4,
          Matrix4,
          SAT)
{
"use strict";

   /*
    * p7 -------- p6  far plane
    * | \         | \
    * | p3 --------- p2
    * |  |        |  |
    * |  |        |  |
    * p4 |______ p5  |
    *  \ |         \ |
    *   \|          \|
    *    p0 -------- p1  near plane
    */

   function ViewVolume (projectionMatrix, viewport, scissor)
   {
      this .viewport = new Vector4 (0, 0, 0, 0);
      this .scissor  = new Vector4 (0, 0, 0, 0);

      this .points = [
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),

         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
      ];

      this .normals = [
         new Vector3 (0, 0, 0), // front
         new Vector3 (0, 0, 0), // left
         new Vector3 (0, 0, 0), // right
         new Vector3 (0, 0, 0), // top
         new Vector3 (0, 0, 0), // bottom
         new Vector3 (0, 0, 0), // back
      ];

      this .edges = [
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),

         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
         new Vector3 (0, 0, 0),
      ];

      this .planes = [
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // front
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // left
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // right
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // top
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // bottom
         new Plane3 (Vector3 .Zero, Vector3 .Zero), // back
      ];

      if (arguments .length)
         this .set (projectionMatrix, viewport, scissor);
   }

   ViewVolume .prototype =
   {
      constructor: ViewVolume,
      set: (function ()
      {
         const matrix = new Matrix4 ();

         return function (projectionMatrix, viewport, scissor)
         {
            this .viewport .assign (viewport);
            this .scissor  .assign (scissor);

            const points = this .points;

            const
               p0 = points [0],
               p1 = points [1],
               p2 = points [2],
               p3 = points [3],
               p4 = points [4],
               p5 = points [5],
               p6 = points [6],
               p7 = points [7];

            const
               x1 = scissor [0],
               x2 = x1 + scissor [2],
               y1 = scissor [1],
               y2 = y1 + scissor [3];

            matrix .assign (projectionMatrix) .inverse ();

            ViewVolume .unProjectPointMatrix (x1, y1, 0, matrix, viewport, p0),
            ViewVolume .unProjectPointMatrix (x2, y1, 0, matrix, viewport, p1),
            ViewVolume .unProjectPointMatrix (x2, y2, 0, matrix, viewport, p2),
            ViewVolume .unProjectPointMatrix (x1, y2, 0, matrix, viewport, p3),
            ViewVolume .unProjectPointMatrix (x1, y1, 1, matrix, viewport, p4),
            ViewVolume .unProjectPointMatrix (x2, y1, 1, matrix, viewport, p5);
            ViewVolume .unProjectPointMatrix (x2, y2, 1, matrix, viewport, p6);
            ViewVolume .unProjectPointMatrix (x1, y2, 1, matrix, viewport, p7);

            const normals = this .normals;

            Triangle3 .normal (p0, p1, p2, normals [0]); // front
            Triangle3 .normal (p7, p4, p0, normals [1]); // left
            Triangle3 .normal (p6, p2, p1, normals [2]); // right
            Triangle3 .normal (p2, p6, p7, normals [3]); // top
            Triangle3 .normal (p1, p0, p4, normals [4]); // bottom
            Triangle3 .normal (p4, p7, p6, normals [5]); // back

            const planes = this .planes;

            planes [0] .set (p1, normals [0]); // front
            planes [1] .set (p4, normals [1]); // left
            planes [2] .set (p2, normals [2]); // right
            planes [3] .set (p6, normals [3]); // top
            planes [4] .set (p0, normals [4]); // bottom
            planes [5] .set (p7, normals [5]); // back

            this .edges .tainted = true;

            return this;
         };
      })(),
      getViewport: function ()
      {
         return this .viewport;
      },
      getScissor: function ()
      {
         return this .scissor;
      },
      getEdges: function ()
      {
         // Return suitable edges for SAT theorem.

         const edges = this .edges;

         if (edges .tainted)
         {
            const points = this .points;

            edges [0] .assign (points [0]) .subtract (points [1]);
            edges [1] .assign (points [1]) .subtract (points [2]);
            edges [2] .assign (points [2]) .subtract (points [3]);
            edges [3] .assign (points [3]) .subtract (points [0]);

            edges [4] .assign (points [0]) .subtract (points [4]);
            edges [5] .assign (points [1]) .subtract (points [5]);
            edges [6] .assign (points [2]) .subtract (points [6]);
            edges [7] .assign (points [3]) .subtract (points [7]);

            // Edges 8 - 11 are equal to edges 0 - 3.

            edges .tainted = false;
         }

         return edges;
      },
      intersectsSphere: function (radius, center)
      {
         const planes = this .planes;

         if (planes [0] .getDistanceToPoint (center) > radius)
            return false;

         if (planes [1] .getDistanceToPoint (center) > radius)
            return false;

         if (planes [2] .getDistanceToPoint (center) > radius)
            return false;

         if (planes [3] .getDistanceToPoint (center) > radius)
            return false;

         if (planes [4] .getDistanceToPoint (center) > radius)
            return false;

         if (planes [5] .getDistanceToPoint (center) > radius)
            return false;

         return true;
      },
      intersectsBox: (function ()
      {
         const points1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const normals1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes = [ ];

         for (let i = 0; i < 3 * 8; ++ i)
            axes .push (new Vector3 (0, 0, 0));

         return function (box)
         {
            // Get points.

            box .getPoints (points1);

            const points2 = this .points;

            // Test the three planes spanned by the normal vectors of the faces of the box.

            if (SAT .isSeparated (box .getNormals (normals1), points1, points2))
               return false;

            // Test the six planes spanned by the normal vectors of the faces of the view volume.

            if (SAT .isSeparated (this .normals, points1, points2))
               return false;

            // Test the planes spanned by the edges of each object.

            box .getAxes (axes1);

            const edges = this .getEdges ();

            for (let i1 = 0; i1 < 3; ++ i1)
            {
               for (let i2 = 0; i2 < 8; ++ i2)
                  axes [i1 * 3 + i2] .assign (axes1 [i1]) .cross (edges [i2]);
            }

            if (SAT .isSeparated (axes, points1, points2))
               return false;

            // Both boxes intersect.

            return true;
         };
      })(),
   };

   Object .assign (ViewVolume,
   {
      unProjectPoint: (function ()
      {
         const matrix = new Matrix4 ();

         return function (winx, winy, winz, modelViewMatrix, projectionMatrix, viewport, point)
         {
            matrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse ();

            return this .unProjectPointMatrix (winx, winy, winz, matrix, viewport, point);
         };
      })(),
      unProjectPointMatrix: (function ()
      {
         const vin = new Vector4 (0, 0, 0, 0);

         return function (winx, winy, winz, invModelViewProjection, viewport, point)
         {
            // Transformation of normalized coordinates between -1 and 1
            vin .set ((winx - viewport [0]) / viewport [2] * 2 - 1,
                      (winy - viewport [1]) / viewport [3] * 2 - 1,
                      2 * winz - 1,
                      1);

            //Objects coordinates
            invModelViewProjection .multVecMatrix (vin);

            const d = 1 / vin .w;

            return point .set (vin .x * d, vin .y * d, vin .z * d, 1);
         };
      })(),
      unProjectRay: (function ()
      {
         const
            near   = new Vector3 (0, 0, 0),
            far    = new Vector3 (0, 0, 0),
            matrix = new Matrix4 ();

         return function (winx, winy, modelViewMatrix, projectionMatrix, viewport, result)
         {
            matrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse ();

            ViewVolume .unProjectPointMatrix (winx, winy, 0.0, matrix, viewport, near);
            ViewVolume .unProjectPointMatrix (winx, winy, 0.9, matrix, viewport, far);

            return result .setPoints (near, far);
         };
      })(),
      projectPoint: (function ()
      {
         const vin = new Vector4 (0, 0, 0, 0);

         return function (point, modelViewMatrix, projectionMatrix, viewport, vout)
         {
            if (point .length === 4)
               vin .assign (point);
            else
               vin .set (point .x, point .y, point .z, 1);

            projectionMatrix .multVecMatrix (modelViewMatrix .multVecMatrix (vin));

            const d = 1 / (2 * vin .w);

            return vout .set ((vin .x * d + 0.5) * viewport [2] + viewport [0],
                              (vin .y * d + 0.5) * viewport [3] + viewport [1],
                              (vin .z * d + 0.5));
         };
      })(),
      projectPointMatrix: (function ()
      {
         const vin = new Vector4 (0, 0, 0, 0);

         return function (point, modelViewProjectionMatrix, viewport, vout)
         {
            if (point .length === 4)
               vin .assign (point);
            else
               vin .set (point .x, point .y, point .z, 1);

            modelViewProjectionMatrix .multVecMatrix (vin);

            const d = 1 / (2 * vin .w);

            return vout .set ((vin .x * d + 0.5) * viewport [2] + viewport [0],
                              (vin .y * d + 0.5) * viewport [3] + viewport [1],
                              (vin .z * d + 0.5));
         };
      })(),
      projectLine: (function ()
      {
         const
            near = new Vector3 (0, 0, 0),
            far  = new Vector3 (0, 0, 0);

         return function (line, modelViewMatrix, projectionMatrix, viewport, result)
         {
            ViewVolume .projectPoint (line .point, modelViewMatrix, projectionMatrix, viewport, near);
            ViewVolume .projectPoint (Vector3 .multiply (line .direction, 1e9) .add (line .point), modelViewMatrix, projectionMatrix, viewport, far);

            near .z = 0;
            far  .z = 0;

            return result .setPoints (near, far);
         };
      })(),
   });

   return ViewVolume;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/TextureBuffer',[
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (ViewVolume,
          Vector3,
          Matrix4)
{
"use strict";

   function TextureBuffer (browser, width, height)
   {
      const gl = browser .getContext ();

      this .browser = browser;
      this .width   = width;
      this .height  = height;
      this .array   = new Uint8Array (width * height * 4);

      // Create frame buffer.

      this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);
      this .buffer     = gl .createFramebuffer ();

      gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);

      // Create color texture.

      this .colorTexture = gl .createTexture ();

      gl .bindTexture (gl .TEXTURE_2D, this .colorTexture);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .LINEAR);
      gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .LINEAR);
      gl .texImage2D (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, null);

      gl .framebufferTexture2D (gl .FRAMEBUFFER, gl .COLOR_ATTACHMENT0, gl .TEXTURE_2D, this .colorTexture, 0);

      // Create depth buffer.

      if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
      {
         this .depthTexture = gl .createTexture ();

         gl .bindTexture (gl .TEXTURE_2D, this .depthTexture);

         gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
         gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
         gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
         gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .NEAREST);

         const internalFormat = gl .getVersion () >= 2 ? gl .DEPTH_COMPONENT24 : gl .DEPTH_COMPONENT;

         gl .texImage2D (gl .TEXTURE_2D, 0, internalFormat, width, height, 0, gl .DEPTH_COMPONENT, gl .UNSIGNED_INT, null);
         gl .framebufferTexture2D (gl .FRAMEBUFFER, gl .DEPTH_ATTACHMENT, gl .TEXTURE_2D, this .depthTexture, 0);
      }
      else
      {
         this .depthBuffer = gl .createRenderbuffer ();

         gl .bindRenderbuffer (gl .RENDERBUFFER, this .depthBuffer);
         gl .renderbufferStorage (gl .RENDERBUFFER, gl .DEPTH_COMPONENT16, width, height);
         gl .framebufferRenderbuffer (gl .FRAMEBUFFER, gl .DEPTH_ATTACHMENT, gl .RENDERBUFFER, this .depthBuffer);
      }

      // Always check that our framebuffer is ok.

      const complete = gl .checkFramebufferStatus (gl .FRAMEBUFFER) === gl .FRAMEBUFFER_COMPLETE;

      gl .bindTexture (gl .TEXTURE_2D, null);
      gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);

      if (complete)
         return;

      throw new Error ("Couldn't create frame buffer.");
   }

   TextureBuffer .prototype =
   {
      constructor: TextureBuffer,
      getWidth: function ()
      {
         return this .width;
      },
      getHeight: function ()
      {
         return this .height;
      },
      getColorTexture: function ()
      {
         return this .colorTexture;
      },
      getDepthTexture: function ()
      {
         return this .depthTexture;
      },
      readPixels: function ()
      {
         const
            gl     = this .browser .getContext (),
            array  = this .array,
            width  = this .width,
            height = this .height;

         gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);

         return array;
      },
      getDepth: (function ()
      {
         const
            invProjectionMatrix = new Matrix4 (),
            point               = new Vector3 (0, 0, 0);

         return function (projectionMatrix, viewport)
         {
            const
               gl     = this .browser .getContext (),
               array  = this .array,
               width  = this .width,
               height = this .height;

            let
               winx = 0,
               winy = 0,
               winz = Number .POSITIVE_INFINITY;

            invProjectionMatrix .assign (projectionMatrix) .inverse ();

            gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);

            for (let wy = 0, i = 0; wy < height; ++ wy)
            {
               for (let wx = 0; wx < width; ++ wx, i += 4)
               {
                  const wz = array [i] / 255 + array [i + 1] / (255 * 255) + array [i + 2] / (255 * 255 * 255) + array [i + 3] / (255 * 255 * 255 * 255);

                  if (wz < winz)
                  {
                     winx = wx;
                     winy = wy;
                     winz = wz;
                  }
               }
            }

            ViewVolume .unProjectPointMatrix (winx, winy, winz, invProjectionMatrix, viewport, point);

            return point .z;
         };
      })(),
      bind: function ()
      {
         const gl = this .browser .getContext ();

         this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);

         gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);
      },
      unbind: function ()
      {
         const gl = this .browser .getContext ();

         gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);
      },
      delete: function ()
      {
         const gl = this .browser .getContext ();

         gl .deleteFramebuffer (this .buffer);
         gl .deleteTexture (this .colorTexture);

         if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
            gl .deleteTexture (this .depthTexture);
         else
            gl .deleteRenderbuffer (this .depthBuffer);
       },
   };

   for (const key of Reflect .ownKeys (TextureBuffer .prototype))
      Object .defineProperty (TextureBuffer .prototype, key, { enumerable: false });

   return TextureBuffer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/MergeSort',[],function ()
{
"use strict";

   function MergeSort (array, compare)
   {
      this .array     = array;
      this .auxiliary = [ ];

      if (compare)
         this .compare = compare;
   }

   MergeSort .prototype =
   {
      compare: function (lhs, rhs)
      {
         return lhs < rhs;
      },
      sort: function (first, last)
      {
         this .mergeSort (first, last - 1);
      },
      mergeSort: function (lo, hi)
      {
         if (lo < hi)
         {
            const m = (lo + hi) >>> 1;
            this .mergeSort (lo, m);   // Recursion
            this .mergeSort (m + 1, hi); // Recursion
            this .merge (lo, m, hi);
         }
      },
      merge: function (lo, m, hi)
      {
         let i, j, k;

         i = 0, j = lo;
         // Copy first half of array a to auxiliary array b.
         while (j <= m)
            this .auxiliary [i++] = this .array [j++];

         i = 0; k = lo;
         // Copy back next-greatest element at each time.
         while (k < j && j <= hi)
         {
            if (this .compare (this .array [j], this .auxiliary [i]))
               this .array [k++] = this .array [j++];
            else
               this .array [k++] = this .auxiliary [i++];
         }

         // Copy back remaining elements of first half (if any).
         while (k < j)
            this .array [k++] = this .auxiliary [i++];
      }
   };

   return MergeSort;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Box3',[
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithms/SAT",
],
function (Triangle3,
          Matrix4,
          Vector3,
          SAT)
{
"use strict";

   function Box3 (size, center)
   {
      switch (arguments .length)
      {
         case 0:
         {
            this .matrix = new Matrix4 (0, 0, 0, 0,
                                        0, 0, 0, 0,
                                        0, 0, 0, 0,
                                        0, 0, 0, 0);
            return;
         }
         case 2:
         {
            this .matrix = new Matrix4 (size .x / 2, 0, 0, 0,
                                        0, size .y / 2, 0, 0,
                                        0, 0, size .z / 2, 0,
                                        center .x, center .y, center .z, 1);
            return;
         }
         case 3:
         {
            const
               min = arguments [0],
               max = arguments [1],
               sx  = (max .x - min .x) / 2,
               sy  = (max .y - min .y) / 2,
               sz  = (max .z - min .z) / 2,
               cx  = (max .x + min .x) / 2,
               cy  = (max .y + min .y) / 2,
               cz  = (max .z + min .z) / 2;

            this .matrix = new Matrix4 (sx, 0,  0,  0,
                                        0,  sy, 0,  0,
                                        0,  0,  sz, 0,
                                        cx, cy, cz, 1);
            return;
         }
      }
   }

   Box3 .prototype =
   {
      constructor: Box3,
      copy: function ()
      {
         const copy = Object .create (Box3 .prototype);
         copy .matrix = this .matrix .copy ();
         return copy;
      },
      assign: function (box)
      {
         this .matrix .assign (box .matrix);
         return this;
      },
      equals: function (box)
      {
         return this .matrix .equals (box .matrix);
      },
      getMatrix: function ()
      {
         return this .matrix;
      },
      set: function (size, center)
      {
         const m = this .matrix;

         switch (arguments .length)
         {
            case 0:
            {
               m [ 0] = 0.5; m [ 1] = 0;   m [ 2] = 0;   m [ 3] = 0;
               m [ 4] = 0;   m [ 5] = 0.5; m [ 6] = 0;   m [ 7] = 0;
               m [ 8] = 0;   m [ 9] = 0;   m [10] = 0.5; m [11] = 0;
               m [12] = 0;   m [13] = 0;   m [14] = 0;   m [15] = 0;
               return this;
            }
            case 2:
            {
               m [ 0] = size .x / 2; m [ 1] = 0;           m [ 2] = 0;           m [ 3] = 0;
               m [ 4] = 0;           m [ 5] = size .y / 2; m [ 6] = 0;           m [ 7] = 0;
               m [ 8] = 0;           m [ 9] = 0;           m [10] = size .z / 2; m [11] = 0;
               m [12] = center .x;   m [13] = center .y;   m [14] = center .z;   m [15] = 1;
               return this;
            }
            case 3:
            {
               const
                  min = arguments [0],
                  max = arguments [1],
                  sx  = (max .x - min .x) / 2,
                  sy  = (max .y - min .y) / 2,
                  sz  = (max .z - min .z) / 2,
                  cx  = (max .x + min .x) / 2,
                  cy  = (max .y + min .y) / 2,
                  cz  = (max .z + min .z) / 2;

               this .matrix .set (sx, 0,  0,  0,
                                  0,  sy, 0,  0,
                                  0,  0,  sz, 0,
                                  cx, cy, cz, 1);
               return this;
            }
         }
      },
      setExtents: function (min, max)
      {
         const
            m  = this .matrix,
            sx = (max .x - min .x) / 2,
            sy = (max .y - min .y) / 2,
            sz = (max .z - min .z) / 2,
            cx = (max .x + min .x) / 2,
            cy = (max .y + min .y) / 2,
            cz = (max .z + min .z) / 2;

         m [ 0] = sx; m [ 1] = 0;  m [ 2] = 0;  m [ 3] = 0;
         m [ 4] = 0;  m [ 5] = sy; m [ 6] = 0;  m [ 7] = 0;
         m [ 8] = 0;  m [ 9] = 0;  m [10] = sz; m [11] = 0;
         m [12] = cx; m [13] = cy; m [14] = cz; m [15] = 1;
         return this;
      },
      getExtents: function (min, max)
      {
         this .getAbsoluteExtents (min, max);

         min .add (this .center);
         max .add (this .center);
      },
      getAbsoluteExtents: (function ()
      {
         const
            r1 = new Vector3 (0, 0, 0),
            p1 = new Vector3 (0, 0, 0),
            p4 = new Vector3 (0, 0, 0);

         return function (min, max)
         {
            const
               m = this .matrix,
               x = m .xAxis,
               y = m .yAxis,
               z = m .zAxis;

            r1 .assign (y) .add (z);

            const r2 = z .subtract (y);

            p1 .assign (x) .add (r1),
            p4 .assign (x) .add (r2);

            const
               p2 = r1 .subtract (x),
               p3 = r2 .subtract (x);

            min .assign (p1);
            max .assign (p1);

            min .min (p2, p3, p4);
            max .max (p2, p3, p4);

            p1 .negate ();
            p2 .negate ();
            p3 .negate ();
            p4 .negate ();

            min .min (p1, p2, p3, p4);
            max .max (p1, p2, p3, p4);
         };
      })(),
      getPoints: (function ()
      {
         const
            x  = new Vector3 (0, 0, 0),
            y  = new Vector3 (0, 0, 0),
            z  = new Vector3 (0, 0, 0),
            r1 = new Vector3 (0, 0, 0);

         return function (points)
         {
            /*
             * p6 ---------- p5
             * | \           | \
             * | p2------------ p1
             * |  |          |  |
             * |  |          |  |
             * p7 |_________ p8 |
             *  \ |           \ |
             *   \|            \|
             *    p3 ---------- p4
             */

            const m = this .matrix;

            x .assign (m .xAxis);
            y .assign (m .yAxis);
            z .assign (m .zAxis);

            r1 .assign (y) .add (z);

            const r2 = z .subtract (y);

            points [0] .assign (x)  .add (r1);
            points [1] .assign (r1) .subtract (x);
            points [2] .assign (r2) .subtract (x);
            points [3] .assign (x)  .add (r2);

            points [4] .assign (points [2]) .negate ();
            points [5] .assign (points [3]) .negate ();
            points [6] .assign (points [0]) .negate ();
            points [7] .assign (points [1]) .negate ();

            const center = this .center;

            points [0] .add (center);
            points [1] .add (center);
            points [2] .add (center);
            points [3] .add (center);

            points [4] .add (center);
            points [5] .add (center);
            points [6] .add (center);
            points [7] .add (center);

            return points;
         };
      })(),
      getAxes: function (axes)
      {
         const m = this .matrix;

         axes [0] .assign (m .xAxis);
         axes [1] .assign (m .yAxis);
         axes [2] .assign (m .zAxis);

         return axes;
      },
      getNormals: (function ()
      {
         const
            x = new Vector3 (0, 0, 0),
            y = new Vector3 (0, 0, 0),
            z = new Vector3 (0, 0, 0);

         const axes = [ Vector3 .xAxis, Vector3 .yAxis, Vector3 .zAxis ];

         return function (normals)
         {
            const m = this .matrix;

            x .assign (m .xAxis);
            y .assign (m .yAxis);
            z .assign (m .zAxis);

            if (x .norm () === 0)
            {
               x .assign (y) .cross (z);

               if (x .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     x .assign (axis) .cross (y);

                     if (x .norm () !== 0)
                        break;
                  }

                  if (x .norm () === 0)
                  {
                     for (const axis of axes)
                     {
                        x .assign (axis) .cross (z);

                        if (x .norm () !== 0)
                           break;
                     }

                     if (x .norm () === 0)
                        x .assign (Vector3 .xAxis);
                  }
               }
            }

            if (y .norm () === 0)
            {
               y .assign (z) .cross (x);

               if (y .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     y .assign (axis) .cross (z);

                     if (y .norm () !== 0)
                        break;
                  }

                  if (y .norm () === 0)
                  {
                     for (const axis of axes)
                     {
                        y .assign (axis) .cross (x);

                        if (y .norm () !== 0)
                           break;
                     }

                     if (y .norm () === 0)
                        y .assign (Vector3 .yAxis);
                  }
               }
            }

            if (z .norm () === 0)
            {
               z .assign (x) .cross (y);

               if (z .norm () === 0)
               {
                  for (const axis of axes)
                  {
                     z .assign (axis) .cross (x);

                     if (z .norm () !== 0)
                        break;
                  }

                  if (z .norm () === 0)
                  {
                     for (const axis of axes)
                     {
                        z .assign (axis) .cross (y);

                        if (z .norm () !== 0)
                           break;
                     }

                     if (z .norm () === 0)
                        z .assign (Vector3 .zAxis);
                  }
               }
            }

            normals [0] .assign (y) .cross (z) .normalize ();
            normals [1] .assign (z) .cross (x) .normalize ();
            normals [2] .assign (x) .cross (y) .normalize ();

            return normals;
         };
      })(),
      isEmpty: function ()
      {
         return this .matrix [15] === 0;
      },
      add: (function ()
      {
         const
            lhs_min = new Vector3 (0, 0, 0),
            lhs_max = new Vector3 (0, 0, 0),
            rhs_min = new Vector3 (0, 0, 0),
            rhs_max = new Vector3 (0, 0, 0);

         return function (box)
         {
            if (this .isEmpty ())
               return this .assign (box);

            if (box .isEmpty ())
               return this;

            this .getExtents (lhs_min, lhs_max);
            box  .getExtents (rhs_min, rhs_max);

            return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
         };
      })(),
      multLeft: function (matrix)
      {
         this .matrix .multLeft (matrix);
         return this;
      },
      multRight: function (matrix)
      {
         this .matrix .multRight (matrix);
         return this;
      },
      containsPoint: (function ()
      {
         const
            min = new Vector3 (0, 0, 0),
            max = new Vector3 (0, 0, 0);

         return function (point)
         {
            this .getExtents (min, max);

            return min .x <= point .x &&
                   max .x >= point .x &&
                   min .y <= point .y &&
                   max .y >= point .y &&
                   min .z <= point .z &&
                   max .z >= point .z;
         };
      })(),
      intersectsBox: (function ()
      {
         const points1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const points2 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes2 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes9 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const normals = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         return function (other)
         {
            // Test special cases.

            if (this .isEmpty ())
               return false;

            if (other .isEmpty ())
               return false;

            // Get points.

            this  .getPoints (points1);
            other .getPoints (points2);

            // Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

            if (SAT .isSeparated (this .getNormals (normals), points1, points2))
               return false;

            // Test the three planes spanned by the normal vectors of the faces of the second parallelepiped.

            if (SAT .isSeparated (other .getNormals (normals), points1, points2))
               return false;

            // Test the nine other planes spanned by the edges of each parallelepiped.

            this  .getAxes (axes1);
            other .getAxes (axes2);

            for (let i1 = 0; i1 < 3; ++ i1)
            {
               for (let i2 = 0; i2 < 3; ++ i2)
                  axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (axes2 [i2]);
            }

            if (SAT .isSeparated (axes9, points1, points2))
               return false;

            // Both boxes intersect.

            return true;
         };
      })(),
      intersectsTriangle: (function ()
      {
         const points1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes1 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const axes9 = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),

            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const normals = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
         ];

         const triangle = [ ];

         const triangleNormal = [ new Vector3 (0, 0, 0) ];

         const triangleEdges = [
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0),
            new Vector3 (0, 0, 0)
         ];

         return function (a, b, c)
         {
            // Test special cases.

            if (this .isEmpty ())
               return false;

            // Get points.

            this .getPoints (points1);

            triangle [0] = a;
            triangle [1] = b;
            triangle [2] = c;

            // Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

            if (SAT .isSeparated (this .getNormals (normals), points1, triangle))
               return false;

            // Test the normal of the triangle.

            Triangle3 .normal (a, b, c, triangleNormal [0]);

            if (SAT .isSeparated (triangleNormal, points1, triangle))
               return false;

            // Test the nine other planes spanned by the edges of each parallelepiped.

            this .getAxes (axes1);

            triangleEdges [0] .assign (a) .subtract (b);
            triangleEdges [1] .assign (b) .subtract (c);
            triangleEdges [2] .assign (c) .subtract (a);

            for (let i1 = 0; i1 < 3; ++ i1)
            {
               for (let i2 = 0; i2 < 3; ++ i2)
                  axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (triangleEdges [i2]);
            }

            if (SAT .isSeparated (axes9, points1, triangle))
               return false;

            // Box and triangle intersect.

            return true;
         };
      })(),
      toString: function ()
      {
         return this .size + ", " + this .center;
      },
   };

   Object .defineProperty (Box3 .prototype, "size",
   {
      get: (function ()
      {
         const
            min = new Vector3 (0, 0, 0),
            max = new Vector3 (0, 0, 0);

         return function ()
         {
            this .getAbsoluteExtents (min, max);

            return max .subtract (min);
         };
      })(),
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (Box3 .prototype, "center",
   {
      get: function ()
      {
         return this .matrix .origin;
      },
      enumerable: true,
      configurable: false
   });

   return Box3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Utility/MatrixStack',[],function ()
{
"use strict";

   function MatrixStack (Type)
   {
      return Object .assign ([ new Type () ],
      {
         top: 0,
         set: function (matrix)
         {
            this [this .top] .assign (matrix);
         },
         get: function ()
         {
            return this [this .top];
         },
         push: function ()
         {
            const top = ++ this .top;

            if (top < this .length)
               this [top] .assign (this [top - 1]);
            else
               this [top] = this [top - 1] .copy ();
         },
         pushMatrix: function (matrix)
         {
            const top = ++ this .top;

            if (top < this .length)
               this [top] .assign (matrix);
            else
               this [top] = matrix .copy ();
         },
         pop: function ()
         {
            -- this .top;
         },
         clear: function ()
         {
            this .top = 0;
         },
         size: function ()
         {
            return this .top + 1;
         },
         identity: function ()
         {
            this [this .top] .identity ();
         },
         multLeft: function (matrix)
         {
            this [this .top] .multLeft (matrix);
         },
         translate: function (vector)
         {
            this [this .top] .translate (vector);
         },
         rotate: function (rotation)
         {
            this [this .top] .rotate (rotation);
         },
         scale: function (vector)
         {
            this [this .top] .scale (vector);
         },
      });
   }

   return MatrixStack;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/X3DRenderObject',[
   "x_ite/Rendering/TextureBuffer",
   "x_ite/Rendering/TraverseType",
   "standard/Math/Algorithm",
   "standard/Math/Algorithms/MergeSort",
   "standard/Math/Geometry/Camera",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Utility/MatrixStack",
],
function (TextureBuffer,
          TraverseType,
          Algorithm,
          MergeSort,
          Camera,
          Box3,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix4,
          MatrixStack)
{
"use strict";

   const
      DEPTH_BUFFER_WIDTH  = 16,
      DEPTH_BUFFER_HEIGHT = DEPTH_BUFFER_WIDTH;

   function compareDistance (lhs, rhs) { return lhs .distance < rhs .distance; }

   function X3DRenderObject (executionContext)
   {
      this .cameraSpaceMatrix        = new MatrixStack (Matrix4);
      this .viewMatrix               = new MatrixStack (Matrix4);
      this .projectionMatrix         = new MatrixStack (Matrix4);
      this .modelViewMatrix          = new MatrixStack (Matrix4);
      this .viewVolumes              = [ ];
      this .globalObjects            = [ ];
      this .localObjects             = [ ];
      this .lights                   = [ ];
      this .shadow                   = [ false ];
      this .localFogs                = [ ];
      this .layouts                  = [ ];
      this .textureProjectors        = [ ];
      this .generatedCubeMapTextures = [ ];
      this .shaders                  = new Set ();
      this .collisions               = [ ];
      this .numOpaqueShapes          = 0;
      this .numTransparentShapes     = 0;
      this .numCollisionShapes       = 0;
      this .numDepthShapes           = 0;
      this .opaqueShapes             = [ ];
      this .transparentShapes        = [ ];
      this .transparencySorter       = new MergeSort (this .transparentShapes, compareDistance);
      this .collisionShapes          = [ ];
      this .activeCollisions         = new Set ();
      this .depthShapes              = [ ];
      this .speed                    = 0;

      try
      {
         this .depthBuffer = new TextureBuffer (executionContext .getBrowser (), DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT);
      }
      catch (error)
      {
         console .error (error);

         this .getDepth = function () { return 0; };
      }
   }

   X3DRenderObject .prototype =
   {
      constructor: X3DRenderObject,
      initialize: function ()
      { },
      isIndependent: function ()
      {
         return true;
      },
      getCameraSpaceMatrix: function ()
      {
         return this .cameraSpaceMatrix;
      },
      getViewMatrix: function ()
      {
         return this .viewMatrix;
      },
      getProjectionMatrix: function ()
      {
         return this .projectionMatrix;
      },
      getModelViewMatrix: function ()
      {
         return this .modelViewMatrix;
      },
      getViewVolumes: function ()
      {
         return this .viewVolumes;
      },
      getViewVolume: function ()
      {
         return this .viewVolumes .at (-1);
      },
      getGlobalObjects: function ()
      {
         return this .globalObjects;
      },
      getLocalObjects: function ()
      {
         return this .localObjects;
      },
      getLights: function ()
      {
         return this .lights;
      },
      pushShadow: function (value)
      {
         this .shadow .push (value || this .shadow .at (-1));
      },
      popShadow: function ()
      {
         this .shadow .pop ();
      },
      setGlobalFog: (function ()
      {
         const modelViewMatrix = new Matrix4 ();

         return function (fog)
         {
            const fogContainer = this .localFogs [0] || fog .getFogs () .pop ();

            modelViewMatrix .assign (fog .getModelMatrix ()) .multRight (this .getViewMatrix () .get ());
            fogContainer .set (fog, modelViewMatrix);

            this .localFog = this .localFogs [0] = fogContainer;
         };
      })(),
      pushLocalFog: function (localFog)
      {
         this .localFogs .push (localFog);

         this .localFog = localFog;
      },
      popLocalFog: function ()
      {
         const localFog = this .localFogs .pop ();

         this .localFog = this .localFogs .at (-1);

         return localFog;
      },
      getLayouts: function ()
      {
         return this .layouts;
      },
      getParentLayout: function ()
      {
         return this .layouts .at (-1);
      },
      getTextureProjectors: function ()
      {
         return this .textureProjectors;
      },
      getGeneratedCubeMapTextures: function ()
      {
         return this .generatedCubeMapTextures;
      },
      getShaders: function ()
      {
         return this .shaders;
      },
      getCollisions: function ()
      {
         return this .collisions;
      },
      setNumCollisionShapes: function (value)
      {
         this .numCollisionShapes = value;
      },
      getNumCollisionShapes: function ()
      {
         return this .numCollisionShapes;
      },
      getCollisionShapes: function ()
      {
         return this .collisionShapes;
      },
      setNumDepthShapes: function (value)
      {
         this .numDepthShapes = value;
      },
      getNumDepthShapes: function ()
      {
         return this .numDepthShapes;
      },
      getDepthShapes: function ()
      {
         return this .depthShapes;
      },
      setNumOpaqueShapes: function (value)
      {
         this .numOpaqueShapes = value;
      },
      getNumOpaqueShapes: function ()
      {
         return this .numOpaqueShapes;
      },
      getOpaqueShapes: function ()
      {
         return this .opaqueShapes;
      },
      setNumTransparentShapes: function (value)
      {
         this .numTransparentShapes = value;
      },
      getNumTransparentShapes: function ()
      {
         return this .numTransparentShapes;
      },
      getTransparentShapes: function ()
      {
         return this .transparentShapes;
      },
      constrainTranslation: function (translation, stepBack)
      {
         ///  Contrains @a translation to a possible value the avatar can move.  If the avatar reaches and intersects with an
         ///  and obstacle and @a stepBack is true a translation in the opposite directiion is returned.  Future implementation will
         ///  will then return a value where the avatar slides along the wall.  Modifies translation in place.

         // Constrain translation when the viewer collides with an obstacle.

         const distance = this .getDistance (translation) - this .getNavigationInfo () .getCollisionRadius ();

         if (distance > 0)
         {
            // Move.

            const length = translation .abs ();

            if (length > distance)
            {
               // Collision, the avatar would intersect with the obstacle.

               return translation .normalize () .multiply (distance);
            }

            // Everything is fine.

            return translation;
         }

         // Collision, the avatar is already within an obstacle.

         if (stepBack)
            return this .constrainTranslation (translation .normalize () .multiply (distance), false);

         return translation .assign (Vector3 .Zero);
      },
      getDistance: (function ()
      {
         const
            projectionMatrix            = new Matrix4 (),
            cameraSpaceProjectionMatrix = new Matrix4 (),
            localOrientation            = new Rotation4 (0, 0, 1, 0),
            vector                      = new Vector3 (0, 0, 0),
            rotation                    = new Rotation4 (0, 0, 1, 0);

         return function (direction)
         {
            ///  Returns the distance to the closest object in @a direction.  The maximum determinable value is avatarHeight * 2.

            const t0 = performance .now ();

            const
               viewpoint       = this .getViewpoint (),
               navigationInfo  = this .getNavigationInfo (),
               collisionRadius = navigationInfo .getCollisionRadius (),
               bottom          = navigationInfo .getStepHeight () - navigationInfo .getAvatarHeight (),
               nearValue       = navigationInfo .getNearValue (),
               avatarHeight    = navigationInfo .getAvatarHeight ();

            // Determine width and height of camera

            // Reshape camera

            Camera .ortho (-collisionRadius,
                           collisionRadius,
                           Math .min (bottom, -collisionRadius), /// TODO: bottom could be a positive value if stepHeight > avatarHeight.
                           collisionRadius,
                           nearValue,
                           Math .max (collisionRadius * 2, avatarHeight * 2),
                           projectionMatrix);

            // Translate camera to user position and to look in the direction of the direction.

            localOrientation .assign (viewpoint ._orientation .getValue ()) .inverse () .multRight (viewpoint .getOrientation ());
            rotation .setFromToVec (Vector3 .zAxis, vector .assign (direction) .negate ()) .multRight (localOrientation);
            viewpoint .straightenHorizon (rotation);

            cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
            cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
            cameraSpaceProjectionMatrix .rotate (rotation);
            cameraSpaceProjectionMatrix .inverse ();

            cameraSpaceProjectionMatrix .multRight (projectionMatrix);
            cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

            this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

            const depth = this .getDepth (projectionMatrix);

            this .getProjectionMatrix () .pop ();

            this .collisionTime += performance .now () - t0;
            return -depth;
         };
      })(),
      getDepth: (function ()
      {
         const
            depthBufferViewport   = new Vector4 (0, 0, DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT),
            depthBufferViewVolume = new ViewVolume ();

         depthBufferViewVolume .set (Matrix4 .Identity, depthBufferViewport, depthBufferViewport);

         return function (projectionMatrix)
         {
            ///  Returns the depth value to the closest object.  The maximum determinable value is avatarHeight * 2.

            this .depthBuffer .bind ();

            this .viewVolumes .push (depthBufferViewVolume);
            this .depth (this .collisionShapes, this .numCollisionShapes);
            this .viewVolumes .pop ();

            const depth = this .depthBuffer .getDepth (projectionMatrix, depthBufferViewport);

            this .depthBuffer .unbind ();

            return depth;
         };
      })(),
      render: function (type, callback, group)
      {
         switch (type)
         {
            case TraverseType .COLLISION:
            {
               // Collect for collide and gravite
               this .numCollisionShapes = 0;

               callback .call (group, type, this);
               this .collide ();
               this .gravite ();
               break;
            }
            case TraverseType .SHADOW:
            {
               this .numDepthShapes = 0;

               callback .call (group, type, this);
               this .depth (this .depthShapes, this .numDepthShapes);
               break;
            }
            case TraverseType .DISPLAY:
            {
               this .lightIndex           = 0;
               this .numOpaqueShapes      = 0;
               this .numTransparentShapes = 0;

               this .setGlobalFog (this .getFog ());

               callback .call (group, type, this);
               this .draw ();
               break;
            }
         }
      },
      addCollisionShape: (function ()
      {
         const
            bboxSize   = new Vector3 (0, 0, 0),
            bboxCenter = new Vector3 (0, 0, 0);

         return function (shapeNode)
         {
            const modelViewMatrix = this .getModelViewMatrix () .get ();

            modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
            modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

            const
               radius     = bboxSize .abs () / 2,
               viewVolume = this .viewVolumes .at (-1);

            if (viewVolume .intersectsSphere (radius, bboxCenter))
            {
               const num = this .numCollisionShapes ++;

               if (num === this .collisionShapes .length)
               {
                  this .collisionShapes .push ({ renderer: this, browser: this .getBrowser (), modelViewMatrix: new Float32Array (16), collisions: [ ], clipPlanes: [ ] });
               }

               const context = this .collisionShapes [num];

               context .modelViewMatrix .set (modelViewMatrix);
               context .shapeNode = shapeNode;
               context .scissor   = viewVolume .getScissor ();

               // Collisions

               assign (context .collisions, this .collisions);

               // Clip planes

               assign (context .clipPlanes, this .localObjects);

               return true;
            }

            return false;
         };
      })(),
      addDepthShape: (function ()
      {
         const
            bboxSize   = new Vector3 (0, 0, 0),
            bboxCenter = new Vector3 (0, 0, 0);

         return function (shapeNode)
         {
            const modelViewMatrix = this .getModelViewMatrix () .get ();

            modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
            modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

            const
               radius     = bboxSize .abs () / 2,
               viewVolume = this .viewVolumes .at (-1);

            if (viewVolume .intersectsSphere (radius, bboxCenter))
            {
               const num = this .numDepthShapes ++;

               if (num === this .depthShapes .length)
               {
                  this .depthShapes .push ({ renderer: this, browser: this .getBrowser (), modelViewMatrix: new Float32Array (16), clipPlanes: [ ] });
               }

               const context = this .depthShapes [num];

               context .modelViewMatrix .set (modelViewMatrix);
               context .shapeNode = shapeNode;
               context .scissor   = viewVolume .getScissor ();

               // Clip planes

               assign (context .clipPlanes, this .localObjects);

               return true;
            }

            return false;
         };
      })(),
      addDisplayShape: (function ()
      {
         const
            bboxSize   = new Vector3 (0, 0, 0),
            bboxCenter = new Vector3 (0, 0, 0);

         return function (shapeNode)
         {
            const modelViewMatrix = this .getModelViewMatrix () .get ();

            modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
            modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

            const
               radius     = bboxSize .abs () / 2,
               viewVolume = this .viewVolumes .at (-1);

            if (viewVolume .intersectsSphere (radius, bboxCenter))
            {
               if (shapeNode .getTransparent ())
               {
                  const num = this .numTransparentShapes ++;

                  if (num === this .transparentShapes .length)
                     this .transparentShapes .push (this .createShapeContext (true));

                  var context = this .transparentShapes [num];
               }
               else
               {
                  const num = this .numOpaqueShapes ++;

                  if (num === this .opaqueShapes .length)
                     this .opaqueShapes .push (this .createShapeContext (false));

                  var context = this .opaqueShapes [num];
               }

               context .modelViewMatrix .set (modelViewMatrix);
               context .scissor .assign (viewVolume .getScissor ());
               context .shapeNode   = shapeNode;
               context .textureNode = null;
               context .distance    = bboxCenter .z;
               context .fogNode     = this .localFog;
               context .shadow      = this .shadow .at (-1);

               // Clip planes and local lights

               assign (context .localObjects, this .localObjects);

               return true;
            }

            return false;
         };
      })(),
      createShapeContext: function (transparent)
      {
         return {
            renderer: this,
            browser: this .getBrowser (),
            transparent: transparent,
            modelViewMatrix: new Float32Array (16),
            scissor: new Vector4 (0, 0, 0, 0),
            localObjects: [ ],
         };
      },
      collide: (function ()
      {
         const
            invModelViewMatrix = new Matrix4 (),
            modelViewMatrix    = new Matrix4 (),
            collisionBox       = new Box3 (Vector3 .Zero, Vector3 .Zero),
            collisionSize      = new Vector3 (0, 0, 0);

         return function ()
         {
            // Collision nodes are handled here.

            const
               activeCollisions = new Set (), // current active Collision nodes
               collisionRadius2 = 2.2 * this .getNavigationInfo () .getCollisionRadius (); // Make the radius a little bit larger.

            collisionSize .set (collisionRadius2, collisionRadius2, collisionRadius2);

            for (let i = 0, length = this .numCollisionShapes; i < length; ++ i)
            {
               const
                  context    = this .collisionShapes [i],
                  collisions = context .collisions;

               if (collisions .length)
               {
                  collisionBox .set (collisionSize, Vector3 .Zero);
                  collisionBox .multRight (invModelViewMatrix .assign (context .modelViewMatrix) .inverse ());

                  if (context .shapeNode .intersectsBox (collisionBox, context .clipPlanes, modelViewMatrix .assign (context .modelViewMatrix)))
                  {
                     for (const collision of collisions)
                        activeCollisions .add (collision);
                  }
               }
            }

            // Set isActive to FALSE for affected nodes.

            if (this .activeCollisions .size)
            {
               const inActiveCollisions = activeCollisions .size
                                          ? Algorithm .set_difference (this .activeCollisions, activeCollisions, new Set ())
                                          : this .activeCollisions;

               for (const collision of inActiveCollisions)
                  collision .set_active (false);
            }

            // Set isActive to TRUE for affected nodes.

            this .activeCollisions = activeCollisions;

            for (const collision of activeCollisions)
               collision .set_active (true);
         };
      })(),
      gravite: (function ()
      {
         const
            projectionMatrix            = new Matrix4 (),
            cameraSpaceProjectionMatrix = new Matrix4 (),
            translation                 = new Vector3 (0, 0, 0),
            rotation                    = new Rotation4 (0, 0, 1, 0);

         return function ()
         {
            const
               browser    = this .getBrowser (),
               shaderNode = browser .getDepthShader ();

            if (shaderNode .isValid ())
            {
               // Terrain following and gravitation

               if (browser .getActiveLayer () === this)
               {
                  if (browser .getCurrentViewer () !== "WALK")
                     return;
               }
               else if (this .getNavigationInfo () .getViewer () !== "WALK")
                  return;

               // Get NavigationInfo values

               const
                  navigationInfo  = this .getNavigationInfo (),
                  viewpoint       = this .getViewpoint (),
                  collisionRadius = navigationInfo .getCollisionRadius (),
                  nearValue       = navigationInfo .getNearValue (),
                  avatarHeight    = navigationInfo .getAvatarHeight (),
                  stepHeight      = navigationInfo .getStepHeight ();

               // Reshape viewpoint for gravite.

               Camera .ortho (-collisionRadius,
                              collisionRadius,
                              -collisionRadius,
                              collisionRadius,
                              nearValue,
                              Math .max (collisionRadius * 2, avatarHeight * 2),
                              projectionMatrix);

               // Transform viewpoint to look down the up vector

               const
                  upVector = viewpoint .getUpVector (),
                  down     = rotation .setFromToVec (Vector3 .zAxis, upVector);

               cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
               cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
               cameraSpaceProjectionMatrix .rotate (down);
               cameraSpaceProjectionMatrix .inverse ();

               cameraSpaceProjectionMatrix .multRight (projectionMatrix);
               cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

               this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

               let distance = -this .getDepth (projectionMatrix);

               this .getProjectionMatrix () .pop ();

               // Gravite or step up

               distance -= avatarHeight;

               const up = rotation .setFromToVec (Vector3 .yAxis, upVector);

               if (distance > 0)
               {
                  // Gravite and fall down the to the floor

                  const currentFrameRate = this .speed ? browser .getCurrentFrameRate () : 1000000;

                  this .speed -= browser .getBrowserOptions () ._Gravity .getValue () / currentFrameRate;

                  let y = this .speed / currentFrameRate;

                  if (y < -distance)
                  {
                     // The ground is reached.
                     y = -distance;
                     this .speed = 0;
                  }

                  viewpoint ._positionOffset = viewpoint ._positionOffset .getValue () .add (up .multVecRot (translation .set (0, y, 0)));
               }
               else
               {
                  this .speed = 0;

                  distance = -distance;

                  if (distance > 0.01 && distance < stepHeight)
                  {
                     // Step up
                     this .constrainTranslation (up .multVecRot (translation .set (0, distance, 0)), false);

                     //if (getBrowser () -> getBrowserOptions () -> animateStairWalks ())
                     //{
                     //	float step = getBrowser () -> getCurrentSpeed () / getBrowser () -> getCurrentFrameRate ();
                     //	step = abs (getViewMatrix () .mult_matrix_dir (Vector3f (0, step, 0) * up));
                     //
                     //	Vector3f offset = Vector3f (0, step, 0) * up;
                     //
                     //	if (math::abs (offset) > math::abs (translation) or getBrowser () -> getCurrentSpeed () == 0)
                     //		offset = translation;
                     //
                     //	getViewpoint () -> positionOffset () += offset;
                     //}
                     //else
                        viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());
                  }
               }
            }
         };
      })(),
      depth: (function ()
      {
         const projectionMatrixArray = new Float32Array (16);

         return function (shapes, numShapes)
         {
            const
               browser    = this .getBrowser (),
               gl         = browser .getContext (),
               viewport   = this .getViewVolume () .getViewport (),
               shaderNode = browser .getDepthShader ();

            // Configure depth shader.

            if (shaderNode .isValid ())
            {
               shaderNode .enable (gl);

               projectionMatrixArray .set (this .getProjectionMatrix () .get ());

               gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrixArray);

               // Configure viewport and background

               gl .viewport (viewport [0],
                             viewport [1],
                             viewport [2],
                             viewport [3]);

               gl .scissor (viewport [0],
                            viewport [1],
                            viewport [2],
                            viewport [3]);

               gl .clearColor (1, 0, 0, 0); // Must be '1, 0, 0, 0'.
               gl .clear (gl .COLOR_BUFFER_BIT | gl .DEPTH_BUFFER_BIT);

               // Render all objects

               gl .enable (gl .DEPTH_TEST);
               gl .depthMask (true);
               gl .disable (gl .BLEND);
               gl .disable (gl .CULL_FACE);

               for (let s = 0; s < numShapes; ++ s)
               {
                  const
                     context = shapes [s],
                     scissor = context .scissor;

                  // TODO: viewport must not be the browser or layer viewport.
                  gl .scissor (scissor .x,
                               scissor .y,
                               scissor .z,
                               scissor .w);

                  // Clip planes

                  shaderNode .setLocalObjects (gl, context .clipPlanes);

                  // modelViewMatrix

                  gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix, false, context .modelViewMatrix);

                  // Draw

                  context .shapeNode .depth (gl, context, shaderNode);
               }
            }
         };
      })(),
      draw: (function ()
      {
         const
            viewportArray          = new Int32Array (4),
            projectionMatrixArray  = new Float32Array (16),
            cameraSpaceMatrixArray = new Float32Array (16);

         return function ()
         {
            const
               browser                  = this .getBrowser (),
               gl                       = browser .getContext (),
               viewport                 = this .getViewVolume () .getViewport (),
               shaders                  = this .shaders,
               lights                   = this .lights,
               textureProjectors        = this .textureProjectors,
               generatedCubeMapTextures = this .generatedCubeMapTextures;


            // PREPARATIONS


            if (this .isIndependent ())
            {
               // Render shadow maps.

               for (const light of lights)
                  light .renderShadowMap (this);

               // Render GeneratedCubeMapTextures.

               for (const generatedCubeMapTexture of generatedCubeMapTextures)
                  generatedCubeMapTexture .renderTexture (this);
            }


            // DRAW


            // Set up shadow matrix for all lights, and matrix for all projective textures.

            browser .getHeadlight () .setGlobalVariables (this);

            for (const light of lights)
               light .setGlobalVariables (this);

            for (const textureProjector of textureProjectors)
               textureProjector .setGlobalVariables (this);

            // Configure viewport and background

            gl .viewport (viewport [0],
                          viewport [1],
                          viewport [2],
                          viewport [3]);

            gl .scissor (viewport [0],
                         viewport [1],
                         viewport [2],
                         viewport [3]);

            // Draw background.

            gl .clear (gl .DEPTH_BUFFER_BIT);

            this .getBackground () .display (gl, this, viewport);

            // Set global uniforms.

            viewportArray          .set (viewport);
            cameraSpaceMatrixArray .set (this .getCameraSpaceMatrix () .get ());
            projectionMatrixArray  .set (this .getProjectionMatrix () .get ());

            for (const shader of browser .getStandardShaders ())
               shaders .add (shader);

            for (const shader of shaders)
               shader .setGlobalUniforms (gl, this, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray);

            // Sorted blend

            // Render opaque objects first

            gl .enable (gl .DEPTH_TEST);
            gl .depthMask (true);
            gl .disable (gl .BLEND);

            const opaqueShapes = this .opaqueShapes;

            for (let i = 0, length = this .numOpaqueShapes; i < length; ++ i)
            {
               const
                  context = opaqueShapes [i],
                  scissor = context .scissor;

               gl .scissor (scissor .x,
                            scissor .y,
                            scissor .z,
                            scissor .w);

               context .shapeNode .display (gl, context);
               browser .resetTextureUnits ();
            }

            // Render transparent objects

            gl .depthMask (false);
            gl .enable (gl .BLEND);

            const transparentShapes = this .transparentShapes;

            this .transparencySorter .sort (0, this .numTransparentShapes);

            for (let i = 0, length = this .numTransparentShapes; i < length; ++ i)
            {
               const
                  context = transparentShapes [i],
                  scissor = context .scissor;

               gl .scissor (scissor .x,
                            scissor .y,
                            scissor .z,
                            scissor .w);

               context .shapeNode .display (gl, context);
               browser .resetTextureUnits ();
            }

            gl .depthMask (true);
            gl .disable (gl .BLEND);


            // POST DRAW

            const globalObjects = this .globalObjects;

            if (this .isIndependent ())
            {
               // Recycle clip planes, local fogs, local lights, and local projective textures.

               const localObjects = browser .getLocalObjects ();

               for (const localObject of localObjects)
                  localObject .dispose ();

               localObjects .length = 0;

               // Recycle global lights and global projective textures.

               for (const globalObject of globalObjects)
                  globalObject .dispose ();
            }

            // Reset containers.

            shaders .clear ();

            globalObjects            .length = 0;
            lights                   .length = 0;
            textureProjectors        .length = 0;
            generatedCubeMapTextures .length = 0;
         };
      })(),
   };

   function assign (lhs, rhs)
   {
      for (var i = 0, length = rhs .length; i < length; ++ i)
         lhs [i] = rhs [i];

      lhs .length = length;
   }

   return X3DRenderObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DBoundedObject',[
   "x_ite/Fields",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Box3",
],
function (Fields,
          X3DCast,
          X3DConstants,
          Vector3,
          Matrix4,
          Box3)
{
"use strict";

   function X3DBoundedObject (executionContext)
   {
      this .addType (X3DConstants .X3DBoundedObject);

      this .addChildObjects ("transformSensors_changed", new Fields .SFTime ());

      this ._bboxSize   .setUnit ("length");
      this ._bboxCenter .setUnit ("length");

      this .childBBox            = new Box3 (); // Must be unique for each X3DBoundedObject.
      this .transformSensorNodes = new Set ();
   }

   X3DBoundedObject .prototype =
   {
      constructor: X3DBoundedObject,
      initialize: function () { },
      getDefaultBBoxSize: (function ()
      {
         const defaultBBoxSize = new Vector3 (-1, -1, -1);

         return function ()
         {
            return defaultBBoxSize;
         };
      })(),
      getBBox: function (nodes, bbox, shadow)
      {
         // Must be unique for each X3DBoundedObject.
         const childBBox = this .childBBox;

         // Add bounding boxes.

         bbox .set ();

         for (var i = 0, length = nodes .length; i < length; ++ i)
         {
            const node = nodes [i];

            if (node .getBBox)
               bbox .add (node .getBBox (childBBox, shadow));
         }

         return bbox;
      },
      displayBBox: (function ()
      {
         const
            bbox   = new Box3 (),
            matrix = new Matrix4 ();

         return function (type, renderObject)
         {
            const modelViewMatrix = renderObject .getModelViewMatrix ();

            this .getBBox (bbox);

            matrix .set (bbox .center, null, bbox .size);

            modelViewMatrix .push ();
            modelViewMatrix .multLeft (matrix);

            this .getBrowser () .getBBoxNode () .traverse (type, renderObject);

            modelViewMatrix .pop ();
         };
      })(),
      addTransformSensor: function (transformSensorNode)
      {
         this .transformSensorNodes .add (transformSensorNode);

         this ._transformSensors_changed = this .getBrowser () .getCurrentTime ();
      },
      removeTransformSensor: function (transformSensorNode)
      {
         this .transformSensorNodes .delete (transformSensorNode);

         this ._transformSensors_changed = this .getBrowser () .getCurrentTime ();
      },
      getTransformSensors: function ()
      {
         return this .transformSensorNodes;
      },
   };

   return X3DBoundedObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DGroupingNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Grouping/X3DBoundedObject",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/X3DCast",
],
function (X3DChildNode,
          X3DBoundedObject,
          TraverseType,
          X3DConstants,
          X3DCast)
{
"use strict";

   function X3DGroupingNode (executionContext)
   {
      X3DChildNode     .call (this, executionContext);
      X3DBoundedObject .call (this, executionContext);

      this .addType (X3DConstants .X3DGroupingNode);

      this .hidden                    = false;
      this .allowedTypes              = new Set ();
      this .clipPlaneNodes            = [ ];
      this .localFogNodes             = [ ];
      this .lightNodes                = [ ];
      this .textureProjectorNodes     = [ ];
      this .pointingDeviceSensorNodes = [ ];
      this .maybeCameraObjects        = [ ];
      this .cameraObjects             = [ ];
      this .maybePickableSensorNodes  = [ ];
      this .pickableSensorNodes       = [ ];
      this .pickableObjects           = [ ];
      this .childNodes                = [ ];
      this .displayNodes              = [ ];
      this .visibleNodes              = [ ];
      this .boundedObjects            = [ ];
      this .sensors                   = new Map ();
   }

   X3DGroupingNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DBoundedObject .prototype,
   {
      constructor: X3DGroupingNode,
      initialize: function ()
      {
         X3DChildNode     .prototype .initialize .call (this);
         X3DBoundedObject .prototype .initialize .call (this);

         this ._transformSensors_changed .addInterest ("set_transformSensors__", this);

         this ._addChildren    .addInterest ("set_addChildren__",    this);
         this ._removeChildren .addInterest ("set_removeChildren__", this);
         this ._children       .addInterest ("set_children__",       this);

         this .set_children__ ();
      },
      getBBox: function (bbox, shadow)
      {
         return this .getSubBBox (bbox, shadow);
      },
      getSubBBox: function (bbox, shadow)
      {
         if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
            return X3DBoundedObject .prototype .getBBox .call (this, this .visibleNodes, bbox, shadow);

         return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
      },
      setHidden: function (value)
      {
         if (value !== this .hidden)
         {
            this .hidden = value;

            this .set_children__ ();
         }
      },
      setAllowedTypes: function (/* type, ... */)
      {
         const allowedTypes = this .allowedTypes;

         allowedTypes .clear ();

         for (const type of arguments)
            allowedTypes .add (type);
      },
      set_addChildren__: function ()
      {
         if (this ._addChildren .length === 0)
            return;

         this ._addChildren .setTainted (true);
         this ._addChildren .erase (remove (this ._addChildren, 0, this ._addChildren .length,
                                            this ._children,    0, this ._children    .length),
                                    this ._addChildren .length);

         if (!this ._children .isTainted ())
         {
            this ._children .removeInterest ("set_children__", this);
            this ._children .addInterest ("connectChildren", this);
         }

         this ._children .insert (this ._children .length, this ._addChildren, 0, this ._addChildren .length);
         this .add (this ._addChildren);

         this ._addChildren .length = 0;
         this ._addChildren .setTainted (false);
      },
      set_removeChildren__: function ()
      {
         if (this ._removeChildren .length === 0)
            return;

         this ._removeChildren .setTainted (true);

         if (this ._children .length > 0)
         {
            if (!this ._children .isTainted ())
            {
               this ._children .removeInterest ("set_children__", this);
               this ._children .addInterest ("connectChildren", this);
            }

            this ._children .erase (remove (this ._children,       0, this ._children .length,
                                            this ._removeChildren, 0, this ._removeChildren .length),
                                    this ._children .length);

            this .remove (this ._removeChildren);
         }

         this ._removeChildren .length = 0;
         this ._removeChildren .setTainted (false);
      },
      set_children__: function ()
      {
         this .clear ();
         this .add (this ._children);
      },
      connectChildren: function ()
      {
         this ._children .removeInterest ("connectChildren", this);
         this ._children .addInterest ("set_children__", this);
      },
      clear: function ()
      {
         for (const maybePickableSensorNode of this .maybePickableSensorNodes)
            maybePickableSensorNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

         for (const childNode of this .childNodes)
         {
            childNode ._isCameraObject   .removeInterest ("set_cameraObjects__",   this);
            childNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

            if (X3DCast (X3DConstants .X3DBoundedObject, childNode))
            {
               childNode ._visible     .removeInterest ("set_visibles__",      this);
               childNode ._bboxDisplay .removeInterest ("set_bboxDisplays__",  this);
            }
         }

         this .clipPlaneNodes            .length = 0;
         this .localFogNodes             .length = 0;
         this .lightNodes                .length = 0;
         this .textureProjectorNodes     .length = 0;
         this .pointingDeviceSensorNodes .length = 0;
         this .maybeCameraObjects        .length = 0;
         this .maybePickableSensorNodes  .length = 0;
         this .childNodes                .length = 0;
      },
      add: function (children)
      {
         if (this .hidden)
            return;

         for (const child of children)
         {
            if (child)
            {
               try
               {
                  const
                     innerNode = child .getValue () .getInnerNode (),
                     type      = innerNode .getType ();

                  for (let t = type .length - 1; t >= 0; -- t)
                  {
//							if (this .allowedTypes .size)
//							{
//								if (!innerNode .getType () .some (Set .prototype .has, this .allowedTypes))
//									continue;
//							}

                     switch (type [t])
                     {
                        case X3DConstants .X3DPointingDeviceSensorNode:
                        {
                           this .pointingDeviceSensorNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .ClipPlane:
                        {
                           this .clipPlaneNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .LocalFog:
                        {
                           this .localFogNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .X3DTextureProjectorNode:
                        {
                           this .textureProjectorNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .X3DLightNode:
                        {
                           this .lightNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .X3DBindableNode:
                        {
                           this .maybeCameraObjects .push (innerNode);
                           break;
                        }
                        case X3DConstants .TransformSensor:
                        case X3DConstants .X3DPickSensorNode:
                        {
                           innerNode ._isPickableObject .addInterest ("set_pickableObjects__", this);

                           this .maybePickableSensorNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .X3DBackgroundNode:
                        case X3DConstants .X3DChildNode:
                        {
                           innerNode ._isCameraObject   .addInterest ("set_cameraObjects__",   this);
                           innerNode ._isPickableObject .addInterest ("set_pickableObjects__", this);

                           if (X3DCast (X3DConstants .X3DBoundedObject, innerNode))
                           {
                              innerNode ._visible     .addInterest ("set_visibles__",     this);
                              innerNode ._bboxDisplay .addInterest ("set_bboxDisplays__", this);
                           }

                           this .maybeCameraObjects .push (innerNode);
                           this .childNodes .push (innerNode);
                           break;
                        }
                        case X3DConstants .BooleanFilter:
                        case X3DConstants .BooleanToggle:
                        case X3DConstants .NurbsOrientationInterpolator:
                        case X3DConstants .NurbsPositionInterpolator:
                        case X3DConstants .NurbsSurfaceInterpolator:
                        case X3DConstants .TimeSensor:
                        case X3DConstants .X3DFollowerNode:
                        case X3DConstants .X3DInfoNode:
                        case X3DConstants .X3DInterpolatorNode:
                        case X3DConstants .X3DKeyDeviceSensorNode:
                        case X3DConstants .X3DLayoutNode:
                        case X3DConstants .X3DScriptNode:
                        case X3DConstants .X3DSequencerNode:
                        case X3DConstants .X3DTriggerNode:
                           break;
                        default:
                           continue;
                     }

                     break;
                  }
               }
               catch (error)
               { }
            }
         }

         this .set_pickableObjects__ ()
         this .set_displayNodes__ ()
         this .set_visibles__ ()
         this .set_bboxDisplays__ ();
      },
      remove: function (children)
      {
         for (const child of children)
         {
            if (child)
            {
               try
               {
                  const
                     innerNode = child .getValue () .getInnerNode (),
                     type      = innerNode .getType ();

                  for (let t = type .length - 1; t >= 0; -- t)
                  {
                     switch (type [t])
                     {
                        case X3DConstants .X3DPointingDeviceSensorNode:
                        {
                           const index = this .pointingDeviceSensorNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .pointingDeviceSensorNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .ClipPlane:
                        {
                           const index = this .clipPlaneNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .clipPlaneNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .LocalFog:
                        {
                           const index = this .localFogNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .localFogNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .X3DTextureProjectorNode:
                        {
                           const index = this .textureProjectorNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .textureProjectorNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .X3DLightNode:
                        {
                           const index = this .lightNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .lightNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .X3DBindableNode:
                        {
                           const index = this .maybeCameraObjects .indexOf (innerNode);

                           if (index >= 0)
                              this .maybeCameraObjects .splice (index, 1);

                           break;
                        }
                        case X3DConstants .TransformSensor:
                        case X3DConstants .X3DPickSensorNode:
                        {
                           innerNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

                           const index = this .maybePickableSensorNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .maybePickableSensorNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .X3DBackgroundNode:
                        case X3DConstants .X3DChildNode:
                        {
                           innerNode ._isCameraObject   .removeInterest ("set_cameraObjects__",   this);
                           innerNode ._isPickableObject .removeInterest ("set_pickableObjects__", this);

                           if (X3DCast (X3DConstants .X3DBoundedObject, innerNode))
                           {
                              innerNode ._visible     .removeInterest ("set_visibles__",     this);
                              innerNode ._bboxDisplay .removeInterest ("set_bboxDisplays__", this);
                           }

                           var index = this .maybeCameraObjects .indexOf (innerNode);

                           if (index >= 0)
                              this .maybeCameraObjects .splice (index, 1);

                           var index = this .childNodes .indexOf (innerNode);

                           if (index >= 0)
                              this .childNodes .splice (index, 1);

                           break;
                        }
                        case X3DConstants .BooleanFilter:
                        case X3DConstants .BooleanToggle:
                        case X3DConstants .NurbsOrientationInterpolator:
                        case X3DConstants .NurbsPositionInterpolator:
                        case X3DConstants .NurbsSurfaceInterpolator:
                        case X3DConstants .TimeSensor:
                        case X3DConstants .X3DFollowerNode:
                        case X3DConstants .X3DInfoNode:
                        case X3DConstants .X3DInterpolatorNode:
                        case X3DConstants .X3DKeyDeviceSensorNode:
                        case X3DConstants .X3DLayoutNode:
                        case X3DConstants .X3DScriptNode:
                        case X3DConstants .X3DSequencerNode:
                        case X3DConstants .X3DTriggerNode:
                           break;
                        default:
                           continue;
                     }

                     break;
                  }
               }
               catch (error)
               { }
            }
         }

         this .set_pickableObjects__ ();
         this .set_displayNodes__ ();
         this .set_visibles__ ();
         this .set_bboxDisplays__ ();
      },
      set_cameraObjects__: function ()
      {
         const cameraObjects = this .cameraObjects;

         cameraObjects .length = 0;

         for (const childNode of this .maybeCameraObjects)
         {
            if (childNode .getCameraObject ())
            {
               if (X3DCast (X3DConstants .X3DBoundedObject, childNode))
               {
                  if (childNode ._visible .getValue ())
                  {
                     cameraObjects .push (childNode);
                  }
               }
               else
               {
                  cameraObjects .push (childNode);
               }
            }
         }

         this .setCameraObject (Boolean (cameraObjects .length));
      },
      set_pickableObjects__: function ()
      {
         const
            pickableSensorNodes = this .pickableSensorNodes,
            pickableObjects     = this .pickableObjects;

         pickableSensorNodes .length = 0;
         pickableObjects     .length = 0;

         for (const sensorNode of this .maybePickableSensorNodes)
         {
            if (sensorNode .getPickableObject ())
               pickableSensorNodes .push (sensorNode);
         }

         for (const childNode of this .childNodes)
         {
            if (childNode .getPickableObject ())
               pickableObjects .push (childNode);
         }

         this .set_transformSensors__ ()
      },
      set_transformSensors__: function ()
      {
         this .setPickableObject (Boolean (this .getTransformSensors () .size || this .pickableSensorNodes .length || this .pickableObjects .length));
      },
      set_displayNodes__: function ()
      {
         const displayNodes = this .displayNodes;

         displayNodes .length = 0;

         for (const node of this .clipPlaneNodes)
            displayNodes .push (node);

         for (const node of this .localFogNodes)
            displayNodes .push (node);

         for (const node of this .lightNodes)
            displayNodes .push (node);

         for (const node of this .textureProjectorNodes)
            displayNodes .push (node);
      },
      set_visibles__: function ()
      {
         const
            childNodes   = this .childNodes,
            visibleNodes = this .visibleNodes;

         visibleNodes .length = 0;

         for (const childNode of childNodes)
         {
            if (X3DCast (X3DConstants .X3DBoundedObject, childNode))
            {
               if (childNode ._visible .getValue ())
               {
                  visibleNodes .push (childNode);
               }
            }
            else
            {
               visibleNodes .push (childNode);
            }
         }

         this .set_cameraObjects__ ();
      },
      set_bboxDisplays__: function ()
      {
         const boundedObjects = this .boundedObjects;

         boundedObjects .length = 0;

         for (const childNode of this .childNodes)
         {
            if (X3DCast (X3DConstants .X3DBoundedObject, childNode))
            {
               if (childNode ._bboxDisplay .getValue ())
               {
                  boundedObjects .push (childNode);
               }
            }
         }
      },
      traverse: function (type, renderObject)
      {
         switch (type)
         {
            case TraverseType .POINTER:
            {
               const
                  pointingDeviceSensorNodes = this .pointingDeviceSensorNodes,
                  clipPlaneNodes            = this .clipPlaneNodes,
                  sensors                   = this .sensors;

               sensors .clear ();

               if (pointingDeviceSensorNodes .length)
               {
                  for (const pointingDeviceSensorNode of pointingDeviceSensorNodes)
                     pointingDeviceSensorNode .push (renderObject, sensors);

                  if (sensors .size)
                     renderObject .getBrowser () .getSensors () .push (sensors);
               }

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .push (renderObject);

               for (const childNode of this .childNodes)
                  childNode .traverse (type, renderObject);

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .pop (renderObject);

               if (sensors .size)
                  renderObject .getBrowser () .getSensors () .pop ();

               return;
            }
            case TraverseType .CAMERA:
            {
               for (const cameraObject of this .cameraObjects)
                  cameraObject .traverse (type, renderObject);

               return;
            }
            case TraverseType .PICKING:
            {
               if (this .getTransformSensors () .size)
               {
                  const modelMatrix = renderObject .getModelViewMatrix () .get ();

                  for (const transformSensorNode of this .getTransformSensors ())
                     transformSensorNode .collect (modelMatrix);
               }

               for (const pickableSensorNode of this .pickableSensorNodes)
                  pickableSensorNode .traverse (type, renderObject);

               const
                  browser          = renderObject .getBrowser (),
                  pickingHierarchy = browser .getPickingHierarchy ();

               pickingHierarchy .push (this);

               if (browser .getPickable () .at (-1))
               {
                  for (const childNode of this .childNodes)
                     childNode .traverse (type, renderObject);
               }
               else
               {
                  for (const pickableObject of this .pickableObjects)
                     pickableObject .traverse (type, renderObject);
               }

               pickingHierarchy .pop ();
               return;
            }
            case TraverseType .COLLISION:
            {
               const clipPlaneNodes = this .clipPlaneNodes;

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .push (renderObject);

               for (const childNode of this .childNodes)
                  childNode .traverse (type, renderObject);

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .pop (renderObject);

               return;
            }
            case TraverseType .SHADOW:
            {
               // Nodes that are not visible do not cast shadows.

               const clipPlaneNodes = this .clipPlaneNodes;

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .push (renderObject);

               for (const visibleNode of this .visibleNodes)
                  visibleNode .traverse (type, renderObject);

               for (const clipPlaneNode of clipPlaneNodes)
                  clipPlaneNode .push (renderObject);

               return;
            }
            case TraverseType .DISPLAY:
            {
               const displayNodes = this .displayNodes;

               for (const displayNode of displayNodes)
                  displayNode .push (renderObject, this);

               for (const visibleNode of this .visibleNodes)
                  visibleNode .traverse (type, renderObject);

               for (const boundedObject of this .boundedObjects)
                  boundedObject .displayBBox (type, renderObject);

               for (const displayNode of displayNodes)
                  displayNode .pop (renderObject);

               return;
            }
         }
      },
   });

   function remove (array, first, last, range, rfirst, rlast)
   {
      const set = new Set ();

      for (let i = rfirst; i < rlast; ++ i)
         set .add (range [i]);

      function compare (value) { return set .has (value); }

      return array .remove (first, last, compare);
   }

   return X3DGroupingNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/X3DViewportNode',[
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Base/X3DConstants",
],
function (X3DGroupingNode,
          X3DConstants)
{
"use strict";

   function X3DViewportNode (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .X3DViewportNode);
   }

   X3DViewportNode .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: X3DViewportNode,
   });

   return X3DViewportNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/BindableStack',[
   "x_ite/Base/X3DBaseNode",
],
function (X3DBaseNode)
{
"use strict";

   function BindableStack (executionContext, defaultNode)
   {
      X3DBaseNode .call (this, executionContext);

      this .array          = [ defaultNode ];
      this .transitionNode = defaultNode .create (executionContext);
   }

   BindableStack .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BindableStack,
      getTypeName: function ()
      {
         return "BindableStack";
      },
      get: function ()
      {
         return this .array;
      },
      top: function ()
      {
         return this .transitionNode ._transitionActive .getValue () ? this .transitionNode : this .array .at (-1);
      },
      pushOnTop: function (node)
      {
         if (node !== this .array [0])
         {
            this .array .at (-1) ._isBound = false;
            this .array .push (node);
         }

         // Don't do set_bind.
         node ._isBound  = true;
         node ._bindTime = this .getBrowser () .getCurrentTime ();

         this .addNodeEvent ();
      },
      update: function (layerNode, removedNodes, changedNodes)
      {
         if (removedNodes .length === 0 && changedNodes .length === 0)
            return;

         // Save top node for later use.

         const
            fromNode  = this .top (),
            boundNode = this .array .at (-1);

         // Remove invisible nodes and unbind them if needed.

         for (const removedNode of removedNodes)
         {
            const index = this .array .indexOf (removedNode);

            if (index > 0)
               this .array .splice (index, 1);
         }

         // Unbind nodes with set_bind false and pop top node.

         if (boundNode !== this .array [0])
         {
            if (changedNodes .some (node => ! node ._set_bind .getValue () && node === boundNode))
            {
               this .array .pop ();
            }
         }

         // Push nodes with set_bind true to top of stack.

         for (const bindNode of changedNodes)
         {
            if (bindNode ._set_bind .getValue ())
            {
               const index = this .array .indexOf (bindNode);

               if (index > -1)
               {
                  this .array .splice (index, 1);
               }

               this .array .push (bindNode);
            }
         }

         // Bind top node if not bound.

         const top = this .array .at (-1);

         if (top === boundNode)
            return;

         // First unbind last bound node.

         boundNode ._set_bind = false;
         boundNode ._isBound  = false;

         // Now bind new top node.

         top ._set_bind  = true;
         top ._isBound   = true;
         top ._bindTime  = this .getBrowser () .getCurrentTime ();

         // Do transition.

         this .transitionNode = top .create (this .getExecutionContext ());

         this .transitionNode .setup ();
         this .transitionNode .transitionStart (layerNode, fromNode, top);

         if (this .transitionNode ._transitionActive .getValue ())
            this .transitionNode ._transitionActive .addInterest ("set_transitionActive__", this);

         this .addNodeEvent ();
      },
      set_transitionActive__: function (transitionActive)
      {
         if (transitionActive .getValue ())
            return;

         this .transitionNode ._transitionActive .removeInterest ("set_transitionActive__", this);

         this .addNodeEvent ();
      },
   });

   for (const key of Reflect .ownKeys (BindableStack .prototype))
      Object .defineProperty (BindableStack .prototype, key, { enumerable: false });

   return BindableStack;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/BindableList',[
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Core/X3DPrototypeInstance",
],
function (X3DBaseNode,
          X3DPrototypeInstance)
{
"use strict";

   function BindableList (executionContext, defaultNode)
   {
      X3DBaseNode .call (this, executionContext);

      this .collected    = [ defaultNode ];
      this .array        = [ defaultNode ];
      this .updateTime   = 0;
      this .removedNodes = [ ];
   }

   BindableList .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BindableList,
      getTypeName: function ()
      {
         return "BindableList";
      },
      get: function ()
      {
         return this .array;
      },
      getBound: function (name)
      {
         if (this .array .length > 1)
         {
            const
               enableInlineBindables = false,
               mainScene             = this .getMainScene ();

            if (name && name .length)
            {
               // Return first viewpoint with @name.

               for (let i = 1, length = this .array .length; i < length; ++ i)
               {
                  const
                     node      = this .array [i],
                     outerNode = node .getExecutionContext () .getOuterNode (),
                     scene     = outerNode instanceof X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

                  if (!enableInlineBindables && scene !== mainScene)
                     continue;

                  if (node .getName () == name)
                     return node;
               }
            }

            // Return first bound viewpoint in scene.

            for (let i = 1, length = this .array .length; i < length; ++ i)
            {
               const
                  node      = this .array [i],
                  outerNode = node .getExecutionContext () .getOuterNode (),
                  scene     = outerNode instanceof X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

               if (!enableInlineBindables && scene !== mainScene)
                  continue;

               if (node ._isBound .getValue ())
                  return node;
            }

            // Return first viewpoint in scene.

            for (let i = 1, length = this .array .length; i < length; ++ i)
            {
               const
                  node      = this .array [i],
                  outerNode = node .getExecutionContext () .getOuterNode (),
                  scene     = outerNode instanceof X3DPrototypeInstance ? outerNode .getScene () : node .getScene ();

               if (!enableInlineBindables && scene !== mainScene)
                  continue;

               return node;
            }
         }

         // Return default viewpoint.

         return this .array [0];
      },
      push: function (node)
      {
         return this .collected .push (node);
      },
      update: function (layerNode, stack)
      {
         const
            changedNodes = this .collected .filter (node => node ._set_bind .getModificationTime () > this .updateTime),
            removedNodes = this .removedNodes;

         if (! equals (this .collected, this .array))
         {
            // Unbind nodes not in current list (collected);

            for (const node of this .array)
            {
               if (this .collected .indexOf (node) === -1)
               {
                  removedNodes .push (node);
               }
            }

            // Swap arrays.

            const tmp = this .array;

            this .array     = this .collected;
            this .collected = tmp;
         }

         // Clear collected array.

         this .collected .length = 1;

         // Update stack.

         stack .update (layerNode, removedNodes, changedNodes)

         removedNodes .length = 0;

         // Advance updateTime time.

         this .updateTime = performance .now ();
      },
   });

   for (const key of Reflect .ownKeys (BindableList .prototype))
      Object .defineProperty (BindableList .prototype, key, { enumerable: false });

   // Compares two arrays.

   function equals (lhs, rhs)
   {
      if (lhs .length !== rhs .length)
         return false;

      for (let i = 0; i < lhs .length; ++ i)
      {
         if (lhs [i] !== rhs [i])
            return false
      }

      return true;
   }

   return BindableList;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/ObjectCache',[],function ()
{
"use strict";

   return function (Type)
   {
      return {
         stack: [ ],
         last: -1,
         pop: function ()
         {
            if (this .last > -1)
            {
               const object = this .stack [this .last];

               this .last --;

               return object;
            }

            return new Type ();
         },
         push: function (object)
         {
            this .last ++;
            return this .stack [this .last] = object;
         },
         clear: function ()
         {
            this .stack .length = 0;
            this .last          = -1;
         },
      };
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/X3DFogObject',[
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix3",
   "standard/Utility/ObjectCache",
],
function (X3DConstants,
          Matrix3,
          ObjectCache)
{
"use strict";

   const Fogs = ObjectCache (FogContainer);

   function FogContainer ()
   {
      this .fogMatrix = new Float32Array (9);
   }

   FogContainer .prototype =
   {
      constructor: FogContainer,
      set: function (fogNode, modelViewMatrix)
      {
         this .fogNode = fogNode;
         
         this .fogMatrix .set (modelViewMatrix .submatrix .inverse ());
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         if (shaderObject .hasFog (this))
            return;

         const
            fogNode         = this .fogNode,
            visibilityRange = Math .max (0, fogNode ._visibilityRange .getValue ());

         if (fogNode .getHidden () || visibilityRange === 0)
         {
            gl .uniform1i (shaderObject .x3d_FogType, 0); // NO_FOG
         }
         else
         {
            const color = fogNode ._color .getValue ();

            gl .uniform1i        (shaderObject .x3d_FogType,            fogNode .fogType);
            gl .uniform3f        (shaderObject .x3d_FogColor,           color .r, color .g, color .b);
            gl .uniform1f        (shaderObject .x3d_FogVisibilityRange, visibilityRange);
            gl .uniformMatrix3fv (shaderObject .x3d_FogMatrix, false,   this .fogMatrix);
         }
      },
      dispose: function ()
      {
         Fogs .push (this);
      },
   };

   function X3DFogObject (executionContext)
   {
      this .addType (X3DConstants .X3DFogObject);

      this ._visibilityRange .setUnit ("length");

      this .hidden = false;
   }

   X3DFogObject .prototype =
   {
      constructor: X3DFogObject,
      initialize: function ()
      {
         this ._fogType .addInterest ("set_fogType__", this);

         this .set_fogType__ ();
      },
      set_fogType__: function ()
      {
         switch (this ._fogType .getValue ())
         {
            case "EXPONENTIAL":
               this .fogType = 2;
               break;
            //case "EXPONENTIAL2":
            //	this .fogType = 3;
            //	break;
            default:
               this .fogType = 1;
               break;
         }
      },
      setHidden: function (value)
      {
         this .hidden = value;

         this .getBrowser () .addBrowserEvent ();
      },
      getHidden: function ()
      {
         return this .hidden;
      },
      getFogs: function ()
      {
         return Fogs;
      },
   };

   return X3DFogObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/Fog',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DBindableNode",
   "x_ite/Components/EnvironmentalEffects/X3DFogObject",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBindableNode,
          X3DFogObject,
          TraverseType,
          X3DConstants,
          Matrix4)
{
"use strict";

   function Fog (executionContext)
   {
      X3DBindableNode .call (this, executionContext);
      X3DFogObject    .call (this, executionContext);

      this .addType (X3DConstants .Fog);

      this .modelMatrix = new Matrix4 ();
   }

   Fog .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
      X3DFogObject .prototype,
   {
      constructor: Fog,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",        new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fogType",         new Fields .SFString ("LINEAR")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",           new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityRange", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",         new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",        new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "Fog";
      },
      getComponentName: function ()
      {
         return "EnvironmentalEffects";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DBindableNode .prototype .initialize .call (this);
         X3DFogObject    .prototype .initialize .call (this);
      },
      getModelMatrix: function ()
      {
         return this .modelMatrix;
      },
      traverse: function (type, renderObject)
      {
         if (type !== TraverseType .CAMERA)
            return;

         renderObject .getLayer () .getFogs () .push (this);

         this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
      },
   });

   return Fog;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/VertexArray',[],function ()
{
"use strict";

   function VertexArray ()
   {
      this .vertexArray = null;
      this .shaderNode  = null;
      this .tainted     = true;
   }

   VertexArray .prototype =
   {
      update: function ()
      {
         this .tainted = true;
      },
      enable: function (gl, shaderNode)
      {
         if (this .tainted || this .shaderNode !== shaderNode)
         {
            gl .deleteVertexArray (this .vertexArray);

            this .vertexArray = gl .createVertexArray ();
            this .shaderNode  = shaderNode;
            this .tainted     = false;

            gl .bindVertexArray (this .vertexArray);

            // console .log ("update vao");

            return true;
         }
         else
         {
            gl .bindVertexArray (this .vertexArray);

            return false;
         }
      },
      disable: function (gl)
      {
         gl .bindVertexArray (null);
      },
      delete: function (gl)
      {
         gl .deleteVertexArray (this .vertexArray);
      },
   };

   return VertexArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Complex',[],function ()
{
"use strict";

   function Complex (real, imag)
   {
      this .real = real
      this .imag = imag;
   }

   Complex .prototype =
   {
      constructor: Complex,
      [Symbol .iterator]: function* ()
      {
         yield this .real;
         yield this .imag;
      },
      copy: function ()
      {
         const copy = Object .create (Complex .prototype);
         copy .real = this .real;
         copy .imag = this .imag;
         return copy;
      },
      assign: function (complex)
      {
         this .real = complex .real;
         this .imag = complex .imag;
         return this;
      },
      equals: function (complex)
      {
         return this .real === complex .real &&
                this .imag === complex .imag;
      },
      setRadius: function (radius)
      {
         return this .setPolar (radius, this .getAngle ());
      },
      getRadius: function ()
      {
         if (this .real)
         {
            if (this .imag)
               return Math .hypot (this .real, this .imag);

            return Math .abs (this .real);
         }

         return Math .abs (this .imag);
      },
      setAngle: function (angle)
      {
         return this .setPolar (this .getRadius (), angle);
      },
      getAngle: function ()
      {
         return Math .atan2 (this .imag, this .real);
      },
      setPolar: function (radius, angle)
      {
         this .real = radius * Math .cos (angle);
         this .imag = radius * Math .sin (angle);
         return this;
      },
      conjugate: function ()
      {
         this .imag = -this .imag;
         return this;
      },
      negate: function ()
      {
         this .real = -this .real;
         this .imag = -this .imag;
         return this;
      },
      inverse: function ()
      {
         const d = this .real * this .real + this .imag * this .imag;

         this .real /=  d;
         this .imag /= -d;
         return this;
      },
      add: function (value)
      {
         this .real += value .real;
         this .imag += value .imag;
         return this;
      },
      subtract: function (value)
      {
         this .real -= value .real;
         this .imag -= value .imag;
         return this;
      },
      multiply: function (value)
      {
         this .real *= value;
         this .imag *= value;
         return this;
      },
      multComp: function ()
      {
         const
            real = this .real,
            imag = this .imag;

         this .real = real * value .real - imag * value .imag;
         this .imag = real * value .imag + imag * value .real;
         return this;
      },
      //divide: function (value)
      //{
      //	return this;
      //},
      divComp: function (value)
      {
         const
            ar = this .real, ai = this .imag,
            br = value .real, bi = value .imag;

         const d = br * br + bi * bi;

         this .real = (ar * br + ai * bi) / d;
         this .imag = (ai * br - ar * bi) / d;
         return this;
      },
      toString: function ()
      {
         if (this .imag)
            return this .real + " " + this .imag + "i";

         return "" + this .real;
      },
   };

   Object .assign (Complex,
   {
      Polar: function (radius, angle)
      {
         const complex = Object .create (Complex .prototype);
         complex .real = radius * Math .cos (angle);
         complex .imag = radius * Math .sin (angle);
         return complex;
      },
      multiply: function (lhs, rhs)
      {
         return lhs .copy () .multiply (rhs);
      },
      multComp: function (lhs, rhs)
      {
         return lhs .copy () .multComp (rhs);
      },
   });

   return Complex;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/X3DBackgroundNode',[
   "x_ite/Components/Core/X3DBindableNode",
   "x_ite/Rendering/VertexArray",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Complex",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithm",
],
function (X3DBindableNode,
          VertexArray,
          TraverseType,
          X3DConstants,
          ViewVolume,
          Complex,
          Vector3,
          Rotation4,
          Matrix4,
          Algorithm)
{
"use strict";

   const
      RADIUS      = 1,
      SIZE        = Math .sqrt (RADIUS * RADIUS / 2),
      U_DIMENSION = 20;

   const s = SIZE;

   const texCoords = [
      1, 1, 0, 1,
      0, 1, 0, 1,
      0, 0, 0, 1,
      1, 1, 0, 1,
      0, 0, 0, 1,
      1, 0, 0, 1,
   ];

   const frontVertices = [
       s,  s, -s, 1,
      -s,  s, -s, 1,
      -s, -s, -s, 1,
       s,  s, -s, 1,
      -s, -s, -s, 1,
       s, -s, -s, 1,
   ];

   const backVertices = [
      -s,  s,  s, 1,
       s,  s,  s, 1,
       s, -s,  s, 1,
      -s,  s,  s, 1,
       s, -s,  s, 1,
      -s, -s,  s, 1,
   ];

   const leftVertices = [
      -s,  s, -s, 1,
      -s,  s,  s, 1,
      -s, -s,  s, 1,
      -s,  s, -s, 1,
      -s, -s,  s, 1,
      -s, -s, -s, 1,
   ];

   const rightVertices = [
      s,  s,  s, 1,
      s,  s, -s, 1,
      s, -s, -s, 1,
      s,  s,  s, 1,
      s, -s, -s, 1,
      s, -s,  s, 1,
   ];

   const topVertices = [
       s, s,  s, 1,
      -s, s,  s, 1,
      -s, s, -s, 1,
       s, s,  s, 1,
      -s, s, -s, 1,
       s, s, -s, 1,
   ];

   const bottomVertices = [
       s, -s, -s, 1,
      -s, -s, -s, 1,
      -s, -s,  s, 1,
       s, -s, -s, 1,
      -s, -s,  s, 1,
       s, -s,  s, 1,
   ];

   const
      z1 = new Complex (0, 0),
      z2 = new Complex (0, 0),
      y1 = new Complex (0, 0),
      y2 = new Complex (0, 0),
      y3 = new Complex (0, 0),
      y4 = new Complex (0, 0);

   function X3DBackgroundNode (executionContext)
   {
      X3DBindableNode .call (this, executionContext);

      this .addType (X3DConstants .X3DBackgroundNode);

      this ._skyAngle    .setUnit ("angle");
      this ._groundAngle .setUnit ("angle");

      this .hidden                = false;
      this .projectionMatrixArray = new Float32Array (16);
      this .modelMatrix           = new Matrix4 ();
      this .modelViewMatrixArray  = new Float32Array (16);
      this .localObjects          = [ ];
      this .colors                = [ ];
      this .sphere                = [ ];
      this .textures              = 0;
   }

   X3DBackgroundNode .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
   {
      constructor: X3DBackgroundNode,
      initialize: function ()
      {
         X3DBindableNode .prototype .initialize .call (this);

         const
            browser = this .getBrowser (),
            gl      = browser .getContext ();

         this .colorBuffer       = gl .createBuffer ();
         this .sphereBuffer      = gl .createBuffer ();
         this .texCoordBuffer    = gl .createBuffer ();
         this .cubeBuffer        = gl .createBuffer ();
         this .texCoordBuffers   = new Array (browser .getMaxTextures ()) .fill (gl .createBuffer ());
         this .frontBuffer       = gl .createBuffer ();
         this .backBuffer        = gl .createBuffer ();
         this .leftBuffer        = gl .createBuffer ();
         this .rightBuffer       = gl .createBuffer ();
         this .topBuffer         = gl .createBuffer ();
         this .bottomBuffer      = gl .createBuffer ();
         this .sphereArrayObject = new VertexArray ();
         this .frontArrayObject  = new VertexArray ();
         this .backArrayObject   = new VertexArray ();
         this .leftArrayObject   = new VertexArray ();
         this .rightArrayObject  = new VertexArray ();
         this .topArrayObject    = new VertexArray ();
         this .bottomArrayObject = new VertexArray ();

         this ._groundAngle  .addInterest ("build", this);
         this ._groundColor  .addInterest ("build", this);
         this ._skyAngle     .addInterest ("build", this);
         this ._skyColor     .addInterest ("build", this);
         this ._transparency .addInterest ("build", this);

         this .build ();
         this .transferRectangle ();
      },
      set_frontTexture__: function (value)
      {
         this .setTexture ("frontTexture", value, 0);
      },
      set_backTexture__: function (value)
      {
         this .setTexture ("backTexture", value, 1);
      },
      set_leftTexture__: function (value)
      {
         this .setTexture ("leftTexture", value, 2);
      },
      set_rightTexture__: function (value)
      {
         this .setTexture ("rightTexture", value, 3);
      },
      set_topTexture__: function (value)
      {
         this .setTexture ("topTexture", value, 4);
      },
      set_bottomTexture__: function (value)
      {
         this .setTexture ("bottomTexture", value, 5);
      },
      setTexture: function (key, texture, bit)
      {
         if (this [key])
            this [key] ._loadState .removeInterest ("setTextureBit", this);

         this [key] = texture;

         if (texture)
         {
            texture ._loadState .addInterest ("setTextureBit", this, texture, bit);
            this .setTextureBit (texture, bit, texture ._loadState);
         }
         else
            this .textures &= ~(1 << bit);
      },
      setTextureBit: function (texture, bit, loadState)
      {
         if (loadState .getValue () === X3DConstants .COMPLETE_STATE || (texture && texture .getData ()))
            this .textures |= 1 << bit;
         else
            this .textures &= ~(1 << bit);
      },
      setHidden: function (value)
      {
         this .hidden = value;

         this .getBrowser () .addBrowserEvent ();
      },
      getHidden: function ()
      {
         return this .hidden;
      },
      getTransparent: function ()
      {
         if (this .hidden)
            return true;

         if (this ._transparency .getValue () === 0)
            return false;

         if (! this .frontTexture  || this .frontTexture  ._transparent .getValue ())
               return true;

         if (! this .backTexture   || this .backTexture   ._transparent .getValue ())
               return true;

         if (! this .leftTexture   || this .leftTexture   ._transparent .getValue ())
               return true;

         if (! this .rightTexture  || this .rightTexture  ._transparent .getValue ())
               return true;

         if (! this .topTexture    || this .topTexture    ._transparent .getValue ())
               return true;

         if (! this .bottomTexture || this .bottomTexture ._transparent .getValue ())
               return true;

         return false;
      },
      getColor: function (theta, color, angle)
      {
         const index = Algorithm .upperBound (angle, 0, angle .length, theta);

         return color [index];
      },
      build: function ()
      {
         this .colors .length = 0;
         this .sphere .length = 0;

         if (this ._transparency .getValue () >= 1)
            return;

         const alpha = 1 - Algorithm .clamp (this ._transparency .getValue (), 0, 1);

         if (this ._groundColor .length === 0 && this ._skyColor .length == 1)
         {
            const s = SIZE;

            // Build cube

            this .sphere .vertices = 36;

            this .sphere .push ( s,  s, -s, 1, -s,  s, -s, 1, -s, -s, -s, 1, // Back
                                 s,  s, -s, 1, -s, -s, -s, 1,  s, -s, -s, 1,
                                -s,  s,  s, 1,  s,  s,  s, 1, -s, -s,  s, 1, // Front
                                -s, -s,  s, 1,  s,  s,  s, 1,  s, -s,  s, 1,
                                -s,  s, -s, 1, -s,  s,  s, 1, -s, -s,  s, 1, // Left
                                -s,  s, -s, 1, -s, -s,  s, 1, -s, -s, -s, 1,
                                   s,  s,  s, 1,  s,  s, -s, 1,  s, -s,  s, 1, // Right
                                 s, -s,  s, 1,  s,  s, -s, 1,  s, -s, -s, 1,
                                   s,  s,  s, 1, -s,  s,  s, 1, -s,  s, -s, 1, // Top
                                 s,  s,  s, 1, -s,  s, -s, 1,  s,  s, -s, 1,
                                -s, -s,  s, 1,  s, -s,  s, 1, -s, -s, -s, 1, // Bottom
                                -s, -s, -s, 1,  s, -s,  s, 1,  s, -s, -s, 1);

            const c = this ._skyColor [0];

            for (let i = 0, vertices = this .sphere .vertices; i < vertices; ++ i)
               this .colors .push (c .r, c .g, c .b, alpha);
         }
         else
         {
            // Build sphere

            if (this ._skyColor .length > this ._skyAngle .length)
            {
               const vAngle = this ._skyAngle .slice ();

               if (vAngle .length === 0 || vAngle [0] > 0)
                  vAngle .unshift (0);

               if (vAngle .at (-1) < Math .PI)
                  vAngle .push (Math .PI);

               if (vAngle .length === 2)
						vAngle .splice (1, 0, (vAngle [0] + vAngle [1]) / 2)

               this .buildSphere (RADIUS, vAngle, this ._skyAngle, this ._skyColor, alpha, false);
            }

            if (this ._groundColor .length > this ._groundAngle .length)
            {
               const vAngle = this ._groundAngle .slice () .reverse ();

               if (vAngle .length === 0 || vAngle [0] < Math .PI / 2)
                  vAngle .unshift (Math .PI / 2);

               if (vAngle .at (-1) > 0)
                  vAngle .push (0);

               this .buildSphere (RADIUS, vAngle, this ._groundAngle, this ._groundColor, alpha, true);
            }
         }

         this .transferSphere ();
      },
      buildSphere: function (radius, vAngle, angle, color, alpha, bottom)
      {
         const
            vAngleMax   = bottom ? Math .PI / 2 : Math .PI,
            V_DIMENSION = vAngle .length - 1;

         for (let v = 0; v < V_DIMENSION; ++ v)
         {
            let
               theta1 = Algorithm .clamp (vAngle [v],     0, vAngleMax),
               theta2 = Algorithm .clamp (vAngle [v + 1], 0, vAngleMax);

            if (bottom)
            {
               theta1 = Math .PI - theta1;
               theta2 = Math .PI - theta2;
            }

            z1 .setPolar (radius, theta1);
            z2 .setPolar (radius, theta2);

            const
               c1 = this .getColor (vAngle [v],     color, angle),
               c2 = this .getColor (vAngle [v + 1], color, angle);

            for (let u = 0; u < U_DIMENSION; ++ u)
            {
               // p4 --- p1
               //  |   / |
               //  | /   |
               // p3 --- p2

               // The last point is the first one.
               const u1 = u < U_DIMENSION - 1 ? u + 1 : 0;

               // p1, p2
               let phi = 2 * Math .PI * (u / U_DIMENSION);
               y1 .setPolar (-z1 .imag, phi);
               y2 .setPolar (-z2 .imag, phi);

               // p3, p4
               phi = 2 * Math .PI * (u1 / U_DIMENSION);
               y3 .setPolar (-z2 .imag, phi);
               y4 .setPolar (-z1 .imag, phi);

               // Triangle 1 and 2

               this .colors .push (c1 .r, c1 .g, c1 .b, alpha,
                                   c2 .r, c2 .g, c2 .b, alpha,
                                   c2 .r, c2 .g, c2 .b, alpha,
                                   // Triangle 2
                                   c1 .r, c1 .g, c1 .b, alpha,
                                   c1 .r, c1 .g, c1 .b, alpha,
                                   c2 .r, c2 .g, c2 .b, alpha);

               this .sphere .push (y1 .imag, z1 .real, y1 .real, 1,
                                   y3 .imag, z2 .real, y3 .real, 1,
                                   y2 .imag, z2 .real, y2 .real, 1,
                                   // Triangle 2
                                   y1 .imag, z1 .real, y1 .real, 1,
                                   y4 .imag, z1 .real, y4 .real, 1,
                                   y3 .imag, z2 .real, y3 .real, 1);
            }
         }
      },
      transferSphere: function ()
      {
         const gl = this .getBrowser () .getContext ();

         // Transfer colors.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .colors), gl .DYNAMIC_DRAW);

         // Transfer sphere.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .sphereBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .sphere), gl .DYNAMIC_DRAW);
         this .sphereCount = this .sphere .length / 4;
      },
      transferRectangle: function ()
      {
         const gl = this .getBrowser () .getContext ();

         // Transfer texCoords.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [0]);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (texCoords), gl .DYNAMIC_DRAW);

         // Transfer rectangle.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .frontBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (frontVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .backBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (backVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .leftBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (leftVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .rightBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (rightVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .topBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (topVertices), gl .DYNAMIC_DRAW);

         gl .bindBuffer (gl .ARRAY_BUFFER, this .bottomBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (bottomVertices), gl .DYNAMIC_DRAW);
      },
      traverse: function (type, renderObject)
      {
         switch (type)
         {
            case TraverseType .CAMERA:
            {
               renderObject .getLayer () .getBackgrounds () .push (this);

               this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
               return;
            }
            case TraverseType .DISPLAY:
            {
               const
                  sourceObjects = renderObject .getLocalObjects (),
                  destObjects   = this .localObjects;

               for (let i = 0, length = sourceObjects .length; i < length; ++ i)
                  destObjects [i] = sourceObjects [i];

               destObjects .length = sourceObjects .length;
               return;
            }
         }
      },
      display: (function ()
      {
         const
            invProjectionMatrix = new Matrix4 (),
            modelViewMatrix     = new Matrix4 (),
            rotation            = new Rotation4 (),
            scale               = new Vector3 (0, 0, 0),
            farVector           = new Vector3 (0, 0, 0);

         return function (gl, renderObject, viewport)
         {
            if (this .hidden)
               return;

            // Setup context.

            gl .disable (gl .DEPTH_TEST);
            gl .depthMask (false);
            gl .enable (gl .CULL_FACE);
            gl .frontFace (gl .CCW);

            // Get background scale.

            const farValue = -ViewVolume .unProjectPointMatrix (0, 0, 1, invProjectionMatrix .assign (renderObject .getProjectionMatrix () .get ()) .inverse (), viewport, farVector) .z * 0.8;

            // Get projection matrix.

            this .projectionMatrixArray .set (renderObject .getProjectionMatrix () .get ());

            // Rotate and scale background.

            modelViewMatrix .assign (this .modelMatrix);
            modelViewMatrix .multRight (renderObject .getViewMatrix () .get ());
            modelViewMatrix .get (null, rotation);
            modelViewMatrix .identity ();
            modelViewMatrix .rotate (rotation);
            modelViewMatrix .scale (scale .set (farValue, farValue, farValue));

            this .modelViewMatrixArray .set (modelViewMatrix);

            // Draw background sphere and texture cube.

            this .drawSphere (renderObject);

            if (this .textures)
               this .drawCube (renderObject);
         };
      })(),
      drawSphere: function (renderObject)
      {
         const transparency = this ._transparency .getValue ();

         if (transparency >= 1)
            return;

         const
            browser    = renderObject .getBrowser (),
            gl         = browser .getContext (),
            shaderNode = browser .getBackgroundSphereShader ();

         if (shaderNode .isValid ())
         {
            shaderNode .enable (gl);

            // Clip planes

            shaderNode .setLocalObjects (gl, this .localObjects);

            // Enable vertex attribute arrays.

            if (this .sphereArrayObject .enable (gl, shaderNode))
            {
               shaderNode .enableColorAttribute  (gl, this .colorBuffer,  0, 0);
               shaderNode .enableVertexAttribute (gl, this .sphereBuffer, 0, 0);
            }

            // Uniforms

            gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, this .projectionMatrixArray);
            gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, this .modelViewMatrixArray);

            // Setup context.

            if (transparency)
               gl .enable (gl .BLEND);
            else
               gl .disable (gl .BLEND);

            // Draw.

            gl .drawArrays (gl .TRIANGLES, 0, this .sphereCount);
         }
      },
      drawCube: (function ()
      {
         const
            textureMatrixArray = new Float32Array (Matrix4 .Identity),
            white              = new Float32Array ([1, 1, 1]);

         return function (renderObject)
         {
            const
               browser    = renderObject .getBrowser (),
               gl         = browser .getContext (),
               shaderNode = browser .getUnlitShader ();

            if (shaderNode .isValid ())
            {
               shaderNode .enable (gl);

               // Clip planes

               shaderNode .setLocalObjects (gl, this .localObjects);

               // Uniforms

               gl .uniform1i  (shaderNode .x3d_FogType,                            0);
               gl .uniform1i  (shaderNode .x3d_FillPropertiesFilled,               true);
               gl .uniform1i  (shaderNode .x3d_FillPropertiesHatched,              false);
               gl .uniform1i  (shaderNode .x3d_ColorMaterial,                      false);
               gl .uniform3fv (shaderNode .x3d_EmissiveColor,                      white)
               gl .uniform1i  (shaderNode .x3d_EmissiveTexture .textureType,       0)
               gl .uniform1f  (shaderNode .x3d_Transparency,                       0)
               gl .uniform1i  (shaderNode .x3d_NumTextures,                        1);
               gl .uniform1i  (shaderNode .x3d_TextureCoordinateGeneratorMode [0], 0);
               gl .uniform1i  (shaderNode .x3d_NumProjectiveTextures,              0);

               gl .uniformMatrix4fv (shaderNode .x3d_TextureMatrix [0], false, textureMatrixArray);
               gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix,  false, this .projectionMatrixArray);
               gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,   false, this .modelViewMatrixArray);

               // Draw.

               this .drawRectangle (gl, browser, shaderNode, renderObject, this .frontTexture,  this .frontBuffer,  this .frontArrayObject);
               this .drawRectangle (gl, browser, shaderNode, renderObject, this .backTexture,   this .backBuffer,   this .backArrayObject);
               this .drawRectangle (gl, browser, shaderNode, renderObject, this .leftTexture,   this .leftBuffer,   this .leftArrayObject);
               this .drawRectangle (gl, browser, shaderNode, renderObject, this .rightTexture,  this .rightBuffer,  this .rightArrayObject);
               this .drawRectangle (gl, browser, shaderNode, renderObject, this .topTexture,    this .topBuffer,    this .topArrayObject);
               this .drawRectangle (gl, browser, shaderNode, renderObject, this .bottomTexture, this .bottomBuffer, this .bottomArrayObject);
            }
         };
      })(),
      drawRectangle: function (gl, browser, shaderNode, renderObject, texture, buffer, vertexArray)
      {
         if (texture && (texture .checkLoadState () === X3DConstants .COMPLETE_STATE || texture .getData ()))
         {
            texture .setShaderUniforms (gl, shaderNode, renderObject);

            if (texture ._transparent .getValue ())
               gl .enable (gl .BLEND);
            else
               gl .disable (gl .BLEND);

            if (vertexArray .enable (gl, shaderNode))
            {
               shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
               shaderNode .enableVertexAttribute (gl, buffer, 0, 0);
            }

            // Draw.

            gl .drawArrays (gl .TRIANGLES, 0, 6);

            browser .resetTextureUnits ();
         }
      },
   });

   return X3DBackgroundNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureNode',[
   "x_ite/Fields",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function X3DTextureNode (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTextureNode);

      this .addChildObjects ("transparent", new Fields .SFBool ());

      this ._transparent .setAccessType (X3DConstants .outputOnly);
   }

   X3DTextureNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: X3DTextureNode,
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
   });

   return X3DTextureNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Texturing/X3DSingleTextureNode',[
   "x_ite/Components/Texturing/X3DTextureNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/X3DCast",
   "x_ite/Browser/Texturing/MultiTextureModeType",
   "x_ite/Browser/Texturing/MultiTextureSourceType",
   "x_ite/Browser/Texturing/MultiTextureFunctionType",
],
function (X3DTextureNode,
          X3DConstants,
          X3DCast,
          ModeType,
          SourceType,
          FunctionType)
{
"use strict";

   function X3DSingleTextureNode (executionContext)
   {
      X3DTextureNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSingleTextureNode);
   }

   X3DSingleTextureNode .prototype = Object .assign (Object .create (X3DTextureNode .prototype),
   {
      constructor: X3DSingleTextureNode,
      initialize: function ()
      {
         X3DTextureNode .prototype .initialize .call (this);

         this ._textureProperties .addInterest ("set_textureProperties__", this, true);

         const gl = this .getBrowser () .getContext ();

         this .texture = gl .createTexture ();

         this .set_textureProperties__ (false);
      },
      set_textureProperties__: function (update)
      {
         if (this .texturePropertiesNode)
            this .texturePropertiesNode .removeInterest ("updateTextureProperties", this);

         this .texturePropertiesNode = X3DCast (X3DConstants .TextureProperties, this ._textureProperties);

         if (! this .texturePropertiesNode)
            this .texturePropertiesNode = this .getBrowser () .getDefaultTextureProperties ();

         this .texturePropertiesNode .addInterest ("updateTextureProperties", this);

         if (update)
            this .updateTextureProperties ();
      },
      getTexture: function ()
      {
         return this .texture;
      },
      updateTextureProperties: (function ()
      {
         // Anisotropic Filtering in WebGL is handled by an extension, use one of getExtension depending on browser:

         const ANISOTROPIC_EXT = [
            "EXT_texture_filter_anisotropic",
            "MOZ_EXT_texture_filter_anisotropic",
            "WEBKIT_EXT_texture_filter_anisotropic",
         ];

         return function (target, haveTextureProperties, textureProperties, width, height, repeatS, repeatT, repeatR)
         {
            const gl = this .getBrowser () .getContext ();

            gl .bindTexture (target, this .getTexture ());

            if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! haveTextureProperties)
            {
               // Dont generate mipmaps.
               gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl .NEAREST);
               gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
            }
            else
            {
               if (textureProperties ._generateMipMaps .getValue ())
                  gl .generateMipmap (target);

               gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl [textureProperties .getMinificationFilter ()]);
               gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl [textureProperties .getMagnificationFilter ()]);
            }

            if (haveTextureProperties)
            {
               gl .texParameteri (target, gl .TEXTURE_WRAP_S, gl [textureProperties .getBoundaryModeS ()]);
               gl .texParameteri (target, gl .TEXTURE_WRAP_T, gl [textureProperties .getBoundaryModeT ()]);

               if (gl .getVersion () >= 2)
                  gl .texParameteri (target, gl .TEXTURE_WRAP_R, gl [textureProperties .getBoundaryModeR ()]);
            }
            else
            {
               gl .texParameteri (target, gl .TEXTURE_WRAP_S, repeatS ? gl .REPEAT : gl .CLAMP_TO_EDGE);
               gl .texParameteri (target, gl .TEXTURE_WRAP_T, repeatT ? gl .REPEAT : gl .CLAMP_TO_EDGE);

               if (gl .getVersion () >= 2)
                  gl .texParameteri (target, gl .TEXTURE_WRAP_R, repeatR ? gl .REPEAT : gl .CLAMP_TO_EDGE);
            }

            //gl .texParameterfv (target, gl .TEXTURE_BORDER_COLOR, textureProperties ._borderColor .getValue ());
            //gl .texParameterf  (target, gl .TEXTURE_PRIORITY,     textureProperties ._texturePriority .getValue ());

            for (const extension of ANISOTROPIC_EXT)
            {
               const ext = gl .getExtension (extension);

               if (ext)
               {
                  gl .texParameterf (target, ext .TEXTURE_MAX_ANISOTROPY_EXT, textureProperties ._anisotropicDegree .getValue ());
                  break;
               }
            }
         };
      })(),
      setShaderUniforms: function (gl, shaderObject, renderObject)
      {
         this .setShaderUniformsToChannel (gl, shaderObject, renderObject, shaderObject .x3d_Textures [0]);

         gl .uniform1i (shaderObject .x3d_NumTextures, 1);
         gl .uniform1i (shaderObject .x3d_MultiTextureMode [0],      ModeType .MODULATE);
         gl .uniform1i (shaderObject .x3d_MultiTextureAlphaMode [0], ModeType .MODULATE);
         gl .uniform1i (shaderObject .x3d_MultiTextureSource [0],    SourceType .DEFAULT);
         gl .uniform1i (shaderObject .x3d_MultiTextureFunction [0],  FunctionType .DEFAULT);
      },
   });

   return X3DSingleTextureNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTexture2DNode',[
   "x_ite/Components/Texturing/X3DSingleTextureNode",
   "x_ite/Base/X3DConstants",
],
function (X3DSingleTextureNode,
          X3DConstants)
{
"use strict";

   const defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

   function X3DTexture2DNode (executionContext)
   {
      X3DSingleTextureNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTexture2DNode);

      const gl = this .getBrowser () .getContext ();

      this .target = gl .TEXTURE_2D;
      this .width  = 0;
      this .height = 0;
      this .flipY  = false;
      this .data   = null;
   }

   X3DTexture2DNode .prototype = Object .assign (Object .create (X3DSingleTextureNode .prototype),
   {
      constructor: X3DTexture2DNode,
      initialize: function ()
      {
         X3DSingleTextureNode .prototype .initialize .call (this);

         this ._repeatS .addInterest ("updateTextureProperties", this);
         this ._repeatT .addInterest ("updateTextureProperties", this);

         const gl = this .getBrowser () .getContext ();

         gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
         gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
      },
      getTarget: function ()
      {
         return this .target;
      },
      getTextureType: function ()
      {
         return 2;
      },
      getTextureTypeString: function ()
      {
         return "2D";
      },
      getWidth: function ()
      {
         return this .width;
      },
      getHeight: function ()
      {
         return this .height;
      },
      getFlipY: function ()
      {
         return this .flipY;
      },
      getData: function ()
      {
         return this .data;
      },
      clearTexture: function ()
      {
         this .setTexture (1, 1, false, defaultData, false);

         this .data = null;
      },
      setTexture: function (width, height, transparent, data, flipY)
      {
         this .width  = width;
         this .height = height;
         this .flipY  = flipY;
         this .data   = data;

         const gl = this .getBrowser () .getContext ();

         gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
         gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
         gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);
         gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, false);

         this .setTransparent (transparent);
         this .updateTextureProperties ();
         this .addNodeEvent ();
      },
      updateTexture: function (data, flipY)
      {
         this .data = data;

         const gl = this .getBrowser () .getContext ();

         gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
         gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
         gl .texSubImage2D (gl .TEXTURE_2D, 0, 0, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);
         gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, false);

         if (this .texturePropertiesNode ._generateMipMaps .getValue ())
            gl .generateMipmap (gl .TEXTURE_2D);

         this .addNodeEvent ();
      },
      updateTextureProperties: function ()
      {
         X3DSingleTextureNode .prototype .updateTextureProperties .call (this,
                                                                         this .target,
                                                                         this ._textureProperties .getValue (),
                                                                         this .texturePropertiesNode,
                                                                         this .width,
                                                                         this .height,
                                                                         this ._repeatS .getValue (),
                                                                         this ._repeatT .getValue (),
                                                                         false);
      },
      setShaderUniformsToChannel: function (gl, shaderObject, renderObject, channel)
      {
         const textureUnit = renderObject .getBrowser () .getTexture2DUnit ();

         gl .activeTexture (gl .TEXTURE0 + textureUnit);
         gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
         gl .uniform1i (channel .textureType, 2);
         gl .uniform1i (channel .texture2D, textureUnit);
      },
   });

   return X3DTexture2DNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/ImageTexture',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTexture2DNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
   "x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DUrlObject,
          X3DConstants,
          Algorithm,
          DEBUG)
{
"use strict";

   function ImageTexture (executionContext)
   {
      X3DTexture2DNode .call (this, executionContext);
      X3DUrlObject     .call (this, executionContext);

      this .addType (X3DConstants .ImageTexture);

      this .urlStack = new Fields .MFString ();
   }

   ImageTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: ImageTexture,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "description",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties",    new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "ImageTexture";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texture";
      },
      initialize: function ()
      {
         X3DTexture2DNode .prototype .initialize .call (this);
         X3DUrlObject     .prototype .initialize .call (this);

         this .canvas = $("<canvas></canvas>");

         this .image = $("<img></img>");
         this .image .on ("load", this .setImage .bind (this));
         this .image .on ("error", this .setError .bind (this));
         this .image .bind ("abort", this .setError .bind (this));

         this .image [0] .crossOrigin = "Anonymous";

         this .requestImmediateLoad ();
      },
      unloadNow: function ()
      {
         this .clearTexture ();
      },
      loadNow: function ()
      {
         this .urlStack .setValue (this ._url);
         this .loadNext ();
      },
      loadNext: function ()
      {
         if (this .urlStack .length === 0)
         {
            this .clearTexture ();
            this .setLoadState (X3DConstants .FAILED_STATE);
            return;
         }

         // Get URL.

         this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

         if (this .URL .protocol !== "data:")
         {
            if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
               this .URL .searchParams .set ("_", Date .now ());
         }

         this .image .attr ("src", this .URL .href);
      },
      setError: function ()
      {
         if (this .URL .protocol !== "data:")
            console .warn ("Error loading image:", decodeURI (this .URL .href));

         this .loadNext ();
      },
      setImage: function ()
      {
         if (DEBUG)
         {
             if (this .URL .protocol !== "data:")
               console .info ("Done loading image:", decodeURI (this .URL .href));
         }

         try
         {
            const
               gl     = this .getBrowser () .getContext (),
               image  = this .image [0],
               canvas = this .canvas [0],
               cx     = canvas .getContext ("2d");

            let
               width  = image .width,
               height = image .height;

            // Scale image if needed and flip vertically.

            if (gl .getVersion () >= 2 || (Algorithm .isPowerOfTwo (width) && Algorithm .isPowerOfTwo (height)))
            {
               // Flip Y

               canvas .width  = width;
               canvas .height = height;

               cx .clearRect (0, 0, width, height);
               cx .save ();
               cx .translate (0, height);
               cx .scale (1, -1);
               cx .drawImage (image, 0, 0);
               cx .restore ();
            }
            else
            {
               // Flip Y and scale image to next power of two.

               width  = Algorithm .nextPowerOfTwo (width);
               height = Algorithm .nextPowerOfTwo (height);

               canvas .width  = width;
               canvas .height = height;

               cx .clearRect (0, 0, width, height);
               cx .save ();
               cx .translate (0, height);
               cx .scale (1, -1);
               cx .drawImage (image, 0, 0, image .width, image .height, 0, 0, width, height);
               cx .restore ();
            }

            // Determine image alpha.

            const data = cx .getImageData (0, 0, width, height) .data;

            let transparent = false;

            for (let i = 3, length = data .length; i < length; i += 4)
            {
               if (data [i] !== 255)
               {
                  transparent = true;
                  break;
               }
            }

            this .setTexture (width, height, transparent, new Uint8Array (data .buffer), false);
            this .setLoadState (X3DConstants .COMPLETE_STATE);
         }
         catch (error)
         {
            // Catch security error from cross origin requests.
            console .log (error .message);
            this .setError ();
         }
      },
   });

   return ImageTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/Background',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
   "x_ite/Components/Texturing/ImageTexture",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBackgroundNode,
          ImageTexture,
          X3DConstants)
{
"use strict";

   function Background (executionContext)
   {
      X3DBackgroundNode .call (this, executionContext);

      this .addType (X3DConstants .Background);
   }

   Background .prototype = Object .assign (Object .create (X3DBackgroundNode .prototype),
   {
      constructor: Background,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",     new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",     new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "frontUrl",     new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backUrl",      new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "leftUrl",      new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "rightUrl",     new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "topUrl",       new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "bottomUrl",    new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "skyAngle",     new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "skyColor",     new Fields .MFColor (new Fields .SFColor ())),
         new X3DFieldDefinition (X3DConstants .inputOutput, "groundAngle",  new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "groundColor",  new Fields .MFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",      new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",     new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "Background";
      },
      getComponentName: function ()
      {
         return "EnvironmentalEffects";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DBackgroundNode .prototype .initialize .call (this);

         const
            frontTexture      = new ImageTexture (this .getExecutionContext ()),
            backTexture       = new ImageTexture (this .getExecutionContext ()),
            leftTexture       = new ImageTexture (this .getExecutionContext ()),
            rightTexture      = new ImageTexture (this .getExecutionContext ()),
            topTexture        = new ImageTexture (this .getExecutionContext ()),
            bottomTexture     = new ImageTexture (this .getExecutionContext ()),
            textureProperties = this .getBrowser () .getBackgroundTextureProperties ();

         this ._frontUrl  .addFieldInterest (frontTexture  ._url);
         this ._backUrl   .addFieldInterest (backTexture   ._url);
         this ._leftUrl   .addFieldInterest (leftTexture   ._url);
         this ._rightUrl  .addFieldInterest (rightTexture  ._url);
         this ._topUrl    .addFieldInterest (topTexture    ._url);
         this ._bottomUrl .addFieldInterest (bottomTexture ._url);

         frontTexture  ._url = this ._frontUrl;
         backTexture   ._url = this ._backUrl;
         leftTexture   ._url = this ._leftUrl;
         rightTexture  ._url = this ._rightUrl;
         topTexture    ._url = this ._topUrl;
         bottomTexture ._url = this ._bottomUrl;

         frontTexture  ._textureProperties = textureProperties;
         backTexture   ._textureProperties = textureProperties;
         leftTexture   ._textureProperties = textureProperties;
         rightTexture  ._textureProperties = textureProperties;
         topTexture    ._textureProperties = textureProperties;
         bottomTexture ._textureProperties = textureProperties;

         frontTexture  .setup ();
         backTexture   .setup ();
         leftTexture   .setup ();
         rightTexture  .setup ();
         topTexture    .setup ();
         bottomTexture .setup ();

         this .set_frontTexture__  (frontTexture);
         this .set_backTexture__   (backTexture);
         this .set_leftTexture__   (leftTexture);
         this .set_rightTexture__  (rightTexture);
         this .set_topTexture__    (topTexture);
         this .set_bottomTexture__ (bottomTexture);
      }
   });

   return Background;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/X3DLayerNode',[
   "x_ite/Components/Core/X3DNode",
   "x_ite/Rendering/X3DRenderObject",
   "x_ite/Components/Layering/X3DViewportNode",
   "x_ite/Execution/BindableStack",
   "x_ite/Execution/BindableList",
   "x_ite/Components/Navigation/NavigationInfo",
   "x_ite/Components/EnvironmentalEffects/Fog",
   "x_ite/Components/EnvironmentalEffects/Background",
   "x_ite/Base/X3DCast",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Camera",
   "standard/Math/Geometry/Box3",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (X3DNode,
          X3DRenderObject,
          X3DViewportNode,
          BindableStack,
          BindableList,
          NavigationInfo,
          Fog,
          Background,
          X3DCast,
          TraverseType,
          X3DConstants,
          Camera,
          Box3,
          Vector3,
          Matrix4)
{
"use strict";

   var projectionMatrix = new Matrix4 ();

   function X3DLayerNode (executionContext, defaultViewpoint, groupNode)
   {
      X3DNode         .call (this, executionContext);
      X3DRenderObject .call (this, executionContext);

      this .addType (X3DConstants .X3DLayerNode);

      this .groupNode       = groupNode;
      this .currentViewport = null;

      this .defaultNavigationInfo = new NavigationInfo (executionContext);
      this .defaultViewpoint      = defaultViewpoint;
      this .defaultBackground     = new Background (executionContext);
      this .defaultFog            = new Fog (executionContext);

      this .navigationInfoStack = new BindableStack (executionContext, this .defaultNavigationInfo);
      this .viewpointStack      = new BindableStack (executionContext, this .defaultViewpoint);
      this .backgroundStack     = new BindableStack (executionContext, this .defaultBackground);
      this .fogStack            = new BindableStack (executionContext, this .defaultFog);

      this .navigationInfos = new BindableList (executionContext, this .defaultNavigationInfo);
      this .viewpoints      = new BindableList (executionContext, this .defaultViewpoint);
      this .backgrounds     = new BindableList (executionContext, this .defaultBackground);
      this .fogs            = new BindableList (executionContext, this .defaultFog);

      this .defaultBackground .setHidden (true);
      this .defaultFog        .setHidden (true);

      this .collisionTime = 0;
   }

   X3DLayerNode .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DRenderObject .prototype,
   {
      constructor: X3DLayerNode,
      layer0: false,
      initialize: function ()
      {
         X3DNode         .prototype .initialize .call (this);
         X3DRenderObject .prototype .initialize .call (this);

         this .defaultNavigationInfo .setup ();
         this .defaultViewpoint      .setup ();
         this .defaultBackground     .setup ();
         this .defaultFog            .setup ();

         this .navigationInfoStack .setup ();
         this .viewpointStack      .setup ();
         this .backgroundStack     .setup ();
         this .fogStack            .setup ();

         this .navigationInfos .setup ();
         this .viewpoints      .setup ();
         this .backgrounds     .setup ();
         this .fogs            .setup ();

         this ._viewport       .addInterest ("set_viewport__", this);

         this .set_viewport__ ();
      },
      isLayer0: function (value)
      {
         this .layer0 = value;
         this .defaultBackground .setHidden (! value);
      },
      getLayer: function ()
      {
         return this;
      },
      getGroup: function ()
      {
         return this .groupNode;
      },
      getViewport: function ()
      {
         return this .currentViewport;
      },
      getBackground: function ()
      {
         return this .backgroundStack .top ();
      },
      getFog: function ()
      {
         return this .fogStack .top ();
      },
      getNavigationInfo: function ()
      {
         return this .navigationInfoStack .top ();
      },
      getViewpoint: function ()
      {
         return this .viewpointStack .top ();
      },
      getBackgrounds: function ()
      {
         return this .backgrounds;
      },
      getFogs: function ()
      {
         return this .fogs;
      },
      getNavigationInfos: function ()
      {
         return this .navigationInfos;
      },
      getViewpoints: function ()
      {
         return this .viewpoints;
      },
      getUserViewpoints: function ()
      {
         var userViewpoints = [ ];

         for (var i = 0; i < this .viewpoints .get () .length; ++ i)
         {
            var viewpoint = this .viewpoints .get () [i];

            if (viewpoint ._description .length)
               userViewpoints .push (viewpoint);
         }

         return userViewpoints;
      },
      getBackgroundStack: function ()
      {
         return this .backgroundStack;
      },
      getFogStack: function ()
      {
         return this .fogStack;
      },
      getNavigationInfoStack: function ()
      {
         return this .navigationInfoStack;
      },
      getViewpointStack: function ()
      {
         return this .viewpointStack;
      },
      getBBox: function (bbox, shadow)
      {
         return this .groupNode .getBBox (bbox, shadow);
      },
      lookAt: function (factor, straighten)
      {
         this .getViewpoint () .lookAtBBox (this .getBBox (new Box3 ()), factor, straighten);
      },
      set_viewport__: function ()
      {
         this .currentViewport = X3DCast (X3DConstants .X3DViewportNode, this ._viewport);

         if (! this .currentViewport)
            this .currentViewport = this .getBrowser () .getDefaultViewport ();
      },
      bind: function (viewpointName)
      {
         this .traverse (TraverseType .CAMERA, this);

         // Bind first viewpoint in viewpoint list.

         const
            navigationInfoNode = this .navigationInfos .getBound (),
            backgroundNode     = this .backgrounds     .getBound (),
            fogNode            = this .fogs            .getBound (),
            viewpointNode      = this .viewpoints      .getBound (viewpointName);

         this .navigationInfoStack .pushOnTop (navigationInfoNode);
         this .viewpointStack      .pushOnTop (viewpointNode);
         this .backgroundStack     .pushOnTop (backgroundNode);
         this .fogStack            .pushOnTop (fogNode);

         viewpointNode .resetUserOffsets ();
      },
      traverse: function (type, renderObject)
      {
         renderObject = renderObject || this;

         var viewpoint = this .getViewpoint ();

         this .getProjectionMatrix ()  .pushMatrix (viewpoint .getProjectionMatrix (this));
         this .getCameraSpaceMatrix () .pushMatrix (viewpoint .getCameraSpaceMatrix ());
         this .getViewMatrix ()        .pushMatrix (viewpoint .getViewMatrix ());

         switch (type)
         {
            case TraverseType .POINTER:
               this .pointer (type, renderObject);
               break;
            case TraverseType .CAMERA:
               this .camera (type, renderObject);
               break;
            case TraverseType .PICKING:
               this .picking (type, renderObject);
               break;
            case TraverseType .COLLISION:
               this .collision (type, renderObject);
               break;
            case TraverseType .SHADOW:
            case TraverseType .DISPLAY:
               this .display (type, renderObject);
               break;
         }

         this .getViewMatrix ()        .pop ();
         this .getCameraSpaceMatrix () .pop ();
         this .getProjectionMatrix ()  .pop ();
      },
      pointer: function (type, renderObject)
      {
         if (this ._isPickable .getValue ())
         {
            var
               browser  = this .getBrowser (),
               viewport = this .currentViewport .getRectangle (browser);

            if (browser .getSelectedLayer ())
            {
               if (browser .getSelectedLayer () !== this)
                  return;
            }
            else
            {
               if (! browser .isPointerInRectangle (viewport))
                  return;
            }

            browser .setHitRay (this .getProjectionMatrix () .get (), viewport);
            this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

            this .currentViewport .push (this);
            this .groupNode .traverse (type, renderObject);
            this .currentViewport .pop (this);

            this .getModelViewMatrix () .pop ()
         }
      },
      camera: function (type, renderObject)
      {
         this .getModelViewMatrix () .pushMatrix (Matrix4 .Identity);

         this .currentViewport .push (this);
         this .groupNode .traverse (type, renderObject);
         this .currentViewport .pop (this);

         this .getModelViewMatrix () .pop ();

         this .navigationInfos .update (this, this .navigationInfoStack);
         this .viewpoints      .update (this, this .viewpointStack);
         this .backgrounds     .update (this, this .backgroundStack);
         this .fogs            .update (this, this .fogStack);

         this .getViewpoint () .update ();
      },
      picking: function (type, renderObject)
      {
         this .getModelViewMatrix () .pushMatrix (Matrix4 .Identity);

         this .currentViewport .push (this);
         this .groupNode .traverse (type, renderObject);
         this .currentViewport .pop (this);

         this .getModelViewMatrix () .pop ();
      },
      collision: function (type, renderObject)
      {
         var navigationInfo = this .getNavigationInfo ();

         if (navigationInfo ._transitionActive .getValue ())
            return;

         var
            collisionRadius = navigationInfo .getCollisionRadius (),
            avatarHeight    = navigationInfo .getAvatarHeight (),
            size            = Math .max (collisionRadius * 2, avatarHeight * 2);

         this .collisionTime = 0;

         Camera .ortho (-size, size, -size, size, -size, size, projectionMatrix);

         this .getProjectionMatrix () .pushMatrix (projectionMatrix);
         this .getModelViewMatrix  () .pushMatrix (this .getViewMatrix () .get ());

         // Render
         this .currentViewport .push (this);
         renderObject .render (type, this .groupNode .traverse, this .groupNode);
         this .currentViewport .pop (this);

         this .getModelViewMatrix  () .pop ()
         this .getProjectionMatrix () .pop ()
      },
      display: function (type, renderObject)
      {
         this .getNavigationInfo () .enable (type, renderObject);

         this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

         this .currentViewport .push (this);
         renderObject .render (type, this .groupNode .traverse, this .groupNode);
         this .currentViewport .pop (this);

         this .getModelViewMatrix () .pop ()
      },
   });

   return X3DLayerNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Viewpoint',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Navigation/X3DViewpointNode",
   "x_ite/Components/Interpolation/ScalarInterpolator",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Camera",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewpointNode,
          ScalarInterpolator,
          X3DConstants,
          Camera,
          Vector2,
          Vector3,
          Matrix4)
{
"use strict";

   function Viewpoint (executionContext)
   {
      X3DViewpointNode .call (this, executionContext);

      this .addType (X3DConstants .Viewpoint);

      this ._position         .setUnit ("length");
      this ._centerOfRotation .setUnit ("length");
      this ._fieldOfView      .setUnit ("angle");

      this .projectionMatrix        = new Matrix4 ();
      this .fieldOfViewInterpolator = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
   }

   Viewpoint .prototype = Object .assign (Object .create (X3DViewpointNode .prototype),
   {
      constructor: Viewpoint,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",          new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "position",          new Fields .SFVec3f (0, 0, 10)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "orientation",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "centerOfRotation",  new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fieldOfView",       new Fields .SFFloat (0.7854)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "jump",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",          new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "Viewpoint";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DViewpointNode .prototype .initialize .call (this);

         this .fieldOfViewInterpolator ._key = new Fields .MFFloat (0, 1);
         this .fieldOfViewInterpolator .setup ();

         this .getEaseInEaseOut () ._modifiedFraction_changed .addFieldInterest (this .fieldOfViewInterpolator ._set_fraction);
         this .fieldOfViewInterpolator ._value_changed .addFieldInterest (this ._fieldOfViewScale);
      },
      setInterpolators: function (fromViewpointNode, toViewpointNode)
      {
         if (fromViewpointNode .getType () .indexOf (X3DConstants .Viewpoint) >= 0)
         {
            const scale = fromViewpointNode .getFieldOfView () / toViewpointNode .getFieldOfView ();

            this .fieldOfViewInterpolator ._keyValue = new Fields .MFFloat (scale, toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewScale = scale;
         }
         else
         {
            this .fieldOfViewInterpolator ._keyValue = new Fields .MFFloat (toViewpointNode ._fieldOfViewScale .getValue (), toViewpointNode ._fieldOfViewScale .getValue ());

            this ._fieldOfViewScale = toViewpointNode ._fieldOfViewScale .getValue ();
         }
      },
      getFieldOfView: function ()
      {
         var fov = this ._fieldOfView .getValue () * this ._fieldOfViewScale .getValue ();

         return fov > 0 && fov < Math .PI ? fov : Math .PI / 4;
      },
      getScreenScale: (function ()
      {
         var screenScale = new Vector3 (0, 0, 0);

         return function (point, viewport)
         {
            // Returns the screen scale in meter/pixel for on pixel.

            var
               width  = viewport [2],
               height = viewport [3],
               size   = Math .abs (point .z) * Math .tan (this .getFieldOfView () / 2) * 2;

            if (width > height)
               size /= height;
            else
               size /= width;

            return screenScale .set (size, size, size);
         };
      })(),
      getViewportSize: (function ()
      {
         var viewportSize = new Vector2 (0, 0);

         return function (viewport, nearValue)
         {
            // Returns viewport size in meters.

            var
               width  = viewport [2],
               height = viewport [3],
               size   = nearValue * Math .tan (this .getFieldOfView () / 2) * 2,
               aspect = width / height;

            if (aspect > 1)
               return viewportSize .set (size * aspect, size);

            return viewportSize .set (size, size / aspect);
         };
      })(),
      getLookAtDistance: function (bbox)
      {
         return (bbox .size .abs () / 2) / Math .tan (this .getFieldOfView () / 2);
      },
      getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
      {
         return Camera .perspective (this .getFieldOfView (), nearValue, farValue, viewport [2], viewport [3], this .projectionMatrix);
      },
   });

   return Viewpoint;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Group',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DConstants)
{
"use strict";

   function Group (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .Group);
   }

   Group .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: Group,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Group";
      },
      getComponentName: function ()
      {
         return "Grouping";
      },
      getContainerField: function ()
      {
         return "children";
      },
   });

   return Group;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/Layer',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Layering/X3DLayerNode",
   "x_ite/Components/Navigation/Viewpoint",
   "x_ite/Components/Grouping/Group",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLayerNode,
          Viewpoint,
          Group,
          X3DConstants)
{
"use strict";

   function Layer (executionContext)
   {
      X3DLayerNode .call (this,
                          executionContext,
                          new Viewpoint (executionContext),
                          new Group (executionContext));

      this .addType (X3DConstants .Layer);
   }

   Layer .prototype = Object .assign (Object .create (X3DLayerNode .prototype),
   {
      constructor: Layer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "isPickable",     new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "viewport",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Layer";
      },
      getComponentName: function ()
      {
         return "Layering";
      },
      getContainerField: function ()
      {
         return "layers";
      },
      initialize: function ()
      {
         X3DLayerNode .prototype .initialize .call (this);

         this ._addChildren    .addFieldInterest (this .getGroup () ._addChildren);
         this ._removeChildren .addFieldInterest (this .getGroup () ._removeChildren);
         this ._children       .addFieldInterest (this .getGroup () ._children);

         this .getGroup () ._children = this ._children;
         this .getGroup () .setPrivate (true);
         this .getGroup () .setup ();
      },
   });

   return Layer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/LayerSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Layering/Layer",
   "x_ite/Base/X3DCast",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          Layer,
          X3DCast,
          TraverseType,
          X3DConstants)
{
"use strict";

   function LayerSet (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .LayerSet);

      this .layerNodes      = [ new Layer (executionContext) ];
      this .layerNode0      = this .layerNodes [0];
      this .activeLayerNode = null;
   }

   LayerSet .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: LayerSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "activeLayer", new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "order",       new Fields .MFInt32 (0)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "layers",      new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "LayerSet";
      },
      getComponentName: function ()
      {
         return "Layering";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DNode .prototype .initialize .call (this);

         this .layerNode0 .setPrivate (true);
         this .layerNode0 .setup ();
         this .layerNode0 .isLayer0 (true);

         this ._activeLayer .addInterest ("set_activeLayer", this);
         this ._order       .addInterest ("set_layers", this);
         this ._layers      .addInterest ("set_layers", this);

         this .set_layers ();
      },
      getActiveLayer: function ()
      {
         return this .activeLayerNode;
      },
      setLayer0: function (value)
      {
         this .layerNode0 = value;

         this .set_layers ();
      },
      getLayer0: function ()
      {
         return this .layerNode0;
      },
      getLayers: function ()
      {
         return this .layerNodes;
      },
      set_activeLayer: function ()
      {
         if (this ._activeLayer .getValue () === 0)
         {
            if (this .activeLayerNode !== this .layerNode0)
               this .activeLayerNode = this .layerNode0;
         }
         else
         {
            const index = this ._activeLayer - 1;

            if (index >= 0 && index < this ._layers .length)
            {
               if (this .activeLayerNode !== this ._layers [index] .getValue ())
                  this .activeLayerNode = X3DCast (X3DConstants .X3DLayerNode, this ._layers [index]);
            }
            else
            {
               if (this .activeLayerNode !== null)
                  this .activeLayerNode = null;
            }
         }
      },
      set_layers: function ()
      {
         const layers = this ._layers .getValue ();

         this .layerNodes .length = 0;

         for (let index of this ._order)
         {
            if (index === 0)
            {
               this .layerNodes .push (this .layerNode0);
            }
            else
            {
               -- index;

               if (index >= 0 && index < layers .length)
               {
                  const layerNode = X3DCast (X3DConstants .X3DLayerNode, layers [index]);

                  if (layerNode)
                     this .layerNodes .push (layerNode);
               }
            }
         }

         this .set_activeLayer ();
      },
      bind: function (viewpointName)
      {
         const layers = this ._layers .getValue ();

         this .layerNode0 .bind (viewpointName);

         for (let i = 0, length = layers .length; i < length; ++ i)
         {
            const layerNode = X3DCast (X3DConstants .X3DLayerNode, layers [i]);

            if (layerNode)
               layerNode .bind (viewpointName);
         }
      },
      traverse: function (type, renderObject)
      {
         const layerNodes = this .layerNodes;

         if (type === TraverseType .POINTER)
         {
            for (let i = 0, length = layerNodes .length; i < length; ++ i)
            {
               this .getBrowser () .setLayerNumber (i);
               layerNodes [i] .traverse (type, renderObject);
            }
         }
         else
         {
            for (const layerNode of layerNodes)
            {
               layerNode .traverse (type, renderObject);
            }
         }
      },
   });

   return LayerSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DWorld',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Fields/SFNode",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Layering/LayerSet",
   "x_ite/Components/Layering/Layer",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (SupportedNodes,
          SFNode,
          X3DBaseNode,
          LayerSet,
          Layer,
          X3DCast,
          X3DConstants)
{
"use strict";

   SupportedNodes .addAbstractType ("X3DWorld", X3DWorld);

   function X3DWorld (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addType (X3DConstants .X3DWorld)

      this .addChildObjects ("activeLayer", new SFNode (this .layer0));

      this .defaultLayerSet = new LayerSet (executionContext);
      this .layerSet        = this .defaultLayerSet;
      this .layer0          = new Layer (executionContext);
   }

   X3DWorld .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DWorld,
      getTypeName: function ()
      {
         return "X3DWorld";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         this .layerSet .setPrivate (true);
         this .layerSet .setup ();
         this .layerSet .setLayer0 (this .layer0);
         this .layerSet ._activeLayer .addInterest ("set_rootNodes__", this);

         this .getExecutionContext () .getRootNodes () .addInterest ("set_rootNodes__", this);

         this .set_rootNodes__ ();

         this .layer0 .setPrivate (true);
         this .layer0 .isLayer0 (true);
         this .layer0 .setup ();

         this .set_activeLayer__ ();
      },
      getCache: function ()
      {
         return true;
      },
      getLayerSet: function ()
      {
         return this .layerSet;
      },
      getActiveLayer: function ()
      {
         return this ._activeLayer .getValue ();
      },
      set_rootNodes__: function ()
      {
         const
            oldLayerSet = this .layerSet,
            rootNodes   = this .getExecutionContext () .getRootNodes ();

         this .layerSet          = this .defaultLayerSet;
         this .layer0 ._children = rootNodes;

         for (const rootNode of rootNodes)
         {
            const layerSet = X3DCast (X3DConstants .LayerSet, rootNode);

            if (layerSet)
               this .layerSet = layerSet;
         }

         if (this .layerSet === oldLayerSet)
            return;

         this .layerSet .setLayer0 (this .layer0);

         oldLayerSet    ._activeLayer .removeInterest ("set_activeLayer__", this);
         this .layerSet ._activeLayer .addInterest ("set_activeLayer__", this);

         this .set_activeLayer__ ();
      },
      set_activeLayer__: function ()
      {
         this ._activeLayer = this .layerSet .getActiveLayer ();
      },
      bind: function ()
      {
         // Bind first X3DBindableNodes found in each layer.

         const worldURL = this .getExecutionContext () .getWorldURL ();

         this .layerSet .bind (decodeURIComponent (new URL (worldURL, worldURL) .hash .substr (1)));
      },
      traverse: function (type, renderObject)
      {
         this .layerSet .traverse (type, renderObject);
      },
   });

   for (const key of Reflect .ownKeys (X3DWorld .prototype))
      Object .defineProperty (X3DWorld .prototype, key, { enumerable: false });

   return X3DWorld;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Networking/BinaryTransport',[],function ()
{
"use strict";

   return function ($)
   {
      // Use this transport for "binary" data type
      $.ajaxTransport ("+binary", function (options, originalOptions, jqXHR)
      {
         // Check for conditions and support for blob / arraybuffer response type
         if (options .dataType && options .dataType == 'binary')
         {
            return {
               send: function (headers, callback)
               {
                  // Setup all variables
                  const xhr = options .xhr ();

                  xhr .open (options .type, options .url, options .async, options .username, options .password);

                  // Apply custom fields if provided
                  if (options .xhrFields)
                  {
                     for (const i in options .xhrFields)
                        xhr [i] = options .xhrFields [i];
                  }

                  // Override mime type if needed
                  if (options .mimeType && xhr .overrideMimeType)
                     xhr .overrideMimeType (options .mimeType);

                  // Setup custom headers
                  for (const i in headers)
                     xhr .setRequestHeader (i, headers [i]);

                  // Setup onload callback
                  xhr .onload = function ()
                  {
                     xhr .onload = xhr .onerror = null;

                     const data = { };

                     data [options .dataType] = xhr .response;

                     callback (xhr .status || 200, xhr .statusText, data, xhr .getAllResponseHeaders ());
                  };

                  // Setup onerror callback
                  xhr .onerror = function ()
                  {
                     xhr .onload = xhr .onerror = null;

                     callback (xhr .status || 404, xhr .statusText);
                  };

                  // Send data
                  xhr .responseType = options .responseType || "blob";
                  xhr .send (options .hasContent && options .data || null);
               },
               abort: function ()
               {
                  const xhr = options .xhr ();

                  xhr .onload = xhr .onerror = null;

                  xhr .abort ();
               }
            };
         }
      });
   };
});


/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define('pako_inflate/dist/pako_inflate',['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));
}(this, (function (exports) { 'use strict';

  // Note: adler32 takes 12% for level 0 and 2% for level 6.
  // It isn't worth it to make additional optimizations as in original.
  // Small size is preferable.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const adler32 = (adler, buf, len, pos) => {
    let s1 = (adler & 0xffff) |0,
        s2 = ((adler >>> 16) & 0xffff) |0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = (s1 + buf[pos++]) |0;
        s2 = (s2 + s1) |0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return (s1 | (s2 << 16)) |0;
  };


  var adler32_1 = adler32;

  // Note: we can't get significant speed boost here.
  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // Use ordinary array, since untyped makes no boost here
  const makeTable = () => {
    let c, table = [];

    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }

    return table;
  };

  // Create table on load. Just 255 signed longs. Not a problem.
  const crcTable = new Uint32Array(makeTable());


  const crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;

    crc ^= -1;

    for (let i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
  };


  var crc32_1 = crc32;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // See state defs from inflate.js
  const BAD$1 = 30;       /* got a data error -- remain here until reset */
  const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8

     On return, state.mode is one of:

          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data

     Notes:

      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.

      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
  var inffast = function inflate_fast(strm, start) {
    let _in;                    /* local strm.input */
    let last;                   /* have enough input while in < last */
    let _out;                   /* local strm.output */
    let beg;                    /* inflate()'s initial strm.output */
    let end;                    /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
    let dmax;                   /* maximum distance from zlib header */
  //#endif
    let wsize;                  /* window size or zero if not using window */
    let whave;                  /* valid bytes in the window */
    let wnext;                  /* window write index */
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools
    let s_window;               /* allocated sliding window, if wsize != 0 */
    let hold;                   /* local strm.hold */
    let bits;                   /* local strm.bits */
    let lcode;                  /* local strm.lencode */
    let dcode;                  /* local strm.distcode */
    let lmask;                  /* mask for first level of length codes */
    let dmask;                  /* mask for first level of distance codes */
    let here;                   /* retrieved table entry */
    let op;                     /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    let len;                    /* match length, unused bytes */
    let dist;                   /* match distance */
    let from;                   /* where to copy match from */
    let from_source;


    let input, output; // JS specific, because we have no pointers

    /* copy state to local variables */
    const state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
    dmax = state.dmax;
  //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;


    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen:
      for (;;) { // Goto emulation
        op = here >>> 24/*here.bits*/;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff/*here.op*/;
        if (op === 0) {                          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          output[_out++] = here & 0xffff/*here.val*/;
        }
        else if (op & 16) {                     /* length base */
          len = here & 0xffff/*here.val*/;
          op &= 15;                           /* number of extra bits */
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          //Tracevv((stderr, "inflate:         length %u\n", len));
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];

          dodist:
          for (;;) { // goto emulation
            op = here >>> 24/*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff/*here.op*/;

            if (op & 16) {                      /* distance base */
              dist = here & 0xffff/*here.val*/;
              op &= 15;                       /* number of extra bits */
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
  //#ifdef INFLATE_STRICT
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD$1;
                break top;
              }
  //#endif
              hold >>>= op;
              bits -= op;
              //Tracevv((stderr, "inflate:         distance %u\n", dist));
              op = _out - beg;                /* max distance in output */
              if (dist > op) {                /* see if copy from window */
                op = dist - op;               /* distance back in window */
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD$1;
                    break top;
                  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //                if (len <= op - whave) {
  //                  do {
  //                    output[_out++] = 0;
  //                  } while (--len);
  //                  continue top;
  //                }
  //                len -= op - whave;
  //                do {
  //                  output[_out++] = 0;
  //                } while (--op > whave);
  //                if (op === 0) {
  //                  from = _out - dist;
  //                  do {
  //                    output[_out++] = output[from++];
  //                  } while (--len);
  //                  continue top;
  //                }
  //#endif
                }
                from = 0; // window index
                from_source = s_window;
                if (wnext === 0) {           /* very common case */
                  from += wsize - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                else if (wnext < op) {      /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {         /* some from end of window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {  /* some from start of window */
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;      /* rest from output */
                      from_source = output;
                    }
                  }
                }
                else {                      /* contiguous in window */
                  from += wnext - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              }
              else {
                from = _out - dist;          /* copy direct from output */
                do {                        /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            }
            else if ((op & 64) === 0) {          /* 2nd level distance code */
              here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
              continue dodist;
            }
            else {
              strm.msg = 'invalid distance code';
              state.mode = BAD$1;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        }
        else if ((op & 64) === 0) {              /* 2nd level length code */
          here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
          continue dolen;
        }
        else if (op & 32) {                     /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.mode = TYPE$1;
          break top;
        }
        else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;

    /* update state and return */
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const MAXBITS = 15;
  const ENOUGH_LENS$1 = 852;
  const ENOUGH_DISTS$1 = 592;
  //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

  const CODES$1 = 0;
  const LENS$1 = 1;
  const DISTS$1 = 2;

  const lbase = new Uint16Array([ /* Length codes 257..285 base */
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ]);

  const lext = new Uint8Array([ /* Length codes 257..285 extra */
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
    19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
  ]);

  const dbase = new Uint16Array([ /* Distance codes 0..29 base */
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577, 0, 0
  ]);

  const dext = new Uint8Array([ /* Distance codes 0..29 extra */
    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
    23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
    28, 28, 29, 29, 64, 64
  ]);

  const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
  {
    const bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

    let len = 0;               /* a code's length in bits */
    let sym = 0;               /* index of code symbols */
    let min = 0, max = 0;          /* minimum and maximum code lengths */
    let root = 0;              /* number of index bits for root table */
    let curr = 0;              /* number of index bits for current table */
    let drop = 0;              /* code bits to drop for sub-table */
    let left = 0;                   /* number of prefix codes available */
    let used = 0;              /* code entries in table used */
    let huff = 0;              /* Huffman code */
    let incr;              /* for incrementing code, index */
    let fill;              /* index for replicating entries */
    let low;               /* low bits for current root entry */
    let mask;              /* mask for low root bits */
    let next;             /* next available space in table */
    let base = null;     /* base value table to use */
    let base_index = 0;
  //  let shoextra;    /* extra bits table to use */
    let end;                    /* use base and extra for symbol > end */
    const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
    const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
    let extra = null;
    let extra_index = 0;

    let here_bits, here_op, here_val;

    /*
     Process a set of code lengths to create a canonical Huffman code.  The
     code lengths are lens[0..codes-1].  Each length corresponds to the
     symbols 0..codes-1.  The Huffman code is generated by first sorting the
     symbols by length from short to long, and retaining the symbol order
     for codes with equal lengths.  Then the code starts with all zero bits
     for the first code of the shortest length, and the codes are integer
     increments for the same length, and zeros are appended as the length
     increases.  For the deflate format, these bits are stored backwards
     from their more natural integer increment ordering, and so when the
     decoding tables are built in the large loop below, the integer codes
     are incremented backwards.

     This routine assumes, but does not check, that all of the entries in
     lens[] are in the range 0..MAXBITS.  The caller must assure this.
     1..MAXBITS is interpreted as that code length.  zero means that that
     symbol does not occur in this code.

     The codes are sorted by computing a count of codes for each length,
     creating from that a table of starting indices for each length in the
     sorted table, and then entering the symbols in order in the sorted
     table.  The sorted table is work[], with that space being provided by
     the caller.

     The length counts are used for other purposes as well, i.e. finding
     the minimum and maximum length codes, determining if there are any
     codes at all, checking for a valid set of lengths, and looking ahead
     at length counts to determine sub-table sizes when building the
     decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }

    /* bound code lengths, force root to be within code lengths */
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) { break; }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {                     /* no symbols to code at all */
      //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
      //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
      //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;


      //table.op[opts.table_index] = 64;
      //table.bits[opts.table_index] = 1;
      //table.val[opts.table_index++] = 0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;

      opts.bits = 1;
      return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) { break; }
    }
    if (root < min) {
      root = min;
    }

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }        /* over-subscribed */
    }
    if (left > 0 && (type === CODES$1 || max !== 1)) {
      return -1;                      /* incomplete set */
    }

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }

    /*
     Create and fill in decoding tables.  In this loop, the table being
     filled is at next and has curr index bits.  The code being used is huff
     with length len.  That code is converted to an index by dropping drop
     bits off of the bottom.  For codes where len is less than drop + curr,
     those top drop + curr - len bits are incremented through all values to
     fill the table with replicated entries.

     root is the number of index bits for the root table.  When len exceeds
     root, sub-tables are created pointed to by the root entry with an index
     of the low root bits of huff.  This is saved in low to check for when a
     new sub-table should be started.  drop is zero when the root table is
     being filled, and drop is root when sub-tables are being filled.

     When a new sub-table is needed, it is necessary to look ahead in the
     code lengths to determine what size sub-table is needed.  The length
     counts are used for this, and so count[] is decremented as codes are
     entered in the tables.

     used keeps track of how many table entries have been allocated from the
     provided *table space.  It is checked for LENS and DIST tables against
     the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
     the initial root table size constants.  See the comments in inftrees.h
     for more information.

     sym increments through all symbols, and the loop terminates when
     all codes of length max, i.e. all codes, have been processed.  This
     routine permits incomplete codes, so another loop after this one fills
     in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    // poor man optimization - use if-else instead of switch,
    // to avoid deopts in old v8
    if (type === CODES$1) {
      base = extra = work;    /* dummy value--not used */
      end = 19;

    } else if (type === LENS$1) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;

    } else {                    /* DISTS */
      base = dbase;
      extra = dext;
      end = -1;
    }

    /* initialize opts for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = table_index;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = -1;                   /* trigger new sub-table when len > root */
    used = 1 << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
      (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
      return 1;
    }

    /* process all codes and make table entries */
    for (;;) {
      /* create table entry */
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      }
      else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      }
      else {
        here_op = 32 + 64;         /* end of block */
        here_val = 0;
      }

      /* replicate for those indices with low len bits equal to huff */
      incr = 1 << (len - drop);
      fill = 1 << curr;
      min = fill;                 /* save offset to next table */
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
      } while (fill !== 0);

      /* backwards increment the len-bit code huff */
      incr = 1 << (len - 1);
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }

      /* go to next symbol, update count, len */
      sym++;
      if (--count[len] === 0) {
        if (len === max) { break; }
        len = lens[lens_index + work[sym]];
      }

      /* create new sub-table if needed */
      if (len > root && (huff & mask) !== low) {
        /* if first time, transition to sub-tables */
        if (drop === 0) {
          drop = root;
        }

        /* increment past last table */
        next += min;            /* here min is 1 << curr */

        /* determine length of next table */
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) { break; }
          curr++;
          left <<= 1;
        }

        /* check for enough space */
        used += 1 << curr;
        if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
          (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
          return 1;
        }

        /* point entry in root table to sub-table */
        low = huff & mask;
        /*table.op[low] = curr;
        table.bits[low] = root;
        table.val[low] = next - opts.table_index;*/
        table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
      }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
     at most one remaining entry, since if the code is incomplete, the
     maximum code length that was allowed to get this far is one bit) */
    if (huff !== 0) {
      //table.op[next + huff] = 64;            /* invalid code marker */
      //table.bits[next + huff] = len - drop;
      //table.val[next + huff] = 0;
      table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
    }

    /* set return parameters */
    //opts.table_index += used;
    opts.bits = root;
    return 0;
  };


  var inftrees = inflate_table;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var constants$1 = {

    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH:         0,
    Z_PARTIAL_FLUSH:    1,
    Z_SYNC_FLUSH:       2,
    Z_FULL_FLUSH:       3,
    Z_FINISH:           4,
    Z_BLOCK:            5,
    Z_TREES:            6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK:               0,
    Z_STREAM_END:       1,
    Z_NEED_DICT:        2,
    Z_ERRNO:           -1,
    Z_STREAM_ERROR:    -2,
    Z_DATA_ERROR:      -3,
    Z_MEM_ERROR:       -4,
    Z_BUF_ERROR:       -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION:         0,
    Z_BEST_SPEED:             1,
    Z_BEST_COMPRESSION:       9,
    Z_DEFAULT_COMPRESSION:   -1,


    Z_FILTERED:               1,
    Z_HUFFMAN_ONLY:           2,
    Z_RLE:                    3,
    Z_FIXED:                  4,
    Z_DEFAULT_STRATEGY:       0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY:                 0,
    Z_TEXT:                   1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN:                2,

    /* The deflate compression method */
    Z_DEFLATED:               8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.






  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$1;


  /* STATES ====================================================================*/
  /* ===========================================================================*/


  const    HEAD = 1;       /* i: waiting for magic header */
  const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
  const    TIME = 3;       /* i: waiting for modification time (gzip) */
  const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
  const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
  const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
  const    NAME = 7;       /* i: waiting for end of file name (gzip) */
  const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
  const    HCRC = 9;       /* i: waiting for header crc (gzip) */
  const    DICTID = 10;    /* i: waiting for dictionary check value */
  const    DICT = 11;      /* waiting for inflateSetDictionary() call */
  const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
  const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
  const        STORED = 14;    /* i: waiting for stored size (length and complement) */
  const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
  const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
  const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
  const        LENLENS = 18;   /* i: waiting for code length code lengths */
  const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
  const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
  const            LEN = 21;       /* i: waiting for length/lit/eob code */
  const            LENEXT = 22;    /* i: waiting for length extra bits */
  const            DIST = 23;      /* i: waiting for distance code */
  const            DISTEXT = 24;   /* i: waiting for distance extra bits */
  const            MATCH = 25;     /* o: waiting for output space to copy string */
  const            LIT = 26;       /* o: waiting for output space to write literal */
  const    CHECK = 27;     /* i: waiting for 32-bit check value */
  const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
  const    DONE = 29;      /* finished check, done -- remain here until reset */
  const    BAD = 30;       /* got a data error -- remain here until reset */
  const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
  const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

  /* ===========================================================================*/



  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

  const MAX_WBITS = 15;
  /* 32K LZ77 window */
  const DEF_WBITS = MAX_WBITS;


  const zswap32 = (q) => {

    return  (((q >>> 24) & 0xff) +
            ((q >>> 8) & 0xff00) +
            ((q & 0xff00) << 8) +
            ((q & 0xff) << 24));
  };


  function InflateState() {
    this.mode = 0;             /* current inflate mode */
    this.last = false;          /* true if processing last block */
    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
    this.havedict = false;      /* true if dictionary provided */
    this.flags = 0;             /* gzip header method and flags (0 if zlib) */
    this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
    this.check = 0;             /* protected copy of check value */
    this.total = 0;             /* protected copy of output count */
    // TODO: may be {}
    this.head = null;           /* where to save gzip header information */

    /* sliding window */
    this.wbits = 0;             /* log base 2 of requested window size */
    this.wsize = 0;             /* window size or zero if not using window */
    this.whave = 0;             /* valid bytes in the window */
    this.wnext = 0;             /* window write index */
    this.window = null;         /* allocated sliding window, if needed */

    /* bit accumulator */
    this.hold = 0;              /* input bit accumulator */
    this.bits = 0;              /* number of bits in "in" */

    /* for string and stored block copying */
    this.length = 0;            /* literal or length of data to copy */
    this.offset = 0;            /* distance back to copy string from */

    /* for table and code decoding */
    this.extra = 0;             /* extra bits needed */

    /* fixed and dynamic code tables */
    this.lencode = null;          /* starting table for length/literal codes */
    this.distcode = null;         /* starting table for distance codes */
    this.lenbits = 0;           /* index bits for lencode */
    this.distbits = 0;          /* index bits for distcode */

    /* dynamic table building */
    this.ncode = 0;             /* number of code length code lengths */
    this.nlen = 0;              /* number of length code lengths */
    this.ndist = 0;             /* number of distance code lengths */
    this.have = 0;              /* number of code lengths in lens[] */
    this.next = null;              /* next available space in codes[] */

    this.lens = new Uint16Array(320); /* temporary storage for code lengths */
    this.work = new Uint16Array(288); /* work area for code table building */

    /*
     because we don't have pointers in js, we use lencode and distcode directly
     as buffers so we don't need codes
    */
    //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
    this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
    this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
    this.sane = 0;                   /* if false, allow invalid distance too far */
    this.back = 0;                   /* bits back of last unprocessed length/lit */
    this.was = 0;                    /* initial length of match */
  }


  const inflateResetKeep = (strm) => {

    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = ''; /*Z_NULL*/
    if (state.wrap) {       /* to support ill-conceived Java test suite */
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null/*Z_NULL*/;
    state.hold = 0;
    state.bits = 0;
    //state.lencode = state.distcode = state.next = state.codes;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

    state.sane = 1;
    state.back = -1;
    //Tracev((stderr, "inflate: reset\n"));
    return Z_OK$1;
  };


  const inflateReset = (strm) => {

    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);

  };


  const inflateReset2 = (strm, windowBits) => {
    let wrap;

    /* get the state */
    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    }
    else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }

    /* update state and reset the rest of it */
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };


  const inflateInit2 = (strm, windowBits) => {

    if (!strm) { return Z_STREAM_ERROR$1; }
    //strm.msg = Z_NULL;                 /* in case we return an error */

    const state = new InflateState();

    //if (state === Z_NULL) return Z_MEM_ERROR;
    //Tracev((stderr, "inflate: allocated\n"));
    strm.state = state;
    state.window = null/*Z_NULL*/;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null/*Z_NULL*/;
    }
    return ret;
  };


  const inflateInit = (strm) => {

    return inflateInit2(strm, DEF_WBITS);
  };


  /*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
   */
  let virgin = true;

  let lenfix, distfix; // We have no pointers in JS, so keep tables separate


  const fixedtables = (state) => {

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);

      /* literal/length table */
      let sym = 0;
      while (sym < 144) { state.lens[sym++] = 8; }
      while (sym < 256) { state.lens[sym++] = 9; }
      while (sym < 280) { state.lens[sym++] = 7; }
      while (sym < 288) { state.lens[sym++] = 8; }

      inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

      /* distance table */
      sym = 0;
      while (sym < 32) { state.lens[sym++] = 5; }

      inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

      /* do this just once */
      virgin = false;
    }

    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };


  /*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
   */
  const updatewindow = (strm, src, end, copy) => {

    let dist;
    const state = strm.state;

    /* if it hasn't been done already, allocate space for the window */
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;

      state.window = new Uint8Array(state.wsize);
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    }
    else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      //zmemcpy(state->window + state->wnext, end - copy, dist);
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        //zmemcpy(state->window, end - copy, copy);
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      }
      else {
        state.wnext += dist;
        if (state.wnext === state.wsize) { state.wnext = 0; }
        if (state.whave < state.wsize) { state.whave += dist; }
      }
    }
    return 0;
  };


  const inflate$1 = (strm, flush) => {

    let state;
    let input, output;          // input/output buffers
    let next;                   /* next input INDEX */
    let put;                    /* next output INDEX */
    let have, left;             /* available input and output */
    let hold;                   /* bit buffer */
    let bits;                   /* bits in bit buffer */
    let _in, _out;              /* save starting available input and output */
    let copy;                   /* number of stored or match bytes to copy */
    let from;                   /* where to copy match bytes from */
    let from_source;
    let here = 0;               /* current decoding table entry */
    let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
    //let last;                   /* parent table entry */
    let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
    let len;                    /* length to copy for repeats, bits to drop */
    let ret;                    /* return code */
    const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
    let opts;

    let n; // temporary variable for NEED_BITS

    const order = /* permutation of code lengths */
      new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


    if (!strm || !strm.state || !strm.output ||
        (!strm.input && strm.avail_in !== 0)) {
      return Z_STREAM_ERROR$1;
    }

    state = strm.state;
    if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


    //--- LOAD() ---
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    //---

    _in = have;
    _out = left;
    ret = Z_OK$1;

    inf_leave: // goto emulation
    for (;;) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          //=== NEEDBITS(16);
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
            state.check = 0/*crc32(0L, Z_NULL, 0)*/;
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//

            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;           /* expect zlib header */
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) ||   /* check if zlib header allowed */
            (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
            strm.msg = 'incorrect header check';
            state.mode = BAD;
            break;
          }
          if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
          len = (hold & 0x0f)/*BITS(4)*/ + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          else if (len > state.wbits) {
            strm.msg = 'invalid window size';
            state.mode = BAD;
            break;
          }

          // !!! pako patch. Force use `options.windowBits` if passed.
          // Required to always use max window size by default.
          state.dmax = 1 << state.wbits;
          //state.dmax = 1 << len;

          //Tracev((stderr, "inflate:   zlib header ok\n"));
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = hold & 0x200 ? DICTID : TYPE;
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          break;
        case FLAGS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.flags = hold;
          if ((state.flags & 0xff) !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          if (state.flags & 0xe000) {
            strm.msg = 'unknown header flags set';
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = ((hold >> 8) & 1);
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = TIME;
          /* falls through */
        case TIME:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC4(state.check, hold)
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            hbuf[2] = (hold >>> 16) & 0xff;
            hbuf[3] = (hold >>> 24) & 0xff;
            state.check = crc32_1(state.check, hbuf, 4, 0);
            //===
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = OS;
          /* falls through */
        case OS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.xflags = (hold & 0xff);
            state.head.os = (hold >> 8);
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = EXLEN;
          /* falls through */
        case EXLEN:
          if (state.flags & 0x0400) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          else if (state.head) {
            state.head.extra = null/*Z_NULL*/;
          }
          state.mode = EXTRA;
          /* falls through */
        case EXTRA:
          if (state.flags & 0x0400) {
            copy = state.length;
            if (copy > have) { copy = have; }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  // Use untyped array for more convenient processing later
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
                //zmemcpy(state.head.extra + len, next,
                //        len + copy > state.head.extra_max ?
                //        state.head.extra_max - len : copy);
              }
              if (state.flags & 0x0200) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) { break inf_leave; }
          }
          state.length = 0;
          state.mode = NAME;
          /* falls through */
        case NAME:
          if (state.flags & 0x0800) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              // TODO: 2 or 1 bytes?
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.name_max*/)) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
          /* falls through */
        case COMMENT:
          if (state.flags & 0x1000) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.comm_max*/)) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
          /* falls through */
        case HCRC:
          if (state.flags & 0x0200) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (hold !== (state.check & 0xffff)) {
              strm.msg = 'header crc mismatch';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          if (state.head) {
            state.head.hcrc = ((state.flags >> 9) & 1);
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          strm.adler = state.check = zswap32(hold);
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = DICT;
          /* falls through */
        case DICT:
          if (state.havedict === 0) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = TYPE;
          /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case TYPEDO:
          if (state.last) {
            //--- BYTEBITS() ---//
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            state.mode = CHECK;
            break;
          }
          //=== NEEDBITS(3); */
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.last = (hold & 0x01)/*BITS(1)*/;
          //--- DROPBITS(1) ---//
          hold >>>= 1;
          bits -= 1;
          //---//

          switch ((hold & 0x03)/*BITS(2)*/) {
            case 0:                             /* stored block */
              //Tracev((stderr, "inflate:     stored block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = STORED;
              break;
            case 1:                             /* fixed block */
              fixedtables(state);
              //Tracev((stderr, "inflate:     fixed codes block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = LEN_;             /* decode codes */
              if (flush === Z_TREES) {
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
                break inf_leave;
              }
              break;
            case 2:                             /* dynamic block */
              //Tracev((stderr, "inflate:     dynamic codes block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = 'invalid block type';
              state.mode = BAD;
          }
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break;
        case STORED:
          //--- BYTEBITS() ---// /* go to byte boundary */
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
            strm.msg = 'invalid stored block lengths';
            state.mode = BAD;
            break;
          }
          state.length = hold & 0xffff;
          //Tracev((stderr, "inflate:       stored length %u\n",
          //        state.length));
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = COPY_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case COPY_:
          state.mode = COPY;
          /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) { copy = have; }
            if (copy > left) { copy = left; }
            if (copy === 0) { break inf_leave; }
            //--- zmemcpy(put, next, copy); ---
            output.set(input.subarray(next, next + copy), put);
            //---//
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          //Tracev((stderr, "inflate:       stored end\n"));
          state.mode = TYPE;
          break;
        case TABLE:
          //=== NEEDBITS(14); */
          while (bits < 14) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
  //#ifndef PKZIP_BUG_WORKAROUND
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = 'too many length or distance symbols';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracev((stderr, "inflate:       table sizes ok\n"));
          state.have = 0;
          state.mode = LENLENS;
          /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            //=== NEEDBITS(3);
            while (bits < 3) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          // We have separate tables & no pointers. 2 commented lines below not needed.
          //state.next = state.codes;
          //state.lencode = state.next;
          // Switch to use dynamic table
          state.lencode = state.lendyn;
          state.lenbits = 7;

          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid code lengths set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, "inflate:       code lengths ok\n"));
          state.have = 0;
          state.mode = CODELENS;
          /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if (here_val < 16) {
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              state.lens[state.have++] = here_val;
            }
            else {
              if (here_val === 16) {
                //=== NEEDBITS(here.bits + 2);
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                if (state.have === 0) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 0x03);//BITS(2);
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
              }
              else if (here_val === 17) {
                //=== NEEDBITS(here.bits + 3);
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 3 + (hold & 0x07);//BITS(3);
                //--- DROPBITS(3) ---//
                hold >>>= 3;
                bits -= 3;
                //---//
              }
              else {
                //=== NEEDBITS(here.bits + 7);
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 11 + (hold & 0x7f);//BITS(7);
                //--- DROPBITS(7) ---//
                hold >>>= 7;
                bits -= 7;
                //---//
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }

          /* handle error breaks in while */
          if (state.mode === BAD) { break; }

          /* check for end-of-block code (better have one) */
          if (state.lens[256] === 0) {
            strm.msg = 'invalid code -- missing end-of-block';
            state.mode = BAD;
            break;
          }

          /* build code tables -- note: do not change the lenbits or distbits
             values here (9 and 6) without reading the comments in inftrees.h
             concerning the ENOUGH constants, which depend on those values */
          state.lenbits = 9;

          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.lenbits = opts.bits;
          // state.lencode = state.next;

          if (ret) {
            strm.msg = 'invalid literal/lengths set';
            state.mode = BAD;
            break;
          }

          state.distbits = 6;
          //state.distcode.copy(state.codes);
          // Switch to use dynamic table
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.distbits = opts.bits;
          // state.distcode = state.next;

          if (ret) {
            strm.msg = 'invalid distances set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, 'inflate:       codes ok\n'));
          state.mode = LEN_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case LEN_:
          state.mode = LEN;
          /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            inffast(strm, _out);
            //--- LOAD() ---
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            //---

            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_op && (here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.lencode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            //Tracevv((stderr, "inflate:         end of block\n"));
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
          /* falls through */
        case LENEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
          //Tracevv((stderr, "inflate:         length %u\n", state.length));
          state.was = state.length;
          state.mode = DIST;
          /* falls through */
        case DIST:
          for (;;) {
            here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if ((here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.distcode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = (here_op) & 15;
          state.mode = DISTEXT;
          /* falls through */
        case DISTEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
  //#ifdef INFLATE_STRICT
          if (state.offset > state.dmax) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
          state.mode = MATCH;
          /* falls through */
        case MATCH:
          if (left === 0) { break inf_leave; }
          copy = _out - left;
          if (state.offset > copy) {         /* copy from window */
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //          Trace((stderr, "inflate.c too far\n"));
  //          copy -= state.whave;
  //          if (copy > state.length) { copy = state.length; }
  //          if (copy > left) { copy = left; }
  //          left -= copy;
  //          state.length -= copy;
  //          do {
  //            output[put++] = 0;
  //          } while (--copy);
  //          if (state.length === 0) { state.mode = LEN; }
  //          break;
  //#endif
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            }
            else {
              from = state.wnext - copy;
            }
            if (copy > state.length) { copy = state.length; }
            from_source = state.window;
          }
          else {                              /* copy from output */
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) { copy = left; }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) { state.mode = LEN; }
          break;
        case LIT:
          if (left === 0) { break inf_leave; }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              // Use '|' instead of '+' to make sure that result is signed
              hold |= input[next++] << bits;
              bits += 8;
            }
            //===//
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check =
                  /*UPDATE(state.check, put - _out, _out);*/
                  (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

            }
            _out = left;
            // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = 'incorrect data check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   check matches trailer\n"));
          }
          state.mode = LENGTH;
          /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (hold !== (state.total & 0xffffffff)) {
              strm.msg = 'incorrect length check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   length matches trailer\n"));
          }
          state.mode = DONE;
          /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
          /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }

    // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */

    //--- RESTORE() ---
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    //---

    if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                        (state.mode < CHECK || flush !== Z_FINISH$1))) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) +
                      (state.mode === TYPE ? 128 : 0) +
                      (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };


  const inflateEnd = (strm) => {

    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR$1;
    }

    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };


  const inflateGetHeader = (strm, head) => {

    /* check state */
    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

    /* save header structure */
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };


  const inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;

    let state;
    let dictid;
    let ret;

    /* check state */
    if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
    state = strm.state;

    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }

    /* check for correct dictionary identifier */
    if (state.mode === DICT) {
      dictid = 1; /* adler32(0, null, 0)*/
      /* dictid = adler32(dictid, dictionary, dictLength); */
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    /* copy dictionary to window using updatewindow(), which will amend the
     existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    // Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK$1;
  };


  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$1;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = 'pako inflate (from Nodeca project)';

  /* Not implemented
  module.exports.inflateCopy = inflateCopy;
  module.exports.inflateGetDictionary = inflateGetDictionary;
  module.exports.inflateMark = inflateMark;
  module.exports.inflatePrime = inflatePrime;
  module.exports.inflateSync = inflateSync;
  module.exports.inflateSyncPoint = inflateSyncPoint;
  module.exports.inflateUndermine = inflateUndermine;
  */

  var inflate_1$1 = {
  	inflateReset: inflateReset_1,
  	inflateReset2: inflateReset2_1,
  	inflateResetKeep: inflateResetKeep_1,
  	inflateInit: inflateInit_1,
  	inflateInit2: inflateInit2_1,
  	inflate: inflate_2$1,
  	inflateEnd: inflateEnd_1,
  	inflateGetHeader: inflateGetHeader_1,
  	inflateSetDictionary: inflateSetDictionary_1,
  	inflateInfo: inflateInfo
  };

  const _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  var assign = function (obj /*from1, from2, from3, ...*/) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) { continue; }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };


  // Join array of chunks to single array.
  var flattenChunks = (chunks) => {
    // calculate data length
    let len = 0;

    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    const result = new Uint8Array(len);

    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  };

  var common = {
  	assign: assign,
  	flattenChunks: flattenChunks
  };

  // String encode/decode helpers


  // Quick check if we can use fast array to bin string conversion
  //
  // - apply(Array) can fail on Android 2.2
  // - apply(Uint8Array) can fail on iOS 5.1 Safari
  //
  let STR_APPLY_UIA_OK = true;

  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


  // Table with utf8 lengths (calculated by first byte of sequence)
  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
  // because max possible codepoint is 0x10ffff
  const _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
  }
  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


  // convert string to array (typed, when possible)
  var string2buf = (str) => {
    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }

    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    buf = new Uint8Array(buf_len);

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      if (c < 0x80) {
        /* one byte */
        buf[i++] = c;
      } else if (c < 0x800) {
        /* two bytes */
        buf[i++] = 0xC0 | (c >>> 6);
        buf[i++] = 0x80 | (c & 0x3f);
      } else if (c < 0x10000) {
        /* three bytes */
        buf[i++] = 0xE0 | (c >>> 12);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      } else {
        /* four bytes */
        buf[i++] = 0xf0 | (c >>> 18);
        buf[i++] = 0x80 | (c >>> 12 & 0x3f);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      }
    }

    return buf;
  };

  // Helper
  const buf2binstring = (buf, len) => {
    // On Chrome, the arguments in a function call that are allowed is `65534`.
    // If the length of the buffer is smaller than that, we can use this optimization,
    // otherwise we will take a slower path.
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }

    let result = '';
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };


  // convert array to string
  var buf2string = (buf, max) => {
    const len = max || buf.length;

    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }

    let i, out;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    const utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
      let c = buf[i++];
      // quick process ascii
      if (c < 0x80) { utf16buf[out++] = c; continue; }

      let c_len = _utf8len[c];
      // skip 5 & 6 byte codes
      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

      // apply mask on first byte
      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
      // join the rest
      while (c_len > 1 && i < len) {
        c = (c << 6) | (buf[i++] & 0x3f);
        c_len--;
      }

      // terminated by end of string?
      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

      if (c < 0x10000) {
        utf16buf[out++] = c;
      } else {
        c -= 0x10000;
        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
        utf16buf[out++] = 0xdc00 | (c & 0x3ff);
      }
    }

    return buf2binstring(utf16buf, out);
  };


  // Calculate max possible position in utf8 buffer,
  // that will not break sequence. If that's not possible
  // - (very small limits) return max size as is.
  //
  // buf[] - utf8 bytes array
  // max   - length limit (mandatory);
  var utf8border = (buf, max) => {

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means buffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
  };

  var strings = {
  	string2buf: string2buf,
  	buf2string: buf2string,
  	utf8border: utf8border
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var messages = {
    2:      'need dictionary',     /* Z_NEED_DICT       2  */
    1:      'stream end',          /* Z_STREAM_END      1  */
    0:      '',                    /* Z_OK              0  */
    '-1':   'file error',          /* Z_ERRNO         (-1) */
    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */
    this.avail_in = 0;
    /* total number of input bytes read so far */
    this.total_in = 0;
    /* next output byte should be put there */
    this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */
    this.avail_out = 0;
    /* total number of bytes output so far */
    this.total_out = 0;
    /* last error message, NULL if no error */
    this.msg = ''/*Z_NULL*/;
    /* not visible by applications */
    this.state = null;
    /* best guess about the data type: binary or text */
    this.data_type = 2/*Z_UNKNOWN*/;
    /* adler32 value of the uncompressed data */
    this.adler = 0;
  }

  var zstream = ZStream;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function GZheader() {
    /* true if compressed data believed to be text */
    this.text       = 0;
    /* modification time */
    this.time       = 0;
    /* extra flags (not used when writing a gzip file) */
    this.xflags     = 0;
    /* operating system */
    this.os         = 0;
    /* pointer to extra field or Z_NULL if none */
    this.extra      = null;
    /* extra field length (valid if extra != Z_NULL) */
    this.extra_len  = 0; // Actually, we don't need it in JS,
                         // but leave for few code modifications

    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //

    /* space at extra (only when reading header) */
    // this.extra_max  = 0;
    /* pointer to zero-terminated file name or Z_NULL */
    this.name       = '';
    /* space at name (only when reading header) */
    // this.name_max   = 0;
    /* pointer to zero-terminated comment or Z_NULL */
    this.comment    = '';
    /* space at comment (only when reading header) */
    // this.comm_max   = 0;
    /* true if there was or will be a header crc */
    this.hcrc       = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */
    this.done       = false;
  }

  var gzheader = GZheader;

  const toString = Object.prototype.toString;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_NO_FLUSH, Z_FINISH,
    Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
  } = constants$1;

  /* ===========================================================================*/


  /**
   * class Inflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[inflate]]
   * and [[inflateRaw]].
   **/

  /* internal
   * inflate.chunks -> Array
   *
   * Chunks of output data, if [[Inflate#onData]] not overridden.
   **/

  /**
   * Inflate.result -> Uint8Array|String
   *
   * Uncompressed result, generated by default [[Inflate#onData]]
   * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
   **/

  /**
   * Inflate.err -> Number
   *
   * Error code after inflate finished. 0 (Z_OK) on success.
   * Should be checked if broken data possible.
   **/

  /**
   * Inflate.msg -> String
   *
   * Error message, if [[Inflate.err]] != 0
   **/


  /**
   * new Inflate(options)
   * - options (Object): zlib inflate options.
   *
   * Creates new inflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - `windowBits`
   * - `dictionary`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - `chunkSize` - size of generated data chunks (16K by default)
   * - `raw` (Boolean) - do raw inflate
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   * By default, when no options set, autodetect deflate/gzip data format via
   * wrapper header.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const inflate = new pako.Inflate({ level: 3});
   *
   * inflate.push(chunk1, false);
   * inflate.push(chunk2, true);  // true -> last chunk
   *
   * if (inflate.err) { throw new Error(inflate.err); }
   *
   * console.log(inflate.result);
   * ```
   **/
  function Inflate(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ''
    }, options || {});

    const opt = this.options;

    // Force window size for `raw` data, if not set directly,
    // because we have no header for autodetect.
    if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) { opt.windowBits = -15; }
    }

    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
    if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
        !(options && options.windowBits)) {
      opt.windowBits += 32;
    }

    // Gzip header has no info about windows size, we can do autodetect only
    // for deflate. So, if window size not set, force it to max when gzip possible
    if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
      // bit 3 (16) -> gzipped data
      // bit 4 (32) -> autodetect gzip/deflate
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }

    this.err    = 0;      // error code, if happens (0 = Z_OK)
    this.msg    = '';     // error message
    this.ended  = false;  // used to avoid multiple onEnd() calls
    this.chunks = [];     // chunks of compressed data

    this.strm   = new zstream();
    this.strm.avail_out = 0;

    let status  = inflate_1$1.inflateInit2(
      this.strm,
      opt.windowBits
    );

    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }

    this.header = new gzheader();

    inflate_1$1.inflateGetHeader(this.strm, this.header);

    // Setup dictionary
    if (opt.dictionary) {
      // Convert data if needed
      if (typeof opt.dictionary === 'string') {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) { //In raw mode we need to set the dictionary early
        status = inflate_1$1.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }

  /**
   * Inflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer): input data
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
   *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
   *   `true` means Z_FINISH.
   *
   * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
   * new output chunks. Returns `true` on success. If end of stream detected,
   * [[Inflate#onEnd]] will be called.
   *
   * `flush_mode` is not needed for normal operation, because end of stream
   * detected automatically. You may try to use it for advanced things, but
   * this functionality was not tested.
   *
   * On fail call [[Inflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/
  Inflate.prototype.push = function (data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;

    if (this.ended) return false;

    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

    // Convert data if needed
    if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = inflate_1$1.inflate(strm, _flush_mode);

      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$1.inflateSetDictionary(strm, dictionary);

        if (status === Z_OK) {
          status = inflate_1$1.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          // Replace code with more verbose
          status = Z_NEED_DICT;
        }
      }

      // Skip snyc markers if more data follows and not raw mode
      while (strm.avail_in > 0 &&
             status === Z_STREAM_END &&
             strm.state.wrap > 0 &&
             data[strm.next_in] !== 0)
      {
        inflate_1$1.inflateReset(strm);
        status = inflate_1$1.inflate(strm, _flush_mode);
      }

      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }

      // Remember real `avail_out` value, because we may patch out buffer content
      // to align utf8 strings boundaries.
      last_avail_out = strm.avail_out;

      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {

          if (this.options.to === 'string') {

            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);

            // move tail & realign counters
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

            this.onData(utf8str);

          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }

      // Must repeat iteration if out buffer is full
      if (status === Z_OK && last_avail_out === 0) continue;

      // Finalize if end of stream reached.
      if (status === Z_STREAM_END) {
        status = inflate_1$1.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };


  /**
   * Inflate#onData(chunk) -> Void
   * - chunk (Uint8Array|String): output data. When string output requested,
   *   each chunk will be string.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/
  Inflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };


  /**
   * Inflate#onEnd(status) -> Void
   * - status (Number): inflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called either after you tell inflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/
  Inflate.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };


  /**
   * inflate(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Decompress `data` with inflate/ungzip and `options`. Autodetect
   * format via wrapper header by default. That's why we don't provide
   * separate `ungzip` method.
   *
   * Supported options are:
   *
   * - windowBits
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako');
   * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
   * let output;
   *
   * try {
   *   output = pako.inflate(input);
   * } catch (err) {
   *   console.log(err);
   * }
   * ```
   **/
  function inflate(input, options) {
    const inflator = new Inflate(options);

    inflator.push(input);

    // That will never happens, if you don't cheat with options :)
    if (inflator.err) throw inflator.msg || messages[inflator.err];

    return inflator.result;
  }


  /**
   * inflateRaw(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * The same as [[inflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }


  /**
   * ungzip(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Just shortcut to [[inflate]], because it autodetects format
   * by header.content. Done for convenience.
   **/


  var Inflate_1 = Inflate;
  var inflate_2 = inflate;
  var inflateRaw_1 = inflateRaw;
  var ungzip = inflate;
  var constants = constants$1;

  var inflate_1 = {
  	Inflate: Inflate_1,
  	inflate: inflate_2,
  	inflateRaw: inflateRaw_1,
  	ungzip: ungzip,
  	constants: constants
  };

  exports.Inflate = Inflate_1;
  exports.constants = constants;
  exports['default'] = inflate_1;
  exports.inflate = inflate_2;
  exports.inflateRaw = inflateRaw_1;
  exports.ungzip = ungzip;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

define('pako_inflate', ['pako_inflate/dist/pako_inflate'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/InputOutput/FileLoader',[
   "jquery",
   "x_ite/Base/X3DObject",
   "x_ite/Fields",
   "x_ite/Parser/GoldenGate",
   "x_ite/Parser/JSONParser",
   "x_ite/Parser/XMLParser",
   "x_ite/Execution/X3DWorld",
   "standard/Networking/BinaryTransport",
   "pako_inflate",
   "x_ite/DEBUG",
],
function ($,
          X3DObject,
          Fields,
          GoldenGate,
          JSONParser,
          XMLParser,
          X3DWorld,
          BinaryTransport,
          pako,
          DEBUG)
{
"use strict";

   BinaryTransport ($);

   const _dom = Symbol .for ("X_ITE.dom");

   const
      ECMAScript    = /^\s*(?:vrmlscript|javascript|ecmascript)\:([^]*)$/,
      dataURL       = /^data:(.*?)(?:;charset=(.*?))?(?:;(base64))?,([^]*)$/,
      contentTypeRx = /^(?:(.*?);(.*?)$)/;

   const foreignExtensions = new RegExp ("\.(?:html|xhtml)$");

   const foreign = {
      "text/html":             true,
      "application/xhtml+xml": true,
   };

   const defaultParameter = new Fields .MFString ();

   function FileLoader (node, external)
   {
      X3DObject .call (this);

      this .node             = node;
      this .browser          = node .getBrowser ();
      this .external         = external === undefined ? this .browser .isExternal () : external;
      this .executionContext = this .external ? node .getExecutionContext () : this .browser .currentScene;
      this .userAgent        = this .browser .getName () + "/" + this .browser .getVersion () + " (X3D Browser; +" + this .browser .getProviderUrl () + ")";
      this .target           = "";
      this .url              = [ ];
      this .URL              = new URL (this .getReferer (), this .getReferer ());
      this .fileReader       = new FileReader ();
      this .text             = true;
   }

   FileLoader .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: FileLoader,
      abort: function ()
      {
         this .callback      = Function .prototype;
         this .bindViewpoint = Function .prototype;
         this .foreign       = Function .prototype;
      },
      getWorldURL: function ()
      {
         return this .URL;
      },
      createX3DFromString: function (worldURL, string, success, error)
      {
         try
         {
            const scene = this .browser .createScene ();

            if (this .node instanceof X3DWorld)
               scene .loader = this;
            else
               scene .setExecutionContext (this .executionContext);

            scene .setWorldURL (decodeURI (new URL (worldURL, this .getReferer ()) .href));

            if (success)
               success = this .setScene .bind (this, scene, success, error);

            new GoldenGate (scene) .parseIntoScene (string, success, error);

            return scene;
         }
         catch (exception)
         {
            if (error)
               error (exception);
            else
               throw error;
         }
      },
      setScene: function (scene, success, error)
      {
         scene ._initLoadCount .addInterest ("set_initLoadCount__", this, scene, success, error);
         scene ._initLoadCount .addEvent ();
      },
      set_initLoadCount__: function (scene, success, error, field)
      {
         if (field .getValue ())
            return;

         scene ._initLoadCount .removeInterest ("set_initLoadCount__", this);

         delete scene .loader;

         try
         {
            success (scene);
         }
         catch (exception)
         {
            if (error)
               error (exception);
            else
               throw exception;
         }

         if (DEBUG)
         {
            if (this .URL .protocol !== "data:")
               console .info ("Done loading scene " + decodeURI (this .URL .href));
         }
      },
      createX3DFromURL: function (url, parameter, callback, bindViewpoint, foreign)
      {
         this .bindViewpoint = bindViewpoint;
         this .foreign       = foreign;
         this .target        = this .getTarget (parameter || defaultParameter);

         if (callback)
            return this .loadDocument (url, this .createX3DFromURLAsync .bind (this, callback));

         return this .createX3DFromURLSync (url);
      },
      createX3DFromURLAsync: function (callback, data)
      {
         if (data === null)
            callback (null);
         else
            this .createX3DFromString (this .URL, data, callback, this .loadDocumentError .bind (this));
      },
      createX3DFromURLSync: function (urls)
      {
         if (urls .length === 0)
            throw new Error ("No URL given.");

         let
            scene   = null,
            success = false;

         for (const url of urls)
         {
            this .URL = new URL (url, this .getReferer ());

            $.ajax ({
               url: decodeURI (this .URL .href),
               dataType: "text",
               async: false,
               cache: this .browser .getBrowserOptions () .getCache () && this .node .getCache (),
               //timeout: 15000,
               global: false,
               context: this,
               success: function (data)
               {
                  try
                  {
                     scene   = this .createX3DFromString (this .URL, data);
                     success = true;
                  }
                  catch (exception)
                  {
                     this .error (exception);
                  }
               },
               error: function (jqXHR, textStatus, errorThrown)
               {
                  //console .warn ("Couldn't load URL '" + this .URL .href + "': " + errorThrown + ".");
               },
            });

            if (success)
               return scene;
         }

         throw new Error ("Couldn't load any url of '" + Array .prototype .join .call (urls, ", ") + "'.");
      },
      loadScript: function (url, callback)
      {
         this .script = true;

         this .loadDocument (url, callback);
      },
      loadDocument: function (url, callback)
      {
         this .url       = url .copy ();
         this .callback  = callback;

         if (url .length === 0)
            return this .loadDocumentError (new Error ("No URL given."));

         this .loadDocumentAsync (this .url .shift ());
      },
      loadBinaryDocument: function (url, callback)
      {
         this .url       = url .copy ();
         this .callback  = callback;
         this .text      = false;

         if (url .length === 0)
            return this .loadDocumentError (new Error ("No URL given."));

         this .loadDocumentAsync (this .url .shift ());
      },
      getTarget: function (parameters)
      {
         for (const parameter of parameters)
         {
            const pair = parameter .split ("=");

            if (pair .length !== 2)
               continue;

            if (pair [0] === "target")
               return pair [1];
         }

         return "";
      },
      loadDocumentAsync: function (url)
      {
         try
         {
            if (url .length === 0)
            {
               this .loadDocumentError (new Error ("URL is empty."));
               return;
            }

            // Script

            if (this .script)
            {
               const result = ECMAScript .exec (url);

               if (result)
               {
                  this .callback (result [1]);
                  return;
               }
            }

            // Test for data URL here.

            {
               const result = dataURL .exec (url);

               if (result)
               {
                  //const mimeType = result [1];

                  // ??? If called from loadURL and mime type is text/html do a window.open or window.location=URL and return; ???

                  let data = result [4];

                  if (result [3] === "base64")
                     data = atob (data);
                  else
                     data = unescape (data);

                  this .callback (data);
                  return;
               }
            }

            this .URL = new URL (url, this .getReferer ());

            if (this .bindViewpoint)
            {
               if (this .URL .href .substr (0, this .getReferer () .length) === this .getReferer ())
               {
                  this .bindViewpoint (decodeURIComponent (this .URL .hash .substr (1)));
                  return;
               }
            }

            if (this .foreign)
            {
               // Handle target

               if (this .target .length && this .target !== "_self")
                  return this .foreign (this .URL .href, this .target);

               // Handle well known foreign content depending on extension or if path looks like directory.

               if (this .URL .href .match (foreignExtensions))
                  return this .foreign (this .URL .href, this .target);
            }

            // Load URL async

            $.ajax ({
               url: decodeURI (this .URL .href),
               dataType: "binary",
               async: true,
               cache: this .browser .getBrowserOptions () .getCache () && this .node .getCache (),
               //timeout: 15000,
               global: false,
               context: this,
               success: function (blob, status, xhr)
               {
                  if (this .foreign)
                  {
                     //console .log (this .getContentType (xhr));

                     if (foreign [this .getContentType (xhr)])
                        return this .foreign (this .URL .href, this .target);
                  }

                  if (this .text)
                  {
                     this .fileReader .onload = this .readAsArrayBuffer .bind (this, blob);

                     this .fileReader .readAsArrayBuffer (blob);
                  }
                  else
                  {
                     this .fileReader .onload = this .readAsBinaryString .bind (this);

                     this .fileReader .readAsBinaryString (blob);
                  }
               },
               error: function (xhr, textStatus, exception)
               {
                  this .loadDocumentError (new Error (exception));
               },
            });
         }
         catch (exception)
         {
            this .loadDocumentError (exception);
            return;
         }
      },
      readAsArrayBuffer: function (blob)
      {
         try
         {
            this .callback (pako .ungzip (this .fileReader .result, { to: "string" }));
         }
         catch (exception)
         {
            this .fileReader .onload = this .readAsText .bind (this, blob);

            this .fileReader .readAsText (blob);
         }
      },
      readAsText: function (blob)
      {
         try
         {
            this .callback (this .fileReader .result);
         }
         catch (exception)
         {
            this .loadDocumentError (exception);
         }
      },
      readAsBinaryString: function ()
      {
         try
         {
            this .callback (this .fileReader .result);
         }
         catch (exception)
         {
            this .loadDocumentError (exception);
         }
      },
      loadDocumentError: function (exception)
      {
         // Output exception.

         this .error (exception);

         // Try to load next URL.

         if (this .url .length)
            this .loadDocumentAsync (this .url .shift ());

         else
            this .callback (null);
      },
      error: function (exception)
      {
         if (this .URL .protocol === "data:")
            console .warn ("Couldn't load URL 'data':", exception .message);
         else
            console .warn ("Couldn't load URL '" + decodeURI (this .URL .href) + "':", exception .message);

         if (DEBUG)
            console .error (exception);
      },
      getReferer: function ()
      {
         if (this .node .getTypeName () === "X3DWorld")
         {
            if (this .external)
               return this .browser .getLocation ();
         }

         return this .executionContext .getWorldURL ();
      },
      getContentType: function (xhr)
      {
         const
            contentType = xhr .getResponseHeader ("Content-Type"),
            result      = contentTypeRx .exec (contentType);

         if (result)
            return result [1];

         return "";
      },
   });

   for (const key of Reflect .ownKeys (FileLoader .prototype))
      Object .defineProperty (FileLoader .prototype, key, { enumerable: false });

   return FileLoader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ShaderPart',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Browser/Shaders/Shader",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/InputOutput/FileLoader",
   "x_ite/Base/X3DConstants",
   "x_ite/DEBUG",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          Shader,
          X3DNode,
          X3DUrlObject,
          FileLoader,
          X3DConstants,
          DEBUG)
{
"use strict";

   function ShaderPart (executionContext)
   {
      X3DNode      .call (this, executionContext);
      X3DUrlObject .call (this, executionContext);

      this .addType (X3DConstants .ShaderPart);

      this .options = [ ];
   }

   ShaderPart .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: ShaderPart,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "type",                 new Fields .SFString ("VERTEX")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
      ]),
      getTypeName: function ()
      {
         return "ShaderPart";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "parts";
      },
      initialize: function ()
      {
         X3DNode      .prototype .initialize .call (this);
         X3DUrlObject .prototype .initialize .call (this);

         const gl = this .getBrowser () .getContext ();

         this .shader = gl .createShader (gl [this .getShaderType ()]);

         this .requestImmediateLoad ();
      },
      getShader: function ()
      {
         return this .shader;
      },
      getShaderType: (function ()
      {
         const shaderTypes =
         {
            VERTEX:          "VERTEX_SHADER",
            TESS_CONTROL:    "TESS_CONTROL_SHADER",
            TESS_EVALUATION: "TESS_EVALUATION_SHADER",
            GEOMETRY:        "GEOMETRY_SHADER",
            FRAGMENT:        "FRAGMENT_SHADER",
            COMPUTE:         "COMPUTE_SHADER",
         };

         return function ()
         {
            const type = shaderTypes [this ._type .getValue ()];

            if (type)
               return type;

            return "VERTEX_SHADER";
         };
      })(),
      getSourceText: function ()
      {
         return this ._url;
      },
      setOptions: function (value)
      {
         this .options = value;
      },
      getOptions: function ()
      {
         return this .options;
      },
      unloadNow: function ()
      {
         this .valid = false;
      },
      loadNow: function ()
      {
         new FileLoader (this) .loadDocument (this ._url,
         function (data)
         {
            if (data === null)
            {
               // No URL could be loaded.
               this .setLoadState (X3DConstants .FAILED_STATE);
            }
            else
            {
               const
                  gl     = this .getBrowser () .getContext (),
                  source = Shader .getShaderSource (this .getBrowser (), this .getName (), data, this .options);

               gl .shaderSource (this .shader, source);
               gl .compileShader (this .shader);

               if (!gl .getShaderParameter (this .shader, gl .COMPILE_STATUS))
                  throw new Error (this .getTypeName () + " '" + this .getName () + "': " + gl .getShaderInfoLog (this .shader));

               this .setLoadState (X3DConstants .COMPLETE_STATE);
            }
         }
         .bind (this));
      },
   });

   return ShaderPart;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/ShaderTest',[
   "x_ite/Rendering/VertexArray",
   "x_ite/Rendering/TextureBuffer",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Camera",
],
function (VertexArray,
          TextureBuffer,
          Matrix3,
          Matrix4,
          Camera)
{
"use strict";

   const ShaderTest =
   {
      verify: (function ()
      {
         const normals = [
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
         ];

         const vertices = [
             2,  2, 0, 1,
            -2,  2, 0, 1,
            -2, -2, 0, 1,
             2,  2, 0, 1,
            -2, -2, 0, 1,
             2, -2, 0, 1,
         ];

         return function (browser, shaderNode)
         {
            const
               gl           = browser .getContext (),
               frameBuffer  = new TextureBuffer (browser, 16, 16),
               normalBuffer = gl .createBuffer (),
               vertexBuffer = gl .createBuffer (),
               vertexArrayObject  = new VertexArray ();

            frameBuffer .bind ();

            shaderNode .enable (gl);
            shaderNode .setLocalObjects (gl, [ ]);

            gl .bindBuffer (gl .ARRAY_BUFFER, vertexBuffer);
            gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (vertices), gl .DYNAMIC_DRAW);
            gl .bindBuffer (gl .ARRAY_BUFFER, normalBuffer);
            gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (normals), gl .DYNAMIC_DRAW);

            // Matrices

            gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, new Float32Array (Camera .ortho (-1, 1, -1, 1, -1, 1, new Matrix4 ())));
            gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, new Float32Array (Matrix4 .Identity));
            gl .uniformMatrix3fv (shaderNode .x3d_NormalMatrix,     false, new Float32Array (Matrix3 .Identity));

            // Set clip planes and lights to none.

            gl .uniform1i (shaderNode .x3d_FogType,               0);
            gl .uniform1f (shaderNode .x3d_AlphaCutoff,           0);
            gl .uniform1i (shaderNode .x3d_FillPropertiesFilled,  true);
            gl .uniform1i (shaderNode .x3d_FillPropertiesHatched, false);
            gl .uniform1i (shaderNode .x3d_ColorMaterial,         false);
            gl .uniform1i (shaderNode .x3d_NumLights,             0);
            gl .uniform1i (shaderNode .x3d_NumTextures,           0);
            gl .uniform1i (shaderNode .x3d_NumProjectiveTextures, 0);
            gl .uniform1i (shaderNode .x3d_NumClipPlanes,         0);

            gl .uniform1f (shaderNode .x3d_AmbientIntensity, 0);
            gl .uniform3f (shaderNode .x3d_DiffuseColor,     1, 0, 0);
            gl .uniform3f (shaderNode .x3d_SpecularColor,    1, 0, 0);
            gl .uniform3f (shaderNode .x3d_EmissiveColor,    1, 0, 0);
            gl .uniform1f (shaderNode .x3d_Shininess,        0);
            gl .uniform1f (shaderNode .x3d_Transparency,     0);

            gl .viewport (0, 0, 16, 16);
            gl .clearColor (0, 0, 0, 0);
            gl .clear (gl .COLOR_BUFFER_BIT);

            gl .disable (gl .DEPTH_TEST);
            gl .disable (gl .BLEND);
            gl .frontFace (gl .CCW);
            gl .enable (gl .CULL_FACE);
            gl .cullFace (gl .BACK);

            vertexArrayObject .enable (gl, shaderNode);
            shaderNode .enableNormalAttribute (gl, normalBuffer, 0, 0);
            shaderNode .enableVertexAttribute (gl, vertexBuffer, 0, 0);

            gl .drawArrays (gl .TRIANGLES, 0, 6);

            const data = frameBuffer .readPixels ();

            frameBuffer .unbind ();
            frameBuffer .delete ();

            gl .deleteBuffer (normalBuffer);
            gl .deleteBuffer (vertexBuffer);

            vertexArrayObject .delete (gl);

            return true || (data [0] == 255 && data [1] == 0 && data [2] == 0 && data [3] == 255);
         };
      })(),
   };

   return ShaderTest;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/X3DShadersContext',[
   "x_ite/Browser/Core/Shading",
   "x_ite/Components/Shaders/ComposedShader",
   "x_ite/Components/Shaders/ShaderPart",
   "x_ite/Browser/Shaders/ShaderTest",
   "x_ite/Browser/Networking/urls",
],
function (Shading,
          ComposedShader,
          ShaderPart,
          ShaderTest,
          urls)
{
"use strict";

   const
      _shaders                        = Symbol (),
      _defaultShader                  = Symbol (),
      _standardShaders                = Symbol (),
      _pointShader                    = Symbol (),
      _lineShader                     = Symbol (),
      _unlitShader                    = Symbol (),
      _unlitTexturesShader            = Symbol (),
      _gouraudShader                  = Symbol (),
      _phongShader                    = Symbol (),
      _materialTexturesShader         = Symbol (),
      _physicalMaterialShader         = Symbol (),
      _physicalMaterialTexturesShader = Symbol (),
      _shadowShader                   = Symbol (),
      _depthShader                    = Symbol ();

   function X3DShadersContext ()
   {
      this [_shaders]         = new Set ();
      this [_standardShaders] = [ ];
   }

   X3DShadersContext .prototype =
   {
      initialize: function ()
      {
         this .setShading (this .getBrowserOptions () .getShading ());
      },
      getShadingLanguageVersion: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .SHADING_LANGUAGE_VERSION);
      },
      getMaxVertexUniformVectors: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .MAX_VERTEX_UNIFORM_VECTORS);
      },
      getMaxFragmentUniformVectors: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .MAX_FRAGMENT_UNIFORM_VECTORS);
      },
      getMaxVertexAttribs: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .MAX_VERTEX_ATTRIBS);
      },
      addShader: function (shader)
      {
         this [_shaders] .add (shader);

         shader .setShading (this .getBrowserOptions () .getShading ());
      },
      removeShader: function (shader)
      {
         this [_shaders] .delete (shader);
      },
      getShaders: function ()
      {
         return this [_shaders];
      },
      getDefaultShader: function ()
      {
         return this [_defaultShader];
      },
      getStandardShaders: function ()
      {
         return this [_standardShaders];
      },
      getPointShader: function ()
      {
         return this .getStandardShader ("getPointShader", _pointShader, "PointShader", "Point", [ ], "set_point_shader_valid__");
      },
      getLineShader: function ()
      {
         return this .getStandardShader ("getLineShader", _lineShader, "LineShader", "Line", [ ], "set_line_shader_valid__");
      },
      getUnlitShader: function ()
      {
         return this .getStandardShader ("getUnlitShader", _unlitShader, "UnlitShader", "Unlit", [ ], "set_unlit_shader_valid__");
      },
      getGouraudShader: function ()
      {
         return this .getStandardShader ("getGouraudShader", _gouraudShader, "GouraudShader", "Gouraud", [ ], "set_gouraud_shader_valid__");
      },
      getPhongShader: function ()
      {
         return this .getStandardShader ("getPhongShader", _phongShader, "PhongShader", "Phong", [ ], "set_phong_shader_valid__");
      },
      getShadowShader: function ()
      {
         return this .getStandardShader ("getShadowShader", _shadowShader, "ShadowShader", "Phong",["X3D_SHADOWS", "X3D_PCF_FILTERING"], "set_shadow_shader_valid__");
      },
      getPhysicalMaterialShader: function ()
      {
         return this .getStandardShader ("getPhysicalMaterialShader", _physicalMaterialShader, "PhysicalMaterialShader", "PBR", [ ], "set_physical_material_shader_valid__");
      },
      getDepthShader: function ()
      {
         this [_depthShader] = this .createShader ("DepthShader", "Depth");

         this .getDepthShader = function () { return this [_depthShader]; };

         Object .defineProperty (this, "getDepthShader", { enumerable: false });

         return this [_depthShader];
      },
      setShading: function (type)
      {
         switch (type)
         {
            case Shading .PHONG:
            {
               this [_defaultShader] = this .getPhongShader ();
               break;
            }
            default:
            {
               this [_defaultShader] = this .getGouraudShader ();
               break;
            }
         }

         // Configure shaders.

         for (const shader of this .getShaders ())
            shader .setShading (type);
      },
      getStandardShader: function (func, property, name, shader, options, valid)
      {
         this [property] = this .createShader (name, shader, options);

         this [property] ._isValid .addInterest (valid, this);

         this [func] = function () { return this [property]; };

         Object .defineProperty (this, func, { enumerable: false });

         return this [property];
      },
      createShader: function (name, file, options = [ ])
      {
         if (this .getDebug ())
            console .log ("Initializing " + name);

         const
            gl      = this .getContext (),
            version = gl .getVersion ();

         const vertexShader = new ShaderPart (this .getPrivateScene ());
         vertexShader .setName (name + "Vertex");
         vertexShader ._url .push (urls .getShaderUrl ("webgl" + version + "/" + file + ".vs"));
         vertexShader .setOptions (options);
         vertexShader .setup ();

         const fragmentShader = new ShaderPart (this .getPrivateScene ());
         fragmentShader .setName (name + "Fragment");
         fragmentShader ._type  = "FRAGMENT";
         fragmentShader ._url .push (urls .getShaderUrl ("webgl" + version + "/" + file + ".fs"));
         fragmentShader .setOptions (options);
         fragmentShader .setup ();

         const shader = new ComposedShader (this .getPrivateScene ());
         shader .setName (name);
         shader ._language = "GLSL";
         shader ._parts .push (vertexShader);
         shader ._parts .push (fragmentShader);
         shader .setShading (this .getBrowserOptions () .getShading ());
         shader .setup ();

         this [_standardShaders] .push (shader);

         this .addShader (shader);

         return shader;
      },
      set_point_shader_valid__: function ()
      { },
      set_line_shader_valid__: function ()
      { },
      set_unlit_shader_valid__: function (valid)
      {
         this [_unlitShader] ._isValid .removeInterest ("set_unlit_shader_valid__", this);

         if (valid .getValue () && ShaderTest .verify (this, this [_unlitShader]))
            return;

         console .error ("X_ITE: Unlit shading is not available, using fallback VRML shader.");

         // Recompile shader.
         this [_unlitShader] ._parts [0] .url = [ urls .getShaderUrl ("webgl1/FallbackUnlit.vs") ];
         this [_unlitShader] ._parts [1] .url = [ urls .getShaderUrl ("webgl1/FallbackUnlit.fs") ];
      },
      set_gouraud_shader_valid__: function (valid)
      {
         this [_gouraudShader] ._isValid .removeInterest ("set_gouraud_shader_valid__", this);

         if (valid .getValue () && ShaderTest .verify (this, this [_gouraudShader]))
            return;

         console .warn ("X_ITE: All else fails, using fallback VRML shader.");

         // Recompile shader.
         this [_gouraudShader] ._parts [0] .url = [ urls .getShaderUrl ("webgl1/Fallback.vs") ];
         this [_gouraudShader] ._parts [1] .url = [ urls .getShaderUrl ("webgl1/Fallback.fs") ];
      },
      set_phong_shader_valid__: function (valid)
      {
         this [_phongShader] ._isValid .removeInterest ("set_phong_shader_valid__", this);

         if (valid .getValue () && ShaderTest .verify (this, this [_phongShader]))
            return;

         console .warn ("X_ITE: Phong shading is not available, using Gouraud shading.");

         this [_phongShader] = this .getGouraudShader ();

         this .setShading (this .getBrowserOptions () .getShading ());
      },
      set_physical_material_shader_valid__: function (valid)
      {
         this [_physicalMaterialShader] ._isValid .removeInterest ("set_physical_material_shader_valid__", this);

         if (valid .getValue () && ShaderTest .verify (this, this [_physicalMaterialShader]))
            return;

         console .warn ("X_ITE: Physical material shading is not available, using Gouraud shading.");

         this [_physicalMaterialShader] = this .getGouraudShader ();

         this .setShading (this .getBrowserOptions () .getShading ());
      },
      set_shadow_shader_valid__: function (valid)
      {
         this [_shadowShader] ._isValid .removeInterest ("set_shadow_shader_valid__", this);

         if (valid .getValue () && ShaderTest .verify (this, this [_shadowShader]))
            return;

         console .warn ("X_ITE: Shadow shading is not available, using Gouraud shading.");

         this [_shadowShader] = this .getGouraudShader ();
      },
   };

   return X3DShadersContext;
});



/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define('ResizeSensor/src/ResizeSensor',factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.ResizeSensor = factory();
    }
}(typeof window !== 'undefined' ? window : this, function () {

    // Make sure it does not throw in a SSR (Server Side Rendering) situation
    if (typeof window === "undefined") {
        return null;
    }
    // https://github.com/Semantic-Org/Semantic-UI/issues/3855
    // https://github.com/marcj/css-element-queries/issues/257
    var globalWindow = typeof window != 'undefined' && window.Math == Math
        ? window
        : typeof self != 'undefined' && self.Math == Math
            ? self
            : Function('return this')();
    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.
    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
    // would generate too many unnecessary events.
    var requestAnimationFrame = globalWindow.requestAnimationFrame ||
        globalWindow.mozRequestAnimationFrame ||
        globalWindow.webkitRequestAnimationFrame ||
        function (fn) {
            return globalWindow.setTimeout(fn, 20);
        };

    var cancelAnimationFrame = globalWindow.cancelAnimationFrame ||
        globalWindow.mozCancelAnimationFrame ||
        globalWindow.webkitCancelAnimationFrame ||
        function (timer) {
            globalWindow.clearTimeout(timer);
        };

    /**
     * Iterate over each of the provided element(s).
     *
     * @param {HTMLElement|HTMLElement[]} elements
     * @param {Function}                  callback
     */
    function forEachElement(elements, callback){
        var elementsType = Object.prototype.toString.call(elements);
        var isCollectionTyped = ('[object Array]' === elementsType
            || ('[object NodeList]' === elementsType)
            || ('[object HTMLCollection]' === elementsType)
            || ('[object Object]' === elementsType)
            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery
            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools
        );
        var i = 0, j = elements.length;
        if (isCollectionTyped) {
            for (; i < j; i++) {
                callback(elements[i]);
            }
        } else {
            callback(elements);
        }
    }

    /**
    * Get element size
    * @param {HTMLElement} element
    * @returns {Object} {width, height}
    */
    function getElementSize(element) {
        if (!element.getBoundingClientRect) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight
            }
        }

        var rect = element.getBoundingClientRect();
        return {
            width: Math.round(rect.width),
            height: Math.round(rect.height)
        }
    }

    /**
     * Apply CSS styles to element.
     *
     * @param {HTMLElement} element
     * @param {Object} style
     */
    function setStyle(element, style) {
        Object.keys(style).forEach(function(key) {
            element.style[key] = style[key];
        });
    }

    /**
     * Class for dimension change detection.
     *
     * @param {Element|Element[]|Elements|jQuery} element
     * @param {Function} callback
     *
     * @constructor
     */
    var ResizeSensor = function(element, callback) {
        //Is used when checking in reset() only for invisible elements
        var lastAnimationFrameForInvisibleCheck = 0;

        /**
         *
         * @constructor
         */
        function EventQueue() {
            var q = [];
            this.add = function(ev) {
                q.push(ev);
            };

            var i, j;
            this.call = function(sizeInfo) {
                for (i = 0, j = q.length; i < j; i++) {
                    q[i].call(this, sizeInfo);
                }
            };

            this.remove = function(ev) {
                var newQueue = [];
                for(i = 0, j = q.length; i < j; i++) {
                    if(q[i] !== ev) newQueue.push(q[i]);
                }
                q = newQueue;
            };

            this.length = function() {
                return q.length;
            }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
            if (!element) return;
            if (element.resizedAttached) {
                element.resizedAttached.add(resized);
                return;
            }

            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);

            element.resizeSensor = document.createElement('div');
            element.resizeSensor.dir = 'ltr';
            element.resizeSensor.className = 'resize-sensor';

            var style = {
                pointerEvents: 'none',
                position: 'absolute',
                left: '0px',
                top: '0px',
                right: '0px',
                bottom: '0px',
                overflow: 'hidden',
                zIndex: '-1',
                visibility: 'hidden',
                maxWidth: '100%'
            };
            var styleChild = {
                position: 'absolute',
                left: '0px',
                top: '0px',
                transition: '0s',
            };

            setStyle(element.resizeSensor, style);

            var expand = document.createElement('div');
            expand.className = 'resize-sensor-expand';
            setStyle(expand, style);

            var expandChild = document.createElement('div');
            setStyle(expandChild, styleChild);
            expand.appendChild(expandChild);

            var shrink = document.createElement('div');
            shrink.className = 'resize-sensor-shrink';
            setStyle(shrink, style);

            var shrinkChild = document.createElement('div');
            setStyle(shrinkChild, styleChild);
            setStyle(shrinkChild, { width: '200%', height: '200%' });
            shrink.appendChild(shrinkChild);

            element.resizeSensor.appendChild(expand);
            element.resizeSensor.appendChild(shrink);
            element.appendChild(element.resizeSensor);

            var computedStyle = window.getComputedStyle(element);
            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;
            if ('absolute' !== position && 'relative' !== position && 'fixed' !== position && 'sticky' !== position) {
                element.style.position = 'relative';
            }

            var dirty = false;

            //last request animation frame id used in onscroll event
            var rafId = 0;
            var size = getElementSize(element);
            var lastWidth = 0;
            var lastHeight = 0;
            var initialHiddenCheck = true;
            lastAnimationFrameForInvisibleCheck = 0;

            var resetExpandShrink = function () {
                var width = element.offsetWidth;
                var height = element.offsetHeight;

                expandChild.style.width = (width + 10) + 'px';
                expandChild.style.height = (height + 10) + 'px';

                expand.scrollLeft = width + 10;
                expand.scrollTop = height + 10;

                shrink.scrollLeft = width + 10;
                shrink.scrollTop = height + 10;
            };

            var reset = function() {
                // Check if element is hidden
                if (initialHiddenCheck) {
                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;
                    if (invisible) {
                        // Check in next frame
                        if (!lastAnimationFrameForInvisibleCheck){
                            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                                lastAnimationFrameForInvisibleCheck = 0;
                                reset();
                            });
                        }

                        return;
                    } else {
                        // Stop checking
                        initialHiddenCheck = false;
                    }
                }

                resetExpandShrink();
            };
            element.resizeSensor.resetSensor = reset;

            var onResized = function() {
                rafId = 0;

                if (!dirty) return;

                lastWidth = size.width;
                lastHeight = size.height;

                if (element.resizedAttached) {
                    element.resizedAttached.call(size);
                }
            };

            var onScroll = function() {
                size = getElementSize(element);
                dirty = size.width !== lastWidth || size.height !== lastHeight;

                if (dirty && !rafId) {
                    rafId = requestAnimationFrame(onResized);
                }

                reset();
            };

            var addEvent = function(el, name, cb) {
                if (el.attachEvent) {
                    el.attachEvent('on' + name, cb);
                } else {
                    el.addEventListener(name, cb);
                }
            };

            addEvent(expand, 'scroll', onScroll);
            addEvent(shrink, 'scroll', onScroll);

            // Fix for custom Elements and invisible elements
            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                lastAnimationFrameForInvisibleCheck = 0;
                reset();
            });
        }

        forEachElement(element, function(elem){
            attachResizeEvent(elem, callback);
        });

        this.detach = function(ev) {
            // clean up the unfinished animation frame to prevent a potential endless requestAnimationFrame of reset
            if (!lastAnimationFrameForInvisibleCheck) {
                cancelAnimationFrame(lastAnimationFrameForInvisibleCheck);
                lastAnimationFrameForInvisibleCheck = 0;
            }
            ResizeSensor.detach(element, ev);
        };

        this.reset = function() {
            element.resizeSensor.resetSensor();
        };
    };

    ResizeSensor.reset = function(element) {
        forEachElement(element, function(elem){
            elem.resizeSensor.resetSensor();
        });
    };

    ResizeSensor.detach = function(element, ev) {
        forEachElement(element, function(elem){
            if (!elem) return;
            if(elem.resizedAttached && typeof ev === "function"){
                elem.resizedAttached.remove(ev);
                if(elem.resizedAttached.length()) return;
            }
            if (elem.resizeSensor) {
                if (elem.contains(elem.resizeSensor)) {
                    elem.removeChild(elem.resizeSensor);
                }
                delete elem.resizeSensor;
                delete elem.resizedAttached;
            }
        });
    };

    if (typeof MutationObserver !== "undefined") {
        var observer = new MutationObserver(function (mutations) {
            for (var i in mutations) {
                if (mutations.hasOwnProperty(i)) {
                    var items = mutations[i].addedNodes;
                    for (var j = 0; j < items.length; j++) {
                        if (items[j].resizeSensor) {
                            ResizeSensor.reset(items[j]);
                        }
                    }
                }
            }
        });

        document.addEventListener("DOMContentLoaded", function (event) {
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }

    return ResizeSensor;

}));

define('ResizeSensor', ['ResizeSensor/src/ResizeSensor'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


//https://github.com/sdecima/javascript-detect-element-resize

define ('x_ite/Browser/Rendering/X3DRenderingContext',[
   "jquery",
   "ResizeSensor",
],
function ($,
          ResizeSensor)
{
"use strict";

   const
      _viewport     = Symbol (),
      _localObjects = Symbol (),
      _resizer      = Symbol ();

   function X3DRenderingContext ()
   {
      this [_viewport]     = [0, 0, 300, 150];
      this [_localObjects] = [ ]; // shader objects dumpster
   }

   X3DRenderingContext .prototype =
   {
      initialize: function ()
      {
         // Configure context.

         const gl = this .getContext ();

         gl .enable (gl .SCISSOR_TEST);
         gl .cullFace (gl .BACK);
         gl .enable (gl .DEPTH_TEST);
         gl .depthFunc (gl .LEQUAL);
         gl .clearDepth (1);

         gl .blendFuncSeparate (gl .SRC_ALPHA, gl .ONE_MINUS_SRC_ALPHA, gl .ONE, gl .ONE_MINUS_SRC_ALPHA);
         gl .blendEquationSeparate (gl .FUNC_ADD, gl .FUNC_ADD);
         gl .enable (gl .BLEND);

         // Configure viewport.

         $(document) .on ('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', this .onfullscreen .bind (this));

         this [_resizer] = new ResizeSensor (this .getSurface (), this .reshape .bind (this));

         this .reshape ();
      },
      getRenderer: function ()
      {
         const gl = this .getContext ();

         if (! navigator .userAgent .match (/Firefox/))
         {
            const dbgRenderInfo = gl .getExtension ("WEBGL_debug_renderer_info");

            if (dbgRenderInfo)
               return gl .getParameter (dbgRenderInfo .UNMASKED_RENDERER_WEBGL);
         }

         return gl .getParameter (gl .RENDERER);
      },
      getVendor: function ()
      {
         const gl = this .getContext ();

         if (! navigator .userAgent .match (/Firefox/))
         {
            const dbgRenderInfo = gl .getExtension ("WEBGL_debug_renderer_info");

            if (dbgRenderInfo)
               return gl .getParameter (dbgRenderInfo .UNMASKED_VENDOR_WEBGL);
         }

         return gl .getParameter (gl .VENDOR);
      },
      getWebGLVersion: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .VERSION);
      },
      getAntialiased: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .SAMPLES) > 0;
      },
      getMaxClipPlanes: function ()
      {
         return 6;
      },
      getDepthSize: function ()
      {
         const gl = this .getContext ();

         return gl .getParameter (gl .DEPTH_BITS);
      },
      getColorDepth: function ()
      {
         const gl = this .getContext ();

         return (gl .getParameter (gl .RED_BITS) +
                 gl .getParameter (gl .BLUE_BITS) +
                 gl .getParameter (gl .GREEN_BITS) +
                 gl .getParameter (gl .ALPHA_BITS));
      },
      getViewport: function ()
      {
         return this [_viewport];
      },
      getLocalObjects: function ()
      {
         return this [_localObjects];
      },
      reshape: function ()
      {
         const
            gl      = this .getContext (),
            jCanvas = this .getCanvas (),
            width   = jCanvas .width (),
            height  = jCanvas .height (),
            canvas  = jCanvas [0];

         canvas .width  = width;
         canvas .height = height;

         this [_viewport] [2] = width;
         this [_viewport] [3] = height;

         gl .viewport (0, 0, width, height);
         gl .scissor  (0, 0, width, height);

         this .addBrowserEvent ();
      },
      onfullscreen: function ()
      {
         const element = this .getElement ();

         if (element .fullScreen ())
            element .addClass ("x_ite-fullscreen");
         else
            element .removeClass ("x_ite-fullscreen");
      },
   };

   return X3DRenderingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DAppearanceNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DNode,
          X3DConstants)
{
"use strict";

   function X3DAppearanceNode (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DAppearanceNode);

      this .addChildObjects ("transparent", new Fields .SFBool ());

      this ._transparent .setAccessType (X3DConstants .outputOnly);
   }

   X3DAppearanceNode .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DAppearanceNode,
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
   });

   return X3DAppearanceNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shape/AlphaMode',[],function ()
{
"use strict";

   let i = 0;

   const AlphaMode =
   {
      AUTO:   i ++,
      OPAQUE: i ++,
      MASK:   i ++,
      BLEND:  i ++,
   };

   return AlphaMode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Appearance',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DAppearanceNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Shape/AlphaMode",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceNode,
          X3DCast,
          X3DConstants,
          AlphaMode)
{
"use strict";

   function Appearance (executionContext)
   {
      X3DAppearanceNode .call (this, executionContext);

      this .addType (X3DConstants .Appearance);

      this .stylePropertiesNode     = [ ];
      this .materialNode            = null;
      this .backMaterialNode        = null;
      this .textureNode             = null;
      this .textureTransformNode    = null;
      this .textureTransformMapping = new Map ();
      this .shaderNodes             = [ ];
      this .shaderNode              = null;
      this .blendModeNode           = null;
   }

   Appearance .prototype = Object .assign (Object .create (X3DAppearanceNode .prototype),
   {
      constructor: Appearance,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "alphaMode",          new Fields .SFString ("AUTO")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "alphaCutoff",        new Fields .SFFloat (0.5)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "acousticProperties", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pointProperties",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "lineProperties",     new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fillProperties",     new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "material",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backMaterial",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "texture",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "textureTransform",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "shaders",            new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "blendMode",          new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Appearance";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "appearance";
      },
      initialize: function ()
      {
         X3DAppearanceNode .prototype .initialize .call (this);

         this .isLive () .addInterest ("set_live__", this);

         this ._alphaMode  		.addInterest ("set_alphaMode__",        this);
         this ._alphaCutoff  		.addInterest ("set_alphaCutoff__",      this);
         this ._pointProperties  .addInterest ("set_pointProperties__",  this);
         this ._lineProperties   .addInterest ("set_lineProperties__",   this);
         this ._fillProperties   .addInterest ("set_fillProperties__",   this);
         this ._material         .addInterest ("set_material__",         this);
         this ._backMaterial     .addInterest ("set_backMaterial__",     this);
         this ._texture          .addInterest ("set_texture__",          this);
         this ._textureTransform .addInterest ("set_textureTransform__", this);
         this ._shaders          .addInterest ("set_shaders__",          this);
         this ._blendMode        .addInterest ("set_blendMode__",        this);

         this ._alphaMode      .addInterest ("set_transparent__", this);
         this ._fillProperties .addInterest ("set_transparent__", this);
         this ._material       .addInterest ("set_transparent__", this);
         this ._texture        .addInterest ("set_transparent__", this);
         this ._blendMode      .addInterest ("set_transparent__", this);

         this .set_live__ ();
         this .set_alphaMode__ ();
         this .set_pointProperties__ ();
         this .set_lineProperties__ ();
         this .set_fillProperties__ ();
         this .set_material__ ();
         this .set_backMaterial__ ();
         this .set_texture__ ();
         this .set_textureTransform__ ();
         this .set_shaders__ ();
         this .set_blendMode__ ();
         this .set_transparent__ ();
      },
      getAlphaMode: function ()
      {
         return this .alphaMode;
      },
      getLineProperties: function ()
      {
         return this .stylePropertiesNode [1];
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue ())
         {
            this .getBrowser () .getBrowserOptions () ._Shading .addInterest ("set_shading__", this);

            if (this .shaderNode)
               this .getBrowser () .addShader (this .shaderNode);
         }
         else
         {
            this .getBrowser () .getBrowserOptions () ._Shading .removeInterest ("set_shading__", this);

            if (this .shaderNode)
               this .getBrowser () .removeShader (this .shaderNode);
         }
      },
      set_alphaMode__: function ()
      {
         this .alphaMode = AlphaMode [this ._alphaMode .getValue ()] || AlphaMode .AUTO;

         this .set_alphaCutoff__ ();
      },
      set_alphaCutoff__: function ()
      {
         this .alphaCutoff = this .alphaMode === AlphaMode .MASK ? this ._alphaCutoff .getValue () : 0;
      },
      set_pointProperties__: function ()
      {
         this .stylePropertiesNode [0] = X3DCast (X3DConstants .PointProperties, this ._pointProperties);

         if (! this .stylePropertiesNode [0])
            this .stylePropertiesNode [0] = this .getBrowser () .getDefaultPointProperties ();
      },
      set_lineProperties__: function ()
      {
         this .stylePropertiesNode [1] = X3DCast (X3DConstants .LineProperties, this ._lineProperties);

         if (! this .stylePropertiesNode [1])
            this .stylePropertiesNode [1] = this .getBrowser () .getDefaultLineProperties ();
      },
      set_fillProperties__: function ()
      {
         if (this .stylePropertiesNode [2])
            this .stylePropertiesNode [2] ._transparent .removeInterest ("set_transparent__", this);

         this .stylePropertiesNode [2] = X3DCast (X3DConstants .FillProperties, this ._fillProperties);

         if (! this .stylePropertiesNode [2])
            this .stylePropertiesNode [2] = this .getBrowser () .getDefaultFillProperties ();

         if (this .stylePropertiesNode [2])
            this .stylePropertiesNode [2] ._transparent .addInterest ("set_transparent__", this);

         this .stylePropertiesNode [3] = this .stylePropertiesNode [2];
      },
      set_material__: function ()
      {
         if (this .materialNode)
            this .materialNode ._transparent .removeInterest ("set_transparent__", this);

         this .materialNode = X3DCast (X3DConstants .X3DMaterialNode, this ._material);

         if (! this .materialNode)
            this .materialNode = this .getBrowser () .getDefaultMaterial ();

         if (this .materialNode)
            this .materialNode ._transparent .addInterest ("set_transparent__", this);

         // Depreciated TwoSidedMaterial handling.

         if (this .materialNode .getTypeName () === "TwoSidedMaterial")
         {
            console .warn ("TwoSidedMaterial is depreciated, please use Appearance backMaterial.");
            this .set_backMaterial__ ();
         }
      },
      set_backMaterial__: function ()
      {
         if (this .backMaterialNode)
            this .backMaterialNode ._transparent .removeInterest ("set_transparent__", this);

         this .backMaterialNode = X3DCast (X3DConstants .X3DOneSidedMaterialNode, this ._backMaterial);

         if (this .backMaterialNode)
            this .backMaterialNode ._transparent .addInterest ("set_transparent__", this);

         // Depreciated TwoSidedMaterial handling.

         if (!this .backMaterialNode && this .materialNode .getTypeName () === "TwoSidedMaterial")
            this .backMaterialNode = this .materialNode;
      },
      set_texture__: function ()
      {
         if (this .textureNode)
            this .textureNode ._transparent .removeInterest ("set_transparent__", this);

         this .textureNode = X3DCast (X3DConstants .X3DTextureNode, this ._texture);

         if (this .textureNode)
            this .textureNode ._transparent .addInterest ("set_transparent__", this);
      },
      set_textureTransform__: function ()
      {
         if (this .textureTransformNode)
            this .textureTransformNode .removeInterest ("updateTextureTransformMapping", this);

         this .textureTransformNode = X3DCast (X3DConstants .X3DTextureTransformNode, this ._textureTransform);

         if (!this .textureTransformNode)
            this .textureTransformNode = this .getBrowser () .getDefaultTextureTransform ();

         this .textureTransformNode .addInterest ("updateTextureTransformMapping", this);

         this .updateTextureTransformMapping ();
      },
      updateTextureTransformMapping: function ()
      {
         this .textureTransformMapping .clear ();

         this .textureTransformNode .getTextureMapping (this .textureTransformMapping);
      },
      set_shaders__: function ()
      {
         const shaderNodes = this .shaderNodes;

         for (const shaderNode of shaderNodes)
         {
            shaderNode ._isValid        .removeInterest ("set_shader__", this);
            shaderNode ._activationTime .removeInterest ("set_shader__", this);
         }

         shaderNodes .length = 0;

         for (const node of this ._shaders)
         {
            const shaderNode = X3DCast (X3DConstants .X3DShaderNode, node);

            if (shaderNode)
            {
               shaderNodes .push (shaderNode);

               shaderNode ._isValid        .addInterest ("set_shader__", this);
               shaderNode ._activationTime .addInterest ("set_shader__", this);
            }
         }

         this .set_shader__ ();
      },
      set_shader__: function ()
      {
         const shaderNodes = this .shaderNodes;

         if (this .shaderNode)
         {
            this .getBrowser () .removeShader (this .shaderNode);
            this .shaderNode .deselect ();
         }

         this .shaderNode = null;

         for (const shaderNode of shaderNodes)
         {
            if (shaderNode ._isValid .getValue ())
            {
               if (shaderNode ._activationTime .getValue () === this .getBrowser () .getCurrentTime ())
               {
                  this .shaderNode = shaderNode;
                  break;
               }
            }
         }

         if (!this .shaderNode)
         {
            for (const shaderNode of shaderNodes)
            {
               if (shaderNode ._isValid .getValue ())
               {
                  this .shaderNode = shaderNode;
                  break;
               }
            }
         }

         if (this .isLive () .getValue ())
         {
            if (this .shaderNode)
            {
               this .getBrowser () .addShader (this .shaderNode);
               this .shaderNode .select ();
            }
         }
      },
      set_shading__: function ()
      {
         this .set_shader__ ();
      },
      set_blendMode__: function ()
      {
         this .blendModeNode = X3DCast (X3DConstants .BlendMode, this ._blendMode);
      },
      set_transparent__: function ()
      {
         switch (this .alphaMode)
         {
            case AlphaMode .AUTO:
               this .setTransparent (Boolean (this .stylePropertiesNode [3] .getTransparent () ||
                                     (this .materialNode && this .materialNode .getTransparent ()) ||
                                     (this .backMaterialNode && this .backMaterialNode .getTransparent ()) ||
                                     (this .textureNode && this .textureNode .getTransparent ()) ||
                                     this .blendModeNode));
               break;
            case AlphaMode .OPAQUE:
               this .setTransparent (false);
               break;
            case AlphaMode .MASK:
               this .setTransparent (false);
               break;
            case AlphaMode .BLEND:
               this .setTransparent (true);
               break;
         }
      },
      traverse: function (type, renderObject)
      {
         if (this .textureNode)
            this .textureNode .traverse (type, renderObject);

         if (this .shaderNode)
            this .shaderNode .traverse (type, renderObject);
      },
   });

   return Appearance;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/PointProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function PointProperties (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .PointProperties);

      this .pointSizeAttenuation = new Float32Array (3);
   }

   PointProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: PointProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeScaleFactor", new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeMinValue",    new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeMaxValue",    new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeAttenuation", new Fields .MFFloat (1, 0, 0)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "markerType",           new Fields .SFInt32 (1)),
      ]),
      getTypeName: function ()
      {
         return "PointProperties";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "pointProperties";
      },
      initialize: function ()
      {
         X3DAppearanceChildNode .prototype .initialize .call (this);

         this ._pointSizeScaleFactor .addInterest ("set_pointSizeScaleFactor__", this);
         this ._pointSizeMinValue    .addInterest ("set_pointSizeMinValue__",    this);
         this ._pointSizeMaxValue    .addInterest ("set_pointSizeMaxValue__",    this);
         this ._pointSizeAttenuation .addInterest ("set_pointSizeAttenuation__", this);
         this ._markerType           .addInterest ("set_markerType__",           this);

         this .set_pointSizeScaleFactor__ ();
         this .set_pointSizeMinValue__ ();
         this .set_pointSizeMaxValue__ ();
         this .set_pointSizeAttenuation__ ();
         this .set_markerType__ ();
      },
      set_pointSizeScaleFactor__: function ()
      {
         this .pointSizeScaleFactor = Math .max (1, this ._pointSizeScaleFactor .getValue ());
      },
      set_pointSizeMinValue__: function ()
      {
         this .pointSizeMinValue = Math .max (0, this ._pointSizeMinValue .getValue ());
      },
      set_pointSizeMaxValue__: function ()
      {
         this .pointSizeMaxValue = Math .max (0, this ._pointSizeMaxValue .getValue ());
      },
      set_pointSizeAttenuation__: function ()
      {
         const length = this ._pointSizeAttenuation .length;

         this .pointSizeAttenuation [0] = length > 0 ? Math .max (0, this ._pointSizeAttenuation [0]) : 1;
         this .pointSizeAttenuation [1] = length > 1 ? Math .max (0, this ._pointSizeAttenuation [1]) : 0;
         this .pointSizeAttenuation [2] = length > 2 ? Math .max (0, this ._pointSizeAttenuation [2]) : 0;
      },
      set_markerType__: function ()
      {
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeScaleFactor, this .pointSizeScaleFactor);
         gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMinValue,    this .pointSizeMinValue);
         gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMaxValue,    this .pointSizeMaxValue);
         gl .uniform3fv (shaderObject .x3d_PointPropertiesPointSizeAttenuation, this .pointSizeAttenuation);
      },
   });

   return PointProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/LineProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function LineProperties (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .LineProperties);
   }

   LineProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: LineProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "applied",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "linetype",             new Fields .SFInt32 (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "linewidthScaleFactor", new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "LineProperties";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "lineProperties";
      },
      initialize: function ()
      {
         X3DAppearanceChildNode .prototype .initialize .call (this);

         this ._applied              .addInterest ("set_applied__",              this);
         this ._linetype             .addInterest ("set_linetype__",             this);
         this ._linewidthScaleFactor .addInterest ("set_linewidthScaleFactor__", this);

         this .set_applied__ ();
         this .set_linetype__ ();
         this .set_linewidthScaleFactor__ ();
      },
      getApplied: function ()
      {
         return this .applied;
      },
      getLinetype: function ()
      {
         return this .linetype;
      },
      getLinewidthScaleFactor: function ()
      {
         return this .linewidthScaleFactor;
      },
      getMustTransformLines: function ()
      {
         return this .mustTransformLines;
      },
      set_applied__: function ()
      {
         this .applied = this ._applied .getValue ();
      },
      set_linetype__: function ()
      {
         let linetype = this ._linetype .getValue ();

         if (linetype < 1 || linetype > 16)
            linetype = 1;

         this .linetype = linetype;
      },
      set_linewidthScaleFactor__: function ()
      {
         const
            browser = this .getBrowser (),
            gl      = browser .getContext ();

         this .linewidthScaleFactor = Math .max (1, this ._linewidthScaleFactor .getValue ());
         this .mustTransformLines   = gl .MUST_TRANSFORM_LINES && this .linewidthScaleFactor > 1;
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         if (this .applied)
         {
            const
               browser     = shaderObject .getBrowser (),
               texture     = browser .getLinetypeTexture (this .linetype),
               textureUnit = browser .getTexture2DUnit ();

            gl .lineWidth (this .linewidthScaleFactor);
            gl .uniform1i (shaderObject .x3d_LinePropertiesApplied,              true);
            gl .uniform1f (shaderObject .x3d_LinePropertiesLinewidthScaleFactor, this .linewidthScaleFactor);

            gl .activeTexture (gl .TEXTURE0 + textureUnit);
            gl .bindTexture (gl .TEXTURE_2D, texture .getTexture ());
            gl .uniform1i (shaderObject .x3d_LinePropertiesLinetype, textureUnit);
         }
         else
         {
            gl .lineWidth (1);
            gl .uniform1i (shaderObject .x3d_LinePropertiesApplied,              false);
            gl .uniform1f (shaderObject .x3d_LinePropertiesLinewidthScaleFactor, 1);
         }
      },
   });

   return LineProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/FillProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function FillProperties (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .FillProperties);

      this .addChildObjects ("transparent", new Fields .SFBool ());

      this ._transparent .setAccessType (X3DConstants .outputOnly);

      this .hatchColor = new Float32Array (3);
   }

   FillProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: FillProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "filled",     new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "hatched",    new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "hatchColor", new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "hatchStyle", new Fields .SFInt32 (1)),
      ]),
      getTypeName: function ()
      {
         return "FillProperties";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "fillProperties";
      },
      initialize: function ()
      {
         X3DAppearanceChildNode .prototype .initialize .call (this);

         this ._filled     .addInterest ("set_filled__",     this);
         this ._hatched    .addInterest ("set_hatched__",    this);
         this ._hatchColor .addInterest ("set_hatchColor__", this);
         this ._hatchStyle .addInterest ("set_hatchStyle__", this);

         this .set_filled__ ();
         this .set_hatched__ ();
         this .set_hatchColor__ ();
         this .set_hatchStyle__ ();
      },
      set_filled__: function ()
      {
         this .filled = this ._filled .getValue ();

         this .setTransparent (! this .filled);
      },
      set_hatched__: function ()
      {
         this .hatched = this ._hatched .getValue ();
      },
      set_hatchColor__: function ()
      {
         this .hatchColor [0] = this ._hatchColor [0];
         this .hatchColor [1] = this ._hatchColor [1];
         this .hatchColor [2] = this ._hatchColor [2];
      },
      set_hatchStyle__: function ()
      {
         let hatchStyle = this ._hatchStyle .getValue ();

         if (hatchStyle < 1 || hatchStyle > 19)
            hatchStyle = 1;

         this .hatchStyle = hatchStyle;
      },
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const hatched = this .hatched;

         gl .uniform1i (shaderObject .x3d_FillPropertiesFilled,  this .filled);
         gl .uniform1i (shaderObject .x3d_FillPropertiesHatched, hatched);

         if (hatched)
         {
            const
               browser     = shaderObject .getBrowser (),
               texture     = browser .getHatchStyleTexture (this .hatchStyle),
               textureUnit = browser .getTexture2DUnit ();

            gl .uniform3fv (shaderObject .x3d_FillPropertiesHatchColor, this .hatchColor);

            gl .activeTexture (gl .TEXTURE0 + textureUnit);
            gl .bindTexture (gl .TEXTURE_2D, texture .getTexture ());
            gl .uniform1i (shaderObject .x3d_FillPropertiesHatchStyle, textureUnit);
         }
      },
   });

   return FillProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DMaterialNode',[
   "x_ite/Fields",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function X3DMaterialNode (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DMaterialNode);

      this .addChildObjects ("transparent", new Fields .SFBool ());

      this ._transparent .setAccessType (X3DConstants .outputOnly);
   }

   X3DMaterialNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: X3DMaterialNode,
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
   });

   return X3DMaterialNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Shape/X3DOneSidedMaterialNode',[
   "x_ite/Fields",
   "x_ite/Components/Shape/X3DMaterialNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DMaterialNode,
          X3DCast,
          X3DConstants,
          Algorithm)
{
"use strict";

   function X3DOneSidedMaterialNode (executionContext)
   {
      X3DMaterialNode .call (this, executionContext);

      this .addType (X3DConstants .X3DOneSidedMaterialNode);

      this .addChildObjects ("textures", new Fields .SFTime ());

      this .emissiveColor = new Float32Array (3);
      this .textures      = 0;
   }

   X3DOneSidedMaterialNode .prototype = Object .assign (Object .create (X3DMaterialNode .prototype),
   {
      constructor: X3DOneSidedMaterialNode,
      initialize: function ()
      {
         X3DMaterialNode .prototype .initialize .call (this);

         this ._emissiveColor   .addInterest ("set_emissiveColor__",   this);
         this ._emissiveTexture .addInterest ("set_emissiveTexture__", this);
         this ._emissiveTexture .addInterest ("set_textures__",        this);
         this ._normalTexture   .addInterest ("set_normalTexture__",   this);
         this ._normalTexture   .addInterest ("set_textures__",        this);
         this ._transparency    .addInterest ("set_transparency__",    this);
         this ._transparency    .addInterest ("set_transparent__",     this);
         this ._textures        .addInterest ("set_textures__",        this);

         this .set_emissiveColor__ ();
         this .set_emissiveTexture__ ();
         this .set_normalTexture__ ();
         this .set_transparency__ ();
      },
      set_emissiveColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .emissiveColor .set (this ._emissiveColor .getValue ());

         const
            emissiveColor  = this .emissiveColor,
            emissiveColor_ = this ._emissiveColor .getValue ();

         emissiveColor [0] = emissiveColor_ .r;
         emissiveColor [1] = emissiveColor_ .g;
         emissiveColor [2] = emissiveColor_ .b;
      },
      set_emissiveTexture__: function ()
      {
         this .emissiveTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._emissiveTexture);

         this .setTexture (this .getTextureIndices () .EMISSIVE_TEXTURE, this .emissiveTextureNode);
      },
      set_normalTexture__: function ()
      {
         this .normalTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._normalTexture);

         this .setTexture (this .getTextureIndices () .NORMAL_TEXTURE, this .normalTextureNode);
      },
      set_transparency__: function ()
      {
         this .transparency = Algorithm .clamp (this ._transparency .getValue (), 0, 1);
      },
      set_textures__: function ()
      { },
      set_transparent__: function ()
      {
         this .setTransparent (Boolean (this .transparency));
      },
      getEmissiveTexture: function ()
      {
         return this .emissiveTextureNode;
      },
      getNormalTexture: function ()
      {
         return this .normalTextureNode;
      },
      getTransparency: function ()
      {
         return this .transparency;
      },
      getTextures: function ()
      {
         return this .textures;
      },
      getTextureIndices: (function ()
      {
         const textureIndices = {
            EMISSIVE_TEXTURE: 0,
            NORMAL_TEXTURE: 1,
         };

         return function ()
         {
            return textureIndices;
         };
      })(),
      setTexture: function (index, value)
      {
         if (value)
            this .textures |= 1 << index;
         else
            this .textures &= ~(1 << index);

         this ._textures = this .getBrowser () .getCurrentTime ();
      },
      setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
      {
         gl .uniform3fv (shaderObject .x3d_EmissiveColor, this .emissiveColor);
         gl .uniform1f  (shaderObject .x3d_Transparency,  this .transparency);

         if (this .textures)
         {
            const
               emissiveTexture = shaderObject .x3d_EmissiveTexture,
               normalTexture   = shaderObject .x3d_NormalTexture;

            // Emissive parameters

            if (this .emissiveTextureNode)
            {
               this .emissiveTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, emissiveTexture);

               gl .uniform1i (emissiveTexture .textureTransformMapping,  textureTransformMapping  .get (this ._emissiveTextureMapping .getValue ()) || 0);
               gl .uniform1i (emissiveTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._emissiveTextureMapping .getValue ()) || 0);
            }

            // Normal parameters

            if (this .normalTextureNode)
            {
               gl .uniform1f (shaderObject .x3d_NormalScale, this ._normalScale .getValue ());

               this .normalTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, normalTexture);

               gl .uniform1i (normalTexture .textureTransformMapping,  textureTransformMapping  .get (this ._normalTextureMapping .getValue ()) || 0);
               gl .uniform1i (normalTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._normalTextureMapping .getValue ()) || 0);
            }
         }
      },
   });

   return X3DOneSidedMaterialNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Shape/UnlitMaterial',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DOneSidedMaterialNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DOneSidedMaterialNode,
          X3DConstants)
{
"use strict";

   function UnlitMaterial (executionContext)
   {
      X3DOneSidedMaterialNode .call (this, executionContext);

      this .addType (X3DConstants .UnlitMaterial);
   }

   UnlitMaterial .prototype = Object .assign (Object .create (X3DOneSidedMaterialNode .prototype),
   {
      constructor: UnlitMaterial,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",               new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",          new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTexture",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTextureMapping", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalScale",            new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTexture",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTextureMapping",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",           new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "UnlitMaterial";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "material";
      },
      initialize: function ()
      {
         X3DOneSidedMaterialNode .prototype .initialize .call (this);

         this .shaderNode = this .getBrowser () .getUnlitShader ();

         this .set_transparent__ ();
      },
      set_emissiveTexture__: function ()
      {
         if (this .getEmissiveTexture ())
            this .getEmissiveTexture () ._transparent .removeInterest ("set_transparent__", this);

         X3DOneSidedMaterialNode .prototype .set_emissiveTexture__ .call (this);

         if (this .getEmissiveTexture ())
            this .getEmissiveTexture () ._transparent .addInterest ("set_transparent__", this);
      },
      set_transparent__: function ()
      {
         this .setTransparent (Boolean (this .getTransparency () ||
                               (this .getEmissiveTexture () && this .getEmissiveTexture () .getTransparent ())));
      },
      set_textures__: function ()
      {
         const browser = this .getBrowser ();

         if (this .getTextures ())
         {
            const options = ["X3D_MATERIAL_TEXTURES"];

            if (this .getEmissiveTexture ())
               options .push ("X3D_EMISSIVE_TEXTURE", "X3D_EMISSIVE_TEXTURE_" + this .getEmissiveTexture () .getTextureTypeString ());

            if (this .getNormalTexture ())
               options .push ("X3D_NORMAL_TEXTURE", "X3D_NORMAL_TEXTURE_" + this .getNormalTexture () .getTextureTypeString ());

            const shaderNode = browser .createShader ("UnlitTexturesShader", "Unlit", options);

            shaderNode ._isValid .addInterest ("set_shader__", this, shaderNode);
         }
         else
         {
            this .shaderNode = browser .getUnlitShader ();
         }
      },
      set_shader__: function (shaderNode)
      {
         shaderNode ._isValid .removeInterest ("set_shader__", this);

         this .shaderNode = shaderNode;
      },
      getShader: function (browser, shadow)
      {
         return this .shaderNode;
      },
   });

   return UnlitMaterial;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function TextureProperties (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .TextureProperties);
   }

   TextureProperties .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: TextureProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "borderColor",         new Fields .SFColorRGBA ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "borderWidth",         new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "anisotropicDegree",   new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "generateMipMaps",     new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "minificationFilter",  new Fields .SFString ("DEFAULT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "magnificationFilter", new Fields .SFString ("DEFAULT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeS",       new Fields .SFString ("REPEAT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeT",       new Fields .SFString ("REPEAT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeR",       new Fields .SFString ("REPEAT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "textureCompression",  new Fields .SFString ("DEFAULT")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texturePriority",     new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "TextureProperties";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "textureProperties";
      },
      getBorderWidth: function ()
      {
         // https://stackoverflow.com/questions/27760277/webgl-border-color-shader?lq=1
         return Algorithm .clamp (this ._borderWidth .getValue (), 0, 1);
      },
      getBoundaryMode: (function ()
      {
         const boundaryModes = new Map ([
            ["CLAMP",             "CLAMP_TO_EDGE"], // "CLAMP"
            ["CLAMP_TO_EDGE",     "CLAMP_TO_EDGE"],
            ["CLAMP_TO_BOUNDARY", "CLAMP_TO_EDGE"], // "CLAMP_TO_BORDER"
            ["MIRRORED_REPEAT",   "MIRRORED_REPEAT"],
            ["REPEAT",            "REPEAT"],
         ]);

         return function (string)
         {
            const boundaryMode = boundaryModes .get (string);

            if (boundaryMode !== undefined)
               return boundaryMode;

            return "REPEAT";
         };
      })(),
      getBoundaryModeS: function ()
      {
         return this .getBoundaryMode (this ._boundaryModeS .getValue ());
      },
      getBoundaryModeT: function ()
      {
         return this .getBoundaryMode (this ._boundaryModeT .getValue ());
      },
      getBoundaryModeR: function ()
      {
         return this .getBoundaryMode (this ._boundaryModeR .getValue ());
      },
      getMinificationFilter: (function ()
      {
         const minificationFilters = new Map ([
            ["AVG_PIXEL_AVG_MIPMAP",         "LINEAR_MIPMAP_LINEAR"],
            ["AVG_PIXEL",                    "LINEAR"],
            ["AVG_PIXEL_NEAREST_MIPMAP",     "LINEAR_MIPMAP_NEAREST"],
            ["NEAREST_PIXEL_AVG_MIPMAP",     "NEAREST_MIPMAP_LINEAR"],
            ["NEAREST_PIXEL_NEAREST_MIPMAP", "NEAREST_MIPMAP_NEAREST"],
            ["NEAREST_PIXEL",                "NEAREST"],
            ["NICEST",                       "LINEAR_MIPMAP_LINEAR"],
            ["FASTEST",                      "NEAREST"],
         ]);

         return function ()
         {
            if (this ._generateMipMaps .getValue ())
            {
               const minificationFilter = minificationFilters .get (this ._minificationFilter .getValue ());

               if (minificationFilter !== undefined)
                  return minificationFilter;

               return this .getBrowser () .getDefaultTextureProperties () .getMinificationFilter ();
            }

            return "LINEAR";
         };
      })(),
      getMagnificationFilter: (function ()
      {
         const magnificationFilters = new Map ([
            ["AVG_PIXEL",     "LINEAR"],
            ["NEAREST_PIXEL", "NEAREST"],
            ["NICEST",        "LINEAR"],
            ["FASTEST",       "NEAREST"],
         ]);

         return function ()
         {
            const magnificationFilter = magnificationFilters .get (this ._magnificationFilter .getValue ());

            if (magnificationFilter !== undefined)
               return magnificationFilter;

            // DEFAULT
            return this .getBrowser () .getDefaultTextureProperties () .getMagnificationFilter ();
         };
      })(),
      getTextureCompression: (function ()
      {
         const textureCompressions = new Map ([
            ["DEFAULT", "RGBA"],
            ["NICEST",  "RGBA"],
            ["FASTEST", "RGBA"],
            ["LOW",     "RGBA"],
            ["MEDIUM",  "RGBA"],
            ["HIGH",    "RGBA"],
         ]);

         return function ()
         {
            const
               browser            = this .getBrowser (),
               gl                 = browser .getContext (),
               compressedTexture  = gl .getExtension ("WEBGL_compressed_texture_etc"), // TODO: find suitable compression.
               textureCompression = compressedTexture ? compressedTexture [textureCompressions .get (this ._textureCompression .getValue ())] : undefined;

            if (textureCompression !== undefined)
               return textureCompression;

            // DEFAULT
            return gl .RGBA;
         };
      })(),
   });

   return TextureProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shape/X3DShapeContext',[
   "x_ite/Components/Shape/Appearance",
   "x_ite/Components/Shape/PointProperties",
   "x_ite/Components/Shape/LineProperties",
   "x_ite/Components/Shape/FillProperties",
   "x_ite/Components/Shape/UnlitMaterial",
   "x_ite/Components/Texturing/ImageTexture",
   "x_ite/Components/Texturing/TextureProperties",
   "x_ite/Browser/Networking/urls",
],
function (Appearance,
          PointProperties,
          LineProperties,
          FillProperties,
          UnlitMaterial,
          ImageTexture,
          TextureProperties,
          urls)
{
"use strict";

   const
      _lineStippleScale          = Symbol (),
      _linetypeTextures          = Symbol (),
      _hatchStyleTextures        = Symbol (),
      _defaultAppearance         = Symbol (),
      _defaultPointProperties    = Symbol (),
      _defaultLineProperties     = Symbol (),
      _defaultFillProperties     = Symbol (),
      _defaultMaterial           = Symbol (),
      _lineFillTextureProperties = Symbol (),
      _lineTransformShaderNode   = Symbol (),
      _lineTransformFeedback     = Symbol ();

   function X3DShapeContext ()
   {
      this [_linetypeTextures]   = [ ];
      this [_hatchStyleTextures] = [ ];
      this [_lineStippleScale]   = 1 / (this .getPixelPerPoint () * 32); // 32px
   }

   X3DShapeContext .prototype =
   {
      initialize: function ()
      { },
      getDefaultAppearance: function ()
      {
         this [_defaultAppearance] = new Appearance (this .getPrivateScene ());
         this [_defaultAppearance] .setup ();

         this .getDefaultAppearance = function () { return this [_defaultAppearance]; };

         Object .defineProperty (this, "getDefaultAppearance", { enumerable: false });

         return this [_defaultAppearance];
      },
      getDefaultPointProperties: function ()
      {
         this [_defaultPointProperties] = new PointProperties (this .getPrivateScene ());
         this [_defaultPointProperties] .setup ();

         this .getDefaultPointProperties = function () { return this [_defaultPointProperties]; };

         Object .defineProperty (this, "getDefaultPointProperties", { enumerable: false });

         return this [_defaultPointProperties];
      },
      getLineStippleScale: function ()
      {
         return this [_lineStippleScale];
      },
      getDefaultLineProperties: function ()
      {
         this [_defaultLineProperties] = new LineProperties (this .getPrivateScene ());

         this [_defaultLineProperties] ._applied = false;
         this [_defaultLineProperties] .setup ();

         this .getDefaultLineProperties = function () { return this [_defaultLineProperties]; };

         Object .defineProperty (this, "getDefaultLineProperties", { enumerable: false });

         return this [_defaultLineProperties];
      },
      getDefaultFillProperties: function ()
      {
         this [_defaultFillProperties] = new FillProperties (this .getPrivateScene ());

         this [_defaultFillProperties] ._hatched = false;
         this [_defaultFillProperties] .setup ();

         this .getDefaultFillProperties = function () { return this [_defaultFillProperties]; };

         Object .defineProperty (this, "getDefaultFillProperties", { enumerable: false });

         return this [_defaultFillProperties];
      },
      getDefaultMaterial: function ()
      {
         this [_defaultMaterial] = new UnlitMaterial (this .getPrivateScene ());

         this [_defaultMaterial] .setup ();

         this .getDefaultMaterial = function () { return this [_defaultMaterial]; };

         Object .defineProperty (this, "getDefaultMaterial", { enumerable: false });

         return this [_defaultMaterial];
      },
      getLinetypeTexture: function (index)
      {
         let linetypeTexture = this [_linetypeTextures] [index];

         if (linetypeTexture)
            return linetypeTexture;

         linetypeTexture = this [_linetypeTextures] [index] = new ImageTexture (this .getPrivateScene ());

         linetypeTexture ._url [0]           = urls .getLinetypeUrl (index);
         linetypeTexture ._textureProperties = this .getLineFillTextureProperties ();
         linetypeTexture .setup ();

         return linetypeTexture;
      },
      getHatchStyleTexture: function (index)
      {
         let hatchStyleTexture = this [_hatchStyleTextures] [index];

         if (hatchStyleTexture)
            return hatchStyleTexture;

         hatchStyleTexture = this [_hatchStyleTextures] [index] = new ImageTexture (this .getPrivateScene ());

         hatchStyleTexture ._url [0]           = urls .getHatchingUrl (index);
         hatchStyleTexture ._textureProperties = this .getLineFillTextureProperties ();
         hatchStyleTexture .setup ();

         return hatchStyleTexture;
      },
      getLineFillTextureProperties: function ()
      {
         this [_lineFillTextureProperties] = new TextureProperties (this .getPrivateScene ());

         this [_lineFillTextureProperties] ._minificationFilter  = "NEAREST_PIXEL";
         this [_lineFillTextureProperties] ._magnificationFilter = "NEAREST_PIXEL";

         this [_lineFillTextureProperties] .setup ();

         this .getLineFillTextureProperties = function () { return this [_lineFillTextureProperties]; };

         Object .defineProperty (this, "getLineFillTextureProperties", { enumerable: false });

         return this [_lineFillTextureProperties];
      },
      getLineTransformShader: function ()
      {
         this [_lineTransformShaderNode] = this .createShader ("LineTransformShader", "LineTransform");

         this [_lineTransformShaderNode] .setUniforms ([
            "viewport",
            "modelViewProjectionMatrix",
            "invModelViewProjectionMatrix",
            "scale",
         ]);

         this [_lineTransformShaderNode] .setTransformFeedbackVaryings ([
            "fogDepth0", "color0", "texCoord0", "vertex0",
            "fogDepth1", "color1", "texCoord1", "vertex1",
            "fogDepth2", "color2", "texCoord2", "vertex2",
         ]);

         this .getLineTransformShader = function () { return this [_lineTransformShaderNode]; };

         Object .defineProperty (this, "getLineTransformShader", { enumerable: false });

         return this [_lineTransformShaderNode];
      },
      getLineTransformFeedback: function ()
      {
         const gl = this .getContext ();

         this [_lineTransformFeedback] = gl .createTransformFeedback ();

         this .getLineTransformFeedback = function () { return this [_lineTransformFeedback]; };

         Object .defineProperty (this, "getLineTransformFeedback", { enumerable: false });

         return this [_lineTransformFeedback];
      },
   };

   return X3DShapeContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DShapeNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Grouping/X3DBoundedObject",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Shape/AlphaMode",
   "standard/Math/Geometry/Box3",
   "standard/Math/Numbers/Vector3",
],
function (X3DChildNode,
          X3DBoundedObject,
          X3DCast,
          X3DConstants,
          AlphaMode,
          Box3,
          Vector3)
{
"use strict";

   function X3DShapeNode (executionContext)
   {
      X3DChildNode     .call (this, executionContext);
      X3DBoundedObject .call (this, executionContext);

      this .addType (X3DConstants .X3DShapeNode);

      this .bbox       = new Box3 ();
      this .bboxSize   = new Vector3 (0, 0, 0);
      this .bboxCenter = new Vector3 (0, 0, 0);
   }

   X3DShapeNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DBoundedObject .prototype,
   {
      constructor: X3DShapeNode,
      initialize: function ()
      {
         X3DChildNode     .prototype .initialize .call (this);
         X3DBoundedObject .prototype .initialize .call (this);

         this ._bboxSize   .addInterest ("set_bbox__",      this);
         this ._bboxCenter .addInterest ("set_bbox__",      this);
         this ._appearance .addInterest ("set_apparance__", this);
         this ._geometry   .addInterest ("set_geometry__",  this);

         this ._appearance .addInterest ("set_transparent__", this);
         this ._geometry   .addInterest ("set_transparent__", this);

         this .set_apparance__ ();
         this .set_geometry__ ();
         this .set_transparent__ ();
      },
      getBBox: function (bbox, shadow)
      {
         if (shadow)
         {
            if (this ._castShadow .getValue ())
            {
               return bbox .assign (this .bbox);
            }
            else
            {
               return bbox .set ();
            }
         }
         else
         {
            return bbox .assign (this .bbox);
         }
      },
      getBBoxSize: function ()
      {
         return this .bboxSize;
      },
      getBBoxCenter: function ()
      {
         return this .bboxCenter;
      },
      getAppearance: function ()
      {
         return this .apparanceNode;
      },
      getGeometry: function ()
      {
         return this .geometryNode;
      },
      setTransparent: function (value)
      {
         this .transparent = value;
      },
      getTransparent: function ()
      {
         return this .transparent;
      },
      set_bbox__: function ()
      {
         if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
         {
            if (this .getGeometry ())
               this .bbox .assign (this .getGeometry () .getBBox ());

            else
               this .bbox .set ();
         }
         else
            this .bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());

         this .bboxSize   .assign (this .bbox .size);
         this .bboxCenter .assign (this .bbox .center);
      },
      set_apparance__: function ()
      {
         if (this .apparanceNode)
            this .apparanceNode ._transparent .removeInterest ("set_transparent__", this);

         this .apparanceNode = X3DCast (X3DConstants .X3DAppearanceNode, this ._appearance);

         if (this .apparanceNode)
         {
            this .apparanceNode ._alphaMode   .addInterest ("set_transparent__", this);
            this .apparanceNode ._transparent .addInterest ("set_transparent__", this);
         }
         else
            this .apparanceNode = this .getBrowser () .getDefaultAppearance ();
      },
      set_geometry__: function ()
      {
         if (this .geometryNode)
         {
            this .geometryNode ._transparent  .addInterest ("set_transparent__", this);
            this .geometryNode ._bbox_changed .addInterest ("set_bbox__",        this);
         }

         this .geometryNode = X3DCast (X3DConstants .X3DGeometryNode, this ._geometry);

         if (this .geometryNode)
         {
            this .geometryNode ._transparent  .addInterest ("set_transparent__", this);
            this .geometryNode ._bbox_changed .addInterest ("set_bbox__",        this);
         }

         this .set_bbox__ ();
      },
      set_transparent__: function ()
      {
         if (this .apparanceNode .getAlphaMode () === AlphaMode .AUTO)
         {
            this .transparent = this .apparanceNode .getTransparent () ||
                                (this .geometryNode && this .geometryNode .getTransparent ());
         }
         else
         {
            this .transparent = this .apparanceNode .getTransparent ();
         }
      },
   });

   return X3DShapeNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Line3',[
   "standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

   function Line3 (point, direction)
   {
      this .point     = point     .copy ();
      this .direction = direction .copy ();
   }

   Line3 .prototype =
   {
      constructor: Line3,
      copy: function ()
      {
         const copy = Object .create (Line3 .prototype);
         copy .point     = this .point .copy ();
         copy .direction = this .direction .copy ();
         return copy;
      },
      assign: function (line)
      {
         this .point     .assign (line .point);
         this .direction .assign (line .direction);
         return this;
      },
      set: function (point, direction)
      {
         this .point     .assign (point);
         this .direction .assign (direction);
         return this;
      },
      setPoints: function (point1, point2)
      {
         this .point .assign (point1);
         this .direction .assign (point2) .subtract (point1) .normalize ();
         return this;
      },
      multMatrixLine: function (matrix)
      {
         matrix .multMatrixVec (this .point);
         matrix .multMatrixDir (this .direction) .normalize ();
         return this;
      },
      multLineMatrix: function (matrix)
      {
         matrix .multVecMatrix (this .point);
         matrix .multDirMatrix (this .direction) .normalize ();
         return this;
      },
      getClosestPointToPoint: function (point, result)
      {
         const
            r = result .assign (point) .subtract (this .point),
            d = r .dot (this .direction);

         return result .assign (this .direction) .multiply (d) .add (this .point);
      },
      getClosestPointToLine: (function ()
      {
         const u = new Vector3 (0, 0, 0);

         return function (line, point)
         {
            const
               p1 = this .point,
               p2 = line .point,
               d1 = this .direction,
               d2 = line .direction;

            let t = Vector3 .dot (d1, d2);

            if (Math .abs (t) >= 1)
               return false;  // lines are parallel

            u .assign (p2) .subtract (p1);

            t = (u .dot (d1) - t * u .dot (d2)) / (1 - t * t);

            point .assign (d1) .multiply (t) .add (p1);
            return true;
         };
      })(),
      getPerpendicularVectorToPoint: (function ()
      {
         const t = new Vector3 (0, 0, 0);

         return function (point, result)
         {
            const d = result;

            d .assign (this .point) .subtract (point);

            return d .subtract (t .assign (this .direction) .multiply (d .dot (this .direction)));
         };
      })(),
      getPerpendicularVectorToLine: (function ()
      {
         const
            d  = new Vector3 (0, 0, 0),
            ad = new Vector3 (0, 0, 0);

         return function (line, result)
         {
            const bd = result;

            d .assign (this .point) .subtract (line .point);

            const
               re1 = d .dot (this .direction),
               re2 = d .dot (line .direction),
               e12 = this .direction .dot (line .direction),
               E12 = e12 * e12;

            const
               a =  (re1 - re2 * e12) / (1 - E12),
               b = -(re2 - re1 * e12) / (1 - E12);

            ad .assign (this .direction) .multiply (a);
            bd .assign (line .direction) .multiply (b);

            return bd .subtract (ad) .add (d);
         };
      })(),
      intersectsTriangle: (function ()
      {
         const
            pvec = new Vector3 (0, 0, 0),
            tvec = new Vector3 (0, 0, 0);

         return function (A, B, C, uvt)
         {
            // Find vectors for two edges sharing vert0.
            const
               edge1 = B .subtract (A),
               edge2 = C .subtract (A);

            // Begin calculating determinant - also used to calculate U parameter.
            pvec .assign (this .direction) .cross (edge2);

            // If determinant is near zero, ray lies in plane of triangle.
            const det = edge1 .dot (pvec);

            // Non culling intersection.

            if (det === 0)
               return false;

               const inv_det = 1 / det;

            // Calculate distance from vert0 to ray point.
            tvec .assign (this .point) .subtract (A);

            // Calculate U parameter and test bounds.
            const u = tvec .dot (pvec) * inv_det;

            if (u < 0 || u > 1)
               return false;

            // Prepare to test V parameter.
            const qvec = tvec .cross (edge1);

            // Calculate V parameter and test bounds.
            const v = this .direction .dot (qvec) * inv_det;

            if (v < 0 || u + v > 1)
               return false;

            //let t = edge2 .dot (qvec) * inv_det;

            uvt .u = u;
            uvt .v = v;
            uvt .t = 1 - u - v;

            return true;
         };
      })(),
      toString: function ()
      {
         return this .point + ", " + this .direction;
      },
   };

   Line3 .Points = function (point1, point2)
   {
      const line = Object .create (Line3 .prototype);
      line .point     = point1 .copy ();
      line .direction = Vector3 .subtract (point2, point1) .normalize ();
      return line;
   };

   return Line3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/QuickSort',[],function ()
{
"use strict";

   function QuickSort (array, compare)
   {
      this .array = array;

      if (compare)
         this .compare = compare;
   }

   QuickSort .prototype =
   {
      compare: function (lhs, rhs)
      {
         return lhs < rhs;
      },
      sort: function (first, last)
      {
         if (last - first > 1)
            this .quicksort (first, last - 1);
      },
      quicksort: function (lo, hi)
      {
         let
            i = lo,
            j = hi;

         const
            array   = this .array,
            compare = this .compare;

         // Vergleichs­element x
         const x = array [(lo + hi) >>> 1];

         for (;;)
         {
            while (compare (array [i], x)) ++ i;
            while (compare (x, array [j])) -- j;

            if (i < j)
            {
               // Exchange

               const t = array [i];
               array [i] = array [j];
               array [j] = t;

               i ++; j --;
            }
            else
            {
               if (i === j) ++ i, -- j;
               break;
            }
         }

         // Rekursion
         if (lo < j) this .quicksort (lo, j);
         if (i < hi) this .quicksort (i, hi);
      },
   };

   return QuickSort;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Shape',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DShapeNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/Line3",
   "standard/Math/Algorithms/QuickSort",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShapeNode,
          TraverseType,
          X3DConstants,
          Algorithm,
          Vector3,
          Matrix4,
          Box3,
          Line3,
          QuickSort)
{
"use strict";

   function Shape (executionContext)
   {
      X3DShapeNode .call (this, executionContext);

      this .addType (X3DConstants .Shape);
   }

   Shape .prototype = Object .assign (Object .create (X3DShapeNode .prototype),
   {
      constructor: Shape,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",     new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "castShadow",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",    new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",  new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "appearance",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "geometry",    new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Shape";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DShapeNode .prototype .initialize .call (this);

         this ._transformSensors_changed .addInterest ("set_transformSensors__", this);

         this .set_transformSensors__ ();
      },
      set_geometry__: function ()
      {
         X3DShapeNode .prototype .set_geometry__ .call (this);

         if (this .getGeometry ())
            delete this .traverse;
         else
            this .traverse = Function .prototype;
      },
      set_transformSensors__: function ()
      {
         this .setPickableObject (this .getTransformSensors () .size);
      },
      intersectsBox: function (box, clipPlanes, modelViewMatrix)
      {
         return this .getGeometry () .intersectsBox (box, clipPlanes, modelViewMatrix);
      },
      traverse: function (type, renderObject)
      {
         // Always look at ParticleSystem if you do modify something here and there.

         switch (type)
         {
            case TraverseType .POINTER:
            {
               this .pointer (renderObject);
               break;
            }
            case TraverseType .PICKING:
            {
               this .picking (renderObject);
               break;
            }
            case TraverseType .COLLISION:
            {
               renderObject .addCollisionShape (this);
               break;
            }
            case TraverseType .SHADOW:
            {
               if (this ._castShadow .getValue ())
                  renderObject .addDepthShape (this);

               break;
            }
            case TraverseType .DISPLAY:
            {
               if (renderObject .addDisplayShape (this))
                  this .getAppearance () .traverse (type, renderObject); // Currently used for GeneratedCubeMapTexture.

               break;
            }
         }

         this .getGeometry () .traverse (type, renderObject); // Currently used for ScreenText.
      },
      pointer: (function ()
      {
         const
            modelViewMatrix    = new Matrix4 (),
            invModelViewMatrix = new Matrix4 (),
            hitRay             = new Line3 (new Vector3 (0, 0, 0), new Vector3 (0, 0, 0)),
            intersections      = [ ],
            intersectionSorter = new QuickSort (intersections, function (lhs, rhs)
            {
               return lhs .point .z > rhs .point .z;
            }),
            distanceCompare    = function (lhs, rhs) { return lhs .point .z > rhs; };

         return function (renderObject)
         {
            const browser = renderObject .getBrowser ();

            if (browser .getPickOnlySensors () && browser .getSensors () .length === 1)
               return;

            const geometryNode = this .getGeometry ();

            modelViewMatrix    .assign (renderObject .getModelViewMatrix () .get ());
            invModelViewMatrix .assign (modelViewMatrix) .inverse ();

            hitRay .assign (browser .getHitRay ()) .multLineMatrix (invModelViewMatrix);

            if (geometryNode .intersectsLine (hitRay, renderObject .getLocalObjects (), modelViewMatrix, intersections))
            {
               // Finally we have intersections and must now find the closest hit in front of the camera.

               // Transform hitPoints to absolute space.
               for (const intersection of intersections)
                  modelViewMatrix .multVecMatrix (intersection .point);

               intersectionSorter .sort (0, intersections .length);

               // Find first point that is not greater than near plane;
               const index = Algorithm .lowerBound (intersections, 0, intersections .length, -renderObject .getNavigationInfo () .getNearValue (), distanceCompare);

               // Are there intersections before the camera?
               if (index !== intersections .length)
               {
                  // Transform hitNormal to absolute space.
                  invModelViewMatrix .multMatrixDir (intersections [index] .normal) .normalize ();

                  browser .addHit (intersections [index], renderObject .getLayer (), this, modelViewMatrix .multRight (renderObject .getCameraSpaceMatrix () .get ()));
               }

               intersections .length = 0;
            }
         };
      })(),
      picking: function (renderObject)
      {
         if (this .getTransformSensors () .size)
         {
            const modelMatrix = renderObject .getModelViewMatrix () .get ();

            for (const transformSensorNode of this .getTransformSensors ())
               transformSensorNode .collect (modelMatrix);
         }

         const
            browser          = renderObject .getBrowser (),
            pickSensorStack  = browser .getPickSensors (),
            pickingHierarchy = browser .getPickingHierarchy ();

         pickingHierarchy .push (this);

         for (const pickSensor of pickSensorStack .at (-1))
         {
            pickSensor .collect (this .getGeometry (), renderObject .getModelViewMatrix () .get (), browser .getPickingHierarchy ());
         }

         pickingHierarchy .pop ();
      },
      depth: function (gl, context, shaderNode)
      {
         this .getGeometry () .depth (gl, context, shaderNode);
      },
      display: function (gl, context)
      {
         this .getGeometry () .display (gl, context);
      },
   });

   return Shape;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DGeometryNode',[
   "x_ite/Fields",
   "x_ite/Rendering/VertexArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Core/Shading",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/Plane3",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Algorithm",
],
function (Fields,
          VertexArray,
          X3DNode,
          X3DConstants,
          Shading,
          Vector2,
          Vector3,
          Matrix4,
          Box3,
          Plane3,
          Triangle3,
          Algorithm)
{
"use strict";

   const ARRAY_TYPE = "Array"; // For color, texCoord, normal, and vertex array, can be MFFloat or Array;

   // Box normals for bbox / line intersection.
   const boxNormals = [
      new Vector3 (0,  0,  1), // front
      new Vector3 (0,  0, -1), // back
      new Vector3 (0,  1,  0), // top
      new Vector3 (0, -1,  0), // bottom
      new Vector3 (1,  0,  0)  // right
      // left: We do not have to test for left.
   ];

   function X3DGeometryNode (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DGeometryNode);

      this .addChildObjects ("transparent",  new Fields .SFBool (),
                             "bbox_changed", new Fields .SFTime (),
                             "rebuild",      new Fields .SFTime ());

      this ._transparent  .setAccessType (X3DConstants .outputOnly);
      this ._bbox_changed .setAccessType (X3DConstants .outputOnly);
      this ._rebuild      .setAccessType (X3DConstants .outputOnly);

      // Members

      const browser = this .getBrowser ();

      this .min                      = new Vector3 (0, 0, 0);
      this .max                      = new Vector3 (0, 0, 0);
      this .bbox                     = new Box3 (this .min, this .max, true);
      this .solid                    = true;
      this .primitiveMode            = browser .getContext () .TRIANGLES;
      this .geometryType             = 3;
      this .flatShading              = undefined;
      this .colorMaterial            = false;
      this .attribNodes              = [ ];
      this .attribArrays             = [ ];
      this .textureCoordinateMapping = new Map ();
      this .multiTexCoords           = [ ];
      this .texCoords                = X3DGeometryNode .createArray ();
      this .fogDepths                = X3DGeometryNode .createArray ();
      this .colors                   = X3DGeometryNode .createArray ();
      this .normals                  = X3DGeometryNode .createArray ();
      this .flatNormals              = X3DGeometryNode .createArray ();
      this .vertices                 = X3DGeometryNode .createArray ();
      this .fogCoords                = false;
      this .vertexCount              = 0;
      this .planes                   = [ ];

      for (let i = 0; i < 5; ++ i)
         this .planes [i] = new Plane3 (Vector3 .Zero, Vector3 .zAxis);
   }

   // Function to select ether Array or MFFloat for color/normal/vertex arrays.
   X3DGeometryNode .createArray = function ()
   {
      if (ARRAY_TYPE == "MFFloat")
         return new Fields .MFFloat ();

      const array = [ ];

      array .typedArray = new Float32Array ();

      array .assign = function (value)
      {
         const length = value .length;

         for (let i = 0; i < length; ++ i)
            this [i] = value [i];

         this .length = length;
      };

      array .getValue = function ()
      {
         return this .typedArray;
      };

      array .shrinkToFit = function ()
      {
         if (this .length === this .typedArray .length)
            this .typedArray .set (this);
         else
            this .typedArray = new Float32Array (this);
      };

      return array;
   }

   X3DGeometryNode .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DGeometryNode,
      setup: function ()
      {
         X3DNode .prototype .setup .call (this);

         this .rebuild ();
      },
      initialize: function ()
      {
         X3DNode .prototype .initialize .call (this);

         const
            browser = this .getBrowser (),
            gl      = browser .getContext ();

         this .isLive () .addInterest ("set_live__", this);

         this .addInterest ("requestRebuild", this);
         this ._rebuild .addInterest ("rebuild", this);

         this .frontFace             = gl .CCW;
         this .attribBuffers         = [ ];
         this .textureCoordinateNode = browser .getDefaultTextureCoordinate ();
         this .texCoordBuffers       = Array .from ({length: browser .getMaxTextures ()}, () => gl .createBuffer ());
         this .fogDepthBuffer        = gl .createBuffer ();
         this .colorBuffer           = gl .createBuffer ();
         this .normalBuffer          = gl .createBuffer ();
         this .vertexBuffer          = gl .createBuffer ();
         this .vertexArrayObject           = new VertexArray ();
         this .shadowArrayObject           = new VertexArray ();

         this .set_live__ ();
      },
      setGeometryType: function (value)
      {
         this .geometryType = value;
      },
      getGeometryType: function ()
      {
         return this .geometryType;
      },
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
      getBBox: function ()
      {
         // With screen matrix applied.
         return this .bbox;
      },
      setBBox: function (bbox)
      {
         if (bbox .equals (this .bbox))
            return;

         bbox .getExtents (this .min, this .max);

         this .bbox .assign (bbox);

         for (let i = 0; i < 5; ++ i)
            this .planes [i] .set (i % 2 ? this .min : this .max, boxNormals [i]);

         this ._bbox_changed .addEvent ();
      },
      getMin: function ()
      {
         // With screen matrix applied.
         return this .min;
      },
      getMax: function ()
      {
         // With screen matrix applied.
         return this .max;
      },
      getMatrix: function ()
      {
         return Matrix4 .Identity;
      },
      setPrimitiveMode: function (value)
      {
         this .primitiveMode = value;
      },
      getPrimitiveMode: function ()
      {
         return this .primitiveMode;
      },
      setSolid: function (value)
      {
         this .solid = value;
      },
      setCCW: function (value)
      {
         this .frontFace = value ? this .getBrowser () .getContext () .CCW : this .getBrowser () .getContext () .CW;
      },
      getAttrib: function ()
      {
         return this .attribNodes;
      },
      getAttribs: function ()
      {
         return this .attribArrays;
      },
      setFogDepths: function (value)
      {
         this .fogDepths .assign (value);
      },
      getFogDepths: function ()
      {
         return this .fogDepths;
      },
      setColors: function (value)
      {
         this .colors .assign (value);
      },
      getColors: function ()
      {
         return this .colors;
      },
      setMultiTexCoords: function (value)
      {
         const
            multiTexCoords = this .multiTexCoords,
            length         = value .length;

         for (let i = 0; i < length; ++ i)
            multiTexCoords [i] = value [i];

         multiTexCoords .length = length;
      },
      getMultiTexCoords: function ()
      {
         return this .multiTexCoords;
      },
      getTexCoords: function ()
      {
         return this .texCoords;
      },
      setTextureCoordinate: function (value)
      {
         this .textureCoordinateNode .removeInterest ("updateTextureCoordinateMapping", this);

         if (value)
            this .textureCoordinateNode = value;
         else
            this .textureCoordinateNode = this .getBrowser () .getDefaultTextureCoordinate ();

         this .textureCoordinateNode .addInterest ("updateTextureCoordinateMapping", this);

         this .updateTextureCoordinateMapping ();
      },
      updateTextureCoordinateMapping: function ()
      {
         this .textureCoordinateMapping .clear ();

         this .textureCoordinateNode .getTextureMapping (this .textureCoordinateMapping);
      },
      setNormals: function (value)
      {
         this .normals .assign (value);
      },
      getNormals: function ()
      {
         return this .normals;
      },
      setVertices: function (value)
      {
         this .vertices .assign (value);
      },
      getVertices: function ()
      {
         return this .vertices;
      },
      updateVertexArrays: function ()
      {
         this .vertexArrayObject .update ();
         this .shadowArrayObject .update ();

         this .updateParticlesShadow = true;
         this .updateParticles       = true;
      },
      buildTexCoords: function ()
      {
         const texCoords = this .texCoords;

         if (texCoords .length === 0)
         {
            const
               p         = this .getTexCoordParams (),
               min       = p .min,
               Sindex    = p .Sindex,
               Tindex    = p .Tindex,
               Ssize     = p .Ssize,
               S         = min [Sindex],
               T         = min [Tindex],
               vertices  = this .vertices .getValue ();

            for (let i = 0, length = vertices .length; i < length; i += 4)
            {
               texCoords .push ((vertices [i + Sindex] - S) / Ssize,
                                (vertices [i + Tindex] - T) / Ssize,
                                0,
                                1);
            }

            texCoords .shrinkToFit ();
         }

         this .getMultiTexCoords () .push (texCoords);
      },
      getTexCoordParams: (function ()
      {
         const texCoordParams = { min: new Vector3 (0, 0, 0), Ssize: 0, Sindex: 0, Tindex: 0 };

         return function ()
         {
            const
               bbox  = this .getBBox (),
               size  = bbox .size,
               Xsize = size .x,
               Ysize = size .y,
               Zsize = size .z;

            texCoordParams .min .assign (bbox .center) .subtract (size .divide (2));

            if ((Xsize >= Ysize) && (Xsize >= Zsize))
            {
               // X size largest
               texCoordParams .Ssize = Xsize; texCoordParams .Sindex = 0;

               if (Ysize >= Zsize)
                  texCoordParams .Tindex = 1;
               else
                  texCoordParams .Tindex = 2;
            }
            else if ((Ysize >= Xsize) && (Ysize >= Zsize))
            {
               // Y size largest
               texCoordParams .Ssize = Ysize; texCoordParams .Sindex = 1;

               if (Xsize >= Zsize)
                  texCoordParams .Tindex = 0;
               else
                  texCoordParams .Tindex = 2;
            }
            else
            {
               // Z is the largest
               texCoordParams .Ssize = Zsize; texCoordParams .Sindex = 2;

               if (Xsize >= Ysize)
                  texCoordParams .Tindex = 0;
               else
                  texCoordParams .Tindex = 1;
            }

            return texCoordParams;
         };
      })(),
      refineNormals: function (normalIndex, normals, creaseAngle)
      {
         if (creaseAngle === 0)
            return normals;

         const
            cosCreaseAngle = Math .cos (Algorithm .clamp (creaseAngle, 0, Math .PI)),
            normals_       = [ ];

         for (const i in normalIndex) // Don't use forEach
         {
            const vertex = normalIndex [i];

            for (const p of vertex)
            {
               const
                  P = normals [p],
                  N = new Vector3 (0, 0, 0);

               for (const q of vertex)
               {
                  const Q = normals [q];

                  if (Q .dot (P) >= cosCreaseAngle)
                     N .add (Q);
               }

               normals_ [p] = N .normalize ();
            }
         }

         return normals_;
      },
      isClipped: function (point, clipPlanes)
      {
         return clipPlanes .some (function (clipPlane)
         {
            return clipPlane .isClipped (point);
         });
      },
      transformLine: function (hitRay)
      {
         // Apply sceen nodes transformation in place here.
      },
      transformMatrix: function (hitRay)
      {
         // Apply sceen nodes transformation in place here.
      },
      intersectsLine: (function ()
      {
         const
            modelViewMatrix = new Matrix4 (),
            uvt             = { u: 0, v: 0, t: 0 },
            v0              = new Vector3 (0, 0, 0),
            v1              = new Vector3 (0, 0, 0),
            v2              = new Vector3 (0, 0, 0),
            clipPoint       = new Vector3 (0, 0, 0);

         return function (hitRay, clipPlanes, modelViewMatrix_, intersections)
         {
            if (this .intersectsBBox (hitRay))
            {
               this .transformLine (hitRay);                                       // Apply screen transformations from screen nodes.
               this .transformMatrix (modelViewMatrix .assign (modelViewMatrix_)); // Apply screen transformations from screen nodes.

               const
                  texCoords  = this .multiTexCoords [0] .getValue (),
                  normals    = this .normals .getValue (),
                  vertices   = this .vertices .getValue ();

               for (let i = 0, length = this .vertexCount; i < length; i += 3)
               {
                  const i4 = i * 4;

                  v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
                  v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
                  v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

                  if (hitRay .intersectsTriangle (v0, v1, v2, uvt))
                  {
                     // Get barycentric coordinates.

                     const
                        u = uvt .u,
                        v = uvt .v,
                        t = uvt .t;

                     // Determine vectors for X3DPointingDeviceSensors.

                     const point = new Vector3 (t * vertices [i4]     + u * vertices [i4 + 4] + v * vertices [i4 +  8],
                                                t * vertices [i4 + 1] + u * vertices [i4 + 5] + v * vertices [i4 +  9],
                                                t * vertices [i4 + 2] + u * vertices [i4 + 6] + v * vertices [i4 + 10]);

                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
                        continue;

                     const texCoord = new Vector2 (t * texCoords [i4]     + u * texCoords [i4 + 4] + v * texCoords [i4 + 8],
                                                   t * texCoords [i4 + 1] + u * texCoords [i4 + 5] + v * texCoords [i4 + 9]);

                     const i3 = i * 3;

                     const normal = new Vector3 (t * normals [i3]     + u * normals [i3 + 3] + v * normals [i3 + 6],
                                                   t * normals [i3 + 1] + u * normals [i3 + 4] + v * normals [i3 + 7],
                                                   t * normals [i3 + 2] + u * normals [i3 + 5] + v * normals [i3 + 8]);

                     intersections .push ({ texCoord: texCoord, normal: normal, point: this .getMatrix () .multVecMatrix (point) });
                  }
               }
            }

            return intersections .length;
         };
      })(),
      intersectsBBox: (function ()
      {
         const intersection = new Vector3 (0, 0, 0);

         return function (hitRay, offset = 0)
         {
            const
               planes = this .planes,
               min    = this .min,
               max    = this .max,
               minX   = min .x - offset,
               maxX   = max .x + offset,
               minY   = min .y - offset,
               maxY   = max .y + offset,
               minZ   = min .z - offset,
               maxZ   = max .z + offset;

            // front
            if (planes [0] .intersectsLine (hitRay, intersection))
            {
               if (intersection .x >= minX && intersection .x <= maxX &&
                   intersection .y >= minY && intersection .y <= maxY)
                  return true;
            }

            // back
            if (planes [1] .intersectsLine (hitRay, intersection))
            {
               if (intersection .x >= minX && intersection .x <= maxX &&
                   intersection .y >= minY && intersection .y <= maxY)
                  return true;
            }

            // top
            if (planes [2] .intersectsLine (hitRay, intersection))
            {
               if (intersection .x >= minX && intersection .x <= maxX &&
                   intersection .z >= minZ && intersection .z <= maxZ)
                  return true;
            }

            // bottom
            if (planes [3] .intersectsLine (hitRay, intersection))
            {
               if (intersection .x >= minX && intersection .x <= maxX &&
                   intersection .z >= minZ && intersection .z <= maxZ)
                  return true;
            }

            // right
            if (planes [4] .intersectsLine (hitRay, intersection))
            {
               if (intersection .y >= minY && intersection .y <= maxY &&
                   intersection .z >= minZ && intersection .z <= maxZ)
                  return true;
            }

            return false;
         };
      })(),
      intersectsBox: (function ()
      {
         const
            v0        = new Vector3 (0, 0, 0),
            v1        = new Vector3 (0, 0, 0),
            v2        = new Vector3 (0, 0, 0),
            invMatrix = new Matrix4 (),
            clipPoint = new Vector3 (0, 0, 0);

         return function (box, clipPlanes, modelViewMatrix)
         {
            if (box .intersectsBox (this .bbox))
            {
               box .multRight (invMatrix .assign (this .getMatrix ()) .inverse ());

               this .transformMatrix (modelViewMatrix); // Apply screen transformations from screen nodes.

               const vertices = this .vertices .getValue ();

               for (let i = 0, length = this .vertexCount; i < length; i += 3)
               {
                  const i4 = i * 4;

                  v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
                  v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
                  v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

                  if (box .intersectsTriangle (v0, v1, v2))
                  {
                     if (clipPlanes .length)
                     {
                        if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v0)), clipPlanes))
                           continue;

                        if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v1)), clipPlanes))
                           continue;

                        if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v2)), clipPlanes))
                           continue;
                     }

                     return true;
                  }
               }
            }

            return false;
         };
      })(),
      set_live__: function ()
      {
         if (this .isLive () .getValue ())
            this .getBrowser () .getBrowserOptions () ._Shading .addInterest ("set_shading__", this);
         else
            this .getBrowser () .getBrowserOptions () ._Shading .removeInterest ("set_shading__", this);
      },
      set_shading__: (function ()
      {
         const
            v0     = new Vector3 (0, 0, 0),
            v1     = new Vector3 (0, 0, 0),
            v2     = new Vector3 (0, 0, 0),
            normal = new Vector3 (0, 0, 0);

         return function (shading)
         {
            if (this .geometryType < 2)
               return;

            const flatShading = this .getBrowser () .getBrowserOptions () .getShading () === Shading .FLAT;

            if (flatShading === this .flatShading)
               return;

            this .flatShading = flatShading;

            // Generate flat normals if needed.

            const gl = this .getBrowser () .getContext ();

            if (flatShading)
            {
               if (! this .flatNormals .length)
               {
                  const
                     cw          = this .frontFace === gl .CW,
                     flatNormals = this .flatNormals,
                     vertices    = this .vertices .getValue ();

                  for (let i = 0, length = vertices .length; i < length; i += 12)
                  {
                     Triangle3 .normal (v0 .set (vertices [i],     vertices [i + 1], vertices [i + 2]),
                                        v1 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6]),
                                        v2 .set (vertices [i + 8], vertices [i + 9], vertices [i + 10]),
                                        normal);

                     if (cw)
                        normal .negate ();

                     flatNormals .push (normal .x, normal .y, normal .z,
                                        normal .x, normal .y, normal .z,
                                        normal .x, normal .y, normal .z);
                  }

                  flatNormals .shrinkToFit ();
               }
            }

            // Transfer normals.

            gl .bindBuffer (gl .ARRAY_BUFFER, this .normalBuffer);
            gl .bufferData (gl .ARRAY_BUFFER, flatShading ? this .flatNormals .getValue () : this .normals .getValue (), gl .DYNAMIC_DRAW);
         };
      })(),
      requestRebuild: function ()
      {
         this ._rebuild .addEvent ();
      },
      rebuild: (function ()
      {
         const point = new Vector3 (0, 0, 0);

         return function ()
         {
            this .clear ();
            this .build ();

            // Shrink arrays before transfer to graphics card.

            for (const attribArray of this .attribArrays)
               attribArray .shrinkToFit ();

            for (const multiTexCoord of this .multiTexCoords)
               multiTexCoord .shrinkToFit ();

            this .fogDepths .shrinkToFit ();
            this .colors    .shrinkToFit ();
            this .normals   .shrinkToFit ();
            this .vertices  .shrinkToFit ();

            // Determine bbox.

            const
               min      = this .min,
               max      = this .max,
               vertices = this .vertices .getValue ();

            if (vertices .length)
            {
               if (min .x === Number .POSITIVE_INFINITY)
               {
                  for (let i = 0, length = vertices .length; i < length; i += 4)
                  {
                     point .set (vertices [i], vertices [i + 1], vertices [i + 2]);

                     min .min (point);
                     max .max (point);
                  }
               }

               this .bbox .setExtents (min, max);
            }
            else
            {
               this .bbox .setExtents (min .set (0, 0, 0), max .set (0, 0, 0));
            }

            this ._bbox_changed .addEvent ();

            for (let i = 0; i < 5; ++ i)
               this .planes [i] .set (i % 2 ? min : max, boxNormals [i]);

            // Generate texCoord if needed.

            if (this .multiTexCoords .length === 0)
               this .buildTexCoords ();

            if (this .multiTexCoords .length)
            {
               const maxTextures = this .getBrowser () .getMaxTextures ();

               for (let i = this .multiTexCoords .length; i < maxTextures; ++ i)
                  this .multiTexCoords [i] = this .multiTexCoords .at (-1);

               this .multiTexCoords .length = maxTextures;
            }

            // Upload normals or flat normals.

            this .set_shading__ (this .getBrowser () .getBrowserOptions () ._Shading);

            // Upload arrays.

            this .transfer ();
         };
      })(),
      clear: function ()
      {
         // BBox

         this .min .set (Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY);
         this .max .set (Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY);

         // Create attribArray arrays.
         {
            const attribArrays = this .attribArrays;

            for (const attribArray of attribArrays)
               attribArray .length = 0;

            const length = this .attribNodes .length;

            for (let a = attribArrays .length; a < length; ++ a)
               attribArrays [a] = X3DGeometryNode .createArray ();

            attribArrays .length = length;
         }

         // Buffer

         this .flatShading = undefined;

         this .fogDepths      .length = 0;
         this .colors         .length = 0;
         this .multiTexCoords .length = 0;
         this .texCoords      .length = 0;
         this .normals        .length = 0;
         this .flatNormals    .length = 0;
         this .vertices       .length = 0;
      },
      transfer: function ()
      {
         const gl = this .getBrowser () .getContext ();

         // Transfer attribArrays.

         for (let i = this .attribBuffers .length, length = this .attribArrays .length; i < length; ++ i)
            this .attribBuffers .push (gl .createBuffer ());

         for (let i = 0, length = this .attribArrays .length; i < length; ++ i)
         {
            gl .bindBuffer (gl .ARRAY_BUFFER, this .attribBuffers [i]);
            gl .bufferData (gl .ARRAY_BUFFER, this .attribArrays [i] .getValue (), gl .DYNAMIC_DRAW);
         }

         // Transfer fog depths.

         const lastFogCoords = this .fogCoords;

         gl .bindBuffer (gl .ARRAY_BUFFER, this .fogDepthBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, this .fogDepths .getValue (), gl .DYNAMIC_DRAW);

         this .fogCoords = !! (this .fogDepths .length);

         if (this .fogCoords !== lastFogCoords)
            this .updateVertexArrays ();

         // Transfer colors.

         const lastColorMaterial = this .colorMaterial;

         gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, this .colors .getValue (), gl .DYNAMIC_DRAW);

         this .colorMaterial = !! (this .colors .length);

         if (this .colorMaterial !== lastColorMaterial)
            this .updateVertexArrays ();

         // Transfer multiTexCoords.

         for (let i = 0, length = this .multiTexCoords .length; i < length; ++ i)
         {
            gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [i]);
            gl .bufferData (gl .ARRAY_BUFFER, this .multiTexCoords [i] .getValue (), gl .DYNAMIC_DRAW);
         }

         // Transfer vertices.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .vertexBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, this .vertices .getValue (), gl .DYNAMIC_DRAW);

         this .vertexCount = this .vertices .length / 4;

         // Setup render functions.

         if (this .vertexCount)
         {
            // Use default render functions.

            delete this .depth;
            delete this .display;
            delete this .displayParticlesDepth;
            delete this .displayParticles;
         }
         else
         {
            // Use no render function.

            this .depth                 = Function .prototype;
            this .display               = Function .prototype;
            this .displayParticlesDepth = Function .prototype;
            this .displayParticles      = Function .prototype;
         }
      },
      traverse: function (type, renderObject)
      { },
      depth: function (gl, context, shaderNode)
      {
         if (this .shadowArrayObject .enable (gl, shaderNode))
            shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);

         gl .drawArrays (this .primitiveMode, 0, this .vertexCount);
      },
      display: function (gl, context)
      {
         const
            appearanceNode   = context .shapeNode .getAppearance (),
            materialNode     = appearanceNode .materialNode,
            backMaterialNode = appearanceNode .backMaterialNode,
            frontShaderNode  = appearanceNode .shaderNode || materialNode .getShader (context .browser, context .shadow);

         if (this .solid || !backMaterialNode || frontShaderNode .wireframe)
         {
            this .displayGeometry (gl, context, appearanceNode, frontShaderNode, true, true);
         }
         else
         {
            const backShaderNode = appearanceNode .shaderNode || backMaterialNode .getShader (context .browser, context .shadow)

            this .displayGeometry (gl, context, appearanceNode, backShaderNode,  true,  false);
            this .displayGeometry (gl, context, appearanceNode, frontShaderNode, false, true);
         }
      },
      displayGeometry: function (gl, context, appearanceNode, shaderNode, back, front)
      {
         if (shaderNode .isValid ())
         {
            const
               blendModeNode = appearanceNode .blendModeNode,
               attribNodes   = this .attribNodes,
               attribBuffers = this .attribBuffers;

            if (blendModeNode)
               blendModeNode .enable (gl);

            shaderNode .enable (gl);
            shaderNode .setLocalUniforms (gl, context, front);

            // Setup vertex attributes.

            if (this .vertexArrayObject .enable (gl, shaderNode))
            {
               for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

               if (this .fogCoords)
                  shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

               if (this .colorMaterial)
                  shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

               shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
               shaderNode .enableNormalAttribute   (gl, this .normalBuffer,    0, 0);
               shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);
            }

            // Draw depending on wireframe, solid and transparent.

            if (shaderNode .wireframe)
            {
               // Points and Wireframes.

               if (shaderNode .primitiveMode === gl .POINTS)
               {
                  gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
               }
               else
               {
                  for (let i = 0, length = this .vertexCount; i < length; i += 3)
                     gl .drawArrays (shaderNode .primitiveMode, i, 3);
               }
            }
            else
            {
               const positiveScale = Matrix4 .prototype .determinant3 .call (context .modelViewMatrix) > 0;

               gl .frontFace (positiveScale ? this .frontFace : (this .frontFace === gl .CCW ? gl .CW : gl .CCW));

               if (context .transparent || back !== front)
               {
                  // Render transparent or back or front.

                  gl .enable (gl .CULL_FACE);

                  // Render back.

                  if (back && !this .solid)
                  {
                     gl .cullFace (gl .FRONT);
                     gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
                  }

                  // Render front.

                  if (front)
                  {
                     gl .cullFace (gl .BACK);
                     gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
                  }
               }
               else
               {
                  // Render solid or both sides.

                  if (this .solid)
                     gl .enable (gl .CULL_FACE);
                  else
                     gl .disable (gl .CULL_FACE);

                  gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
               }
            }

            if (blendModeNode)
               blendModeNode .disable (gl);
         }
      },
      displayParticlesDepth: function (gl, context, shaderNode, particleSystem)
      {
         const outputParticles = particleSystem .outputParticles;

         if (this .updateParticlesShadow)
         {
            this .updateParticlesShadow = false;

            outputParticles .shadowArrayObject .update ();
         }

         if (outputParticles .shadowArrayObject .enable (gl, shaderNode))
         {
            const particleStride = particleSystem .particleStride;

            shaderNode .enableParticleAttribute       (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
            shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset,   1);
            shaderNode .enableVertexAttribute         (gl, this .vertexBuffer, 0, 0);
         }

         gl .drawArraysInstanced (shaderNode .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
      },
      displayParticles: function (gl, context, particleSystem)
      {
         const
            appearanceNode   = context .shapeNode .getAppearance (),
            materialNode     = appearanceNode .materialNode,
            backMaterialNode = appearanceNode .backMaterialNode,
            frontShaderNode  = appearanceNode .shaderNode || materialNode .getShader (context .browser, context .shadow);

         if (this .solid || !backMaterialNode || frontShaderNode .wireframe)
         {
            this .displayParticlesGeometry (gl, context, appearanceNode, frontShaderNode, true, true, particleSystem);
         }
         else
         {
            const backShaderNode = appearanceNode .shaderNode || backMaterialNode .getShader (context .browser, context .shadow);

            this .displayParticlesGeometry (gl, context, appearanceNode, backShaderNode,  true,  false, particleSystem);
            this .displayParticlesGeometry (gl, context, appearanceNode, frontShaderNode, false, true,  particleSystem);
         }
      },
      displayParticlesGeometry: function (gl, context, appearanceNode, shaderNode, back, front, particleSystem)
      {
         if (shaderNode .isValid ())
         {
            const
               blendModeNode = appearanceNode .blendModeNode,
               attribNodes   = this .attribNodes,
               attribBuffers = this .attribBuffers;

            if (blendModeNode)
               blendModeNode .enable (gl);

            // Setup shader.

            shaderNode .enable (gl);
            shaderNode .setLocalUniforms (gl, context, front);

            // Setup vertex attributes.

            const outputParticles = particleSystem .outputParticles;

            if (this .updateParticles)
            {
               this .updateParticles = false;

               outputParticles .vertexArrayObject .update ();
            }

            if (outputParticles .vertexArrayObject .enable (gl, shaderNode))
            {
               const particleStride = particleSystem .particleStride;

               shaderNode .enableParticleAttribute       (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
               shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset,   1);

               for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

               if (this .fogCoords)
                  shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

               if (this .colorMaterial)
                  shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

               shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
               shaderNode .enableNormalAttribute   (gl, this .normalBuffer,    0, 0);
               shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);
            }

            // Draw depending on wireframe, solid and transparent.

            if (shaderNode .wireframe)
            {
               // Points and Wireframes.

               if (shaderNode .primitiveMode === gl .POINTS)
               {
                  gl .drawArraysInstanced (shaderNode .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
               }
               else
               {
                  for (let i = 0, length = this .vertexCount; i < length; i += 3)
                     gl .drawArraysInstanced (shaderNode .primitiveMode, i, 3, particleSystem .numParticles);
               }
            }
            else
            {
               const positiveScale = Matrix4 .prototype .determinant3 .call (context .modelViewMatrix) > 0;

               gl .frontFace (positiveScale ? this .frontFace : (this .frontFace === gl .CCW ? gl .CW : gl .CCW));

               if (context .transparent || back !== front)
               {
                  // Render transparent or back or front.

                  gl .enable (gl .CULL_FACE);

                  if (back && !this .solid)
                  {
                     gl .cullFace (gl .FRONT);
                     gl .drawArraysInstanced (shaderNode .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
                  }

                  if (front)
                  {
                     gl .cullFace (gl .BACK);
                     gl .drawArraysInstanced (shaderNode .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
                  }
               }
               else
               {
                  // Render solid or both sides.

                  if (this .solid)
                     gl .enable (gl .CULL_FACE);
                  else
                     gl .disable (gl .CULL_FACE);

                  gl .drawArraysInstanced (shaderNode .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);
               }
            }

            if (blendModeNode)
               blendModeNode .disable (gl);
         }
      },
   });

   return X3DGeometryNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DLineGeometryNode',[
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Rendering/VertexArray",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Geometry/Line3",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Matrix4",
],
function (X3DGeometryNode,
          VertexArray,
          ViewVolume,
          Line3,
          Vector2,
          Vector3,
          Vector4,
          Matrix4)
{
"use strict";

   function X3DLineGeometryNode (executionContext)
   {
      if (!this .getExecutionContext ())
         X3DGeometryNode .call (this, executionContext);

      const
         browser = this .getBrowser (),
         gl      = browser .getContext ();

      this .transformVertexArrayObject = new VertexArray ();
      this .thickVertexArrayObject     = new VertexArray ();
      this .trianglesBuffer            = gl .createBuffer ();
      this .trianglesTexCoordBuffers   = new Array (browser .getMaxTextures ()) .fill (this .trianglesBuffer);

      this .setGeometryType (1);
      this .setPrimitiveMode (browser .getContext () .LINES);
      this .setSolid (false);
   }

   X3DLineGeometryNode .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: X3DLineGeometryNode,
      updateVertexArrays: function ()
      {
         X3DGeometryNode .prototype .updateVertexArrays .call (this);

         this .transformVertexArrayObject .update ();
         this .thickVertexArrayObject     .update ();
      },
      intersectsLine: (function ()
      {
         const PICK_DISTANCE_FACTOR = 1 / 300;

         const
            point1    = new Vector3 (0, 0, 0),
            point2    = new Vector3 (0, 0, 0),
            line      = new Line3 (Vector3 .Zero, Vector3 .zAxis),
            point     = new Vector3 (0, 0, 0),
            vector    = new Vector3 (0, 0, 0),
            clipPoint = new Vector3 (0, 0, 0);

         return function (hitRay, clipPlanes, modelViewMatrix, intersections)
         {
            if (this .intersectsBBox (hitRay, 1))
            {
               const vertices = this .getVertices ();

               for (let i = 0, length = vertices .length; i < length; i += 8)
               {
                  point1 .set (vertices [i + 0], vertices [i + 1], vertices [i + 2]);
                  point2 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6]);

                  line .setPoints (point1, point2);

                  if (line .getClosestPointToLine (hitRay, point))
                  {
                     if (line .getPerpendicularVectorToLine (hitRay, vector) .abs () < hitRay .point .distance (point) * PICK_DISTANCE_FACTOR)
                     {
                        const distance = point1 .distance (point2);

                        if (point1 .distance (point) <= distance && point2 .distance (point) <= distance)
                        {
                           if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
                              continue;

                           intersections .push ({ texCoord: new Vector2 (0, 0), normal: new Vector3 (0, 0, 0), point: point .copy () });
                           return true;
                        }
                     }
                  }
               }
            }

            return false;
         };
      })(),
      intersectsBox: function (box, clipPlanes, modelViewMatrix)
      {
         return false;
      },
      buildTexCoords: function ()
      {
         // Line stipple support.

         const texCoords = this .getTexCoords ();

         if (texCoords .getValue () .length !== this .getVertices () .length)
         {
            const
               gl       = this .getBrowser () .getContext (),
               numLines = this .getVertices () .length / 8;

            texCoords .length = this .getVertices () .length;

            texCoords .fill (0);
            texCoords .shrinkToFit ();

            gl .bindBuffer (gl .ARRAY_BUFFER, this .trianglesBuffer);
            gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (13 * 6 * numLines), gl .DYNAMIC_DRAW);
         }

         this .getMultiTexCoords () .push (texCoords);
      },
      updateLengthSoFar: (function ()
      {
         const
            modelViewProjectionMatrix = new Matrix4 (),
            point0                    = new Vector4 (0, 0, 0),
            point1                    = new Vector4 (0, 0, 0),
            projectedPoint0           = new Vector2 (0, 0),
            projectedPoint1           = new Vector2 (0, 0);

         return function (gl, context)
         {
            const
               viewport         = context .renderer .getViewVolume () .getViewport (),
               projectionMatrix = context .renderer .getProjectionMatrix () .get (),
               texCoordArray    = this .getTexCoords () .getValue (),
               vertices         = this .getVertices (),
               numVertices      = vertices .length;

            modelViewProjectionMatrix .assign (context .modelViewMatrix) .multRight (projectionMatrix);

            let lengthSoFar = 0;

            for (let i = 0; i < numVertices; i += 8)
            {
               point0 .set (vertices [i],     vertices [i + 1], vertices [i + 2], vertices [i + 3]);
               point1 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6], vertices [i + 7]);

               ViewVolume .projectPointMatrix (point0, modelViewProjectionMatrix, viewport, projectedPoint0);
               ViewVolume .projectPointMatrix (point1, modelViewProjectionMatrix, viewport, projectedPoint1);

               texCoordArray [i]     = projectedPoint1 .x;
               texCoordArray [i + 1] = projectedPoint1 .y;

               texCoordArray [i + 4] = projectedPoint0 .x;
               texCoordArray [i + 5] = projectedPoint0 .y;
               texCoordArray [i + 6] = lengthSoFar;

               lengthSoFar += projectedPoint1 .subtract (projectedPoint0) .abs ();
            }

            gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [0]);
            gl .bufferData (gl .ARRAY_BUFFER, texCoordArray, gl .DYNAMIC_DRAW);
         };
      })(),
      display: (function ()
      {
         const
            matrix                            = new Matrix4 (),
            modelViewProjectionMatrixArray    = new Float32Array (16),
            invModelViewProjectionMatrixArray = new Float32Array (16);

         return function (gl, context)
         {
            const
               browser            = context .browser,
               appearanceNode     = context .shapeNode .getAppearance (),
               linePropertiesNode = appearanceNode .getLineProperties (),
               shaderNode         = appearanceNode .shaderNode || browser .getLineShader (),
               blendModeNode      = appearanceNode .blendModeNode,
               attribNodes        = this .attribNodes,
               attribBuffers      = this .attribBuffers;

            if (linePropertiesNode .getApplied () && linePropertiesNode .getLinetype () !== 1)
               this .updateLengthSoFar (gl, context);

            if (linePropertiesNode .getMustTransformLines ())
            {
               const transformShaderNode = browser .getLineTransformShader ();

               if (transformShaderNode .isValid ())
               {
                  const
                     viewport         = context .renderer .getViewVolume () .getViewport (),
                     projectionMatrix = context .renderer .getProjectionMatrix () .get ();

                  modelViewProjectionMatrixArray .set (matrix .assign (context .modelViewMatrix) .multRight (projectionMatrix));
                  invModelViewProjectionMatrixArray .set (matrix .inverse ());

                  // Start

                  transformShaderNode .enable (gl);

                  gl .uniform4f (transformShaderNode .viewport, viewport .x, viewport .y, viewport .z, viewport .w);
                  gl .uniformMatrix4fv (transformShaderNode .modelViewProjectionMatrix,    false, modelViewProjectionMatrixArray);
                  gl .uniformMatrix4fv (transformShaderNode .invModelViewProjectionMatrix, false, invModelViewProjectionMatrixArray);
                  gl .uniform1f (transformShaderNode .scale, linePropertiesNode .getLinewidthScaleFactor () / 2);

                  // Setup vertex attributes.

                  if (this .transformVertexArrayObject .enable (gl, shaderNode))
                  {
                     const
                        fogDepthStride  = 2 * Float32Array .BYTES_PER_ELEMENT,
                        fogDepthOffset0 = 0,
                        fogDepthOffset1 = 1 * Float32Array .BYTES_PER_ELEMENT,
                        colorStride     = 8 * Float32Array .BYTES_PER_ELEMENT,
                        colorOffset0    = 0,
                        colorOffset1    = 4 * Float32Array .BYTES_PER_ELEMENT,
                        texCoordStride  = 8 * Float32Array .BYTES_PER_ELEMENT,
                        texCoordOffset0 = 0,
                        texCoordOffset1 = 4 * Float32Array .BYTES_PER_ELEMENT,
                        vertexStride    = 8 * Float32Array .BYTES_PER_ELEMENT,
                        vertexOffset0   = 0,
                        vertexOffset1   = 4 * Float32Array .BYTES_PER_ELEMENT;

                     // for (let i = 0, length = attribNodes .length; i < length; ++ i)
                     //    attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

                     if (this .fogCoords)
                     {
                        transformShaderNode .enableFloatAttrib (gl, "x3d_FogDepth0", this .fogDepthBuffer, 1, fogDepthStride, fogDepthOffset0);
                        transformShaderNode .enableFloatAttrib (gl, "x3d_FogDepth1", this .fogDepthBuffer, 1, fogDepthStride, fogDepthOffset1);
                     }

                     if (this .colorMaterial)
                     {
                        transformShaderNode .enableFloatAttrib (gl, "x3d_Color0", this .colorBuffer, 4, colorStride, colorOffset0);
                        transformShaderNode .enableFloatAttrib (gl, "x3d_Color1", this .colorBuffer, 4, colorStride, colorOffset1);
                     }

                     transformShaderNode .enableFloatAttrib (gl, "x3d_TexCoord0", this .texCoordBuffers [0], 4, texCoordStride, texCoordOffset0);
                     transformShaderNode .enableFloatAttrib (gl, "x3d_TexCoord1", this .texCoordBuffers [0], 4, texCoordStride, texCoordOffset1);

                     transformShaderNode .enableFloatAttrib (gl, "x3d_Vertex0", this .vertexBuffer, 4, vertexStride, vertexOffset0);
                     transformShaderNode .enableFloatAttrib (gl, "x3d_Vertex1", this .vertexBuffer, 4, vertexStride, vertexOffset1);
                  }

                  // Transform lines.

                  gl .bindTransformFeedback (gl .TRANSFORM_FEEDBACK, browser .getLineTransformFeedback ());
                  gl .bindBufferBase (gl .TRANSFORM_FEEDBACK_BUFFER, 0, this .trianglesBuffer);
                  gl .enable (gl .RASTERIZER_DISCARD);
                  gl .beginTransformFeedback (gl .POINTS);
                  gl .drawArraysInstanced (gl .POINTS, 0, this .vertexCount / 2, 2);
                  gl .endTransformFeedback ();
                  gl .disable (gl .RASTERIZER_DISCARD);
                  gl .bindTransformFeedback (gl .TRANSFORM_FEEDBACK, null);

                  // DEBUG

                  // const data = new Float32Array (13 * 6 * this .vertexCount / 2);
                  // gl .bindBuffer (gl .ARRAY_BUFFER, this .trianglesBuffer);
                  // gl .getBufferSubData (gl .ARRAY_BUFFER, 0, data);
                  // console .log (data);

                  // Render triangles.

                  if (blendModeNode)
                     blendModeNode .enable (gl);

                  // Setup shader.

                  shaderNode .enable (gl);
                  shaderNode .setLocalUniforms (gl, context);

                  // Setup vertex attributes.

                  if (this .thickVertexArrayObject .enable (gl, shaderNode))
                  {
                     const
                        stride         = 13 * Float32Array .BYTES_PER_ELEMENT,
                        fogCoordOffset = 0,
                        colorOffset    = 1 * Float32Array .BYTES_PER_ELEMENT,
                        texCoordOffset = 5 * Float32Array .BYTES_PER_ELEMENT,
                        vertexOffset   = 9 * Float32Array .BYTES_PER_ELEMENT;

                     // for (let i = 0, length = attribNodes .length; i < length; ++ i)
                     //    attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

                     if (this .fogCoords)
                        shaderNode .enableFogDepthAttribute (gl, this .trianglesBuffer, stride, fogCoordOffset);

                     if (this .colorMaterial)
                        shaderNode .enableColorAttribute (gl, this .trianglesBuffer, stride, colorOffset);

                     shaderNode .enableTexCoordAttribute (gl, this .trianglesTexCoordBuffers, stride, texCoordOffset);
                     shaderNode .enableVertexAttribute   (gl, this .trianglesBuffer,          stride, vertexOffset);

                     gl .bindBuffer (gl .ARRAY_BUFFER, null);
                  }

                  gl .frontFace (gl .CCW);
                  gl .enable (gl .CULL_FACE);
                  gl .drawArrays (shaderNode .primitiveMode === gl .POINTS ? gl .POINTS : gl .TRIANGLES, 0, this .vertexCount * 3);

                  if (blendModeNode)
                     blendModeNode .disable (gl);
               }
            }
            else if (shaderNode .isValid ())
            {
               if (blendModeNode)
                  blendModeNode .enable (gl);

               // Setup shader.

               shaderNode .enable (gl);
               shaderNode .setLocalUniforms (gl, context);

               // Setup vertex attributes.

               if (this .vertexArrayObject .enable (gl, shaderNode))
               {
                  for (let i = 0, length = attribNodes .length; i < length; ++ i)
                     attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

                  if (this .fogCoords)
                     shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

                  if (this .colorMaterial)
                     shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

                  shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
                  shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);
               }

               gl .drawArrays (shaderNode .primitiveMode === gl .POINTS ? gl .POINTS : this .primitiveMode, 0, this .vertexCount);

               if (blendModeNode)
                  blendModeNode .disable (gl);
            }
         };
      })(),
      displayParticles: function (gl, context, particleSystem)
      {
         const
            browser        = context .browser,
            appearanceNode = context .shapeNode .getAppearance (),
            shaderNode     = appearanceNode .shaderNode || browser .getLineShader (),
            blendModeNode  = appearanceNode .blendModeNode,
            attribNodes    = this .attribNodes,
            attribBuffers  = this .attribBuffers;

         if (shaderNode .isValid ())
         {
            if (blendModeNode)
               blendModeNode .enable (gl);

            // Setup shader.

            shaderNode .enable (gl);
            shaderNode .setLocalUniforms (gl, context);

            // Setup vertex attributes.

            const outputParticles = particleSystem .outputParticles;

            if (this .updateParticles)
            {
               this .updateParticles = false;

               outputParticles .vertexArrayObject .update ();
            }

            if (outputParticles .vertexArrayObject .enable (gl, shaderNode))
            {
               const particleStride = particleSystem .particleStride;

               shaderNode .enableParticleAttribute (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
               shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset, 1);

               for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

               if (this .fogCoords)
                  shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

               if (this .colorMaterial)
                  shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

               shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, 0, 0);
               shaderNode .enableVertexAttribute   (gl, this .vertexBuffer,    0, 0);
            }

            // Wireframes are always solid so only one drawing call is needed.

            const primitiveMode = shaderNode .primitiveMode === gl .POINTS ? gl .POINTS : this .primitiveMode;

            gl .drawArraysInstanced (primitiveMode, 0, this .vertexCount, particleSystem .numParticles);

            if (blendModeNode)
               blendModeNode .disable (gl);
         }
      },
   });

   return X3DLineGeometryNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedLineSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DLineGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLineGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function IndexedLineSet (executionContext)
   {
      X3DLineGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .IndexedLineSet);

      this .fogCoordNode = null;
      this .colorNode    = null;
      this .coordNode    = null;
   }

   IndexedLineSet .prototype = Object .assign (Object .create (X3DLineGeometryNode .prototype),
   {
      constructor: IndexedLineSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_colorIndex", new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_coordIndex", new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorIndex",     new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "coordIndex",     new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",         new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",          new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "IndexedLineSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DLineGeometryNode .prototype .initialize .call (this);

         this ._set_colorIndex .addFieldInterest (this ._colorIndex);
         this ._set_coordIndex .addFieldInterest (this ._coordIndex);
         this ._attrib         .addInterest ("set_attrib__",   this);
         this ._fogCoord       .addInterest ("set_fogCoord__", this);
         this ._color          .addInterest ("set_color__",    this);
         this ._coord          .addInterest ("set_coord__",    this);

         this .set_attrib__ ();
         this .set_fogCoord__ ();
         this .set_color__ ();
         this .set_coord__ ();
      },
      set_attrib__: function ()
      {
         const attribNodes = this .getAttrib ();

         for (const attribNode of attribNodes)
         {
            attribNode .removeInterest ("requestRebuild", this);
            attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
         }

         attribNodes .length = 0;

         for (const node of this ._attrib)
         {
            const attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, node);

            if (attribNode)
               attribNodes .push (attribNode);
         }

         for (const attribNode of attribNodes)
         {
            attribNode .addInterest ("requestRebuild", this);
            attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
         }

         this .updateVertexArrays ();
      },
      set_fogCoord__: function ()
      {
         if (this .fogCoordNode)
            this .fogCoordNode .removeInterest ("requestRebuild", this);

         this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this ._fogCoord);

         if (this .fogCoordNode)
            this .fogCoordNode .addInterest ("requestRebuild", this);
      },
      set_color__: function ()
      {
         if (this .colorNode)
         {
            this .colorNode .removeInterest ("requestRebuild", this);
            this .colorNode ._transparent .removeInterest ("set_transparent__", this);
         }

         this .colorNode = X3DCast (X3DConstants .X3DColorNode, this ._color);

         if (this .colorNode)
         {
            this .colorNode .addInterest ("requestRebuild", this);
            this .colorNode ._transparent .addInterest ("set_transparent__", this);

            this .set_transparent__ ();
         }
         else
            this .setTransparent (false);
      },
      set_transparent__: function ()
      {
         this .setTransparent (this .colorNode .getTransparent ());
      },
      set_coord__: function ()
      {
         if (this .coordNode)
            this .coordNode .removeInterest ("requestRebuild", this);

         this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this ._coord);

         if (this .coordNode)
            this .coordNode .addInterest ("requestRebuild", this);
      },
      getColorPerVertexIndex: function (index)
      {
         if (index < this ._colorIndex .length)
            return this ._colorIndex [index];

         return this ._coordIndex [index];
      },
      getColorIndex: function (index)
      {
         if (index < this ._colorIndex .length)
            return this ._colorIndex [index];

         return index;
      },
      getPolylineIndices: function ()
      {
         const
            coordIndex = this ._coordIndex,
            polylines  = [ ];

         let polyline = [ ];

         if (coordIndex .length)
         {
            for (let i = 0, length = coordIndex .length; i < length; ++ i)
            {
               const index = coordIndex [i];

               if (index >= 0)
                  // Add vertex.
                  polyline .push (i);

               else
               {
                  // Negativ index.
                  // Add polylines.
                  polylines .push (polyline);

                  polyline = [ ];
               }
            }

            if (coordIndex [coordIndex .length - 1] >= 0)
            {
               polylines .push (polyline);
            }
         }

         return polylines;
      },
      build: function ()
      {
         if (! this .coordNode || this .coordNode .isEmpty ())
            return;

         const
            coordIndex     = this ._coordIndex,
            polylines      = this .getPolylineIndices (),
            colorPerVertex = this ._colorPerVertex .getValue (),
            attribNodes    = this .getAttrib (),
            numAttribNodes = attribNodes .length,
            attribArrays   = this .getAttribs (),
            fogCoordNode   = this .fogCoordNode,
            colorNode      = this .colorNode,
            coordNode      = this .coordNode,
            fogDepthArray  = this .getFogDepths (),
            colorArray     = this .getColors (),
            vertexArray    = this .getVertices ();

         // Fill GeometryNode

         let face = 0;

         for (const polyline of polylines)
         {
            // Create two vertices for each line.

            if (polyline .length > 1)
            {
               for (let line = 0, l_end = polyline .length - 1; line < l_end; ++ line)
               {
                  for (let l = line, i_end = line + 2; l < i_end; ++ l)
                  {
                     const
                        i     = polyline [l],
                        index = coordIndex [i];

                     for (let a = 0; a < numAttribNodes; ++ a)
                        attribNodes [a] .addValue (index, attribArrays [a]);

                     if (fogCoordNode)
                        fogCoordNode .addDepth (index, fogDepthArray);

                     if (colorNode)
                     {
                        if (colorPerVertex)
                           colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
                        else
                           colorNode .addColor (this .getColorIndex (face), colorArray);
                     }

                     coordNode .addPoint (index, vertexArray);
                  }
               }
            }

            ++ face;
         }
      },
   });

   return IndexedLineSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DGeometricPropertyNode',[
   "x_ite/Components/Core/X3DNode",
   "x_ite/Base/X3DConstants",
],
function (X3DNode,
          X3DConstants)
{
"use strict";

   function X3DGeometricPropertyNode (executionContext)
   {
      X3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DGeometricPropertyNode);
   }

   X3DGeometricPropertyNode .prototype = Object .assign (Object .create (X3DNode .prototype),
   {
      constructor: X3DGeometricPropertyNode,
   });

   return X3DGeometricPropertyNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DColorNode',[
   "x_ite/Fields",
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

   function X3DColorNode (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .X3DColorNode);

      this .addChildObjects ("transparent", new Fields .SFBool ());

      this ._transparent .setAccessType (X3DConstants .outputOnly);
   }

   X3DColorNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: X3DColorNode,
      initialize: function ()
      {
         X3DGeometricPropertyNode .prototype .initialize .call (this);

         this ._color .addInterest ("set_color__", this);

         this .set_color__ ();
      },
      set_color__: function ()
      {
         this .color  = this ._color .getValue ();
         this .length = this ._color .length;
      },
      setTransparent: function (value)
      {
         if (value !== this ._transparent .getValue ())
            this ._transparent = value;
      },
      getTransparent: function ()
      {
         return this ._transparent .getValue ();
      },
   });

   return X3DColorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Rendering/Color',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DColorNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DColorNode,
          X3DConstants)
{
"use strict";

   function Color (executionContext)
   {
      X3DColorNode .call (this, executionContext);

      this .addType (X3DConstants .Color);
   }

   Color .prototype = Object .assign (Object .create (X3DColorNode .prototype),
   {
      constructor: Color,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .MFColor ()),
      ]),
      getTypeName: function ()
      {
         return "Color";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "color";
      },
      addColor: function (index, array)
      {
         if (index >= 0 && index < this .length)
         {
            const color = this .color;

            index *= 3;

            array .push (color [index], color [index + 1], color [index + 2], 1);
         }
         else if (this .length)
         {
            const color = this .color;

            index = (this .length - 1) * 3;

            array .push (color [index], color [index + 1], color [index + 2], 1);
         }
         else
         {
            array .push (1, 1, 1, 1);
         }
      },
      addColors: function (array, min)
      {
         if (this .length)
         {
            const color = this .color;

            for (var index = 0, length = Math .min (min, this .length) * 3; index < length; index += 3)
               array .push (color [index], color [index + 1], color [index + 2], 1);

            if (this .length < min)
            {
               var index = (this .length - 1) * 3;

               const
                  r = color [index],
                  g = color [index + 1],
                  b = color [index + 2];

               for (var index = length, length = min * 3; index < length; index += 3)
                  array .push (r, g, b, 1);
            }
         }
         else
         {
            for (let index = 0; index < min; ++ index)
               array .push (1, 1, 1, 1);
         }

         return array;
      },
   });

   return Color;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DCoordinateNode',[
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Numbers/Vector3",
],
function (X3DGeometricPropertyNode,
          X3DConstants,
          Triangle3,
          Vector3)
{
"use strict";

   function X3DCoordinateNode (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .X3DCoordinateNode);
   }

   X3DCoordinateNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: X3DCoordinateNode,
      initialize: function ()
      {
         X3DGeometricPropertyNode .prototype .initialize .call (this);

         this ._point .addInterest ("set_point__", this);

         this .set_point__ ();
      },
      set_point__: function ()
      {
         this .point  = this ._point .getValue ();
         this .length = this ._point .length;
      },
      isEmpty: function ()
      {
         return this .length === 0;
      },
      getSize: function ()
      {
         return this .length;
      },
      set1Point: function (index, point)
      {
         this ._point [index] = point;
      },
      get1Point: function (index, result)
      {
         if (index < this .length)
         {
            const point = this .point;

            index *= 3;

            return result .set (point [index], point [index + 1], point [index + 2]);
         }
         else
         {
            return result .set (0, 0, 0);
         }
      },
      addPoint: function (index, array)
      {
         if (index < this .length)
         {
            const point = this .point;

            index *= 3;

            array .push (point [index], point [index + 1], point [index + 2], 1);
         }
         else
         {
            array .push (0, 0, 0, 1);
         }
      },
      addPoints: function (array, min)
      {
         const point = this .point;

         for (var index = 0, length = this .length * 3; index < length; index += 3)
            array .push (point [index], point [index + 1], point [index + 2], 1);

         for (var index = length, length = min * 3; index < length; index += 3)
            array .push (0, 0, 0, 1);
      },
      getNormal: (function ()
      {
         const
            point1 = new Vector3 (0, 0, 0),
            point2 = new Vector3 (0, 0, 0),
            point3 = new Vector3 (0, 0, 0);

         return function (index1, index2, index3)
         {
            // The index[1,2,3] cannot be less than 0.

            const length = this .length;

            if (index1 < length && index2 < length && index3 < length)
            {
               return Triangle3 .normal (this .get1Point (index1, point1),
                                         this .get1Point (index2, point2),
                                         this .get1Point (index3, point3),
                                         new Vector3 (0, 0, 0));
            }

            return new Vector3 (0, 0, 0);
         };
      })(),
      getQuadNormal: (function ()
      {
         const
            point1 = new Vector3 (0, 0, 0),
            point2 = new Vector3 (0, 0, 0),
            point3 = new Vector3 (0, 0, 0),
            point4 = new Vector3 (0, 0, 0);

         return function (index1, index2, index3, index4)
         {
            // The index[1,2,3,4] cannot be less than 0.

            const length = this .length;

            if (index1 < length && index2 < length && index3 < length && index4 < length)
            {
               return Triangle3 .quadNormal (this .get1Point (index1, point1),
                                             this .get1Point (index2, point2),
                                             this .get1Point (index3, point3),
                                             this .get1Point (index4, point4),
                                             new Vector3 (0, 0, 0));
            }

            return new Vector3 (0, 0, 0);
         };
      })(),
   });

   return X3DCoordinateNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/Coordinate',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DCoordinateNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DCoordinateNode,
          X3DConstants)
{
"use strict";

   function Coordinate (executionContext)
   {
      X3DCoordinateNode .call (this, executionContext);

      this .addType (X3DConstants .Coordinate);

      this ._point .setUnit ("length");
   }

   Coordinate .prototype = Object .assign (Object .create (X3DCoordinateNode .prototype),
   {
      constructor: Coordinate,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "point",    new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "Coordinate";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "coord";
      },
   });

   return Coordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Grouping/X3DGroupingContext',[
   "x_ite/Fields",
   "x_ite/Components/Shape/Shape",
   "x_ite/Components/Rendering/IndexedLineSet",
   "x_ite/Components/Rendering/Color",
   "x_ite/Components/Rendering/Coordinate",
],
function (Fields,
          Shape,
          IndexedLineSet,
          Color,
          Coordinate)
{
"use strict";

   const _bboxNode = Symbol ();

   function X3DGroupingContext () { }

   X3DGroupingContext .prototype =
   {
      initialize: function () { },
      getBBoxNode: function ()
      {
         const
            bboxNode       = new Shape (this .getPrivateScene ()),
            bboxGeometry   = new IndexedLineSet (this .getPrivateScene ()),
            bboxColor      = new Color (this .getPrivateScene ()),
            bboxCoordinate = new Coordinate (this .getPrivateScene ());

         bboxNode ._geometry       = bboxGeometry;
         bboxGeometry ._coordIndex = new Fields .MFFloat (0, 1, 2, 3, 0, -1, 4, 5, 6, 7, 4, -1, 0, 4, -1, 1, 5, -1, 2, 6, -1, 3, 7, -1);
         bboxGeometry ._color      = bboxColor;
         bboxGeometry ._coord      = bboxCoordinate;
         bboxColor ._color         = new Fields .MFColor (new Fields .SFColor (1, 1, 1));
         bboxCoordinate ._point    = new Fields .MFVec3f (new Fields .SFVec3f (0.5, 0.5, 0.5), new Fields .SFVec3f (-0.5, 0.5, 0.5), new Fields .SFVec3f (-0.5, -0.5, 0.5), new Fields .SFVec3f (0.5, -0.5, 0.5), new Fields .SFVec3f (0.5, 0.5, -0.5), new Fields .SFVec3f (-0.5, 0.5, -0.5), new Fields .SFVec3f (-0.5, -0.5, -0.5), new Fields .SFVec3f (0.5, -0.5, -0.5));

         bboxCoordinate .setup ();
         bboxColor      .setup ();
         bboxGeometry   .setup ();
         bboxNode       .setup ();

         this [_bboxNode] = bboxNode;

         this .getBBoxNode = function () { return this [_bboxNode]; };

         Object .defineProperty (this, "getBBoxNode", { enumerable: false });

         return bboxNode;
      }
   };

   return X3DGroupingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DComposedGeometryNode',[
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (X3DGeometryNode,
          X3DCast,
          X3DConstants,
          Vector3)
{
"use strict";

   function X3DComposedGeometryNode (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .X3DComposedGeometryNode);

      this .fogCoordNode = null;
      this .colorNode    = null;
      this .texCoordNode = null;
      this .normalNode   = null;
      this .coordNode    = null;
   }

   X3DComposedGeometryNode .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: X3DComposedGeometryNode,
      initialize: function ()
      {
         X3DGeometryNode .prototype .initialize .call (this);

         this ._attrib   .addInterest ("set_attrib__",   this);
         this ._fogCoord .addInterest ("set_fogCoord__", this);
         this ._color    .addInterest ("set_color__",    this);
         this ._texCoord .addInterest ("set_texCoord__", this);
         this ._normal   .addInterest ("set_normal__",   this);
         this ._coord    .addInterest ("set_coord__",    this);

         this .set_attrib__ ();
         this .set_fogCoord__ ();
         this .set_color__ ();
         this .set_texCoord__ ();
         this .set_normal__ ();
         this .set_coord__ ();
      },
      getFogCoord: function ()
      {
         return this .fogCoordNode;
      },
      getColor: function ()
      {
         return this .colorNode;
      },
      getTexCoord: function ()
      {
         return this .texCoordNode;
      },
      getNormal: function ()
      {
         return this .normalNode;
      },
      getCoord: function ()
      {
         return this .coordNode;
      },
      set_attrib__: function ()
      {
         const attribNodes = this .getAttrib ();

         for (const attribNode of attribNodes)
         {
            attribNode .removeInterest ("requestRebuild", this);
            attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
         }

         attribNodes .length = 0;

         for (const node of this ._attrib)
         {
            const attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, node);

            if (attribNode)
               attribNodes .push (attribNode);
         }

         for (const attribNode of attribNodes)
         {
            attribNode .addInterest ("requestRebuild", this);
            attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
         }

         this .updateVertexArrays ();
      },
      set_fogCoord__: function ()
      {
         if (this .fogCoordNode)
            this .fogCoordNode .removeInterest ("requestRebuild", this);

         this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this ._fogCoord);

         if (this .fogCoordNode)
            this .fogCoordNode .addInterest ("requestRebuild", this);
      },
      set_color__: function ()
      {
         if (this .colorNode)
         {
            this .colorNode .removeInterest ("requestRebuild", this);
            this .colorNode ._transparent .removeInterest ("set_transparent__", this);
         }

         this .colorNode = X3DCast (X3DConstants .X3DColorNode, this ._color);

         if (this .colorNode)
         {
            this .colorNode .addInterest ("requestRebuild", this);
            this .colorNode ._transparent .addInterest ("set_transparent__", this);

            this .set_transparent__ ();
         }
         else
            this .setTransparent (false);
      },
      set_transparent__: function ()
      {
         this .setTransparent (this .colorNode .getTransparent ());
      },
      set_texCoord__: function ()
      {
         if (this .texCoordNode)
            this .texCoordNode .removeInterest ("requestRebuild", this);

         this .texCoordNode = X3DCast (X3DConstants .X3DTextureCoordinateNode, this ._texCoord);

         if (this .texCoordNode)
            this .texCoordNode .addInterest ("requestRebuild", this);

         this .setTextureCoordinate (this .texCoordNode);
      },
      set_normal__: function ()
      {
         if (this .normalNode)
            this .normalNode .removeInterest ("requestRebuild", this);

         this .normalNode = X3DCast (X3DConstants .X3DNormalNode, this ._normal);

         if (this .normalNode)
            this .normalNode .addInterest ("requestRebuild", this);
      },
      set_coord__: function ()
      {
         if (this .coordNode)
            this .coordNode .removeInterest ("requestRebuild", this);

         this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this ._coord);

         if (this .coordNode)
            this .coordNode .addInterest ("requestRebuild", this);
      },
      getPolygonIndex: function (index)
      {
         return index;
      },
      getTriangleIndex: function (index)
      {
         return index;
      },
      build: function (verticesPerPolygon, polygonsSize, verticesPerFace, trianglesSize)
      {
         if (!this .coordNode || this .coordNode .isEmpty ())
            return;

         // Set size to a multiple of verticesPerPolygon.

         polygonsSize  -= polygonsSize % verticesPerPolygon;
         trianglesSize -= trianglesSize % verticesPerFace;

         const
            colorPerVertex     = this ._colorPerVertex .getValue (),
            normalPerVertex    = this ._normalPerVertex .getValue (),
            attribNodes        = this .getAttrib (),
            numAttribNodes     = attribNodes .length,
            attribArrays       = this .getAttribs (),
            fogCoordNode       = this .getFogCoord (),
            colorNode          = this .getColor (),
            texCoordNode       = this .getTexCoord (),
            normalNode         = this .getNormal (),
            coordNode          = this .getCoord (),
            fogDepthArray      = this .getFogDepths (),
            colorArray         = this .getColors (),
            multiTexCoordArray = this .getMultiTexCoords (),
            normalArray        = this .getNormals (),
            vertexArray        = this .getVertices ();

         if (texCoordNode)
            texCoordNode .init (multiTexCoordArray);

         // Fill GeometryNode

         for (let i = 0; i < trianglesSize; ++ i)
         {
            const
               face  = Math .floor (i / verticesPerFace),
               index = this .getPolygonIndex (this .getTriangleIndex (i));

            for (let a = 0; a < numAttribNodes; ++ a)
               attribNodes [a] .addValue (index, attribArrays [a]);

            if (fogCoordNode)
               fogCoordNode .addDepth (index, fogDepthArray);

            if (colorNode)
            {
               if (colorPerVertex)
                  colorNode .addColor (index, colorArray);
               else
                  colorNode .addColor (face, colorArray);
            }

            if (texCoordNode)
               texCoordNode .addTexCoord (index, multiTexCoordArray);

            if (normalNode)
            {
               if (normalPerVertex)
                  normalNode .addVector (index, normalArray);
               else
                  normalNode .addVector (face, normalArray);
            }

            coordNode .addPoint (index, vertexArray);
         }

         // Autogenerate normal if not specified.

         if (!this .getNormal ())
            this .buildNormals (verticesPerPolygon, polygonsSize, trianglesSize);

         this .setSolid (this ._solid .getValue ());
         this .setCCW (this ._ccw .getValue ());
      },
      buildNormals: function (verticesPerPolygon, polygonsSize, trianglesSize)
      {
         const
            normals     = this .createNormals (verticesPerPolygon, polygonsSize),
            normalArray = this .getNormals ();

         for (let i = 0; i < trianglesSize; ++ i)
         {
            const normal = normals [this .getTriangleIndex (i)];

            normalArray .push (normal .x, normal .y, normal .z);
         }
      },
      createNormals: function (verticesPerPolygon, polygonsSize)
      {
         const normals = this .createFaceNormals (verticesPerPolygon, polygonsSize);

         if (this ._normalPerVertex .getValue ())
         {
            const normalIndex = [ ];

            for (let i = 0; i < polygonsSize; ++ i)
            {
               const index = this .getPolygonIndex (i);

               let pointIndex = normalIndex [index];

               if (!pointIndex)
                  pointIndex = normalIndex [index] = [ ];

               pointIndex .push (i);
            }

            return this .refineNormals (normalIndex, normals, Math .PI);
         }

         return normals;
      },
      createFaceNormals: function (verticesPerPolygon, polygonsSize)
      {
         const
            cw      = !this ._ccw .getValue (),
            coord   = this .coordNode,
            normals = [ ];

         for (let i = 0; i < polygonsSize; i += verticesPerPolygon)
         {
            const normal = this .getPolygonNormal (i, verticesPerPolygon, coord);

            if (cw)
               normal .negate ();

            for (let n = 0; n < verticesPerPolygon; ++ n)
               normals .push (normal);
         }

         return normals;
      },
      getPolygonNormal: (function ()
      {
         let
            current = new Vector3 (0, 0, 0),
            next    = new Vector3 (0, 0, 0);

         return function (index, verticesPerPolygon, coord)
         {
            // Determine polygon normal.
            // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

            const normal = new Vector3 (0, 0, 0);

            coord .get1Point (this .getPolygonIndex (index), next);

            for (let i = 0; i < verticesPerPolygon; ++ i)
            {
               const tmp = current;
               current = next;
               next    = tmp;

               coord .get1Point (this .getPolygonIndex (index + (i + 1) % verticesPerPolygon), next);

               normal .x += (current .y - next .y) * (current .z + next .z);
               normal .y += (current .z - next .z) * (current .x + next .x);
               normal .z += (current .x - next .x) * (current .y + next .y);
            }

            return normal .normalize ();
         };
      })(),
   });

   return X3DComposedGeometryNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/IndexedFaceSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Triangle3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants,
          Vector3,
          Matrix4,
          Triangle3)
{
"use strict";

   function IndexedFaceSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .IndexedFaceSet);

      this ._creaseAngle .setUnit ("angle");
   }

   IndexedFaceSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: IndexedFaceSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_colorIndex",    new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_texCoordIndex", new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_normalIndex",   new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_coordIndex",    new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",               new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "convex",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",       new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",    new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex",   new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorIndex",        new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "texCoordIndex",     new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalIndex",       new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "coordIndex",        new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",            new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",             new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "IndexedFaceSet";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._set_colorIndex    .addFieldInterest (this ._colorIndex);
         this ._set_texCoordIndex .addFieldInterest (this ._texCoordIndex);
         this ._set_normalIndex   .addFieldInterest (this ._normalIndex);
         this ._set_coordIndex    .addFieldInterest (this ._coordIndex);
      },
      getTexCoordPerVertexIndex: function (index)
      {
         if (index < this ._texCoordIndex .length)
            return this ._texCoordIndex [index];

         return this ._coordIndex [index];
      },
      getColorPerVertexIndex: function (index)
      {
         if (index < this ._colorIndex .length)
            return this ._colorIndex [index];

         return this ._coordIndex [index];
      },
      getColorIndex: function (index)
      {
         if (index < this ._colorIndex .length)
            return this ._colorIndex [index];

         return index;
      },
      getNormalPerVertexIndex: function (index)
      {
         if (index < this ._normalIndex .length)
            return this ._normalIndex [index];

         return this ._coordIndex [index];
      },
      getNormalIndex: function (index)
      {
         if (index < this ._normalIndex .length)
            return this ._normalIndex [index];

         return index;
      },
      build: function ()
      {
         // Triangulate

         const polygons = this .triangulate ();

         // Build arrays

         if (polygons .length === 0)
            return;

         // Fill GeometryNode

         const
            colorPerVertex     = this ._colorPerVertex .getValue (),
            normalPerVertex    = this ._normalPerVertex .getValue (),
            coordIndex         = this ._coordIndex .getValue (),
            attribNodes        = this .getAttrib (),
            numAttribNodes     = attribNodes .length,
            attribArrays       = this .getAttribs (),
            fogCoordNode       = this .getFogCoord (),
            colorNode          = this .getColor (),
            texCoordNode       = this .getTexCoord (),
            normalNode         = this .getNormal (),
            coordNode          = this .getCoord (),
            fogDepthArray      = this .getFogDepths (),
            colorArray         = this .getColors (),
            multiTexCoordArray = this .getMultiTexCoords (),
            normalArray        = this .getNormals (),
            vertexArray        = this .getVertices ();

         if (texCoordNode)
            texCoordNode .init (multiTexCoordArray);

         for (const polygon of polygons)
         {
            const
               triangles = polygon .triangles,
               face      = polygon .face;

            for (const i of triangles)
            {
               const index = coordIndex [i];

               for (let a = 0; a < numAttribNodes; ++ a)
                  attribNodes [a] .addValue (index, attribArrays [a]);

               if (fogCoordNode)
                  fogCoordNode .addDepth (index, fogDepthArray);

               if (colorNode)
               {
                  if (colorPerVertex)
                     colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
                  else
                     colorNode .addColor (this .getColorIndex (face), colorArray);
               }

               if (texCoordNode)
                  texCoordNode .addTexCoord (this .getTexCoordPerVertexIndex (i), multiTexCoordArray);

               if (normalNode)
               {
                  if (normalPerVertex)
                     normalNode .addVector (this .getNormalPerVertexIndex (i), normalArray);

                  else
                     normalNode .addVector (this .getNormalIndex (face), normalArray);
               }

               coordNode .addPoint (index, vertexArray);
            }
         }

         // Autogenerate normal if not specified.

         if (!this .getNormal ())
            this .buildNormals (polygons);

         this .setSolid (this ._solid .getValue ());
         this .setCCW (this ._ccw .getValue ());
      },
      triangulate: function ()
      {
         const
            convex      = this ._convex .getValue (),
            coordLength = this ._coordIndex .length,
            polygons    = [ ];

         if (!this .getCoord ())
            return polygons;

         // Add -1 (polygon end marker) to coordIndex if not present.
         if (coordLength && this ._coordIndex [coordLength - 1] > -1)
            this ._coordIndex .push (-1);

         if (coordLength)
         {
            const
               coordIndex  = this ._coordIndex .getValue (),
               coordLength = this ._coordIndex .length;

            // Construct triangle array and determine the number of used points.

            let vertices = [ ];

            for (let i = 0, face = 0; i < coordLength; ++ i)
            {
               const index = coordIndex [i];

               if (index > -1)
               {
                  // Add vertex index.
                  vertices .push (i);
               }
               else
               {
                  // Negativ index.

                  if (vertices .length)
                  {
                     // Closed polygon.
                     //if (coordIndex [vertices [0]] === coordIndex [vertices [vertices .length - 1]])
                     //	vertices .pop ();

                     switch (vertices .length)
                     {
                        case 0:
                        case 1:
                        case 2:
                        {
                           vertices .length = 0;
                           break;
                        }
                        case 3:
                        {
                           // Add polygon with one triangle.
                           polygons .push ({ vertices: vertices, triangles: vertices, face: face });
                           vertices = [ ];
                           break;
                        }
                        default:
                        {
                           // Triangulate polygons.
                           const
                              triangles = [ ],
                              polygon   = { vertices: vertices, triangles: triangles, face: face };

                           if (convex)
                              this .triangulateConvexPolygon (vertices, triangles);
                           else
                              this .triangulatePolygon (vertices, triangles);

                           if (triangles .length < 3)
                           {
                              vertices .length = 0;
                           }
                           else
                           {
                              polygons .push (polygon);
                              vertices = [ ];
                           }

                           break;
                        }
                     }
                  }

                  ++ face;
               }
            }
         }

         return polygons;
      },
      triangulatePolygon: (function ()
      {
         const polygon = [ ];

         return function (vertices, triangles)
         {
            const
               coordIndex = this ._coordIndex .getValue (),
               coord      = this .getCoord (),
               length     = vertices .length;

            for (let v = 0; v < length; ++ v)
            {
               const i = vertices [v];

               let vertex = polygon [v];

               if (!vertex)
                  vertex = polygon [v] = new Vector3 (0, 0, 0);

               vertex .index = i;

               coord .get1Point (coordIndex [i], vertex);
            }

            polygon .length = length;

            Triangle3 .triangulatePolygon (polygon, triangles);

            for (let i = 0, length = triangles .length; i < length; ++ i)
               triangles [i] = triangles [i] .index;
         };
      })(),
      triangulateConvexPolygon: function (vertices, triangles)
      {
         // Fallback: Very simple triangulation for convex polygons.
         for (let i = 1, length = vertices .length - 1; i < length; ++ i)
            triangles .push (vertices [0], vertices [i], vertices [i + 1]);
      },
      buildNormals: function (polygons)
      {
         const
            normals     = this .createNormals (polygons),
            normalArray = this .getNormals ();

         for (const polygon of polygons)
         {
            for (const triangle of polygon .triangles)
            {
               const normal = normals [triangle];

               normalArray .push (normal .x, normal .y, normal .z);
            }
         }
      },
      createNormals: (function ()
      {
         const
            normals     = [ ],
            normalIndex = [ ];

         return function (polygons)
         {
            const
               cw          = ! this ._ccw .getValue (),
               coordIndex  = this ._coordIndex .getValue (),
               coord       = this .getCoord ();

            normals     .length = 0;
            normalIndex .length = 0;

            for (const polygon of polygons)
            {
               const
                  vertices = polygon .vertices,
                  length   = vertices .length;

               switch (length)
               {
                  case 3:
                  {
                     var normal = coord .getNormal (coordIndex [vertices [0]],
                                                    coordIndex [vertices [1]],
                                                    coordIndex [vertices [2]]);
                     break;
                  }
                  case 4:
                  {
                     var normal = coord .getQuadNormal (coordIndex [vertices [0]],
                                                        coordIndex [vertices [1]],
                                                        coordIndex [vertices [2]],
                                                        coordIndex [vertices [3]]);
                     break;
                  }
                  default:
                  {
                     var normal = this .getPolygonNormal (vertices, coordIndex, coord);
                     break;
                  }
               }

               // Add a normal index for each point.

               for (let i = 0; i < length; ++ i)
               {
                  const
                     index = vertices [i],
                     point = coordIndex [index];

                  let pointNormals = normalIndex [point];

                  if (!pointNormals)
                     pointNormals = normalIndex [point] = [ ];

                  pointNormals .push (index);
               }

               if (cw)
                  normal .negate ();

               // Add this normal for each vertex.

               for (let i = 0; i < length; ++ i)
                  normals [vertices [i]] = normal;
            }

            return this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());
         };
      })(),
      getPolygonNormal: (function ()
      {
         let
            current = new Vector3 (0, 0, 0),
            next    = new Vector3 (0, 0, 0);

         return function (vertices, coordIndex, coord)
         {
            // Determine polygon normal.
            // We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

            const normal = new Vector3 (0, 0, 0);

            coord .get1Point (coordIndex [vertices [0]], next);

            for (let i = 0, length = vertices .length; i < length; ++ i)
            {
               const tmp = current;
               current = next;
               next    = tmp;

               coord .get1Point (coordIndex [vertices [(i + 1) % length]], next);

               normal .x += (current .y - next .y) * (current .z + next .z);
               normal .y += (current .z - next .z) * (current .x + next .x);
               normal .z += (current .x - next .x) * (current .y + next .y);
            }

            return normal .normalize ();
         };
      })(),
   });

   return IndexedFaceSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureCoordinateNode',[
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
],
function (X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

   function X3DTextureCoordinateNode (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTextureCoordinateNode);
   }

   X3DTextureCoordinateNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: X3DTextureCoordinateNode,
      setShaderUniformsToChannel: function (gl, shaderObject, i)
      {
         gl .uniform1i (shaderObject .x3d_TextureCoordinateGeneratorMode [i], 0);
      },
   });

   return X3DTextureCoordinateNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Texturing/X3DSingleTextureCoordinateNode',[
   "x_ite/Components/Texturing/X3DTextureCoordinateNode",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (X3DTextureCoordinateNode,
          X3DGeometryNode,
          X3DConstants)
{
"use strict";

   function X3DSingleTextureCoordinateNode (executionContext)
   {
      X3DTextureCoordinateNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSingleTextureCoordinateNode);

      this .texCoordArray = X3DGeometryNode .createArray ();
   }

   X3DSingleTextureCoordinateNode .prototype = Object .assign (Object .create (X3DTextureCoordinateNode .prototype),
   {
      constructor: X3DSingleTextureCoordinateNode,
      initialize: function ()
      {
         X3DTextureCoordinateNode .prototype .initialize .call (this);

         if (this ._point)
         {
            this ._point .addInterest ("set_point__", this);

            this .set_point__ ();
         }
      },
      set_point__: function ()
      {
         this .point  = this ._point .getValue ();
         this .length = this ._point .length;
      },
      isEmpty: function ()
      {
         return this .length === 0;
      },
      getSize: function ()
      {
         return this .length;
      },
      init: function (multiArray)
      {
         this .texCoordArray .length = 0;

         multiArray .push (this .texCoordArray);
      },
      addTexCoord: function (index, multiArray)
      {
         this .addTexCoordToChannel (index, multiArray [0]);
      },
      getTextureMapping: function (textureCoordinateMapping, channel = 0)
      {
         if (this ._mapping .getValue ())
            textureCoordinateMapping .set (this ._mapping .getValue (), channel);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         for (let i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
            this .setShaderUniformsToChannel (gl, shaderObject, i);
      },
   });

   return X3DSingleTextureCoordinateNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureCoordinate',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DSingleTextureCoordinateNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSingleTextureCoordinateNode,
          X3DConstants,
          Vector4)
{
"use strict";

   function TextureCoordinate (executionContext)
   {
      X3DSingleTextureCoordinateNode .call (this, executionContext);

      this .addType (X3DConstants .TextureCoordinate);
   }

   TextureCoordinate .prototype = Object .assign (Object .create (X3DSingleTextureCoordinateNode .prototype),
   {
      constructor: TextureCoordinate,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "mapping",  new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "point",    new Fields .MFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "TextureCoordinate";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texCoord";
      },
      get1Point: function (index, vector)
      {
         if (index >= 0 && index < this .length)
         {
            const point = this .point;

            index *= 2;

            return vector .set (point [index], point [index + 1], 0, 1);
         }
         else if (index >= 0 && this .length)
         {
            const point = this .point;

            index %= this .length;
            index *= 2;

            return vector .set (point [index], point [index + 1], 0, 1);
         }
         else
         {
            return vector .set (0, 0, 0, 1);
         }
      },
      addTexCoordToChannel: function (index, array)
      {
         if (index >= 0 && index < this .length)
         {
            const point = this .point;

            index *= 2;

            array .push (point [index], point [index + 1], 0, 1);
         }
         else if (index >= 0 && this .length)
         {
            const point = this .point;

            index %= this .length;
            index *= 2;

            array .push (point [index], point [index + 1], 0, 1);
         }
         else
         {
            array .push (0, 0, 0, 1);
         }
      },
      getTexCoord: function (array)
      {
         const
            point  = this .point,
            length = this .length;

         for (let i = 0, p = 0; i < length; ++ i, p += 2)
            array .push (point [p], point [p + 1], 0, 1);

         return array;
      },
   });

   return TextureCoordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/BoxOptions',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Geometry3D/IndexedFaceSet",
   "x_ite/Components/Rendering/Coordinate",
   "x_ite/Components/Texturing/TextureCoordinate",
],
function (Fields,
          X3DBaseNode,
          IndexedFaceSet,
          Coordinate,
          TextureCoordinate)
{
"use strict";

   function BoxOptions (executionContext)
   {
      X3DBaseNode .call (this, executionContext);
   }

   BoxOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: BoxOptions,
      getTypeName: function ()
      {
         return "BoxOptions";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "boxOptions";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);
      },
      getGeometry: function ()
      {
         if (this .geometry)
            return this .geometry;

         this .geometry            = new IndexedFaceSet (this .getExecutionContext ());
         this .geometry ._texCoord = new TextureCoordinate (this .getExecutionContext ());
         this .geometry ._coord    = new Coordinate (this .getExecutionContext ());

         const
            geometry = this .geometry,
            texCoord = this .geometry ._texCoord .getValue (),
            coord    = this .geometry ._coord .getValue ();

         geometry ._texCoordIndex = new Fields .MFInt32 (
            0, 1, 2, 3, -1, // front
            0, 1, 2, 3, -1, // back
            0, 1, 2, 3, -1, // left
            0, 1, 2, 3, -1, // right
            0, 1, 2, 3, -1, // top
            0, 1, 2, 3, -1  // bottom
         );

         geometry ._coordIndex = new Fields .MFInt32 (
            0, 1, 2, 3, -1, // front
            5, 4, 7, 6, -1, // back
            1, 5, 6, 2, -1, // left
            4, 0, 3, 7, -1, // right
            4, 5, 1, 0, -1, // top
            3, 2, 6, 7, -1  // bottom
         );

         texCoord ._point = new Fields .MFVec2f (
            new Fields .SFVec2f (1, 1), new Fields .SFVec2f (0, 1), new Fields .SFVec2f (0, 0), new Fields .SFVec2f (1, 0)
         );

         coord ._point = new Fields .MFVec3f (
            new Fields .SFVec3f ( 1,  1,  1), new Fields .SFVec3f (-1,  1,  1), new Fields .SFVec3f (-1, -1,  1), new Fields .SFVec3f ( 1, -1,  1),
            new Fields .SFVec3f ( 1,  1, -1), new Fields .SFVec3f (-1,  1, -1), new Fields .SFVec3f (-1, -1, -1), new Fields .SFVec3f ( 1, -1, -1)
         );

         texCoord .setup ();
         coord    .setup ();
         geometry .setup ();

         return this .geometry;
      },
   });

   return BoxOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/ConeOptions',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
],
function (Fields,
          X3DBaseNode)
{
"use strict";

   function ConeOptions (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addChildObjects ("xDimension", new Fields .SFInt32 (20),
                             "yDimension", new Fields .SFInt32 (1))
   }

   ConeOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: ConeOptions,
      getTypeName: function ()
      {
         return "ConeOptions";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "coneOptions";
      },
   });

   return ConeOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/CylinderOptions',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
],
function (Fields,
          X3DBaseNode)
{
"use strict";

   function CylinderOptions (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addChildObjects ("xDimension", new Fields .SFInt32 (20),
                             "yDimension", new Fields .SFInt32 (1))
   }

   CylinderOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: CylinderOptions,
      getTypeName: function ()
      {
         return "CylinderOptions";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "cylinderOptions";
      },
   });

   return CylinderOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/QuadSphereOptions',[
   "x_ite/Fields",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Geometry3D/IndexedFaceSet",
   "x_ite/Components/Rendering/Coordinate",
   "x_ite/Components/Texturing/TextureCoordinate",
   "standard/Math/Numbers/Complex",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DBaseNode,
          IndexedFaceSet,
          Coordinate,
          TextureCoordinate,
          Complex,
          Vector2,
          Vector3)
{
"use strict";

   function QuadSphereOptions (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .addChildObjects ("xDimension", new Fields .SFInt32 (32),
                             "yDimension", new Fields .SFInt32 (15))
   }

   QuadSphereOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: QuadSphereOptions,
      getTypeName: function ()
      {
         return "QuadSphereOptions";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "quadSphereOptions";
      },
      initialize: function ()
      {
         X3DBaseNode .prototype .initialize .call (this);

         this .addInterest ("eventsProcessed", this);
      },
      getGeometry: function ()
      {
         if (! this .geometry)
            this .eventsProcessed ();

         return this .geometry;
      },
      createTexCoordIndex: function ()
      {
         const
            xDimension    = this ._xDimension .getValue () + 1,
            yDimension    = this ._yDimension .getValue (),
            texCoordIndex = this .geometry ._texCoordIndex;

         // North pole

         for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u)
         {
            texCoordIndex .push (u);
            texCoordIndex .push (u + xDimension - 1);
            texCoordIndex .push (u + xDimension);
            texCoordIndex .push (-1);
         }

         // Sphere segments

         for (let p = xDimension - 1, v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
         {
            for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
            {
               texCoordIndex .push (p);
               texCoordIndex .push (p + xDimension);
               texCoordIndex .push (p + xDimension + 1);
               texCoordIndex .push (p + 1);
               texCoordIndex .push (-1);
            }
         }

         // South pole

         let p = (yDimension - 2) * xDimension - 1;

         for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
         {
            texCoordIndex .push (p + xDimension);
            texCoordIndex .push (p + 1);
            texCoordIndex .push (p);
            texCoordIndex .push (-1);
         }
      },
      createTexCoord: function ()
      {
         const
            xDimension = this ._xDimension .getValue () + 1,
            yDimension = this ._yDimension .getValue (),
            point      = this .geometry ._texCoord .getValue () ._point;

         const poleOffset = -0.5 / (xDimension - 1);

         // North pole

         for (let u = 1; u < xDimension; ++ u)
         {
            const x = u / (xDimension - 1) + poleOffset;

            point .push (new Vector2 (x, 1));
         }

         // Sphere segments

         for (let v = 1, vLength = yDimension - 1; v < vLength; ++ v)
         {
            const y = 1 - v / (yDimension - 1);

            for (let u = 0; u < xDimension; ++ u)
            {
               const x = u / (xDimension - 1);

               point .push (new Vector2 (x, y));
            }
         }

         // South pole

         for (let u = 1; u < xDimension; ++ u)
         {
            const x = u / (xDimension - 1) + poleOffset;

            point .push (new Vector2 (x, 0));
         }
      },
      createCoordIndex: function ()
      {
         const
            xDimension = this ._xDimension .getValue () + 1,
            yDimension = this ._yDimension .getValue (),
            coordIndex = this .geometry ._coordIndex;

         // North pole

         let u = 1;

         for (const uLength = xDimension - 1; u < uLength; ++ u)
         {
            coordIndex .push (0);
            coordIndex .push (u);
            coordIndex .push (u + 1);
            coordIndex .push (-1);
         }

         coordIndex .push (0);
         coordIndex .push (u);
         coordIndex .push (1);
         coordIndex .push (-1);

         // Sphere segments

         let p = 1;

         for (let v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
         {
            for (let u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
            {
               coordIndex .push (p);
               coordIndex .push (p + xDimension - 1);
               coordIndex .push (p + xDimension);
               coordIndex .push (p + 1);
               coordIndex .push (-1);
            }

            coordIndex .push (p);
            coordIndex .push (p + xDimension - 1);
            coordIndex .push (p + 1);
            coordIndex .push (p - xDimension + 2);
            coordIndex .push (-1);
         }

         // South pole

         const last = p + xDimension - 1;

         for (let u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
         {
            coordIndex .push (last);
            coordIndex .push (p + 1);
            coordIndex .push (p);
            coordIndex .push (-1);
         }

         coordIndex .push (last);
         coordIndex .push (last - xDimension + 1);
         coordIndex .push (p);
         coordIndex .push (-1);
      },
      createPoints: function ()
      {
         const
            xDimension = this ._xDimension .getValue () + 1,
            yDimension = this ._yDimension .getValue (),
            point      = this .geometry ._coord .getValue () ._point;

         // North pole
         point .push (new Vector3 (0, 1, 0));

         // Sphere segments
         for (let v = 1, vLength = yDimension - 1; v < vLength; ++ v)
         {
            const zPlane = Complex .Polar (1, -Math .PI * v / vLength);

            for (let u = 0, uLength = xDimension - 1; u < uLength; ++ u)
            {
               const yPlane = Complex .Polar (zPlane .imag, 2 * Math .PI * u / uLength);

               point .push (new Vector3 (yPlane .imag, zPlane .real, yPlane .real));
            }
         }

         // South pole
         point .push (new Vector3 (0, -1, 0));
      },
      eventsProcessed: function ()
      {
         this .geometry            = new IndexedFaceSet (this .getExecutionContext ());
         this .geometry ._texCoord = new TextureCoordinate (this .getExecutionContext ());
         this .geometry ._coord    = new Coordinate (this .getExecutionContext ());

         this .createTexCoordIndex ();
         this .createTexCoord ();
         this .createCoordIndex ();
         this .createPoints ();

         const
            geometry = this .geometry,
            texCoord = this .geometry ._texCoord .getValue (),
            coord    = this .geometry ._coord .getValue ();

         geometry ._creaseAngle = Math .PI;

         texCoord .setup ();
         coord    .setup ();
         geometry .setup ();
      },
   });

   return QuadSphereOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/X3DGeometry3DContext',[
   "x_ite/Browser/Geometry3D/BoxOptions",
   "x_ite/Browser/Geometry3D/ConeOptions",
   "x_ite/Browser/Geometry3D/CylinderOptions",
   "x_ite/Browser/Geometry3D/QuadSphereOptions",
],
function (BoxOptions,
          ConeOptions,
          CylinderOptions,
          QuadSphereOptions)
{
"use strict";

   function X3DGeometry3DContext () { }

   X3DGeometry3DContext .prototype =
   {
      initialize: function ()
      { },
      getBoxOptions: function ()
      {
         return getOptionNode .call (this, "getBoxOptions", BoxOptions);
      },
      getConeOptions: function ()
      {
         return getOptionNode .call (this, "getConeOptions", ConeOptions);
      },
      getCylinderOptions: function ()
      {
         return getOptionNode .call (this, "getCylinderOptions", CylinderOptions);
      },
      getSphereOptions: function ()
      {
         return getOptionNode .call (this, "getSphereOptions", QuadSphereOptions);
      },
   };

   function getOptionNode (key, OptionNode)
   {
      const optionNode = new OptionNode (this .getPrivateScene ());

      optionNode .setup ();

      this [key] = function () { return optionNode; };

      Object .defineProperty (this, key, { enumerable: false });

      return optionNode;
   }

   return X3DGeometry3DContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/PointingDevice',[
   "jquery",
   "x_ite/Base/X3DBaseNode",
],
function ($,
          X3DBaseNode)
{
"use strict";

   const CONTEXT_MENU_TIME = 1200;

   function PointingDevice (executionContext)
   {
      X3DBaseNode .call (this, executionContext);

      this .cursor     = "DEFAULT";
      this .isOver     = false;
      this .motionTime = 0;
   }

   PointingDevice .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: PointingDevice,
      getTypeName: function ()
      {
         return "PointingDevice";
      },
      initialize: function ()
      {
         const element = this .getBrowser () .getSurface ();

         //element .bind ("mousewheel.PointingDevice", this .mousewheel .bind (this));
         element .bind ("mousedown.PointingDevice" + this .getId (), this .mousedown  .bind (this));
         element .bind ("mouseup.PointingDevice"   + this .getId (), this .mouseup    .bind (this));
         element .bind ("dblclick.PointingDevice"  + this .getId (), this .dblclick   .bind (this));
         element .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove  .bind (this));
         element .bind ("mouseout.PointingDevice"  + this .getId (), this .onmouseout .bind (this));

         element .bind ("touchstart.PointingDevice" + this .getId (), this .touchstart .bind (this));
         element .bind ("touchend.PointingDevice"   + this .getId (), this .touchend   .bind (this));
      },
      mousewheel: function (event)
      {
         // event .preventDefault () must be done in the several viewers.
      },
      mousedown: function (event)
      {
         const browser = this .getBrowser ();

         browser .getElement () .focus ();

         if (browser .getShiftKey () && browser .getControlKey ())
            return;

         if (event .button === 0)
         {
            const
               element = browser .getSurface (),
               offset  = element .offset (),
               x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
               y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

            element .unbind ("mousemove.PointingDevice" + this .getId ());

            $(document) .bind ("mouseup.PointingDevice"   + this .getId (), this .mouseup   .bind (this));
            $(document) .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));
            $(document) .bind ("touchend.PointingDevice"  + this .getId (), this .touchend  .bind (this));
            $(document) .bind ("touchmove.PointingDevice" + this .getId (), this .touchmove .bind (this));

            if (browser .buttonPressEvent (x, y))
            {
               event .preventDefault ();
               event .stopImmediatePropagation (); // Keeps the rest of the handlers from being executed

               browser .setCursor ("HAND");
               browser .finished () .addInterest ("onverifymotion", this, x, y);
            }
         }
      },
      mouseup: function (event)
      {
         event .preventDefault ();

         if (event .button === 0)
         {
            const
               browser = this .getBrowser (),
               element = browser .getSurface (),
               offset  = element .offset (),
               x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
               y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

            $(document) .unbind (".PointingDevice" + this .getId ());
            element .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));

            browser .buttonReleaseEvent ();
            browser .setCursor (this .isOver ? "HAND" : "DEFAULT");
            browser .finished () .addInterest ("onverifymotion", this, x, y);
            browser .addBrowserEvent ();

            this .cursor = "DEFAULT";
         }
      },
      dblclick: function (event)
      {
         if (this .isOver)
            event .stopImmediatePropagation ();
      },
      mousemove: function (event)
      {
         event .preventDefault ();

         const browser = this .getBrowser ();

         if (this .motionTime === browser .getCurrentTime ())
            return;

         this .motionTime = browser .getCurrentTime ();

         const
            element = browser .getSurface (),
            offset  = element .offset (),
            x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
            y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

         this .onmotion (x, y);
      },
      touchstart: function (event)
      {
         const touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // button 0.

               event .button = 0;
               event .pageX  = touches [0] .pageX;
               event .pageY  = touches [0] .pageY;

               this .mousedown (event);

               // Show context menu on long tab.

               const nearestHit = this .getBrowser () .getNearestHit ();

               if (! nearestHit || nearestHit .sensors .size === 0)
               {
                  this .touchX       = event .pageX;
                  this .touchY       = event .pageY;
                  this .touchTimeout = setTimeout (this .showContextMenu .bind (this, event), CONTEXT_MENU_TIME);
               }

               break;
            }
            case 2:
            {
               this .touchend (event);
               break;
            }
         }
      },
      touchend: function (event)
      {
         event .button = 0;

         this .mouseup (event);

         clearTimeout (this .touchTimeout);
      },
      touchmove: function (event)
      {
         const touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // button 0.

               event .button = 0;
               event .pageX  = touches [0] .pageX;
               event .pageY  = touches [0] .pageY;

               this .mousemove (event);

               if (Math .hypot (this .touchX - event .pageX, this .touchY - event .pageY) > 7)
                  clearTimeout (this .touchTimeout);

               break;
            }
         }
      },
      onmotion: function (x, y)
      {
         const browser = this .getBrowser ();

         if (browser .motionNotifyEvent (x, y))
         {
            if (!this .isOver)
            {
               this .isOver = true;
               this .cursor = browser .getCursor ();

               browser .setCursor ("HAND");
            }
         }
         else
         {
            if (this .isOver)
            {
               this .isOver = false;

               browser .setCursor (this .cursor);
            }
         }
      },
      onmouseout: function (event)
      {
         this .getBrowser () .leaveNotifyEvent ();
      },
      onverifymotion: function (x, y)
      {
         // Verify isOver state. This is necessary if an Switch changes on buttonReleaseEvent
         // and the new child has a sensor node inside. This sensor node must be update to
         // reflect the correct isOver state.

         this .getBrowser () .finished () .removeInterest ("onverifymotion", this);

         this .onmotion (x, y);
      },
      showContextMenu: function (event)
      {
         this .getBrowser () .getContextMenu () .show (event);
      },
   });

   return PointingDevice;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/X3DPointingDeviceSensorContext',[
   "x_ite/Browser/PointingDeviceSensor/PointingDevice",
   "x_ite/Rendering/TraverseType",
   "standard/Math/Geometry/Line3",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithms/MergeSort",
   "standard/Math/Algorithm",
],
function (PointingDevice,
          TraverseType,
          Line3,
          ViewVolume,
          Vector2,
          Vector3,
          Matrix4,
          MergeSort,
          Algorithm)
{
"use strict";

   const
      _pointingDevice  = Symbol (),
      _cursorType      = Symbol (),
      _pointer         = Symbol (),
      _hitRay          = Symbol (),
      _hits            = Symbol (),
      _enabledSensors  = Symbol (),
      _pickOnlySensors = Symbol (),
      _selectedLayer   = Symbol (),
      _overSensors     = Symbol (),
      _activeSensors   = Symbol (),
      _hitPointSorter  = Symbol (),
      _layerNumber     = Symbol (),
      _layerSorter     = Symbol (),
      _pointerTime     = Symbol ();

   const line = new Line3 (Vector3 .Zero, Vector3 .Zero);

   function X3DPointingDeviceSensorContext ()
   {
      this [_pointingDevice] = new PointingDevice (this);
      this [_pointer]        = new Vector2 (0, 0);
      this [_hitRay]         = new Line3 (Vector3 .Zero, Vector3 .Zero);
      this [_hits]           = [ ];
      this [_enabledSensors] = [new Map ()];
      this [_selectedLayer]  = null;
      this [_overSensors]    = new Set ();
      this [_activeSensors]  = new Set ();
      this [_hitPointSorter] = new MergeSort (this [_hits], function (lhs, rhs) { return lhs .intersection .point .z < rhs .intersection .point .z; });
      this [_layerSorter]    = new MergeSort (this [_hits], function (lhs, rhs) { return lhs .layerNumber < rhs .layerNumber; });
      this [_pointerTime]    = 0;
   }

   X3DPointingDeviceSensorContext .prototype =
   {
      initialize: function ()
      {
         // Make element focusable.
         this .getElement () .attr ("tabindex", this .getElement () .attr ("tabindex") || 0);
         this .setCursor ("DEFAULT");

         this [_pointingDevice] .setup ();
      },
      setCursor: function (value)
      {
         const div = this .getSurface ();

         this [_cursorType] = value;

         switch (value)
         {
            case "HAND": // Hand with finger
               div .css ("cursor", "pointer");
               break;
            case "MOVE": // Hand grabed something
               div .css ("cursor", "move");
               break;
            case "CROSSHAIR":
               div .css ("cursor", "crosshair");
               break;
            default:
            {
               if (this ._loadCount .getValue ())
                  div .css ("cursor", "wait");
               else if (this [_pointingDevice] && this [_pointingDevice] .isOver)
                  div .css ("cursor", "pointer");
               else
                  div .css ("cursor", "default");
               break;
            }
         }
      },
      getCursor: function ()
      {
         return this [_cursorType];
      },
      isPointerInRectangle: function (rectangle)
      {
         return this [_pointer] .x > rectangle .x &&
                this [_pointer] .x < rectangle .x + rectangle .z &&
                this [_pointer] .y > rectangle .y &&
                this [_pointer] .y < rectangle .y + rectangle .w;
      },
      setLayerNumber: function (value)
      {
         this [_layerNumber] = value;
      },
      getSelectedLayer: function ()
      {
         return this [_selectedLayer];
      },
      setHitRay: function (projectionMatrix, viewport)
      {
         ViewVolume .unProjectRay (this [_pointer] .x, this [_pointer] .y, Matrix4 .Identity, projectionMatrix, viewport, this [_hitRay]);
      },
      getHitRay: function ()
      {
         return this [_hitRay];
      },
      getSensors: function ()
      {
         return this [_enabledSensors];
      },
      getPickOnlySensors: function ()
      {
         return this [_pickOnlySensors];
      },
      addHit: function (intersection, layer, shape, modelViewMatrix)
      {
         const sensors = this [_enabledSensors] .at (-1);

         this [_hits] .push ({
            pointer:         this [_pointer],
            hitRay:          this [_hitRay] .copy (),
            intersection:    intersection,
            sensors:         new Set (sensors .values ()),
            layer:           layer,
            layerNumber:     this [_layerNumber],
            shape:           shape,
            modelViewMatrix: modelViewMatrix .copy (),
         });
      },
      getHits: function ()
      {
         return this [_hits];
      },
      getNearestHit: function ()
      {
         return this [_hits] .at (-1);
      },
      buttonPressEvent: function (x, y)
      {
         this .touch (x, y, true);

         if (this [_hits] .length === 0)
            return false;

         const nearestHit = this .getNearestHit ();

         this [_selectedLayer] = nearestHit .layer;
         this [_activeSensors] = nearestHit .sensors;

         for (const sensor of this [_activeSensors])
            sensor .set_active__ (true, nearestHit);

         return !! nearestHit .sensors .size;
      },
      buttonReleaseEvent: function ()
      {
         this [_selectedLayer] = null;

         for (const sensor of this [_activeSensors])
            sensor .set_active__ (false, null);

         this [_activeSensors] = new Set ();

         // Selection

         return true;
      },
      motionNotifyEvent: function (x, y)
      {
         this .touch (x, y, true);
         this .motion ();

         return !! (this [_hits] .length && this [_hits] .at (-1) .sensors .size);
      },
      leaveNotifyEvent: function ()
      { },
      touch: function (x, y, pickOnlySensors)
      {
         if (this .getViewer () ._isActive .getValue ())
         {
            this [_pointerTime] = 0;
            return;
         }

         const t0 = performance .now ();

         this [_pickOnlySensors] = pickOnlySensors;

         this [_pointer] .set (x, y);

         // Clear hits.

         this [_hits] .length = 0;

         // Pick.

         this .getWorld () .traverse (TraverseType .POINTER, null);

         // Picking end.

         this [_hitPointSorter] .sort (0, this [_hits] .length);
         this [_layerSorter]    .sort (0, this [_hits] .length);

         this .addBrowserEvent ();
         this [_pointerTime] = performance .now () - t0;
      },
      motion: function ()
      {
         if (this [_hits] .length)
         {
            var nearestHit = this [_hits] .at (-1);
         }
         else
         {
            var nearestHit = {
               pointer:         this [_pointer],
               modelViewMatrix: new Matrix4 (),
               hitRay:          this [_selectedLayer] ? this [_hitRay] : line,
               intersection:    null,
               sensors:         new Set (),
               shape:           null,
               layer:           null,
               layerNumber:     0,
            };
         }

         // Set isOver to FALSE for appropriate nodes

         if (this [_hits] .length)
         {
            var difference = Algorithm .set_difference (this [_overSensors], nearestHit .sensors, new Set ());
         }
         else
         {
            var difference = new Set (this [_overSensors]);
         }

         for (const sensor of difference)
            sensor .set_over__ (false, nearestHit);

         // Set isOver to TRUE for appropriate nodes

         if (this [_hits] .length)
         {
            this [_overSensors] = nearestHit .sensors;

            for (const sensor of this [_overSensors])
               sensor .set_over__ (true, nearestHit);
         }
         else
         {
            this [_overSensors] = new Set ();
         }

         // Forward motion event to active drag sensor nodes

         for (const sensor of this [_activeSensors])
            sensor .set_motion__ (nearestHit);
      },
      getPointerTime: function ()
      {
         return this [_pointerTime];
      },
   };

   return X3DPointingDeviceSensorContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DViewer',[
   "x_ite/Base/X3DBaseNode",
   "x_ite/Components/Navigation/OrthoViewpoint",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/ViewVolume",
],
function (X3DBaseNode,
          OrthoViewpoint,
          Vector3,
          Matrix4,
          Box3,
          ViewVolume)
{
"use strict";

   function X3DViewer (executionContext)
   {
      X3DBaseNode .call (this, executionContext);
   }

   X3DViewer .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
   {
      constructor: X3DViewer,
      getTypeName: function ()
      {
         return "X3DViewer";
      },
      initialize: function ()
      { },
      initShaders: function ()
      { },
      getActiveLayer: function ()
      {
         return this .getBrowser () .getActiveLayer ();
      },
      getViewport: function ()
      {
         return this .getBrowser () .getActiveLayer () .getViewport ();
      },
      getNavigationInfo: function ()
      {
         return this .getBrowser () .getActiveLayer () .getNavigationInfo ();
      },
      getActiveViewpoint: function ()
      {
         return this .getBrowser () .getActiveLayer () .getViewpoint ();
      },
      getStraightenHorizon: function ()
      {
         return this .getBrowser () .getBrowserOption ("StraightenHorizon");
      },
      getButton: function (button)
      {
         // If Alt key is pressed and button 0, then emulate button 1 (middle).
         if (button === 0)
         {
            if (this .getBrowser () .getAltKey ())
            {
               return 1;
            }
         }

         return button;
      },
      getPointOnCenterPlane: (function ()
      {
         const
            axis     = new Vector3 (0, 0, -1),
            distance = new Vector3 (0, 0, 0),
            far      = new Vector3 (0, 0, 0);

         return function (x, y, result)
         {
            const
               navigationInfo   = this .getNavigationInfo (),
               viewpoint        = this .getActiveViewpoint (),
               viewport         = this .getViewport () .getRectangle (this .getBrowser ()),
               projectionMatrix = viewpoint .getProjectionMatrixWithLimits (navigationInfo .getNearValue (), navigationInfo .getFarValue (viewpoint), viewport);

            // Far plane point
            ViewVolume .unProjectPoint (x, this .getBrowser () .getViewport () [3] - y, 0.9, Matrix4 .Identity, projectionMatrix, viewport, far);

            if (viewpoint instanceof OrthoViewpoint)
               return result .set (far .x, far .y, -this .getDistanceToCenter (distance) .abs ());

            const direction = far .normalize ();

            return result .assign (direction) .multiply (this .getDistanceToCenter (distance) .abs () / direction .dot (axis));
         };
      })(),
      getDistanceToCenter: function (distance, positionOffset)
      {
         const viewpoint = this .getActiveViewpoint ();

         return (distance
            .assign (viewpoint .getPosition ())
            .add (positionOffset || viewpoint ._positionOffset .getValue ())
            .subtract (viewpoint .getUserCenterOfRotation ()));
      },
      trackballProjectToSphere: function (x, y, vector)
      {
         const viewport = this .getViewport () .getRectangle (this .getBrowser ());

         y = this .getBrowser () .getViewport () [3] - y;

         x = (x - viewport [0]) / viewport [2] - 0.5;
         y = (y - viewport [1]) / viewport [3] - 0.5;

         return vector .set (x, y, tbProjectToSphere (0.5, x, y));
      },
      lookAtPoint: function (x, y, straightenHorizon)
      {
         if (! this .touch (x, y))
            return;

         const hit = this .getBrowser () .getNearestHit ();

         this .getActiveViewpoint () .lookAtPoint (this .getActiveLayer (), hit .intersection .point, 2 - 1.618034, straightenHorizon);
      },
      lookAtBBox: (function ()
      {
         const bbox = new Box3 ();

         return function (x, y, straightenHorizon)
         {
            if (! this .touch (x, y))
               return;

            const hit = this .getBrowser () .getNearestHit ();

            hit .shape .getBBox (bbox) .multRight (hit .modelViewMatrix);

            this .getActiveViewpoint () .lookAtBBox (this .getActiveLayer (), bbox, 2 - 1.618034, straightenHorizon);
         };
      })(),
      touch: function (x, y)
      {
         this .getBrowser () .touch (x, y, false);

         return this .getBrowser () .getHits () .length;
      },
      dispose: function () { },
   });

   function tbProjectToSphere (r, x, y)
   {
      const d = Math .hypot (x, y);

      if (d < r * Math .sqrt (0.5)) // Inside sphere
      {
         return Math .sqrt (r * r - d * d);
      }

      // On hyperbola

      const t = r / Math .sqrt (2);

      return t * t / d;
   }

   return X3DViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DFollowerNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DFollowerNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DFollowerNode);

      this .buffer = [ ];

      // Auxillary variables
      this .a      = this .getVector ();
      this .vector = this .getVector ();
   }

   X3DFollowerNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DFollowerNode,
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);

         this .isLive () .addInterest ("set_live__", this);
      },
      getBuffer: function ()
      {
         return this .buffer;
      },
      getValue: function ()
      {
         return this ._set_value .getValue ();
      },
      getDestination: function ()
      {
         return this ._set_destination .getValue ();
      },
      getInitialValue: function ()
      {
         return this ._initialValue .getValue ();
      },
      getInitialDestination: function ()
      {
         return this ._initialDestination .getValue ();
      },
      setValue: function (value)
      {
         this ._value_changed = value;
      },
      setDestination: function (value)
      {
         this .destination .assign (value);
      },
      duplicate: function (value)
      {
         return value .copy ();
      },
      assign: function (buffer, i, value)
      {
         buffer [i] .assign (value);
      },
      equals: function (lhs, rhs, tolerance)
      {
         return this .a .assign (lhs) .subtract (rhs) .abs () < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return this .vector .assign (source) .lerp (destination, weight);
      },
      set_live__: function ()
      {
         if ((this .isLive () .getValue () || this .getPrivate ()) && this ._isActive .getValue ())
         {
            this .getBrowser () .prepareEvents () .addInterest ("prepareEvents", this);
            this .getBrowser () .addBrowserEvent ();
         }
         else
            this .getBrowser () .prepareEvents () .removeInterest ("prepareEvents", this);
      },
      set_active: function (value)
      {
         if (value !== this ._isActive .getValue ())
         {
            this ._isActive = value;

            this .set_live__ ();
         }
      },
   });

   return X3DFollowerNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DChaserNode',[
   "x_ite/Components/Followers/X3DFollowerNode",
   "x_ite/Base/X3DConstants",
],
function (X3DFollowerNode,
          X3DConstants)
{
"use strict";

   function X3DChaserNode (executionContext)
   {
      X3DFollowerNode .call (this, executionContext);

      this .addType (X3DConstants .X3DChaserNode);

      this .destination   = null;
      this .previousValue = null;
      this .bufferEndTime = 0;
      this .stepTime      = 0;

      // Auxillary variables
      this .deltaOut = this .getVector ();
   }

   X3DChaserNode .prototype = Object .assign (Object .create (X3DFollowerNode .prototype),
   {
      constructor: X3DChaserNode,
      initialize: function ()
      {
         X3DFollowerNode .prototype .initialize .call (this);

         this ._set_value       .addInterest ("set_value__",       this);
         this ._set_destination .addInterest ("set_destination__", this);
         this ._duration        .addInterest ("set_duration__",    this);

         this .set_duration__ ();

         var
            buffer             = this .getBuffer (),
            initialValue       = this .getInitialValue (),
            initialDestination = this .getInitialDestination (),
            numBuffers         = this .getNumBuffers ();

         this .bufferEndTime = this .getBrowser () .getCurrentTime ();
         this .previousValue = this .duplicate (initialValue);

         buffer [0] = this .duplicate (initialDestination);

         for (var i = 1; i < numBuffers; ++ i)
            buffer [i] = this .duplicate (initialValue);

         this .destination = this .duplicate (initialDestination);

         if (this .equals (initialDestination, initialValue, this .getTolerance ()))
            this .setValue (initialDestination);

         else
            this .set_active (true);
      },
      getNumBuffers: function ()
      {
         return 60;
      },
      getTolerance: function ()
      {
         return 1e-8;
      },
      getArray: function ()
      {
         return this .getVector ();
      },
      setPreviousValue: function (value)
      {
         this .previousValue .assign (value);
      },
      step: function (value1, value2, t)
      {
         this .output .add (this .deltaOut .assign (value1) .subtract (value2) .multiply (t));
      },
      stepResponse: function (t)
      {
         if (t <= 0)
            return 0;

         var duration = this ._duration .getValue ();

         if (t >= duration)
            return 1;

         return 0.5 - 0.5 * Math .cos ((t / duration) * Math .PI);
      },
      set_value__: function ()
      {
         if (! this ._isActive .getValue ())
            this .bufferEndTime = this .getBrowser () .getCurrentTime ();

         var
            buffer = this .getBuffer (),
            value  = this .getValue ();

         for (var i = 0, length = buffer .length; i < length; ++ i)
            this .assign (buffer, i, value);

         this .setPreviousValue (value);
         this .setValue (value);

         this .set_active (true);
      },
      set_destination__: function ()
      {
         this .setDestination (this .getDestination ());

         if (! this ._isActive .getValue ())
            this .bufferEndTime = this .getBrowser () .getCurrentTime ();

         this .set_active (true);
      },
      set_duration__: function ()
      {
         this .stepTime = this ._duration .getValue () / this .getNumBuffers ();
      },
      prepareEvents: function ()
      {
         var
            buffer     = this .getBuffer (),
            numBuffers = buffer .length,
            fraction   = this .updateBuffer ();

         this .output = this .interpolate (this .previousValue,
                                             buffer [numBuffers - 1],
                                             this .stepResponse ((numBuffers - 1 + fraction) * this .stepTime));

         for (var i = numBuffers - 2; i >= 0; -- i)
         {
            this .step (buffer [i], buffer [i + 1], this .stepResponse ((i + fraction) * this .stepTime));
         }

         this .setValue (this .output);

         if (this .equals (this .output, this .destination, this .getTolerance ()))
            this .set_active (false);
      },
      updateBuffer: function ()
      {
         var
            buffer     = this .getBuffer (),
            numBuffers = buffer .length,
            fraction   = (this .getBrowser () .getCurrentTime () - this .bufferEndTime) / this .stepTime;

         if (fraction >= 1)
         {
            var seconds = Math .floor (fraction);

            fraction -= seconds;

            if (seconds < numBuffers)
            {
               this .setPreviousValue (buffer [numBuffers - seconds]);

               for (var i = numBuffers - 1; i >= seconds; -- i)
               {
                  this .assign (buffer, i, buffer [i - seconds])
               }

               for (var i = 0; i < seconds; ++ i)
               {
                  var alpha = i / seconds;

                  this .assign (buffer, i, this .interpolate (this .destination, buffer [seconds], alpha))
               }
            }
            else
            {
               this .setPreviousValue (seconds == numBuffers ? buffer [0] : this .destination);

               for (var i = 0; i < numBuffers; ++ i)
                  this .assign (buffer, i, this .destination);
            }

            this .bufferEndTime += seconds * this .stepTime;
         }

         return fraction;
      },
   });

   return X3DChaserNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionChaser',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function PositionChaser (executionContext)
   {
      X3DChaserNode .call (this, executionContext);

      this .addType (X3DConstants .PositionChaser);
   }

   PositionChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
   {
      constructor: PositionChaser,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "PositionChaser";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
   });

   return PositionChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/OrientationChaser',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Rotation4)
{
"use strict";

   var
      a        = new Rotation4 (0, 0, 1, 0),
      rotation = new Rotation4 (0, 0, 1, 0);

   function OrientationChaser (executionContext)
   {
      X3DChaserNode .call (this, executionContext);

      this .addType (X3DConstants .OrientationChaser);

      this ._set_value          .setUnit ("angle");
      this ._set_destination    .setUnit ("angle");
      this ._initialValue       .setUnit ("angle");
      this ._initialDestination .setUnit ("angle");
      this ._value_changed      .setUnit ("angle");
   }

   OrientationChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
   {
      constructor: OrientationChaser,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFRotation ()),
      ]),
      getTypeName: function ()
      {
         return "OrientationChaser";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Rotation4 (0, 0, 1, 0);
      },
      equals: function (lhs, rhs, tolerance)
      {
         a .assign (lhs) .inverse () .multRight (rhs);

         return Math .abs (a .angle) < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return rotation .assign (source) .slerp (destination, weight);
      },
      step: function (value1, value2, t)
      {
         this .deltaOut .assign (value2) .inverse () .multRight (value1) .multLeft (this .output);

         this .output .slerp (this .deltaOut, t);
      },
   });

   return OrientationChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/ExamineViewer',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Navigation/X3DViewer",
   "x_ite/Components/Followers/PositionChaser",
   "x_ite/Components/Followers/OrientationChaser",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "jquery-mousewheel",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          PositionChaser,
          OrientationChaser,
          Vector2,
          Vector3,
          Rotation4)
{
"use strict";

   var macOS = /Mac OS X/i .test (navigator .userAgent)

   var
      MOTION_TIME       = 0.05 * 1000,
      SPIN_RELEASE_TIME = 0.04 * 1000,
      SPIN_ANGLE        = 0.003,
      SPIN_FACTOR       = 0.6,
      SCROLL_FACTOR     = macOS ? 1 / 120 : 1 / 20,
      MOVE_TIME         = 0.2,
      ROTATE_TIME       = 0.2,
      MAX_ANGLE         = 0.97;

   function ExamineViewer (executionContext)
   {
      X3DViewer .call (this, executionContext);

      this .button                   = -1;
      this .orientationOffset        = new Rotation4 (0, 0, 1, 0);
      this .fromVector               = new Vector3 (0, 0, 0);
      this .toVector                 = new Vector3 (0, 0, 0);
      this .fromPoint                = new Vector3 (0, 0, 0);
      this .toPoint                  = new Vector3 (0, 0, 0);
      this .rotation                 = new Rotation4 (0, 0, 1, 0);
      this .pressTime                = 0;
      this .motionTime               = 0;

      this .touchMode                = 0;
      this .touch1                   = new Vector2 (0, 0);
      this .touch2                   = new Vector2 (0, 0);
      this .tapStart                 = 0;
      this .dblTapInterval           = 0.4;

      this .initialPositionOffset    = new Vector3 (0, 0, 0);
      this .initialOrientationOffset = new Rotation4 (0, 0, 1, 0);
      this .positionChaser           = new PositionChaser (executionContext);
      this .centerOfRotationChaser   = new PositionChaser (executionContext);
      this .rotationChaser           = new OrientationChaser (executionContext);
   }

   ExamineViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
   {
      constructor: ExamineViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
      initialize: function ()
      {
         X3DViewer .prototype .initialize .call (this);

         var
            browser = this .getBrowser (),
            element = browser .getSurface ();

         // Disconnect from spin.

         this .getNavigationInfo () ._transitionStart .addInterest ("disconnect", this);
         browser ._activeViewpoint .addInterest ("set_activeViewpoint__", this);

         // Bind pointing device events.

         element .bind ("mousedown.ExamineViewer",  this .mousedown  .bind (this));
         element .bind ("mouseup.ExamineViewer",    this .mouseup    .bind (this));
         element .bind ("dblclick.ExamineViewer",   this .dblclick   .bind (this));
         element .bind ("mousewheel.ExamineViewer", this .mousewheel .bind (this));

         element .bind ("touchstart.ExamineViewer",  this .touchstart .bind (this));
         element .bind ("touchend.ExamineViewer",    this .touchend   .bind (this));

         // Setup scroll chaser.

         this .positionChaser ._duration = MOVE_TIME;
         this .positionChaser .setPrivate (true);
         this .positionChaser .setup ();

         this .centerOfRotationChaser ._duration = MOVE_TIME;
         this .centerOfRotationChaser .setPrivate (true);
         this .centerOfRotationChaser .setup ();

         this .rotationChaser ._duration = ROTATE_TIME;
         this .rotationChaser .setPrivate (true);
         this .rotationChaser .setup ();

         this .set_activeViewpoint__ ();
      },
      set_activeViewpoint__: function ()
      {
         if (this .getStraightenHorizon ())
         {
            var viewpoint = this .getActiveViewpoint ();

            if (viewpoint)
               viewpoint ._orientationOffset = this .getOrientationOffset (Rotation4 .Identity, viewpoint ._orientationOffset .getValue (), false);
         }

         this .disconnect ();
      },
      mousedown: function (event)
      {
         if (this .button >= 0)
            return;

         this .pressTime = performance .now ();

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (event .button))
         {
            case 0:
            {
               // Start rotate.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               $(document) .bind ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
               $(document) .bind ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
               $(document) .bind ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

               this .disconnect ();
               this .getActiveViewpoint () .transitionStop ();
               this .getBrowser () .setCursor ("MOVE");

               this .trackballProjectToSphere (x, y, this .fromVector);
               this .rotation .assign (Rotation4 .Identity);

               this .motionTime = 0;

               this ._isActive = true;
               break;
            }
            case 1:
            {
               // Start pan.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               $(document) .bind ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
               $(document) .bind ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
               $(document) .bind ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

               this .disconnect ();
               this .getActiveViewpoint () .transitionStop ();
               this .getBrowser () .setCursor ("MOVE");

               this .getPointOnCenterPlane (x, y, this .fromPoint);

               this ._isActive = true;
               break;
            }
         }
      },
      mouseup: function (event)
      {
         if (event .button !== this .button)
            return;

         this .button = -1;

         $(document) .unbind (".ExamineViewer" + this .getId ());

         switch (this .getButton (event .button))
         {
            case 0:
            {
               // End rotate.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               var viewpoint = this .getActiveViewpoint ();

               this .getBrowser () .setCursor ("DEFAULT");

               if (Math .abs (this .rotation .angle) > SPIN_ANGLE && performance .now () - this .motionTime < SPIN_RELEASE_TIME)
               {
                  if (this .getStraightenHorizon () && viewpoint .getTypeName () !== "GeoViewpoint")
                     this .rotation = this .getHorizonRotation (this .rotation);

                  this .addSpinning (this .rotation);
               }

               this ._isActive = false;
               break;
            }
            case 1:
            {
               // End pan.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .getBrowser () .setCursor ("DEFAULT");

               this ._isActive = false;
               break;
            }
         }
      },
      dblclick: function (event)
      {
         // Stop event propagation.
         event .preventDefault ();
         event .stopImmediatePropagation ();

         const
            element = this .getBrowser () .getSurface (),
            offset  = element .offset (),
            x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
            y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

         this .disconnect ();
         this .lookAtBBox (x, y, this .getStraightenHorizon ());
      },
      mousemove: (function ()
      {
         var fromPoint = new Vector3 (0, 0, 0);

         return function (event)
         {
            var
               offset = this .getBrowser () .getSurface () .offset (),
               x      = event .pageX - offset .left,
               y      = event .pageY - offset .top;

            switch (this .getButton (this .button))
            {
               case 0:
               {
                  // Rotate view around Viewpoint.centerOfRotation.

                  // Stop event propagation.
                  event .preventDefault ();
                  event .stopImmediatePropagation ();

                  var toVector = this .trackballProjectToSphere (x, y, this .toVector);

                  this .rotation .setFromToVec (toVector, this .fromVector);

                  if (Math .abs (this .rotation .angle) < SPIN_ANGLE && performance .now () - this .pressTime < MOTION_TIME)
                     return;

                  this .addRotate (this .rotation);

                  this .fromVector .assign (toVector);
                  this .motionTime = performance .now ();
                  break;
               }
               case 1:
               {
                  // Move view along center plane.

                  // Stop event propagation.
                  event .preventDefault ();
                  event .stopImmediatePropagation ();

                  var
                     viewpoint   = this .getActiveViewpoint (),
                     toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
                     translation = viewpoint .getUserOrientation () .multVecRot (fromPoint .assign (this .fromPoint) .subtract (toPoint));

                  this .addMove (translation, translation);

                  this .fromPoint .assign (toPoint);
                  break;
               }
            }
         };
      })(),
      mousewheel: (function ()
      {
         var
            step        = new Vector3 (0, 0, 0),
            translation = new Vector3 (0, 0, 0);

         return function (event)
         {
            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            // Change viewpoint position.

            var
               browser   = this .getBrowser (),
               viewpoint = this .getActiveViewpoint ();

            browser .prepareEvents () .removeInterest ("spin", this);
            viewpoint .transitionStop ();

            step        = this .getDistanceToCenter (step) .multiply (event .zoomFactor || SCROLL_FACTOR),
            translation = viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .abs ()));

            if (event .deltaY > 0)
               this .addMove (translation .negate (), Vector3 .Zero);

            else if (event .deltaY < 0)
               this .addMove (translation, Vector3 .Zero);
         };
      })(),
      touchstart: function (event)
      {
         var touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Start rotate (button 0).

               event .button = 0;
               event .pageX  = touches [0] .pageX;
               event .pageY  = touches [0] .pageY;

               this .mousedown (event);

               // Remember tap.

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               break;
            }
            case 2:
            {
               // End rotate (button 0).

               this .touchend (event);

               // Start move (button 1).

               event .button = 1;
               event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
               event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

               this .mousedown (event);

               // Start zoom (mouse wheel).

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
               break;
            }
            case 3:
            {
               // End move (button 1).
               this .touchend (event);
               break;
            }
         }
      },
      touchend: function (event)
      {
         switch (this .button)
         {
            case 0:
            {
               // End rotate (button 0).

               event .button = 0;
               event .pageX  = this .touch1 .x;
               event .pageY  = this .touch1 .y;

               this .mouseup (event);

               // Start dblclick (button 0).

               if (this .tapedTwice)
               {
                  this .dblclick (event);
               }
               else
               {
                  this .tapedTwice = true;

                  setTimeout (function () { this .tapedTwice = false; } .bind (this), 300);
               }

               break;
            }
            case 1:
            {
               // End move (button 1).

               this .touchMode = 0;
               event .button   = 1;

               this .mouseup (event);
               break;
            }
         }
      },
      touchmove: (function ()
      {
         var
            MOVE_ANGLE   = 0.7,
            ZOOM_ANGLE   = -0.7,
            touch1Change = new Vector2 (0, 0),
            touch2Change = new Vector2 (0, 0);

         return function (event)
         {
            var touches = event .originalEvent .touches;

            switch (touches .length)
            {
               case 1:
               {
                  // Rotate (button 0).

                  event .pageX = touches [0] .pageX;
                  event .pageY = touches [0] .pageY;

                  this .mousemove (event);
                  break;
               }
               case 2:
               {
                  touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
                  touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

                  var
                     move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
                     zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE,
                     mode = this .touchMode || (move ? 1 : (zoom ? 2 : 0));

                  switch (mode)
                  {
                     case 1:
                     {
                        // Move (button 1).

                        this .touchMode = 1;

                        event .pageX = (touches [0] .pageX + touches [1] .pageX) / 2;
                        event .pageY = (touches [0] .pageY + touches [1] .pageY) / 2;

                        this .mousemove (event);

                        break;
                     }
                     case 2:
                     {
                        // Zoom (mouse wheel).

                        this .touchMode = 2;

                        var distance1 = this .touch1 .distance (this .touch2);

                        this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                        this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

                        var
                           distance2 = this .touch1 .distance (this .touch2),
                           delta     = distance2 - distance1;

                        event .deltaY     = delta;
                        event .zoomFactor = Math .abs (delta) / $(window) .width ();

                        this .mousewheel (event);

                        break;
                     }
                  }

                  this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                  this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
                  break;
               }
            }
         };
      })(),
      spin: function ()
      {
         var viewpoint = this .getActiveViewpoint ();

         this .orientationOffset .assign (viewpoint ._orientationOffset .getValue ());

         viewpoint ._orientationOffset = this .getOrientationOffset (this .rotation, this .orientationOffset);
         viewpoint ._positionOffset    = this .getPositionOffset (viewpoint ._positionOffset .getValue (), this .orientationOffset, viewpoint ._orientationOffset .getValue ());
      },
      set_positionOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._positionOffset = value;
      },
      set_centerOfRotationOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._centerOfRotationOffset = value;
      },
      set_rotation__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._orientationOffset = this .getOrientationOffset (value .getValue (), this .initialOrientationOffset, false);
         viewpoint ._positionOffset    = this .getPositionOffset (this .initialPositionOffset, this .initialOrientationOffset, viewpoint ._orientationOffset .getValue ());
      },
      addRotate: (function ()
      {
         var destination = new Rotation4 ();

         return function (rotationChange)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .rotationChaser ._isActive .getValue () && this .rotationChaser ._value_changed .hasInterest ("set_rotation__", this))
            {
               try
               {
                  destination .assign (this .rotationChaser ._set_destination .getValue ())
                     .multLeft (rotationChange);

                  // Check for critical angle.
                  this .getOrientationOffset (destination, this .initialOrientationOffset, true);

                  this .rotationChaser ._set_destination = destination;
               }
               catch (error)
               {
                  // Slide along critical angle.

                  rotationChange = this .getHorizonRotation (rotationChange);

                  destination .assign (this .rotationChaser ._set_destination .getValue ())
                     .multLeft (rotationChange);

                  this .rotationChaser ._set_destination = destination;
               }
            }
            else
            {
               try
               {
                  this .initialOrientationOffset .assign (viewpoint ._orientationOffset .getValue ());
                  this .initialPositionOffset    .assign (viewpoint ._positionOffset    .getValue ());

                  // Check for critical angle.
                  this .getOrientationOffset (rotationChange, this .initialOrientationOffset, true);

                  this .rotationChaser ._set_value       = Rotation4 .Identity;
                  this .rotationChaser ._set_destination = rotationChange;
               }
               catch (error)
               {
                  // Slide along critical angle.

                  this .rotationChaser ._set_value       = Rotation4 .Identity;
                  this .rotationChaser ._set_destination = this .getHorizonRotation (rotationChange);
               }
            }

            this .disconnect ();
            this .rotationChaser ._value_changed .addInterest ("set_rotation__", this);
         };
      })(),
      addSpinning: (function ()
      {
         var rotation = new Rotation4 (0, 0, 1, 0);

         return function (rotationChange)
         {
            this .disconnect ();
            this .getBrowser () .prepareEvents () .addInterest ("spin", this);

            this .rotation .assign (rotation .assign (Rotation4 .Identity) .slerp (rotationChange, SPIN_FACTOR));
         };
      })(),
      addMove: (function ()
      {
         var
            positionOffset         = new Vector3 (0, 0, 0),
            centerOfRotationOffset = new Vector3 (0, 0, 0);

         return function (positionOffsetChange, centerOfRotationOffsetChange)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .positionChaser ._isActive .getValue () && this .positionChaser ._value_changed .hasInterest ("set_positionOffset__", this))
            {
               positionOffset
                  .assign (this .positionChaser ._set_destination .getValue ())
                  .add (positionOffsetChange);

               this .positionChaser ._set_destination = positionOffset;
            }
            else
            {
               positionOffset
                  .assign (viewpoint ._positionOffset .getValue ())
                  .add (positionOffsetChange);

               this .positionChaser ._set_value       = viewpoint ._positionOffset;
               this .positionChaser ._set_destination = positionOffset;
            }

            if (this .centerOfRotationChaser ._isActive .getValue () && this .centerOfRotationChaser ._value_changed .hasInterest ("set_centerOfRotationOffset__", this))
            {
               centerOfRotationOffset
                  .assign (this .centerOfRotationChaser ._set_destination .getValue ())
                  .add (centerOfRotationOffsetChange);

               this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
            }
            else
            {
               centerOfRotationOffset
                  .assign (viewpoint ._centerOfRotationOffset .getValue ())
                  .add (centerOfRotationOffsetChange);

               this .centerOfRotationChaser ._set_value       = viewpoint ._centerOfRotationOffset;
               this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
            }

            this .disconnect ();
            this .positionChaser         ._value_changed .addInterest ("set_positionOffset__",         this);
            this .centerOfRotationChaser ._value_changed .addInterest ("set_centerOfRotationOffset__", this);
         };
      })(),
      getPositionOffset: (function ()
      {
         var
            distance = new Vector3 (0, 0, 0),
            d        = new Vector3 (0, 0, 0),
            oob      = new Rotation4 (0, 0, 1, 0);

         return function (positionOffsetBefore, orientationOffsetBefore, orientationOffsetAfter)
         {
            this .getDistanceToCenter (distance, positionOffsetBefore);

            return (oob
               .assign (orientationOffsetBefore)
               .inverse ()
               .multRight (orientationOffsetAfter)
               .multVecRot (d .assign (distance))
               .subtract (distance)
               .add (positionOffsetBefore));
         };
      })(),
      getOrientationOffset: (function ()
      {
         var
            userOrientation   = new Rotation4 (0, 0, 1, 0),
            orientationOffset = new Rotation4 (0, 0, 1, 0),
            zAxis             = new Vector3 (0, 0, 0);

         return function (rotation, orientationOffsetBefore, _throw)
         {
            var
               viewpoint         = this .getActiveViewpoint (),
               straightenHorizon = this .getStraightenHorizon ();

            userOrientation
               .assign (rotation)
               .multRight (viewpoint .getOrientation ())
               .multRight (orientationOffsetBefore);

            if (straightenHorizon && viewpoint .getTypeName () !== "GeoViewpoint")
               viewpoint .straightenHorizon (userOrientation);

            var orientationOffsetAfter = orientationOffset
               .assign (viewpoint .getOrientation ())
               .inverse ()
               .multRight (userOrientation);

            if (straightenHorizon && viewpoint .getTypeName () !== "GeoViewpoint")
            {
               if (! _throw)
                  return orientationOffsetAfter;

               var userVector = userOrientation .multVecRot (zAxis .assign (Vector3 .zAxis));

               if (Math .abs (viewpoint .getUpVector () .dot (userVector)) < MAX_ANGLE)
                  return orientationOffsetAfter;

               throw new Error ("Critical angle");
            }
            else
            {
               return orientationOffsetAfter;
            }
         };
      })(),
      getHorizonRotation: (function ()
      {
         var zAxis = new Vector3 (0, 0, 0);

         return function (rotation)
         {
            var viewpoint = this .getActiveViewpoint ();

            var
               V = rotation .multVecRot (zAxis .assign (Vector3 .zAxis)) .normalize (),
               N = Vector3 .cross (viewpoint .getUpVector (), V) .normalize (),
               H = Vector3 .cross (N, viewpoint .getUpVector ()) .normalize ();

            return new Rotation4 (Vector3 .zAxis, H);
         };
      })(),
      disconnect: function ()
      {
         var browser = this .getBrowser ();

         this .positionChaser         ._value_changed .removeInterest ("set_positionOffset__",         this);
         this .centerOfRotationChaser ._value_changed .removeInterest ("set_centerOfRotationOffset__", this);
         this .rotationChaser         ._value_changed .removeInterest ("set_rotation__",               this);

         browser .prepareEvents () .removeInterest ("spin", this);
      },
      dispose: function ()
      {
         var browser = this .getBrowser ();

         this .disconnect ();
         browser ._activeViewpoint .removeInterest ("set_activeViewpoint__", this);
         browser .getSurface () .unbind (".ExamineViewer");
         $(document) .unbind (".ExamineViewer" + this .getId ());
      },
   });

   return ExamineViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DFlyViewer',[
   "jquery",
   "x_ite/Browser/Navigation/X3DViewer",
   "x_ite/Components/Followers/OrientationChaser",
   "x_ite/Rendering/VertexArray",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Camera",
   "jquery-mousewheel",
],
function ($,
          X3DViewer,
          OrientationChaser,
          VertexArray,
          Vector3,
          Rotation4,
          Matrix4,
          Camera)
{
"use strict";

   var macOS = /Mac OS X/i .test (navigator .userAgent)

   var
      SPEED_FACTOR           = 0.007,
      SHIFT_SPEED_FACTOR     = 4 * SPEED_FACTOR,
      ROTATION_SPEED_FACTOR  = 1.4,
      ROTATION_LIMIT         = 40,
      PAN_SPEED_FACTOR       = SPEED_FACTOR,
      PAN_SHIFT_SPEED_FACTOR = 1.4 * PAN_SPEED_FACTOR,
      ROLL_ANGLE             = macOS ? Math .PI / 512 : Math .PI / 32,
      ROTATE_TIME            = 0.3;

   var
      MOVE = 0,
      PAN  = 1;

   function X3DFlyViewer (executionContext)
   {
      X3DViewer .call (this, executionContext);

      var gl = this .getBrowser () .getContext ();

      this .button            = -1;
      this .fromVector        = new Vector3 (0, 0, 0);
      this .toVector          = new Vector3 (0, 0, 0);
      this .direction         = new Vector3 (0, 0, 0);
      this .startTime         = 0;
      this .lineCount         = 2;
      this .lineVertices      = new Array (this .lineCount * 4);
      this .lineArray         = new Float32Array (this .lineVertices);
      this .lineBuffer        = gl .createBuffer ();
      this .lineArrayObject   = new VertexArray ();
      this .event             = null;
      this .lookAround        = false;
      this .orientationChaser = new OrientationChaser (executionContext);
   }

   X3DFlyViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
   {
      constructor: X3DFlyViewer,
      initialize: function ()
      {
         X3DViewer .prototype .initialize .call (this);

         const
            browser = this .getBrowser (),
            element = browser .getSurface ();

         // Bind pointing device events.

         element .bind ("mousedown.X3DFlyViewer",  this .mousedown  .bind (this));
         element .bind ("mouseup.X3DFlyViewer",    this .mouseup    .bind (this));
         element .bind ("mousewheel.X3DFlyViewer", this .mousewheel .bind (this));

         element .bind ("touchstart.X3DFlyViewer", this .touchstart .bind (this));
         element .bind ("touchend.X3DFlyViewer",   this .touchend   .bind (this));

         browser ._controlKey .addInterest ("set_controlKey__", this);

         // Setup look around chaser.

         this .orientationChaser ._duration = ROTATE_TIME;
         this .orientationChaser .setPrivate (true);
         this .orientationChaser .setup ();

         // Preload line shader.
         this .initShaders ()
      },
      initShaders: function ()
      {
         const browser = this .getBrowser ();

         if (!browser .getBrowserOption ("Rubberband"))
            return;

         browser .getLineShader ();
         browser .getDepthShader ();
      },
      addCollision: function () { },
      removeCollision: function () { },
      set_controlKey__: function ()
      {
         if (this .event && this .event .button === 0)
         {
            this .button = -1;
            this .mousedown (this .event);
         }
      },
      mousedown: function (event)
      {
         if (this .button >= 0)
            return;

         this .event = event;

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (event .button))
         {
            case 0:
            {
               // Start walk or fly.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               $(document) .bind ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));
               $(document) .bind ("touchend.X3DFlyViewer"  + this .getId (), this .touchend  .bind (this));
               $(document) .bind ("touchmove.X3DFlyViewer" + this .getId (), this .touchmove .bind (this));

               this .disconnect ();
               this .getActiveViewpoint () .transitionStop ();
               this .getBrowser () .setCursor ("MOVE");
               this .addCollision ();

               if (this .getBrowser () .getControlKey () || this .lookAround)
               {
                  // Look around.

                  this .trackballProjectToSphere (x, y, this .fromVector);
               }
               else
               {
                  // Move.

                  this .fromVector .set (x, 0, y);
                  this .toVector   .assign (this .fromVector);

                  this .getFlyDirection (this .fromVector, this .toVector, this .direction);
                  this .addFly ();

                  if (this .getBrowser () .getBrowserOption ("Rubberband"))
                     this .getBrowser () .finished () .addInterest ("display", this, MOVE);
               }

               this ._isActive = true;
               break;
            }
            case 1:
            {
               // Start pan.

               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               $(document) .bind ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));

               this .disconnect ();
               this .getActiveViewpoint () .transitionStop ();
               this .getBrowser () .setCursor ("MOVE");
               this .addCollision ();

               this .fromVector .set (x, -y, 0);
               this .toVector   .assign (this .fromVector);
               this .direction  .set (0, 0, 0);

               this .addPan ();

               if (this .getBrowser () .getBrowserOption ("Rubberband"))
                  this .getBrowser () .finished () .addInterest ("display", this, PAN);

               this ._isActive = true;
               break;
            }
         }
      },
      mouseup: function (event)
      {
         event .preventDefault ();

         if (event .button !== this .button)
            return;

         this .event  = null;
         this .button = -1;

         $(document) .unbind (".X3DFlyViewer" + this .getId ());

         this .disconnect ();
         this .getBrowser () .setCursor ("DEFAULT");
         this .removeCollision ();

         this ._isActive = false;
      },
      mousemove: function (event)
      {
         this .getBrowser () .addBrowserEvent ();

         this .event = event;

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (this .button))
         {
            case 0:
            {
               if (this .getBrowser () .getControlKey () || this .lookAround)
               {
                  // Stop event propagation.
                  event .preventDefault ();
                  event .stopImmediatePropagation ();

                  // Look around

                  var toVector = this .trackballProjectToSphere (x, y, this .toVector);

                  this .addRotation (this .fromVector, toVector);
                  this .fromVector .assign (toVector);
                  break;
               }
               else
               {
                  // Fly

                  this .toVector .set (x, 0, y);
                  this .getFlyDirection (this .fromVector, this .toVector, this .direction);
                  break;
               }
            }
            case 1:
            {
               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               // Pan

               this .toVector  .set (x, -y, 0);
               this .direction .assign (this .toVector) .subtract (this .fromVector);
               break;
            }
         }
      },
      mousewheel: function (event)
      {
         // Stop event propagation.

         event .preventDefault ();
         event .stopImmediatePropagation ();

         // Change viewpoint position.

         var viewpoint = this .getActiveViewpoint ();

         viewpoint .transitionStop ();

         if (event .deltaY > 0)
            this .addRoll (-ROLL_ANGLE);

         else if (event .deltaY < 0)
            this .addRoll (ROLL_ANGLE);
      },
      touchstart: function (event)
      {
         var touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Start fly or walk (button 0).

               event .button = 0;
               event .pageX  = touches [0] .pageX;
               event .pageY  = touches [0] .pageY;

               this .mousedown (event);
               break;
            }
            case 2:
            {
               // End fly or walk (button 0).

               this .touchend (event);

               // Start look around (button 0).

               this .lookAround = true;
               event .button    = 0;
               event .pageX     = (touches [0] .pageX + touches [1] .pageX) / 2;
               event .pageY     = (touches [0] .pageY + touches [1] .pageY) / 2;

               this .mousedown (event);
               break;
            }
            case 3:
            {
               // End look around (button 0).

               this .touchend (event);
               break;
            }
         }
      },
      touchend: function (event)
      {
         switch (this .button)
         {
            case 0:
            {
               // End move or look around (button 0).
               this .lookAround = false;
               event .button    = 0;

               this .mouseup (event);
               break;
            }
         }
      },
      touchmove: function (event)
      {
         var touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Fly or walk (button 0).

               event .button = 0;
               event .pageX  = touches [0] .pageX;
               event .pageY  = touches [0] .pageY;

               this .mousemove (event);
               break;
            }
            case 2:
            {
               // Fly or walk (button 0).

               event .button = 0;
               event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
               event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

               this .mousemove (event);
               break;
            }
         }
      },
      fly: (function ()
      {
         var
            upVector           = new Vector3 (0, 0, 0),
            direction          = new Vector3 (0, 0, 0),
            axis               = new Vector3 (0, 0, 0),
            userOrientation    = new Rotation4 (0, 0, 1, 0),
            orientationOffset  = new Rotation4 (0, 0, 1, 0),
            rubberBandRotation = new Rotation4 (0, 0, 1, 0),
            up                 = new Rotation4 (0, 0, 1, 0),
            geoRotation        = new Rotation4 (0, 0, 1, 0);

         return function ()
         {
            var
               navigationInfo = this .getNavigationInfo (),
               viewpoint      = this .getActiveViewpoint (),
               now            = performance .now (),
               dt             = (now - this .startTime) / 1000;

            upVector .assign (viewpoint .getUpVector ());

            // Rubberband values

            up .setFromToVec (Vector3 .yAxis, upVector);

            if (this .direction .z > 0)
               rubberBandRotation .setFromToVec (up .multVecRot (direction .assign (this .direction)), up .multVecRot (axis .set (0, 0, 1)));
            else
               rubberBandRotation .setFromToVec (up .multVecRot (axis .set (0, 0, -1)), up .multVecRot (direction .assign (this .direction)));

            var rubberBandLength = this .direction .abs ();

            // Determine positionOffset.

            var speedFactor = 1 - rubberBandRotation .angle / (Math .PI / 2);

            speedFactor *= navigationInfo ._speed .getValue ();
            speedFactor *= viewpoint .getSpeedFactor ();
            speedFactor *= this .getBrowser () .getShiftKey () ? SHIFT_SPEED_FACTOR : SPEED_FACTOR;
            speedFactor *= dt;

            var translation = this .getTranslationOffset (direction .assign (this .direction) .multiply (speedFactor));

            this .getActiveLayer () .constrainTranslation (translation, true);

            viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());

            // Determine weight for rubberBandRotation.

            var weight = ROTATION_SPEED_FACTOR * dt * Math .pow (rubberBandLength / (rubberBandLength + ROTATION_LIMIT), 2);

            // Determine userOrientation.

            userOrientation
               .assign (Rotation4 .Identity)
               .slerp (rubberBandRotation, weight)
               .multRight (viewpoint .getUserOrientation ());

            // Straighten horizon of userOrientation.

            if (viewpoint .getTypeName () !== "GeoViewpoint" && this .getStraightenHorizon ())
               viewpoint .straightenHorizon (userOrientation);

            // Determine orientationOffset.

            orientationOffset
               .assign (viewpoint .getOrientation ())
               .inverse ()
               .multRight (userOrientation);

            // Set orientationOffset.

            viewpoint ._orientationOffset = orientationOffset;

            // GeoRotation

            geoRotation .setFromToVec (upVector, viewpoint .getUpVector ());

            viewpoint ._orientationOffset = geoRotation .multLeft (viewpoint ._orientationOffset .getValue ());

            this .startTime = now;
         };
      })(),
      pan: (function ()
      {
         var
            direction = new Vector3 (0, 0, 0),
            axis      = new Vector3 (0, 0, 0);

         return function ()
         {
            var
               navigationInfo = this .getNavigationInfo (),
               viewpoint      = this .getActiveViewpoint (),
               now            = performance .now (),
               dt             = (now - this .startTime) / 1000,
               upVector       = viewpoint .getUpVector ();

            this .constrainPanDirection (direction .assign (this .direction));

            var speedFactor = 1;

            speedFactor *= navigationInfo ._speed .getValue ();
            speedFactor *= viewpoint .getSpeedFactor ();
            speedFactor *= this .getBrowser () .getShiftKey () ? PAN_SHIFT_SPEED_FACTOR : PAN_SPEED_FACTOR;
            speedFactor *= dt;

            var
               orientation = viewpoint .getUserOrientation () .multRight (new Rotation4 (viewpoint .getUserOrientation () .multVecRot (axis .assign (Vector3 .yAxis)), upVector)),
               translation = orientation .multVecRot (direction .multiply (speedFactor));

            this .getActiveLayer () .constrainTranslation (translation, true);

            viewpoint ._positionOffset = translation .add (viewpoint ._positionOffset .getValue ());

            this .startTime = now;
         };
      })(),
      set_orientationOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._orientationOffset = value;
      },
      addFly: function ()
      {
         if (this .startTime)
            return;

         this .getBrowser () .prepareEvents () .addInterest ("fly", this);
         this .getBrowser () .addBrowserEvent ();

         this .startTime = performance .now ();
      },
      addPan: function ()
      {
         if (this .startTime)
            return;

         this .disconnect ();
         this .getBrowser () .prepareEvents () .addInterest ("pan", this);
         this .getBrowser () .addBrowserEvent ();

         this .startTime = performance .now ();
      },
      addRoll: (function ()
      {
         var
            orientationOffset = new Rotation4 (0, 0, 1, 0),
            roll              = new Rotation4 (0, 0, 1, 0);

         return function (rollAngle)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
            {
               orientationOffset
                  .assign (viewpoint .getOrientation ())
                  .inverse ()
                  .multRight (roll .set (1, 0, 0, rollAngle))
                  .multRight (viewpoint .getOrientation ())
                  .multRight (this .orientationChaser ._set_destination .getValue ());

               this .orientationChaser ._set_destination = orientationOffset;
            }
            else
            {
               orientationOffset
                  .assign (viewpoint .getOrientation ())
                  .inverse ()
                  .multRight (roll .set (1, 0, 0, rollAngle))
                  .multRight (viewpoint .getUserOrientation ());

               this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
               this .orientationChaser ._set_destination = orientationOffset;
            }

            this .disconnect ();
            this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
         };
      })(),
      addRotation: (function ()
      {
         var
            userOrientation   = new Rotation4 (0, 0, 1, 0),
            orientationOffset = new Rotation4 (0, 0, 1, 0);

         return function (fromVector, toVector)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
            {
               userOrientation
                  .setFromToVec (toVector, fromVector)
                  .multRight (viewpoint .getOrientation ())
                  .multRight (this .orientationChaser ._set_destination .getValue ());

               if (viewpoint .getTypeName () !== "GeoViewpoint" && this .getStraightenHorizon ())
                  viewpoint .straightenHorizon (userOrientation);

               orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

               this .orientationChaser ._set_destination = orientationOffset;
            }
            else
            {
               userOrientation
                  .setFromToVec (toVector, fromVector)
                  .multRight (viewpoint .getUserOrientation ());

               if (viewpoint .getTypeName () !== "GeoViewpoint" && this .getStraightenHorizon ())
                  viewpoint .straightenHorizon (userOrientation);

               orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

               this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
               this .orientationChaser ._set_destination = orientationOffset;
            }

            this .disconnect ();
            this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
         };
      })(),
      display: (function ()
      {
         const
            fromPoint             = new Vector3 (0, 0, 0),
            toPoint               = new Vector3 (0, 0, 0),
            projectionMatrix      = new Matrix4 (),
            projectionMatrixArray = new Float32Array (Matrix4 .Identity),
            modelViewMatrixArray  = new Float32Array (Matrix4 .Identity);

         return function (type)
         {
            // Configure HUD

            const
               browser  = this .getBrowser (),
               viewport = browser .getViewport (),
               width    = viewport [2],
               height   = viewport [3];

            Camera .ortho (0, width, 0, height, -1, 1, projectionMatrix);

            projectionMatrixArray .set (projectionMatrix);

            // Display Rubberband.

            if (type === MOVE)
            {
               fromPoint .set (this .fromVector .x, height - this .fromVector .z, 0);
               toPoint   .set (this .toVector   .x, height - this .toVector   .z, 0);
            }
            else
            {
               fromPoint .set (this .fromVector .x, height + this .fromVector .y, 0);
               toPoint   .set (this .toVector   .x, height + this .toVector   .y, 0);
            }

            this .transfer (fromPoint, toPoint);

            const
               gl         = browser .getContext (),
               shaderNode = browser .getLineShader (),
               lineWidth  = gl .getParameter (gl .LINE_WIDTH);

            if (shaderNode .isValid ())
            {
               shaderNode .enable (gl);

               if (this .lineArrayObject .enable (gl, shaderNode))
                  shaderNode .enableVertexAttribute (gl, this .lineBuffer, 0, 0);

               gl .uniform1i (shaderNode .x3d_NumClipPlanes,         0);
               gl .uniform1i (shaderNode .x3d_FogType,               0);
               gl .uniform1i (shaderNode .x3d_ColorMaterial,         false);
               gl .uniform1i (shaderNode .x3d_LinePropertiesApplied, false);

               gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrixArray);
               gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, modelViewMatrixArray);

               gl .disable (gl .DEPTH_TEST);

               // Draw a black and a white line.
               gl .lineWidth (2);
               gl .uniform3f (shaderNode .x3d_EmissiveColor, 0, 0, 0);
               gl .uniform1f (shaderNode .x3d_Transparency,  0);

               gl .drawArrays (gl .LINES, 0, this .lineCount);

               gl .lineWidth (1);
               gl .uniform3f (shaderNode .x3d_EmissiveColor, 1, 1, 1);

               gl .drawArrays (gl .LINES, 0, this .lineCount);
               gl .enable (gl .DEPTH_TEST);

               gl .lineWidth (lineWidth);
            }
         };
      })(),
      transfer: function (fromPoint, toPoint)
      {
         const
            gl           = this .getBrowser () .getContext (),
            lineVertices = this .lineVertices;

         lineVertices [0] = fromPoint .x;
         lineVertices [1] = fromPoint .y;
         lineVertices [2] = fromPoint .z;
         lineVertices [3] = 1;

         lineVertices [4] = toPoint .x;
         lineVertices [5] = toPoint .y;
         lineVertices [6] = toPoint .z;
         lineVertices [7] = 1;

         this .lineArray .set (lineVertices);

         // Transfer line.

         gl .bindBuffer (gl .ARRAY_BUFFER, this .lineBuffer);
         gl .bufferData (gl .ARRAY_BUFFER, this .lineArray, gl .DYNAMIC_DRAW);
      },
      disconnect: function ()
      {
         var browser = this .getBrowser ();

         browser .addBrowserEvent ();

         browser .prepareEvents () .removeInterest ("fly", this);
         browser .prepareEvents () .removeInterest ("pan", this);
         browser .finished ()      .removeInterest ("display", this);

         this .orientationChaser ._value_changed .removeInterest ("set_orientationOffset__", this);

         this .startTime = 0;
      },
      dispose: function ()
      {
         const gl = this .getBrowser () .getContext ();

         gl .deleteBuffer (this .lineBuffer);
         this .lineArrayObject .delete (gl);

         this .disconnect ();
         this .getBrowser () ._controlKey .removeInterest ("set_controlKey__", this);
         this .getBrowser () .getSurface () .unbind (".X3DFlyViewer");
         $(document) .unbind (".X3DFlyViewer" + this .getId ());
      },
   });

   return X3DFlyViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/WalkViewer',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Browser/Navigation/X3DFlyViewer",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DFlyViewer,
          X3DConstants,
          Vector3,
          Rotation4)
{
"use strict";

   function WalkViewer (executionContext)
   {
      X3DFlyViewer .call (this, executionContext);
   }

   WalkViewer .prototype = Object .assign (Object .create (X3DFlyViewer .prototype),
   {
      constructor: WalkViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
      initialize: function ()
      {
         X3DFlyViewer .prototype .initialize .call (this);

         this .getBrowser () .addCollision (this);
      },
      getStraightenHorizon: function ()
      {
         return true;
      },
      getFlyDirection: function (fromVector, toVector, direction)
      {
         return direction .assign (toVector) .subtract (fromVector);
      },
      getTranslationOffset: (function ()
      {
         var
            localYAxis      = new Vector3 (0, 0, 0),
            userOrientation = new Rotation4 (0, 0, 1, 0),
            rotation        = new Rotation4 (0, 0, 1, 0);

         return function (velocity)
         {
            var
               viewpoint = this .getActiveViewpoint (),
               upVector  = viewpoint .getUpVector ();

            userOrientation .assign (viewpoint .getUserOrientation ());
            userOrientation .multVecRot (localYAxis .assign (Vector3 .yAxis));
            rotation        .setFromToVec (localYAxis, upVector);

            var orientation = userOrientation .multRight (rotation);

            return orientation .multVecRot (velocity);
         };
      })(),
      constrainPanDirection: function (direction)
      {
         if (direction .y < 0)
            direction .y = 0;

         return direction;
      },
      dispose: function ()
      {
         this .getBrowser () .removeCollision (this);

         X3DFlyViewer .prototype .dispose .call (this);
      },
   });

   return WalkViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/FlyViewer',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Navigation/X3DFlyViewer",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DFlyViewer,
          Vector3,
          Rotation4)
{
"use strict";

   function FlyViewer (executionContext)
   {
      X3DFlyViewer .call (this, executionContext);
   }

   FlyViewer .prototype = Object .assign (Object .create (X3DFlyViewer .prototype),
   {
      constructor: FlyViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
      addCollision: function ()
      {
         this .getBrowser () .addCollision (this);
      },
      removeCollision: function ()
      {
         this .getBrowser () .removeCollision (this);
      },
      getFlyDirection: function (fromVector, toVector, direction)
      {
         return direction .assign (toVector) .subtract (fromVector);
      },
      getTranslationOffset: function (velocity)
      {
         return this .getActiveViewpoint () .getUserOrientation () .multVecRot (velocity);
      },
      constrainPanDirection: function (direction)
      {
         return direction;
      },
   });

   return FlyViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/PlaneViewer',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Navigation/X3DViewer",
   "x_ite/Components/Navigation/Viewpoint",
   "standard/Math/Numbers/Vector3",
   "jquery-mousewheel",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          Viewpoint,
          Vector3)
{
"use strict";

   var macOS = /Mac OS X/i .test (navigator .userAgent)

   var SCROLL_FACTOR = macOS ? 1 / 160 : 1 / 20;

   var
      vector                 = new Vector3 (0 ,0, 0),
      positionOffset         = new Vector3 (0 ,0, 0),
      centerOfRotationOffset = new Vector3 (0, 0, 0);

   function PlaneViewer (executionContext)
   {
      X3DViewer .call (this, executionContext);

      this .button    = -1;
      this .fromPoint = new Vector3 (0, 0, 0);
      this .toPoint   = new Vector3 (0, 0, 0);
   }

   PlaneViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
   {
      constructor: PlaneViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
      initialize: function ()
      {
         X3DViewer .prototype .initialize .call (this);

         var
            browser = this .getBrowser (),
            element = browser .getSurface ();

         element .bind ("mousedown.PlaneViewer",  this .mousedown  .bind (this));
         element .bind ("mouseup.PlaneViewer",    this .mouseup    .bind (this));
         element .bind ("mousemove.PlaneViewer",  this .mousemove  .bind (this));
         element .bind ("mousewheel.PlaneViewer", this .mousewheel .bind (this));
      },
      mousedown: function (event)
      {
         if (this .button >= 0)
            return;

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (event .button))
         {
            case 1:
            {
               // Stop event propagation.

               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               this .getBrowser () .getSurface () .unbind ("mousemove.PlaneViewer");
               $(document) .bind ("mouseup.PlaneViewer"   + this .getId (), this .mouseup .bind (this));
               $(document) .bind ("mousemove.PlaneViewer" + this .getId (), this .mousemove .bind (this));

               this .getActiveViewpoint () .transitionStop ();
               this .getBrowser () .setCursor ("MOVE");

               this .getPointOnCenterPlane (x, y, this .fromPoint);

               this ._isActive = true;
               break;
            }
         }
      },
      mouseup: function (event)
      {
         // Stop event propagation.

         event .preventDefault ();
         event .stopImmediatePropagation ();

         if (event .button !== this .button)
            return;

         this .button = -1;

         $(document) .unbind (".PlaneViewer" + this .getId ());
         this .getBrowser () .getSurface () .bind ("mousemove.PlaneViewer", this .mousemove .bind (this));

         this .getBrowser () .setCursor ("DEFAULT");

         this ._isActive = false;
      },
      mousemove: function (event)
      {
         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .getButton (this .button))
         {
            case 1:
            {
               // Stop event propagation.

               event .preventDefault ();
               event .stopImmediatePropagation ();

               // Move.

               var
                  viewpoint   = this .getActiveViewpoint (),
                  toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
                  translation = viewpoint .getUserOrientation () .multVecRot (this .fromPoint .subtract (toPoint));

               viewpoint ._positionOffset         = positionOffset         .assign (viewpoint ._positionOffset         .getValue ()) .add (translation);
               viewpoint ._centerOfRotationOffset = centerOfRotationOffset .assign (viewpoint ._centerOfRotationOffset .getValue ()) .add (translation);

               this .fromPoint .assign (toPoint);
               break;
            }
         }
      },
      mousewheel: function (event)
      {
         // Stop event propagation.

         event .preventDefault ();
         event .stopImmediatePropagation ();

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         // Change viewpoint position.

         var
            viewpoint = this .getActiveViewpoint (),
            fromPoint = this .getPointOnCenterPlane (x, y, this .fromPoint);

         viewpoint .transitionStop ();

         if (event .deltaY > 0) // Move backwards.
         {
            viewpoint ._fieldOfViewScale = Math .max (0.00001, viewpoint ._fieldOfViewScale .getValue () * (1 - SCROLL_FACTOR));
         }
         else if (event .deltaY < 0) // Move forwards.
         {
            viewpoint ._fieldOfViewScale = viewpoint ._fieldOfViewScale .getValue () * (1 + SCROLL_FACTOR);

            this .constrainFieldOfViewScale ();
         }

         if (viewpoint .set_fieldOfView___)
            viewpoint .set_fieldOfView___ (); // XXX: Immediately apply fieldOfViewScale;

         var
            toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
            translation = viewpoint .getUserOrientation () .multVecRot (vector .assign (fromPoint) .subtract (toPoint));

         viewpoint ._positionOffset         = positionOffset         .assign (viewpoint ._positionOffset         .getValue ()) .add (translation);
         viewpoint ._centerOfRotationOffset = centerOfRotationOffset .assign (viewpoint ._centerOfRotationOffset .getValue ()) .add (translation);
      },
      constrainFieldOfViewScale: function ()
      {
         var viewpoint = this .getActiveViewpoint ();

         if (viewpoint instanceof Viewpoint || viewpoint .getTypeName () === "GeoViewpoint")
         {
            if (viewpoint ._fieldOfView .getValue () * viewpoint ._fieldOfViewScale .getValue () >= Math .PI)
               viewpoint ._fieldOfViewScale = (Math .PI - 0.001) / viewpoint ._fieldOfView .getValue ();
         }
      },
      dispose: function ()
      {
         this .getBrowser () .getSurface () .unbind (".PlaneViewer");
         $(document) .unbind (".PlaneViewer" + this .getId ());
      },
   });

   return PlaneViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/NoneViewer',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Navigation/X3DViewer",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer)
{
"use strict";

   function NoneViewer (executionContext)
   {
      X3DViewer .call (this, executionContext);
   }

   NoneViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
   {
      constructor: NoneViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
   });

   return NoneViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/LookAtViewer',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Navigation/X3DViewer",
   "x_ite/Components/Followers/PositionChaser",
   "x_ite/Components/Followers/OrientationChaser",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          PositionChaser,
          OrientationChaser,
          Vector2,
          Vector3,
          Rotation4)
{
"use strict";

   var macOS = /Mac OS X/i .test (navigator .userAgent)

   var
      SCROLL_FACTOR = macOS ? 1 / 120 : 1 / 20,
      MOVE_TIME     = 0.3,
      ROTATE_TIME   = 0.3;

   function LookAtViewer (executionContext)
   {
      X3DViewer .call (this, executionContext);

      this .button                 = -1;
      this .fromVector             = new Vector3 (0, 0, 0);
      this .toVector               = new Vector3 (0, 0, 0);

      this .touch1                 = new Vector2 (0, 0);
      this .touch2                 = new Vector2 (0, 0);
      this .tapStart               = 0;
      this .dblTapInterval         = 0.4;

      this .positionChaser         = new PositionChaser (executionContext);
      this .centerOfRotationChaser = new PositionChaser (executionContext);
      this .orientationChaser      = new OrientationChaser (executionContext);
   }

   LookAtViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
   {
      constructor: LookAtViewer,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
      ]),
      initialize: function ()
      {
         X3DViewer .prototype .initialize .call (this);

         var
            browser = this .getBrowser (),
            element = browser .getSurface ();

         // Bind pointing device events.

         element .bind ("mousedown.LookAtViewer",  this .mousedown  .bind (this));
         element .bind ("mouseup.LookAtViewer",    this .mouseup    .bind (this));
         element .bind ("dblclick.LookAtViewer",   this .dblclick   .bind (this));
         element .bind ("mousewheel.LookAtViewer", this .mousewheel .bind (this));

         element .bind ("touchstart.LookAtViewer", this .touchstart .bind (this));
         element .bind ("touchend.LookAtViewer",   this .touchend   .bind (this));

         // Setup chaser.

         this .positionChaser ._duration = MOVE_TIME;
         this .positionChaser .setPrivate (true);
         this .positionChaser .setup ();

         this .centerOfRotationChaser ._duration = MOVE_TIME;
         this .centerOfRotationChaser .setPrivate (true);
         this .centerOfRotationChaser .setup ();

         this .orientationChaser ._duration = ROTATE_TIME;
         this .orientationChaser .setPrivate (true);
         this .orientationChaser .setup ();
      },
      mousedown: function (event)
      {
         if (this .button >= 0)
            return;

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (event .button)
         {
            case 0:
            {
               // Stop event propagation.

               event .preventDefault ();
               event .stopImmediatePropagation ();

               this .button = event .button;

               $(document) .bind ("mouseup.LookAtViewer"   + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("mousemove.LookAtViewer" + this .getId (), this .mousemove .bind (this));
               $(document) .bind ("touchend.LookAtViewer"  + this .getId (), this .mouseup   .bind (this));
               $(document) .bind ("touchmove.LookAtViewer" + this .getId (), this .touchmove .bind (this));

               this .getActiveViewpoint () .transitionStop ();

               // Look around.

               this .trackballProjectToSphere (x, y, this .fromVector);

               this ._isActive = true;
               break;
            }
         }
      },
      mouseup: function (event)
      {
         if (event .button !== this .button)
            return;

         this .button = -1;

         $(document) .unbind (".LookAtViewer" + this .getId ());

         switch (event .button)
         {
            case 0:
            {
               // Stop event propagation.

               event .preventDefault ();
               event .stopImmediatePropagation ();

               this ._isActive = false;
               break;
            }
         }
      },
      dblclick: function (event)
      {
         // Stop event propagation.
         event .preventDefault ();
         event .stopImmediatePropagation ();

         var
            element = this .getBrowser () .getSurface (),
            offset  = element .offset (),
            x       = event .pageX - offset .left - parseFloat (element .css ('borderLeftWidth')),
            y       = element .innerHeight () - (event .pageY - offset .top - parseFloat (element .css ('borderTopWidth')));

         this .disconnect ();
         this .lookAtPoint (x, y, this .getStraightenHorizon ());
      },
      mousemove: function (event)
      {
         this .getBrowser () .addBrowserEvent ();

         this .event = event;

         var
            offset = this .getBrowser () .getSurface () .offset (),
            x      = event .pageX - offset .left,
            y      = event .pageY - offset .top;

         switch (this .button)
         {
            case 0:
            {
               // Stop event propagation.
               event .preventDefault ();
               event .stopImmediatePropagation ();

               // Look around

               var toVector  = this .trackballProjectToSphere (x, y, this .toVector);

               this .addRotation (this .fromVector, toVector);
               this .fromVector .assign (toVector);
               break;
            }
         }
      },
      mousewheel: (function ()
      {
         var
            step        = new Vector3 (0, 0, 0),
            translation = new Vector3 (0, 0, 0);

         return function (event)
         {
            // Stop event propagation.
            event .preventDefault ();
            event .stopImmediatePropagation ();

            // Change viewpoint position.

            var viewpoint = this .getActiveViewpoint ();

            viewpoint .transitionStop ();

            step        = this .getDistanceToCenter (step) .multiply (event .zoomFactor || SCROLL_FACTOR),
            translation = viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .abs ()));

            if (event .deltaY > 0)
               this .addMove (translation .negate (), Vector3 .Zero);

            else if (event .deltaY < 0)
               this .addMove (translation, Vector3 .Zero);
         };
      })(),
      touchstart: function (event)
      {
         var touches = event .originalEvent .touches;

         switch (touches .length)
         {
            case 1:
            {
               // Start move (button 0).

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               break;
            }
            case 2:
            {
               // End move (button 0).

               this .touchend (event);

               // Start look around (button 0).

               event .button = 0;
               event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
               event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

               this .mousedown (event);

               // Start zoom (mouse wheel).

               this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
               this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
               break;
            }
            case 3:
            {
               this .touchend (event);
               break;
            }
         }
      },
      touchend: function (event)
      {
         switch (this .button)
         {
            case 0:
            {
               // End look around (button 0).
               this .mouseup (event);
               break;
            }
         }

         // Start dblclick (button 0).

         if (this .getBrowser () .getCurrentTime () - this .tapStart < this .dblTapInterval)
         {
            event .button = 1;
            event .pageX  = this .touch1 .x;
            event .pageY  = this .touch1 .y;

            this .dblclick (event);
         }

         this .tapStart = this .getBrowser () .getCurrentTime ();
      },
      touchmove: (function ()
      {
         var
            MOVE_ANGLE   = 0.7,
            ZOOM_ANGLE   = -0.7,
            touch1Change = new Vector2 (0, 0),
            touch2Change = new Vector2 (0, 0);

         return function (event)
         {
            var touches = event .originalEvent .touches;

            switch (touches .length)
            {
               case 1:
               {
                  // Move (button 0).
                  break;
               }
               case 2:
               {
                  touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
                  touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

                  var
                     move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
                     zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE;

                  if (move)
                  {
                     // Look around (button 0).

                     event .button = 0;
                     event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
                     event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

                     this .mousemove (event);
                  }
                  else if (zoom)
                  {
                     // Zoom (mouse wheel).

                     var distance1 = this .touch1 .distance (this .touch2);

                     this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                     this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

                     var
                        distance2 = this .touch1 .distance (this .touch2),
                        delta     = distance2 - distance1;

                     event .deltaY     = delta;
                     event .zoomFactor = Math .abs (delta) / $(window) .width ();

                     this .mousewheel (event);
                  }

                  this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
                  this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
                  break;
               }
            }
         };
      })(),
      set_positionOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._positionOffset = value;
      },
      set_centerOfRotationOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._centerOfRotationOffset = value;
      },
      set_orientationOffset__: function (value)
      {
         var viewpoint = this .getActiveViewpoint ();

         viewpoint ._orientationOffset = value;
      },
      addMove: (function ()
      {
         var
            positionOffset         = new Vector3 (0, 0, 0),
            centerOfRotationOffset = new Vector3 (0, 0, 0);

         return function (positionOffsetChange, centerOfRotationOffsetChange)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .positionChaser ._isActive .getValue () && this .positionChaser ._value_changed .hasInterest ("set_positionOffset__", this))
            {
               positionOffset
                  .assign (this .positionChaser ._set_destination .getValue ())
                  .add (positionOffsetChange);

               this .positionChaser ._set_destination = positionOffset;
            }
            else
            {
               positionOffset
                  .assign (viewpoint ._positionOffset .getValue ())
                  .add (positionOffsetChange);

               this .positionChaser ._set_value       = viewpoint ._positionOffset;
               this .positionChaser ._set_destination = positionOffset;
            }

            if (this .centerOfRotationChaser ._isActive .getValue () && this .centerOfRotationChaser ._value_changed .hasInterest ("set_centerOfRotationOffset__", this))
            {
               centerOfRotationOffset
                  .assign (this .centerOfRotationChaser ._set_destination .getValue ())
                  .add (centerOfRotationOffsetChange);

               this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
            }
            else
            {
               centerOfRotationOffset
                  .assign (viewpoint ._centerOfRotationOffset .getValue ())
                  .add (centerOfRotationOffsetChange);

               this .centerOfRotationChaser ._set_value       = viewpoint ._centerOfRotationOffset;
               this .centerOfRotationChaser ._set_destination = centerOfRotationOffset;
            }

            this .disconnect ();
            this .positionChaser         ._value_changed .addInterest ("set_positionOffset__",         this);
            this .centerOfRotationChaser ._value_changed .addInterest ("set_centerOfRotationOffset__", this);
         };
      })(),
      addRotation: (function ()
      {
         var
            userOrientation   = new Rotation4 (0, 0, 1, 0),
            orientationOffset = new Rotation4 (0, 0, 1, 0);

         return function (fromVector, toVector)
         {
            var viewpoint = this .getActiveViewpoint ();

            if (this .orientationChaser ._isActive .getValue () && this .orientationChaser ._value_changed .hasInterest ("set_orientationOffset__", this))
            {
               userOrientation
                  .setFromToVec (toVector, fromVector)
                  .multRight (viewpoint .getOrientation ())
                  .multRight (this .orientationChaser ._set_destination .getValue ());

               viewpoint .straightenHorizon (userOrientation);

               orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

               this .orientationChaser ._set_destination = orientationOffset;
            }
            else
            {
               userOrientation
                  .setFromToVec (toVector, fromVector)
                  .multRight (viewpoint .getUserOrientation ());

               viewpoint .straightenHorizon (userOrientation);

               orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

               this .orientationChaser ._set_value       = viewpoint ._orientationOffset;
               this .orientationChaser ._set_destination = orientationOffset;
            }

            this .disconnect ();
            this .orientationChaser ._value_changed .addInterest ("set_orientationOffset__", this);
         };
      })(),
      disconnect: function ()
      {
         this .orientationChaser      ._value_changed .removeInterest ("set_orientationOffset__", this);
         this .positionChaser         ._value_changed .removeInterest ("set_positionOffset__",         this)
         this .centerOfRotationChaser ._value_changed .removeInterest ("set_centerOfRotationOffset__", this)
      },
      dispose: function ()
      {
         this .getBrowser () .getSurface () .unbind (".LookAtViewer");
         $(document) .unbind (".LookAtViewer" + this .getId ());
      },
   });

   return LookAtViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/X3DLightNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithm",
],
function (X3DChildNode,
          X3DConstants,
          Matrix4,
          Algorithm)
{
"use strict";

   function X3DLightNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DLightNode);
   }

   X3DLightNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DLightNode,
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);

         this ._on        .addInterest ("set_on__", this);
         this ._intensity .addInterest ("set_on__", this);

         this .set_on__ ();
      },
      set_on__: function ()
      {
         if (this ._on .getValue () && this .getIntensity () > 0)
         {
            delete this .push;
            delete this .pop;
         }
         else
         {
            this .push = Function .prototype;
            this .pop  = Function .prototype;
         }
      },
      getGlobal: function ()
      {
         return this ._global .getValue ();
      },
      getColor: function ()
      {
         return this ._color .getValue ();
      },
      getIntensity: function ()
      {
         return Math .max (this ._intensity .getValue (), 0);
      },
      getAmbientIntensity: function ()
      {
         return Algorithm .clamp (this ._ambientIntensity .getValue (), 0, 1);
      },
      getDirection: function ()
      {
         return this ._direction .getValue ();
      },
      getShadows: function ()
      {
         return this ._shadows .getValue ();
      },
      getShadowColor: function ()
      {
         return this ._shadowColor .getValue ();
      },
      getShadowIntensity: function ()
      {
         return this .getShadows () ? Algorithm .clamp (this ._shadowIntensity .getValue (), 0, 1) : 0;
      },
      getShadowBias: function ()
      {
         return Algorithm .clamp (this ._shadowBias .getValue (), 0, 1);
      },
      getShadowMapSize: function ()
      {
         return Math .min (this ._shadowMapSize .getValue (), this .getBrowser () .getMaxTextureSize ());
      },
      getBiasMatrix: (function ()
      {
         // Transforms normalized coords from range (-1, 1) to (0, 1).
         const biasMatrix = new Matrix4 (0.5, 0.0, 0.0, 0.0,
                                         0.0, 0.5, 0.0, 0.0,
                                         0.0, 0.0, 0.5, 0.0,
                                         0.5, 0.5, 0.5, 1.0);

         return function ()
         {
            return biasMatrix;
         };
      })(),
      push: function (renderObject, group)
      {
         if (renderObject .isIndependent ())
         {
            const lightContainer = this .getLights () .pop ();

            if (this ._global .getValue ())
            {
               lightContainer .set (renderObject .getBrowser (),
                                    this,
                                    renderObject .getLayer () .getGroup (),
                                    renderObject .getModelViewMatrix () .get ());

               renderObject .getGlobalObjects () .push (lightContainer);
               renderObject .getLights ()        .push (lightContainer);
            }
            else
            {
               lightContainer .set (renderObject .getBrowser (),
                                    this,
                                    group,
                                    renderObject .getModelViewMatrix () .get ());

               renderObject .getLocalObjects () .push (lightContainer);
               renderObject .getLights ()       .push (lightContainer);
            }
         }
         else
         {
            const lightContainer = renderObject .getLightContainer ();

            if (this ._global .getValue ())
            {
               lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

               renderObject .getGlobalObjects () .push (lightContainer);
               renderObject .getLights ()        .push (lightContainer);
            }
            else
            {
               lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

               renderObject .getLocalObjects () .push (lightContainer);
               renderObject .getLights ()       .push (lightContainer);
            }
         }

         renderObject .pushShadow (this .getShadowIntensity ());
      },
      pop: function (renderObject)
      {
         if (this ._global .getValue ())
            return;

         if (renderObject .isIndependent ())
            renderObject .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());
         else
            renderObject .getLocalObjects () .pop ();

         renderObject .popShadow ();
      },
   });

   return X3DLightNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/DirectionalLight',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Lighting/X3DLightNode",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/Camera",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Utility/MatrixStack",
   "standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode,
          X3DGroupingNode,
          TraverseType,
          X3DConstants,
          Box3,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix4,
          MatrixStack,
          ObjectCache)
{
"use strict";

   const DirectionalLights = ObjectCache (DirectionalLightContainer);

   function DirectionalLightContainer ()
   {
      this .direction                     = new Vector3 (0, 0, 0);
      this .shadowBuffer                  = null;
      this .bbox                          = new Box3 ();
      this .viewVolume                    = new ViewVolume ();
      this .viewport                      = new Vector4 (0, 0, 0, 0);
      this .projectionMatrix              = new Matrix4 ();
      this .modelViewMatrix               = new MatrixStack (Matrix4);
      this .modelMatrix                   = new Matrix4 ();
      this .invLightSpaceMatrix           = new Matrix4 ();
      this .invLightSpaceProjectionMatrix = new Matrix4 ();
      this .shadowMatrix                  = new Matrix4 ();
      this .shadowMatrixArray             = new Float32Array (16);
      this .rotation                      = new Rotation4 ();
      this .textureUnit                   = undefined;
   }

   DirectionalLightContainer .prototype =
   {
      constructor: DirectionalLightContainer,
      getModelViewMatrix: function ()
      {
         return this .modelViewMatrix;
      },
      set: function (browser, lightNode, groupNode, modelViewMatrix)
      {
         const shadowMapSize = lightNode .getShadowMapSize ();

         this .browser   = browser;
         this .lightNode = lightNode;
         this .groupNode = groupNode;

         this .modelViewMatrix .pushMatrix (modelViewMatrix);

         // Get shadow buffer from browser.

         if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
         {
            this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

            if (!this .shadowBuffer)
               console .warn ("Couldn't create shadow buffer.");
         }
      },
      renderShadowMap: function (renderObject)
      {
         if (! this .shadowBuffer)
            return;

         const
            lightNode            = this .lightNode,
            cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
            modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
            invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

         invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Vector3 .zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
         invLightSpaceMatrix .inverse ();

         const
            groupBBox        = this .groupNode .getSubBBox (this .bbox, true), // Group bbox.
            lightBBox        = groupBBox .multRight (invLightSpaceMatrix),     // Group bbox from the perspective of the light.
            shadowMapSize    = lightNode .getShadowMapSize (),
            viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
            projectionMatrix = Camera .orthoBox (lightBBox, this .projectionMatrix);

         this .shadowBuffer .bind ();

         renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
         renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
         renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

         renderObject .render (TraverseType .SHADOW, X3DGroupingNode .prototype .traverse, this .groupNode);

         renderObject .getModelViewMatrix  () .pop ();
         renderObject .getProjectionMatrix () .pop ();
         renderObject .getViewVolumes      () .pop ();

         this .shadowBuffer .unbind ();

         if (! lightNode .getGlobal ())
            invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

         this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
      },
      setGlobalVariables: function (renderObject)
      {
         this .modelViewMatrix .get () .multDirMatrix (this .direction .assign (this .lightNode .getDirection ())) .normalize ();

         this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
         this .shadowMatrixArray .set (this .shadowMatrix);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const i = shaderObject .numLights ++;

         if (shaderObject .hasLight (i, this))
            return;

         const
            lightNode = this .lightNode,
            color     = lightNode .getColor (),
            direction = this .direction;

         gl .uniform1i (shaderObject .x3d_LightType [i],             1);
         gl .uniform3f (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
         gl .uniform1f (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
         gl .uniform1f (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
         gl .uniform3f (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);

         if (this .shadowBuffer)
         {
            const
               browser     = this .browser,
               shadowColor = lightNode .getShadowColor ();

            gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
            gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
            gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
            gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
            gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());

            this .textureUnit = lightNode .getGlobal ()
               ? this .textureUnit === undefined ? browser .popTexture2DUnit () : this .textureUnit
               : browser .getTexture2DUnit ();

            if (this .textureUnit !== undefined)
            {
               gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

               if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
               else
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

               gl .uniform1i (shaderObject .x3d_ShadowMap [i], this .textureUnit);
            }
            else
            {
               console .warn ("Not enough combined texture units for shadow map available.");
            }
         }
      },
      dispose: function ()
      {
         // Return shadowBuffer and textureUnit.

         this .browser .pushShadowBuffer (this .shadowBuffer);

         if (this .lightNode .getGlobal ())
            this .browser .pushTexture2DUnit (this .textureUnit);

         this .modelViewMatrix .clear ();

         this .browser      = null;
         this .lightNode    = null;
         this .groupNode    = null;
         this .shadowBuffer = null;
         this .textureUnit  = undefined;

         // Return container

         DirectionalLights .push (this);
      },
   };

   function DirectionalLight (executionContext)
   {
      X3DLightNode .call (this, executionContext);

      this .addType (X3DConstants .DirectionalLight);

      if (executionContext .getSpecificationVersion () === "2.0")
         this ._global = true;
   }

   DirectionalLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
   {
      constructor: DirectionalLight,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (false)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",        new Fields .SFVec3f (0, 0, -1)),

         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadows",         new  Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat (1)),       // Intensity of shadow color in the range (0, 1).
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
         new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
      ]),
      getTypeName: function ()
      {
         return "DirectionalLight";
      },
      getComponentName: function ()
      {
         return "Lighting";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getLights: function ()
      {
         return DirectionalLights;
      },
   });

   return DirectionalLight;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DNavigationContext',[
   "x_ite/Fields",
   "x_ite/Browser/Navigation/ExamineViewer",
   "x_ite/Browser/Navigation/WalkViewer",
   "x_ite/Browser/Navigation/FlyViewer",
   "x_ite/Browser/Navigation/PlaneViewer",
   "x_ite/Browser/Navigation/NoneViewer",
   "x_ite/Browser/Navigation/LookAtViewer",
   "x_ite/Components/Lighting/DirectionalLight",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          ExamineViewer,
          WalkViewer,
          FlyViewer,
          PlaneViewer,
          NoneViewer,
          LookAtViewer,
          DirectionalLight,
          Matrix4)
{
"use strict";

   const
      _activeCollisions   = Symbol (),
      _viewerNode         = Symbol (),
      _headlightContainer = Symbol ();


   function getHeadLight (browser)
   {
      const headlight = new DirectionalLight (browser .getPrivateScene ());

      headlight .setup ();

      const headlightContainer = headlight .getLights () .pop ();

      headlightContainer .set (browser, headlight, null, Matrix4 .Identity);
      headlightContainer .dispose = Function .prototype;

      return headlightContainer;
   };

   function X3DNavigationContext ()
   {
      this .addChildObjects ("activeLayer",          new Fields .SFNode (),
                             "activeNavigationInfo", new Fields .SFNode (),
                             "activeViewpoint",      new Fields .SFNode (),
                             "availableViewers",     new Fields .MFString (),
                             "viewer",               new Fields .SFString ("EXAMINE"));

      this [_activeCollisions] = new Set ();
      this [_viewerNode]       = new NoneViewer (this);
   }

   X3DNavigationContext .prototype =
   {
      initialize: function ()
      {
         this ._viewer .addInterest ("set_viewer__", this);

         this .initialized () .addInterest ("set_world__",    this);
         this .shutdown ()    .addInterest ("remove_world__", this);

         this [_headlightContainer] = getHeadLight (this);
         this [_viewerNode] .setup ();
      },
      getHeadlight: function ()
      {
         return this [_headlightContainer];
      },
      getActiveLayer: function ()
      {
         return this ._activeLayer .getValue ();
      },
      getActiveNavigationInfo: function ()
      {
         return this ._activeNavigationInfo .getValue ();
      },
      getActiveViewpoint: function ()
      {
         return this ._activeViewpoint .getValue ();
      },
      getCurrentViewer: function ()
      {
         return this ._viewer .getValue ();
      },
      getViewer: function ()
      {
         return this [_viewerNode];
      },
      addCollision: function (object)
      {
         this [_activeCollisions] .add (object);
      },
      removeCollision: function (object)
      {
         this [_activeCollisions] .delete (object);
      },
      getCollisionCount: function ()
      {
         return this [_activeCollisions] .size;
      },
      remove_world__: function ()
      {
         this .getWorld () ._activeLayer .removeInterest ("set_activeLayer__", this);
      },
      set_world__: function ()
      {
         this .getWorld () ._activeLayer .addInterest ("set_activeLayer__", this);

         this .set_activeLayer__ ();
      },
      set_activeLayer__: function ()
      {
         if (this ._activeLayer .getValue ())
         {
            this ._activeLayer .getValue () .getNavigationInfoStack () .removeInterest ("set_activeNavigationInfo__", this);
            this ._activeLayer .getValue () .getViewpointStack ()      .removeInterest ("set_activeViewpoint__",      this);
         }

         this ._activeLayer = this .getWorld () .getActiveLayer ();

         if (this ._activeLayer .getValue ())
         {
            this ._activeLayer .getValue () .getNavigationInfoStack () .addInterest ("set_activeNavigationInfo__", this);
            this ._activeLayer .getValue () .getViewpointStack ()      .addInterest ("set_activeViewpoint__",      this);
         }

         this .set_activeNavigationInfo__ ();
         this .set_activeViewpoint__ ();
      },
      set_activeNavigationInfo__: function ()
      {
         if (this ._activeNavigationInfo .getValue ())
            this ._activeNavigationInfo .getValue () ._viewer .removeFieldInterest (this ._viewer);

         if (this ._activeLayer .getValue ())
         {
            this ._activeNavigationInfo = this ._activeLayer .getValue () .getNavigationInfo ();

            this ._activeNavigationInfo .getValue () ._viewer .addFieldInterest (this ._viewer);

            this ._viewer = this ._activeNavigationInfo .getValue () ._viewer;
         }
         else
         {
            this ._activeNavigationInfo = null;
            this ._viewer               = "NONE";
         }
      },
      set_activeViewpoint__: function ()
      {
         if (this ._activeLayer .getValue ())
            this ._activeViewpoint = this ._activeLayer .getValue () .getViewpoint ();
         else
            this ._activeViewpoint = null;
      },
      set_viewer__: function (viewer)
      {
         if (this ._activeNavigationInfo .getValue ())
            this ._availableViewers = this ._activeNavigationInfo .getValue () ._availableViewers;
         else
            this ._availableViewers .length = 0;

         // Create viewer node.

         if (this [_viewerNode])
            this [_viewerNode] .dispose ();

         switch (viewer .getValue ())
         {
            case "EXAMINE":
               this [_viewerNode] = new ExamineViewer (this);
               break;
            case "WALK":
               this [_viewerNode] = new WalkViewer (this);
               break;
            case "FLY":
               this [_viewerNode] = new FlyViewer (this);
               break;
            case "PLANE":
            case "PLANE_create3000.de":
               this [_viewerNode] = new PlaneViewer (this);
               break;
            case "NONE":
               this [_viewerNode] = new NoneViewer (this);
               break;
            case "LOOKAT":
               this [_viewerNode] = new LookAtViewer (this);
               break;
            default:
               this [_viewerNode] = new ExamineViewer (this);
               break;
         }

         this [_viewerNode] .setup ();
      },
   };

   return X3DNavigationContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/Viewport',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Layering/X3DViewportNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Rendering/TraverseType",
   "standard/Utility/ObjectCache",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewportNode,
          X3DConstants,
          TraverseType,
          ObjectCache,
          ViewVolume,
          Vector4)
{
"use strict";

   const ViewVolumes = ObjectCache (ViewVolume);

   function Viewport (executionContext)
   {
      X3DViewportNode .call (this, executionContext);

      this .addType (X3DConstants .Viewport);

      this .rectangle = new Vector4 (0, 0, 0, 0);
   }

   Viewport .prototype = Object .assign (Object .create (X3DViewportNode .prototype),
   {
      constructor: Viewport,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "clipBoundary",   new Fields .MFFloat (0, 1, 0, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Viewport";
      },
      getComponentName: function ()
      {
         return "Layering";
      },
      getContainerField: function ()
      {
         return "viewport";
      },
      getRectangle: function (browser)
      {
         const viewport = browser .getViewport ();

         const
            left   = Math .floor (viewport [2] * this .getLeft ()),
            right  = Math .floor (viewport [2] * this .getRight ()),
            bottom = Math .floor (viewport [3] * this .getBottom ()),
            top    = Math .floor (viewport [3] * this .getTop ());

         this .rectangle .set (left,
                               bottom,
                               Math .max (0, right - left),
                               Math .max (0, top - bottom));

         return this .rectangle;
      },
      getLeft: function ()
      {
         return this ._clipBoundary .length > 0 ? this ._clipBoundary [0] : 0;
      },
      getRight: function ()
      {
         return this ._clipBoundary .length > 1 ? this ._clipBoundary [1] : 1;
      },
      getBottom: function ()
      {
         return this ._clipBoundary .length > 2 ? this ._clipBoundary [2] : 0;
      },
      getTop: function ()
      {
         return this ._clipBoundary .length > 3 ? this ._clipBoundary [3] : 1;
      },
      traverse: function (type, renderObject)
      {
         this .push (renderObject);

         switch (type)
         {
            case TraverseType .POINTER:
            {
               if (renderObject .getBrowser () .isPointerInRectangle (this .rectangle))
                  X3DViewportNode .prototype .traverse .call (this, type, renderObject);

               break;
            }
            default:
               X3DViewportNode .prototype .traverse .call (this, type, renderObject);
               break;
         }

         this .pop (renderObject);
      },
      push: function (renderObject)
      {
         const
            viewVolumes = renderObject .getViewVolumes (),
            rectangle   = this .getRectangle (renderObject .getBrowser ()),
            viewport    = viewVolumes .length ? viewVolumes .at (-1) .getViewport () : rectangle,
            viewVolume  = ViewVolumes .pop ();

         viewVolume .set (renderObject .getProjectionMatrix () .get (), viewport, rectangle);

         viewVolumes .push (viewVolume);
      },
      pop: function (renderObject)
      {
         ViewVolumes .push (renderObject .getViewVolumes () .pop ());
      },
   });

   return Viewport;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Layering/X3DLayeringContext',[
   "x_ite/Components/Layering/Viewport",
],
function (Viewport)
{
"use strict";

   const _defaultViewport = Symbol ();

   function X3DLayeringContext ()
   {
      this [_defaultViewport] = new Viewport (this .getPrivateScene ());
   }

   X3DLayeringContext .prototype =
   {
      initialize: function ()
      {
         this [_defaultViewport] .setup ();
      },
      getDefaultViewport: function ()
      {
         return this [_defaultViewport];
      },
   };

   return X3DLayeringContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/EnvironmentalEffects/X3DEnvironmentalEffectsContext',[
   "x_ite/Components/Texturing/TextureProperties",
],
function (TextureProperties)
{
"use strict";

   const
      _backgroundSphereShader      = Symbol (),
      _backgroundTextureProperties = Symbol ();

   function X3DEnvironmentalEffectsContext () { }

   X3DEnvironmentalEffectsContext .prototype =
   {
      initialize: function () { },
      getBackgroundSphereShader: function ()
      {
         this [_backgroundSphereShader] = this .createShader ("BackgroundSphereShader", "Background");

         this .getBackgroundSphereShader = function () { return this [_backgroundSphereShader]; };

         Object .defineProperty (this, "getBackgroundSphereShader", { enumerable: false });

         return this [_backgroundSphereShader];
      },
      getBackgroundTextureProperties: function ()
      {
         this [_backgroundTextureProperties] = new TextureProperties (this .getPrivateScene ());

         this [_backgroundTextureProperties] ._boundaryModeS       = "CLAMP_TO_EDGE";
         this [_backgroundTextureProperties] ._boundaryModeT       = "CLAMP_TO_EDGE";
         this [_backgroundTextureProperties] ._boundaryModeR       = "CLAMP_TO_EDGE";
         this [_backgroundTextureProperties] ._minificationFilter  = "NICEST";
         this [_backgroundTextureProperties] ._magnificationFilter = "NICEST";
         this [_backgroundTextureProperties] .setup ();

         this .getBackgroundTextureProperties = function () { return this [_backgroundTextureProperties]; };

         Object .defineProperty (this, "getBackgroundTextureProperties", { enumerable: false });

         return this [_backgroundTextureProperties];
      },
   };

   return X3DEnvironmentalEffectsContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Lighting/X3DLightingContext',[
   "x_ite/Rendering/TextureBuffer",
],
function (TextureBuffer)
{
"use strict";

   const
      _maxLights     = Symbol (),
      _shadowBuffers = Symbol ();

   function X3DLightingContext ()
   {
      const
         gl                    = this .getContext (),
         maxVertexTextureUnits = gl .getParameter (gl .MAX_VERTEX_TEXTURE_IMAGE_UNITS);

      if (maxVertexTextureUnits > 16)
         this [_maxLights] = 8;
      else if (maxVertexTextureUnits > 8)
         this [_maxLights] = 4;
      else
         this [_maxLights] = 2;

      this [_shadowBuffers] = [ ]; // Shadow buffer cache
   }

   X3DLightingContext .prototype =
   {
      initialize: function ()
      { },
      getMaxLights: function ()
      {
         return this [_maxLights];
      },
      popShadowBuffer: function (shadowMapSize)
      {
         try
         {
            const shadowBuffers = this [_shadowBuffers] [shadowMapSize];

            if (shadowBuffers)
            {
               if (shadowBuffers .length)
                  return shadowBuffers .pop ();
            }
            else
               this [_shadowBuffers] [shadowMapSize] = [ ];

            return new TextureBuffer (this, shadowMapSize, shadowMapSize);
         }
         catch (error)
         {
            // Couldn't create texture buffer.
            console .error (error);

            return null;
         }
      },
      pushShadowBuffer: function (buffer)
      {
         if (buffer)
            this [_shadowBuffers] [buffer .getWidth ()] .push (buffer);
      },
   };

   return X3DLightingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Picking/X3DPickingContext',[
   "x_ite/Rendering/TraverseType",
],
function (TraverseType)
{
"use strict";

   const
      _transformSensorNodes = Symbol (),
      _pickSensorNodes      = Symbol (),
      _pickingHierarchy     = Symbol (),
      _pickable             = Symbol (),
      _pickingTime          = Symbol ();

   function X3DPickingContext ()
   {
      this [_transformSensorNodes] = new Set ();
      this [_pickSensorNodes]      = [ new Set () ];
      this [_pickingHierarchy]     = [ ];
      this [_pickable]             = [ false ];
      this [_pickingTime]          = 0;
   }

   X3DPickingContext .prototype =
   {
      initialize: function ()
      { },
      addTransformSensor: function (transformSensorNode)
      {
         this [_transformSensorNodes] .add (transformSensorNode);
         this .enablePicking ();
      },
      removeTransformSensor: function (transformSensorNode)
      {
         this [_transformSensorNodes] .delete (transformSensorNode);
         this .enablePicking ();
      },
      addPickSensor: function (pickSensorNode)
      {
         this [_pickSensorNodes] [0] .add (pickSensorNode);
         this .enablePicking ();
      },
      removePickSensor: function (pickSensorNode)
      {
         this [_pickSensorNodes] [0] .delete (pickSensorNode);
         this .enablePicking ();
      },
      getPickSensors: function ()
      {
         return this [_pickSensorNodes];
      },
      getPickingHierarchy: function ()
      {
         return this [_pickingHierarchy];
      },
      getPickable: function ()
      {
         return this [_pickable];
      },
      enablePicking: function ()
      {
         if (this [_transformSensorNodes] .size || this [_pickSensorNodes] [0] .size)
            this ._sensorEvents .addInterest ("picking", this);
         else
            this ._sensorEvents .removeInterest ("picking", this);
      },
      picking: function ()
      {
         const t0 = performance .now ();

         this .getWorld () .traverse (TraverseType .PICKING, null);

         for (const transformSensorNode of this [_transformSensorNodes])
         {
            transformSensorNode .process ();
         }

         for (const pickSensorNode of this [_pickSensorNodes] [0])
         {
            pickSensorNode .process ();
         }

         this [_pickingTime] = performance .now () - t0;
      },
      getPickingTime: function ()
      {
         return this [_pickingTime];
      },
   };

   return X3DPickingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Sound/X3DSoundContext',[
   "x_ite/Fields",
],
function (Fields)
{
"use strict";

   function X3DSoundContext ()
   {
      this .addChildObjects ("volume", new Fields .SFFloat (1),
                             "mute",   new Fields .SFBool ());
   }

   X3DSoundContext .prototype =
   {
      initialize: function () { },
   };

   return X3DSoundContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/TextAlignment',[],function ()
{
"use strict";

   let i = 0;

   const TextAlignment =
   {
      BEGIN:  ++ i,
      FIRST:  ++ i,
      MIDDLE: ++ i,
      END:    ++ i,
   };

   return TextAlignment;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/X3DFontStyleNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Browser/Text/TextAlignment",
   "x_ite/InputOutput/FileLoader",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Networking/urls",
],
function (Fields,
          X3DNode,
          X3DUrlObject,
          TextAlignment,
          FileLoader,
          X3DConstants,
          urls)
{
"use strict";

   /*
    * Font paths for default SERIF, SANS and TYPWRITER families.
    */

   const Fonts =
   {
      SERIF: {
         PLAIN:      urls .getFontsUrl ("DroidSerif-Regular.ttf"),
         ITALIC:     urls .getFontsUrl ("DroidSerif-Italic.ttf"),
         BOLD:       urls .getFontsUrl ("DroidSerif-Bold.ttf"),
         BOLDITALIC: urls .getFontsUrl ("DroidSerif-BoldItalic.ttf"),
      },
      SANS: {
         PLAIN:      urls .getFontsUrl ("Ubuntu-R.ttf"),
         ITALIC:     urls .getFontsUrl ("Ubuntu-RI.ttf"),
         BOLD:       urls .getFontsUrl ("Ubuntu-B.ttf"),
         BOLDITALIC: urls .getFontsUrl ("Ubuntu-BI.ttf"),
      },
      TYPEWRITER: {
         PLAIN:      urls .getFontsUrl ("UbuntuMono-R.ttf"),
         ITALIC:     urls .getFontsUrl ("UbuntuMono-RI.ttf"),
         BOLD:       urls .getFontsUrl ("UbuntuMono-B.ttf"),
         BOLDITALIC: urls .getFontsUrl ("UbuntuMono-BI.ttf"),
      },
   };

   function X3DFontStyleNode (executionContext)
   {
      X3DNode      .call (this, executionContext);
      X3DUrlObject .call (this, executionContext);

      this .addType (X3DConstants .X3DFontStyleNode);

      this .addChildObjects ("load",                 new Fields .SFBool (true),
                             "autoRefresh",          new Fields .SFTime (),
                             "autoRefreshTimeLimit", new Fields .SFTime (3600));

      this .addAlias ("url", this ._family);

      this .familyStack = [ ];
      this .alignments  = [ ];
      this .loader      = new FileLoader (this);
   }

   X3DFontStyleNode .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: X3DFontStyleNode,
      initialize: function ()
      {
         X3DNode      .prototype .initialize .call (this);
         X3DUrlObject .prototype .initialize .call (this);

         this ._style   .addInterest ("set_style__",   this);
         this ._justify .addInterest ("set_justify__", this);

         this .font        = null;
         this .familyIndex = 0;

         this .set_justify__ ();
         this .set_style__ ();

         this .requestImmediateLoad ();
      },
      set_style__: function ()
      {
         if (!this ._load .getValue ())
            return;

         this .setLoadState (X3DConstants .NOT_STARTED_STATE);

         this .requestImmediateLoad ();
      },
      set_justify__: function ()
      {
         const majorNormal = this ._horizontal .getValue () ? this ._leftToRight .getValue () : this ._topToBottom .getValue ();

         this .alignments [0] = this ._justify .length > 0
                                ? this .getAlignment (0, majorNormal)
                                : majorNormal ? TextAlignment .BEGIN : TextAlignment .END;

         const minorNormal = this ._horizontal .getValue () ? this ._topToBottom .getValue () : this ._leftToRight .getValue ();

         this .alignments [1] = this ._justify .length > 1
                                ? this .getAlignment (1, minorNormal)
                                : minorNormal ? TextAlignment .FIRST : TextAlignment .END;
      },
      getMajorAlignment: function ()
      {
         return this .alignments [0];
      },
      getMinorAlignment: function ()
      {
         return this .alignments [1];
      },
      getAlignment: function (index, normal)
      {
         if (normal)
         {
            // Return for west-european normal alignment.

            switch (this ._justify [index])
            {
               case "FIRST":  return TextAlignment .FIRST;
               case "BEGIN":  return TextAlignment .BEGIN;
               case "MIDDLE": return TextAlignment .MIDDLE;
               case "END":    return TextAlignment .END;
            }
         }
         else
         {
            // Return appropriate alignment if topToBottom or leftToRight are FALSE.

            switch (this ._justify [index])
            {
               case "FIRST":  return TextAlignment .END;
               case "BEGIN":  return TextAlignment .END;
               case "MIDDLE": return TextAlignment .MIDDLE;
               case "END":    return TextAlignment .BEGIN;
            }
         }

         return index ? TextAlignment .FIRST : TextAlignment .BEGIN;
      },
      getDefaultFont: function (familyName)
      {
         const family = Fonts [familyName];

         if (family)
            return family [this ._style .getValue ()] || family .PLAIN;

         return;
      },
      loadNow: function ()
      {
         // Add default font to family array.

         const family = this ._url .copy ();

         family .push ("SERIF");

         // Build family stack.

         this .familyStack .length = 0;

         for (const familyName of family)
            this .familyStack .push (this .getDefaultFont (familyName) || familyName);

         this .loadNext ();
      },
      loadNext: function ()
      {
         try
         {
            if (this .familyStack .length === 0)
            {
               this .setLoadState (X3DConstants .FAILED_STATE);
               this .font = null;
               return;
            }

            this .family = this .familyStack .shift ();
            this .URL    = new URL (this .family, this .loader .getReferer ());

            if (this .URL .protocol !== "data:")
            {
               if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
                  this .URL .searchParams .set ("_", Date .now ());
            }

            this .getBrowser () .getFont (this .URL)
               .done (this .setFont .bind (this))
               .fail (this .setError .bind (this));
         }
         catch (error)
         {
            this .setError (error .message);
         }
      },
      setError: function (error)
      {
         if (this .URL .protocol !== "data:")
            console .warn ("Error loading font '" + decodeURI (this .URL .href) + "':", error);

         this .loadNext ();
      },
      setFont: function (font)
      {
         this .font = font;

         this .setLoadState (X3DConstants .COMPLETE_STATE);
         this .addNodeEvent ();
      },
      getFont: function ()
      {
         return this .font;
      },
   });

   return X3DFontStyleNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Box2',[
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Vector2",
],
function (Matrix3, Vector2)
{
"use strict";

   function Box2 (size, center)
   {
      switch (arguments .length)
      {
         case 0:
         {
            this .matrix = new Matrix3 (0, 0, 0,
                                        0, 0, 0,
                                        0, 0, 0);
            return;
         }
         case 2:
         {
            this .matrix = new Matrix3 (size .x / 2, 0, 0,
                                        0, size .y / 2, 0,
                                        center .x, center .y, 1);
            return;
         }
         case 3:
         {
            const
               min = arguments [0],
               max = arguments [1],
               sx  = (max .x - min .x) / 2,
               sy  = (max .y - min .y) / 2,
               cx  = (max .x + min .x) / 2,
               cy  = (max .y + min .y) / 2;

            this .matrix = new Matrix3 (sx, 0,  0,
                                        0,  sy, 0,
                                        cx, cy, 1);
            return;
         }
      }
   }

   Box2 .prototype =
   {
      constructor: Box2,
      copy: function ()
      {
         const copy = Object .create (Box2 .prototype);
         copy .matrix = this .matrix .copy ();
         return copy;
      },
      assign: function (box)
      {
         this .matrix .assign (box .matrix);
         return this;
      },
      equals: function (box)
      {
         return this .matrix .equals (box .matrix);
      },
      set: function (size, center)
      {
         const m = this .matrix;

         switch (arguments .length)
         {
            case 0:
            {
               m [0] = 0.5; m [1] = 0;   m [2] = 0;
               m [3] = 0;   m [4] = 0.5; m [5] = 0;
               m [6] = 0;   m [7] = 0;   m [8] = 0;
               return this;
            }
            case 2:
            {
               // size, center
               m [0] = size .x / 2; m [1] = 0;           m [2] = 0;
               m [3] = 0;           m [4] = size .y / 2; m [5] = 0;
               m [6] = center .x;   m [7] = center .y;   m [8] = 1;
               return this;
            }
            case 3:
            {
               const
                  min = arguments [0],
                  max = arguments [1],
                  sx  = (max .x - min .x) / 2,
                  sy  = (max .y - min .y) / 2,
                  cx  = (max .x + min .x) / 2,
                  cy  = (max .y + min .y) / 2;

               this .matrix .set (sx, 0,  0,
                                  0,  sy, 0,
                                  cx, cy, 1);
               return this;
            }
         }
      },
      setExtents: function (min, max)
      {
         const
            m  = this .matrix,
            sx = (max .x - min .x) / 2,
            sy = (max .y - min .y) / 2,
            cx = (max .x + min .x) / 2,
            cy = (max .y + min .y) / 2;

         m [0] = sx; m [1] = 0;  m [2] = 0;
         m [3] = 0;  m [4] = sy; m [5] = 0;
         m [6] = cx; m [7] = cy; m [8] = 1;
         return this;
      },
      isEmpty: function ()
      {
         return this .matrix [8] === 0;
      },
      add: (function ()
      {
         const
            lhs_min = new Vector2 (0, 0),
            lhs_max = new Vector2 (0, 0),
            rhs_min = new Vector2 (0, 0),
            rhs_max = new Vector2 (0, 0);

         return function (box)
         {
            if (this .isEmpty ())
               return this .assign (box);

            if (box .isEmpty ())
               return this;

            this .getExtents (lhs_min, lhs_max);
            box  .getExtents (rhs_min, rhs_max);

            return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
         };
      })(),
      multLeft: function (matrix)
      {
         this .matrix .multLeft (matrix);
         return this;
      },
      multRight: function (matrix)
      {
         this .matrix .multRight (matrix);
         return this;
      },
      getExtents: function (min, max)
      {
         this .getAbsoluteExtents (min, max);

         min .add (this .center);
         max .add (this .center);
      },
      getAbsoluteExtents: (function ()
      {
         const p1 = new Vector2 (0, 0);

         return function (min, max)
         {
            const
               m = this .matrix,
               x = m .xAxis,
               y = m .yAxis;

            p1 .assign (x) .add (y);

            const p2 = y .subtract (x);

            min .assign (p1) .min (p2);
            max .assign (p1) .max (p2);

            p1 .negate ();
            p2 .negate ();

            min .min (p1, p2);
            max .max (p1, p2);
         };
      })(),
      containsPoint: (function ()
      {
         const
            min = new Vector2 (0, 0),
            max = new Vector2 (0, 0);

         return function (point)
         {
            this .getExtents (min, max);

            return min .x <= point .x &&
                   max .x >= point .x &&
                   min .y <= point .y &&
                   max .y >= point .y;
         };
      })(),
      toString: function ()
      {
         return this .size + ", " + this .center;
      },
   };

   Object .defineProperty (Box2 .prototype, "size",
   {
      get: (function ()
      {
         const
            min = new Vector2 (0, 0),
            max = new Vector2 (0, 0);

         return function ()
         {
            this .getAbsoluteExtents (min, max);

            return max .subtract (min);
         };
      })(),
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (Box2 .prototype, "center",
   {
      get: function ()
      {
         return this .matrix .origin;
      },
      enumerable: true,
      configurable: false
   });

   return Box2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/X3DTextGeometry',[
   "x_ite/Browser/Text/TextAlignment",
   "standard/Math/Geometry/Box2",
   "standard/Math/Geometry/Box3",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
],
function (TextAlignment,
          Box2,
          Box3,
          Vector2,
          Vector3)
{
"use strict";

   var
      bbox        = new Box2 (),
      lineBBox    = new Box2 (),
      min         = new Vector2 (0, 0),
      max         = new Vector2 (0, 0),
      glyphMin    = new Vector2 (0, 0),
      glyphMax    = new Vector2 (0, 0),
      min3        = new Vector3 (0, 0, 0),
      max3        = new Vector3 (0, 0, 0),
      size        = new Vector2 (0, 0),
      center      = new Vector2 (0, 0),
      size1_2     = new Vector2 (0, 0),
      translation = new Vector2 (0, 0),
      lineBound   = new Vector2 (0, 0),
      origin      = new Vector3 (0, 0, 0),
      vector      = new Vector2 (0, 0),
      box2        = new Box2 (),
      zero2       = new Vector2 (0, 0),
      zero3       = new Vector3 (0, 0, 0);

   function X3DTextGeometry (text, fontStyle)
   {
      this .text           = text;
      this .fontStyle      = fontStyle;
      this .glyphs         = [ ];
      this .minorAlignment = new Vector2 (0, 0);
      this .translations   = [ ];
      this .charSpacings   = [ ];
      this .bearing        = new Vector2 (0, 0);
      this .yPad           = [ ];
      this .bbox           = new Box3 ();
   }

   X3DTextGeometry .prototype =
   {
      constructor: X3DTextGeometry,
      getBrowser: function ()
      {
         return this .text .getBrowser ();
      },
      getText: function ()
      {
         return this .text;
      },
      getFontStyle: function ()
      {
         return this .fontStyle;
      },
      getGlyphs: function ()
      {
         return this .glyphs;
      },
      getMinorAlignment: function ()
      {
         return this .minorAlignment;
      },
      getTranslations: function ()
      {
         return this .translations;
      },
      getCharSpacings: function ()
      {
         return this .charSpacings;
      },
      getBearing: function ()
      {
         return this .bearing;
      },
      getBBox: function ()
      {
         return this .bbox;
      },
      update: function ()
      {
         var
            text      = this .text,
            fontStyle = this .fontStyle,
            numLines  = text ._string .length;

         text ._lineBounds .length = numLines;
         this .glyphs      .length = 0;

         if (numLines === 0 || ! fontStyle .getFont ())
         {
            text ._origin     .setValue (zero3);
            text ._textBounds .setValue (zero2);

            this .bbox .set ();
            return;
         }

         if (fontStyle ._horizontal .getValue ())
         {
            this .resizeArray (this .translations, numLines);
            this .resizeArray (this .charSpacings, numLines);

            this .horizontal (text, fontStyle);
         }
         else
         {
            var
               string   = text ._string,
               numChars = 0;

            for (var i = 0, length = string .length; i < length; ++ i)
               numChars += string [i] .length;

            this .resizeArray (this .translations, numChars);
            this .resizeArray (this .charSpacings, numChars);

            this .vertical (text, fontStyle);
         }
      },
      resizeArray: function (array, size)
      {
         // Resize array in grow only fashion.

         for (var i = array .length; i < size; ++ i)
            array .push (new Vector2 (0, 0));

         array .length = size;
      },
      horizontal: function (text, fontStyle)
      {
         var
            font        = fontStyle .getFont (),
            string      = text ._string,
            numLines    = string .length,
            maxExtent   = Math .max (0, text ._maxExtent .getValue ()),
            topToBottom = fontStyle ._topToBottom .getValue (),
            scale       = fontStyle .getScale (),
            spacing     = fontStyle ._spacing .getValue ();

         bbox .set ();

         // Calculate bboxes.

         var
            first = topToBottom ? 0 : numLines - 1,
            last  = topToBottom ? numLines : -1,
            step  = topToBottom ? 1 : -1;

         for (var l = first, ll = 0; l !== last; l += step, ++ ll)
         {
            var line = string [l];

            // Get line extents.

            var glyphs = this .getHorizontalLineExtents (fontStyle, line, min, max, ll);

            size .assign (max) .subtract (min);

            // Calculate charSpacing and lineBounds.

            var
               charSpacing = 0,
               length      = text .getLength (l);

            lineBound .set (size .x * scale, ll == 0 ? max .y - font .descender / font .unitsPerEm * scale : spacing);

            if (maxExtent)
            {
               if (length)
                  length = Math .min (maxExtent, length);

               else
                  length = Math .min (maxExtent, size .x * scale);
            }

            if (length)
            {
               charSpacing  = (length - lineBound .x) / (glyphs .length - 1);
               lineBound .x = length;
               size .x      = length / scale;
            }

            this .charSpacings [ll] = charSpacing;
            text ._lineBounds [l]   = lineBound;

            // Calculate line translation.

            switch (fontStyle .getMajorAlignment ())
            {
               case TextAlignment .BEGIN:
               case TextAlignment .FIRST:
                  this .translations [ll] .set (0, -ll * spacing);
                  break;
               case TextAlignment .MIDDLE:
                  this .translations [ll] .set (-min .x - size .x / 2, -ll * spacing);
                  break;
               case TextAlignment .END:
                  this .translations [ll] .set (-min .x - size .x, -ll * spacing);
                  break;
            }

            this .translations [ll] .multiply (scale);

            // Calculate center.

            center .assign (min) .add (size1_2 .assign (size) .divide (2));

            // Add bbox.

            bbox .add (box2 .set (size .multiply (scale), center .multiply (scale) .add (this .translations [ll])));
         }

         //console .log ("size", bbox .size, "center", bbox .center);

         // Get text extents.

         bbox .getExtents (min, max);

         size .assign (max) .subtract (min);

         // Calculate text position

         text ._textBounds = size;
         this .bearing .set (0, -max .y);

         switch (fontStyle .getMinorAlignment ())
         {
            case TextAlignment .BEGIN:
               this .minorAlignment .assign (this .bearing);
               break;
            case TextAlignment .FIRST:
               this .minorAlignment .set (0, 0);
               break;
            case TextAlignment .MIDDLE:
               this .minorAlignment .set (0, size .y / 2 - max .y);
               break;
            case TextAlignment .END:
               this .minorAlignment .set (0, (numLines - 1) * spacing * scale);
               break;
         }

         // Translate bbox by minorAlignment.

         min .add (this .minorAlignment);
         max .add (this .minorAlignment);

         // The value of the origin field represents the upper left corner of the textBounds.

         text ._origin .setValue (origin .set (min .x, max .y, 0));

         this .bbox .setExtents (min3 .set (min .x, min .y, 0),
                                 max3 .set (max .x, max .y, 0));
      },
      vertical: function (text, fontStyle)
      {
         var
            font             = fontStyle .getFont (),
            string           = text ._string,
            numLines         = string .length,
            maxExtent        = Math .max (0, text ._maxExtent .getValue ()),
            leftToRight      = fontStyle ._leftToRight .getValue (),
            topToBottom      = fontStyle ._topToBottom .getValue (),
            scale            = fontStyle .getScale (),
            spacing          = fontStyle ._spacing .getValue (),
            yPad             = this .yPad,
            primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality ();

         bbox .set ();

         // Calculate bboxes.

         var
            firstL = leftToRight ? 0 : numLines - 1,
            lastL  = leftToRight ? numLines : -1,
            stepL  = leftToRight ? 1 : -1,
            t      = 0; // Translation index

         for (var l = firstL; l !== lastL; l += stepL)
         {
            var glyphs = this .stringToGlyphs (font, string [l], true, l);

            var
               t0       = t,
               numChars = glyphs .length;

            // Calculate line bbox

            lineBBox .set ();

            var
               firstG = topToBottom ? 0 : numChars - 1,
               lastG  = topToBottom ? numChars : -1,
               stepG  = topToBottom ? 1 : -1;

            for (var g = firstG; g !== lastG; g += stepG, ++ t)
            {
               var glyph = glyphs [g];

               // Get glyph extents.

               this .getGlyphExtents (font, glyph, primitiveQuality, min, max);

               size .assign (max) .subtract (min);

               // Calculate glyph translation

               var glyphNumber = topToBottom ? g : numChars - g - 1;

               this .translations [t] .set ((spacing - size .x - min .x) / 2, -glyphNumber);

               // Calculate center.

               center .assign (min) .add (size1_2 .assign (size) .divide (2)) .add (this .translations [t]);

               // Add bbox.

               lineBBox .add (box2 .set (size, center));
            }

            // Get line extents.

            lineBBox .getExtents (min, max);

            size .assign (max) .subtract (min);

            // Calculate charSpacing and lineBounds.

            var
               lineNumber  = leftToRight ? l : numLines - l - 1,
               padding     = (spacing - size .x) / 2,
               charSpacing = 0,
               length      = text .getLength (l);

            lineBound .set (l === 0 ? spacing - padding: spacing, numChars ? size .y : 0) .multiply (scale);

            if (maxExtent)
            {
               if (length)
                  length = Math .min (maxExtent, length);

               else
                  length = Math .min (maxExtent, size .y * scale);
            }

            if (length)
            {
               charSpacing  = (length - lineBound .y) / (glyphs .length - 1) / scale;
               lineBound .y = length;
               size .y      = length / scale;
               min .y       = max .y  - size .y;
            }

            text ._lineBounds [l] = lineBound;

            // Calculate line translation.

            switch (fontStyle .getMajorAlignment ())
            {
               case TextAlignment .BEGIN:
               case TextAlignment .FIRST:
                  translation .set (lineNumber * spacing, -1);
                  break;
               case TextAlignment .MIDDLE:
                  translation .set (lineNumber * spacing, (size .y / 2 - max .y));
                  break;
               case TextAlignment .END:
               {
                  // This is needed to make maxExtend and charSpacing work.
                  if (numChars)
                     this .getGlyphExtents (font, glyphs [topToBottom ? numChars - 1 : 0], primitiveQuality, glyphMin .assign (Vector2 .Zero), vector);

                  translation .set (lineNumber * spacing, (size .y - max .y + glyphMin .y));
                  break;
               }
            }

            // Calculate glyph translation

            var space = 0;

            for (var tt = t0; tt < t; ++ tt)
            {
               this .translations [tt] .add (translation);

               this .translations [tt] .y -= space;

               this .translations [tt] .multiply (scale);

               space += charSpacing;
            }

            // Calculate ypad to extend line bounds.

            switch (fontStyle .getMajorAlignment ())
            {
               case TextAlignment .BEGIN:
               case TextAlignment .FIRST:
                  yPad [l] = max .y + translation .y;
                  break;
               case TextAlignment .MIDDLE:
                  yPad [l] = 0;
                  break;
               case TextAlignment .END:
                  yPad [l] = min .y + translation .y;
                  break;
            }

            // Calculate center.

            center .assign (min) .add (size1_2 .assign (size) .divide (2));

            // Add bbox.

            bbox .add (box2 .set (size .multiply (scale), center .add (translation) .multiply (scale)));
         }

         // Get text extents.

         bbox .getExtents (min, max);

         size .assign (max) .subtract (min);

         // Extend lineBounds.

         switch (fontStyle .getMajorAlignment ())
         {
            case TextAlignment .BEGIN:
            case TextAlignment .FIRST:
            {
               var lineBounds = text ._lineBounds;

               for (var i = 0, length = lineBounds .length; i < length; ++ i)
                  lineBounds [i] .y += max .y - yPad [i] * scale;

               break;
            }
            case TextAlignment .MIDDLE:
               break;
            case TextAlignment .END:
            {
               var lineBounds = text ._lineBounds;

               for (var i = 0, length = lineBounds .length; i < length; ++ i)
                  lineBounds [i] .y += yPad [i] * scale - min .y;

               break;
            }
         }

         // Calculate text position

         text ._textBounds = size;

         switch (fontStyle .getMajorAlignment ())
         {
            case TextAlignment .BEGIN:
            case TextAlignment .FIRST:
               this .bearing .set (-min .x, max .y);
               break;
            case TextAlignment .MIDDLE:
               this .bearing .set (-min .x, 0);
               break;
            case TextAlignment .END:
               this .bearing .set (-min .x, min .y);
               break;
         }

         switch (fontStyle .getMinorAlignment ())
         {
            case TextAlignment .BEGIN:
            case TextAlignment .FIRST:
               this .minorAlignment .set (-min .x, 0);
               break;
            case TextAlignment .MIDDLE:
               this .minorAlignment .set (-min .x - size .x / 2, 0);
               break;
            case TextAlignment .END:
               this .minorAlignment .set (-min .x - size .x, 0);
               break;
         }

         // Translate bbox by minorAlignment.

         min .add (this .minorAlignment);
         max .add (this .minorAlignment);

         // The value of the origin field represents the upper left corner of the textBounds.

         text ._origin .setValue (origin .set (min .x, max .y, 0));

         this .bbox .set (min3 .set (min .x, min .y, 0),
                          max3 .set (max .x, max .y, 0),
                          true);
      },
      stringToGlyphs: function (font, line, normal, lineNumber)
      {
         var glypes = this .glyphs [lineNumber];

         if (! glypes)
            glypes = this .glyphs [lineNumber] = [ ];

         glypes .length = line .length;

         var
            first = normal ? 0 : line .length - 1,
            last  = normal ? line .length : -1,
            step  = normal ? 1 : -1;

         for (var c = first, g = 0; c !== last; c += step, ++ g)
            glypes [g] = font .charToGlyph (line [c]);

         return glypes;
      },
      getHorizontalLineExtents: function (fontStyle, line, min, max, lineNumber)
      {
         var
            font             = fontStyle .getFont (),
            normal           = fontStyle ._horizontal .getValue () ? fontStyle ._leftToRight .getValue () : fontStyle ._topToBottom .getValue (),
            glyphs           = this .stringToGlyphs (font, line, normal, lineNumber),
            primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
            xMin             = 0,
            xMax             = 0,
            yMin             = Number .POSITIVE_INFINITY,
            yMax             = Number .NEGATIVE_INFINITY;

         for (var g = 0, length = glyphs .length; g < length; ++ g)
         {
            var
               glyph   = glyphs [g],
               kerning = g + 1 < length ? font .getKerningValue (glyph, glyphs [g + 1]) : 0;

            this .getGlyphExtents (font, glyph, primitiveQuality, glyphMin, glyphMax);

            xMax += glyph .advanceWidth + kerning;
            yMin  = Math .min (yMin, glyphMin .y);
            yMax  = Math .max (yMax, glyphMax .y);
         }

         if (glyphs .length)
         {
            this .getGlyphExtents (font, glyphs [0], primitiveQuality, glyphMin, glyphMax);

            xMin  = glyphMin .x;
         }
         else
         {
            yMin = 0;
            yMax = 0;
         }

         min .set (xMin, yMin);
         max .set (xMax / font .unitsPerEm, yMax);

         switch (fontStyle .getMajorAlignment ())
         {
            case TextAlignment .BEGIN:
            case TextAlignment .FIRST:
               min .x = 0;
               break;
         }

         return glyphs;
      },
      traverse: function (type, renderObject)
      { },
   };

   return X3DTextGeometry;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/Bezier',[
   "standard/Math/Algorithm",
],
function (Algorithm)
{
   "use strict";

   const lerp = Algorithm .lerp;

   function Bezier (x0, y0, x1, y1, x2, y2, x3, y3)
   {
      this .x0 = x0;
      this .y0 = y0;
      this .x1 = x1;
      this .y1 = y1;
      this .x2 = x2;
      this .y2 = y2;
      this .x3 = x3;
      this .y3 = y3;

      this .order = arguments .length / 2 - 1;
   }

   Bezier .prototype =
   {
      getLUT: function (dimension)
      {
         const
            x0  = this .x0,
            y0  = this .y0,
            x1  = this .x1,
            y1  = this .y1,
            x2  = this .x2,
            y2  = this .y2,
            x3  = this .x3,
            y3  = this .y3,
            lut = [ ];

         switch (this .order)
         {
            case 2:
            {
               for (let i = 0, d = dimension - 1; i < dimension; ++ i)
               {
                  lut .push (quadric (x0, y0, x1, y1, x2, y2, i / d));
               }

               break;
            }
            case 3:
            {
               for (let i = 0, d = dimension - 1; i < dimension; ++ i)
               {
                  lut .push (cubic (x0, y0, x1, y1, x2, y2, x3, y3, i / d));
               }

               break;
            }
         }

         return lut;
      }
   };

   function quadric (x0, y0, x1, y1, x2, y2, t)
   {
      const
         ax0 = lerp (x0, x1, t),
         ay0 = lerp (y0, y1, t),
         ax1 = lerp (x1, x2, t),
         ay1 = lerp (y1, y2, t),
         bx0 = lerp (ax0, ax1, t),
         by0 = lerp (ay0, ay1, t);

      return {x: bx0, y: by0};
   }

   function cubic (x0, y0, x1, y1, x2, y2, x3, y3, t)
   {
      const
         ax0 = lerp (x0, x1, t),
         ay0 = lerp (y0, y1, t),
         ax1 = lerp (x1, x2, t),
         ay1 = lerp (y1, y2, t),
         ax2 = lerp (x2, x3, t),
         ay2 = lerp (y2, y3, t),
         bx0 = lerp (ax0, ax1, t),
         by0 = lerp (ay0, ay1, t),
         bx1 = lerp (ax1, ax2, t),
         by1 = lerp (ay1, ay2, t),
         cx0 = lerp (bx0, bx1, t),
         cy0 = lerp (by0, by1, t);

      return {x: cx0, y: cy0};
   }

    return Bezier;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/PolygonText',[
   "x_ite/Browser/Core/PrimitiveQuality",
   "x_ite/Browser/Text/X3DTextGeometry",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Algorithms/Bezier"
],
function (PrimitiveQuality,
          X3DTextGeometry,
          X3DGeometryNode,
          Vector3,
          Matrix4,
          Triangle3,
          Bezier)
{
"use strict";

   function PolygonText (text, fontStyle)
   {
      X3DTextGeometry .call (this, text, fontStyle);

      text ._transparent = false;

      this .texCoordArray = X3DGeometryNode .createArray ();
   }

   PolygonText .prototype = Object .assign (Object .create (X3DTextGeometry .prototype),
   {
      constructor: PolygonText,
      getTransparent: function ()
      {
         return false;
      },
      getMatrix: function ()
      {
         return Matrix4 .Identity;
      },
      build: (function ()
      {
         var
            min = new Vector3 (0, 0, 0),
            max = new Vector3 (0, 0, 0);

         return function ()
         {
            var
               fontStyle = this .getFontStyle (),
               font      = fontStyle .getFont ();

            if (! font)
               return;

            var
               text             = this .getText (),
               glyphs           = this .getGlyphs (),
               minorAlignment   = this .getMinorAlignment (),
               translations     = this .getTranslations (),
               charSpacings     = this .getCharSpacings (),
               size             = fontStyle .getScale (),
               spacing          = fontStyle ._spacing .getValue (),
               origin           = text ._origin .getValue (),
               sizeUnitsPerEm   = size / font .unitsPerEm,
               primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
               texCoordArray    = this .texCoordArray,
               normalArray      = text .getNormals (),
               vertexArray      = text .getVertices ();

            // Set texCoords.

            text .getMultiTexCoords () .push (texCoordArray);

            this .getBBox () .getExtents (min, max);
            text .getMin () .assign (min);
            text .getMax () .assign (max);

            if (fontStyle ._horizontal .getValue ())
            {
               for (var l = 0, length = glyphs .length; l < length; ++ l)
               {
                  var
                     line         = glyphs [l],
                     charSpacing  = charSpacings [l],
                     translation  = translations [l],
                     advanceWidth = 0;

                  for (var g = 0, gl = line .length; g < gl; ++ g)
                  {
                     var
                        glyph         = line [g],
                        glyphVertices = this .getGlyphGeometry (font, glyph, primitiveQuality),
                        xOffset       = minorAlignment .x + translation .x + advanceWidth + g * charSpacing,
                        yOffset       = minorAlignment .y + translation .y;

                     for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
                     {
                        var
                           x = glyphVertices [v] .x * size + xOffset,
                           y = glyphVertices [v] .y * size + yOffset;

                        texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
                        normalArray   .push (0, 0, 1);
                        vertexArray   .push (x, y, 0, 1);
                     }

                     // Calculate advanceWidth.

                     var kerning = 0;

                     if (g + 1 < line .length)
                        kerning = font .getKerningValue (glyph, line [g + 1]);

                     advanceWidth += (glyph .advanceWidth + kerning) * sizeUnitsPerEm;
                  }
               }
            }
            else
            {
               var
                  leftToRight = fontStyle ._leftToRight .getValue (),
                  topToBottom = fontStyle ._topToBottom .getValue (),
                  first       = leftToRight ? 0 : text ._string .length - 1,
                  last        = leftToRight ? text ._string .length  : -1,
                  step        = leftToRight ? 1 : -1;

               for (var l = first, t = 0; l !== last; l += step)
               {
                  var line = glyphs [l];

                  var
                     numChars = line .length,
                     firstG   = topToBottom ? 0 : numChars - 1,
                     lastG    = topToBottom ? numChars : -1,
                     stepG    = topToBottom ? 1 : -1;

                  for (var g = firstG; g !== lastG; g += stepG, ++ t)
                  {
                     var
                        translation   = translations [t],
                        glyphVertices = this .getGlyphGeometry (font, line [g], primitiveQuality);

                     for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
                     {
                        var
                           x = glyphVertices [v] .x * size + minorAlignment .x + translation .x,
                           y = glyphVertices [v] .y * size + minorAlignment .y + translation .y;

                        texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
                        normalArray   .push (0, 0, 1);
                        vertexArray   .push (x, y, 0, 1);
                     }
                  }
               }
            }
         };
      })(),
      getGlyphExtents: function (font, glyph, primitiveQuality, min, max)
      {
         var
            glyphCache = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
            extents    = glyphCache .extents;

         if (extents)
         {
            min .assign (extents .min);
            max .assign (extents .max);
            return;
         }

         var vertices = this .getGlyphGeometry (font, glyph, primitiveQuality);

         if (vertices .length)
         {
            var vertex = vertices [0];

            min .assign (vertex);
            max .assign (vertex);

            for (var i = 1, length = vertices .length; i < length; ++ i)
            {
               var vertex = vertices [i];

               min .min (vertex);
               max .max (vertex);
            }
         }
         else
         {
            min .set (0, 0, 0);
            max .set (0, 0, 0);
         }

         var extents = glyphCache .extents = { };

         extents .min = min .copy ();
         extents .max = max .copy ();
      },
      getGlyphGeometry: function (font, glyph, primitiveQuality)
      {
         var
            glyphCache    = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
            glyphGeometry = glyphCache .geometry;

         if (glyphGeometry)
            return glyphGeometry;

         glyphGeometry = glyphCache .geometry = [ ];

         this .createGlyphGeometry (glyph, glyphGeometry, primitiveQuality);

         return glyphGeometry;
      },
      createGlyphGeometry: (function ()
      {
         var
            points = [ ],
            curves = [ ],
            normal = new Vector3 (0, 0, 0);

         return function (glyph, vertices, primitiveQuality)
         {
            // Get curves for the current glyph.

            var
               dimension  = this .getBezierDimension (primitiveQuality),
               path       = glyph .getPath (0, 0, 1),
               commands   = path .commands,
               x          = 0,
               y          = 0;

            points .length = 0;
            curves .length = 0;

            for (var i = 0, cl = commands .length; i < cl; ++ i)
            {
               var command = commands [i];

               switch (command .type)
               {
                  case "M": // Start
                  case "Z": // End
                  {
                     if (points .length > 2)
                     {
                        if (points [0] .x === points .at (-1) .x && points [0] .y === points .at (-1) .y)
                           points .pop ();

                        curves .push (points);
                     }

                     points = [ ];

                     if (command .type === "M")
                        points .push (new Vector3 (command .x, -command .y, 0));

                     break;
                  }
                  case "L": // Linear
                  {
                     points .push (new Vector3 (command .x, -command .y, 0));
                     break;
                  }
                  case "Q": // Quadric
                  {
                     var
                        curve = new Bezier (x, -y, command .x1, -command .y1, command .x, -command .y),
                        lut   = curve .getLUT (dimension);

                     for (var l = 1, ll = lut .length; l < ll; ++ l)
                        points .push (new Vector3 (lut [l] .x, lut [l] .y, 0));

                     break;
                  }
                  case "C": // Cubic
                  {
                     var
                        curve = new Bezier (x, -y, command .x1, -command .y1, command .x2, -command .y2, command .x, -command .y),
                        lut   = curve .getLUT (dimension);

                     for (var l = 1, ll = lut .length; l < ll; ++ l)
                        points .push (new Vector3 (lut [l] .x, lut [l] .y, 0));

                     break;
                  }
                  default:
                     continue;
               }

               x = command .x;
               y = command .y;
            }

            // Triangulate contours.

            curves = curves .map (function (curve)
            {
               Triangle3 .getPolygonNormal (curve, normal);

               if (normal .dot (Vector3 .zAxis) > 0)
                  return curve;

               return curve .reverse ();
            });

            curves .push (vertices);

            Triangle3 .triangulatePolygon .apply (Triangle3, curves);
         };
      })(),
      getBezierDimension: function (primitiveQuality)
      {
         switch (primitiveQuality)
         {
            case PrimitiveQuality .LOW:
               return 3;
            case PrimitiveQuality .HIGH:
               return 7;
            default:
               return 5;
         }
      },
      display: function (gl, context)
      { },
      transformLine: function (line)
      { },
      transformMatrix: function (matrix)
      { },
   });

   return PolygonText;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/FontStyle',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Text/X3DFontStyleNode",
   "x_ite/Browser/Text/PolygonText",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DFontStyleNode,
          PolygonText,
          X3DConstants)
{
"use strict";

   function FontStyle (executionContext)
   {
      X3DFontStyleNode .call (this, executionContext);

      this .addType (X3DConstants .FontStyle);

      this ._size .setUnit ("length");
   }

   FontStyle .prototype = Object .assign (Object .create (X3DFontStyleNode .prototype),
   {
      constructor: FontStyle,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "language",    new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "family",      new Fields .MFString ("SERIF")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "style",       new Fields .SFString ("PLAIN")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "size",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "spacing",     new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "horizontal",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "leftToRight", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "topToBottom", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "justify",     new Fields .MFString ("BEGIN")),
      ]),
      getTypeName: function ()
      {
         return "FontStyle";
      },
      getComponentName: function ()
      {
         return "Text";
      },
      getContainerField: function ()
      {
         return "fontStyle";
      },
      getTextGeometry: function (text)
      {
         return new PolygonText (text, this);
      },
      getScale: function ()
      {
         return this ._size .getValue ();
      },
   });

   return FontStyle;
});

/**
 * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define('opentype/dist/opentype',['exports'], factory) :
	(global = global || self, factory(global.opentype = {}));
}(this, (function (exports) { 'use strict';

	/*! https://mths.be/codepointat v0.2.0 by @mathias */
	if (!String.prototype.codePointAt) {
		(function() {
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var codePointAt = function(position) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				var size = string.length;
				// `ToInteger`
				var index = position ? Number(position) : 0;
				if (index != index) { // better `isNaN`
					index = 0;
				}
				// Account for out-of-bounds indices:
				if (index < 0 || index >= size) {
					return undefined;
				}
				// Get the first code unit
				var first = string.charCodeAt(index);
				var second;
				if ( // check if it’s the start of a surrogate pair
					first >= 0xD800 && first <= 0xDBFF && // high surrogate
					size > index + 1 // there is a next code unit
				) {
					second = string.charCodeAt(index + 1);
					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
					}
				}
				return first;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'codePointAt', {
					'value': codePointAt,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.codePointAt = codePointAt;
			}
		}());
	}

	var TINF_OK = 0;
	var TINF_DATA_ERROR = -3;

	function Tree() {
	  this.table = new Uint16Array(16);   /* table of code length counts */
	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
	}

	function Data(source, dest) {
	  this.source = source;
	  this.sourceIndex = 0;
	  this.tag = 0;
	  this.bitcount = 0;
	  
	  this.dest = dest;
	  this.destLen = 0;
	  
	  this.ltree = new Tree();  /* dynamic length/symbol tree */
	  this.dtree = new Tree();  /* dynamic distance tree */
	}

	/* --------------------------------------------------- *
	 * -- uninitialized global data (static structures) -- *
	 * --------------------------------------------------- */

	var sltree = new Tree();
	var sdtree = new Tree();

	/* extra bits and base tables for length codes */
	var length_bits = new Uint8Array(30);
	var length_base = new Uint16Array(30);

	/* extra bits and base tables for distance codes */
	var dist_bits = new Uint8Array(30);
	var dist_base = new Uint16Array(30);

	/* special ordering of code length codes */
	var clcidx = new Uint8Array([
	  16, 17, 18, 0, 8, 7, 9, 6,
	  10, 5, 11, 4, 12, 3, 13, 2,
	  14, 1, 15
	]);

	/* used by tinf_decode_trees, avoids allocations every call */
	var code_tree = new Tree();
	var lengths = new Uint8Array(288 + 32);

	/* ----------------------- *
	 * -- utility functions -- *
	 * ----------------------- */

	/* build extra bits and base tables */
	function tinf_build_bits_base(bits, base, delta, first) {
	  var i, sum;

	  /* build bits table */
	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

	  /* build base table */
	  for (sum = first, i = 0; i < 30; ++i) {
	    base[i] = sum;
	    sum += 1 << bits[i];
	  }
	}

	/* build the fixed huffman trees */
	function tinf_build_fixed_trees(lt, dt) {
	  var i;

	  /* build fixed length tree */
	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

	  lt.table[7] = 24;
	  lt.table[8] = 152;
	  lt.table[9] = 112;

	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

	  /* build fixed distance tree */
	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

	  dt.table[5] = 32;

	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
	}

	/* given an array of code lengths, build a tree */
	var offs = new Uint16Array(16);

	function tinf_build_tree(t, lengths, off, num) {
	  var i, sum;

	  /* clear code length count table */
	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

	  /* scan symbol lengths, and sum code length counts */
	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

	  t.table[0] = 0;

	  /* compute offset table for distribution sort */
	  for (sum = 0, i = 0; i < 16; ++i) {
	    offs[i] = sum;
	    sum += t.table[i];
	  }

	  /* create code->symbol translation table (symbols sorted by code) */
	  for (i = 0; i < num; ++i) {
	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
	  }
	}

	/* ---------------------- *
	 * -- decode functions -- *
	 * ---------------------- */

	/* get one bit from source stream */
	function tinf_getbit(d) {
	  /* check if tag is empty */
	  if (!d.bitcount--) {
	    /* load next tag */
	    d.tag = d.source[d.sourceIndex++];
	    d.bitcount = 7;
	  }

	  /* shift bit out of tag */
	  var bit = d.tag & 1;
	  d.tag >>>= 1;

	  return bit;
	}

	/* read a num bit value from a stream and add base */
	function tinf_read_bits(d, num, base) {
	  if (!num)
	    { return base; }

	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }

	  var val = d.tag & (0xffff >>> (16 - num));
	  d.tag >>>= num;
	  d.bitcount -= num;
	  return val + base;
	}

	/* given a data stream and a tree, decode a symbol */
	function tinf_decode_symbol(d, t) {
	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }
	  
	  var sum = 0, cur = 0, len = 0;
	  var tag = d.tag;

	  /* get more bits while code value is above sum */
	  do {
	    cur = 2 * cur + (tag & 1);
	    tag >>>= 1;
	    ++len;

	    sum += t.table[len];
	    cur -= t.table[len];
	  } while (cur >= 0);
	  
	  d.tag = tag;
	  d.bitcount -= len;

	  return t.trans[sum + cur];
	}

	/* given a data stream, decode dynamic trees from it */
	function tinf_decode_trees(d, lt, dt) {
	  var hlit, hdist, hclen;
	  var i, num, length;

	  /* get 5 bits HLIT (257-286) */
	  hlit = tinf_read_bits(d, 5, 257);

	  /* get 5 bits HDIST (1-32) */
	  hdist = tinf_read_bits(d, 5, 1);

	  /* get 4 bits HCLEN (4-19) */
	  hclen = tinf_read_bits(d, 4, 4);

	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

	  /* read code lengths for code length alphabet */
	  for (i = 0; i < hclen; ++i) {
	    /* get 3 bits code length (0-7) */
	    var clen = tinf_read_bits(d, 3, 0);
	    lengths[clcidx[i]] = clen;
	  }

	  /* build code length tree */
	  tinf_build_tree(code_tree, lengths, 0, 19);

	  /* decode code lengths for the dynamic trees */
	  for (num = 0; num < hlit + hdist;) {
	    var sym = tinf_decode_symbol(d, code_tree);

	    switch (sym) {
	      case 16:
	        /* copy previous code length 3-6 times (read 2 bits) */
	        var prev = lengths[num - 1];
	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
	          lengths[num++] = prev;
	        }
	        break;
	      case 17:
	        /* repeat code length 0 for 3-10 times (read 3 bits) */
	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      case 18:
	        /* repeat code length 0 for 11-138 times (read 7 bits) */
	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      default:
	        /* values 0-15 represent the actual code lengths */
	        lengths[num++] = sym;
	        break;
	    }
	  }

	  /* build dynamic trees */
	  tinf_build_tree(lt, lengths, 0, hlit);
	  tinf_build_tree(dt, lengths, hlit, hdist);
	}

	/* ----------------------------- *
	 * -- block inflate functions -- *
	 * ----------------------------- */

	/* given a stream and two trees, inflate a block of data */
	function tinf_inflate_block_data(d, lt, dt) {
	  while (1) {
	    var sym = tinf_decode_symbol(d, lt);

	    /* check for end of block */
	    if (sym === 256) {
	      return TINF_OK;
	    }

	    if (sym < 256) {
	      d.dest[d.destLen++] = sym;
	    } else {
	      var length, dist, offs;
	      var i;

	      sym -= 257;

	      /* possibly get more bits from length code */
	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

	      dist = tinf_decode_symbol(d, dt);

	      /* possibly get more bits from distance code */
	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

	      /* copy match */
	      for (i = offs; i < offs + length; ++i) {
	        d.dest[d.destLen++] = d.dest[i];
	      }
	    }
	  }
	}

	/* inflate an uncompressed block of data */
	function tinf_inflate_uncompressed_block(d) {
	  var length, invlength;
	  var i;
	  
	  /* unread from bitbuffer */
	  while (d.bitcount > 8) {
	    d.sourceIndex--;
	    d.bitcount -= 8;
	  }

	  /* get length */
	  length = d.source[d.sourceIndex + 1];
	  length = 256 * length + d.source[d.sourceIndex];

	  /* get one's complement of length */
	  invlength = d.source[d.sourceIndex + 3];
	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

	  /* check length */
	  if (length !== (~invlength & 0x0000ffff))
	    { return TINF_DATA_ERROR; }

	  d.sourceIndex += 4;

	  /* copy block */
	  for (i = length; i; --i)
	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

	  /* make sure we start next block on a byte boundary */
	  d.bitcount = 0;

	  return TINF_OK;
	}

	/* inflate stream from source to dest */
	function tinf_uncompress(source, dest) {
	  var d = new Data(source, dest);
	  var bfinal, btype, res;

	  do {
	    /* read final block flag */
	    bfinal = tinf_getbit(d);

	    /* read block type (2 bits) */
	    btype = tinf_read_bits(d, 2, 0);

	    /* decompress block */
	    switch (btype) {
	      case 0:
	        /* decompress uncompressed block */
	        res = tinf_inflate_uncompressed_block(d);
	        break;
	      case 1:
	        /* decompress block with fixed huffman trees */
	        res = tinf_inflate_block_data(d, sltree, sdtree);
	        break;
	      case 2:
	        /* decompress block with dynamic huffman trees */
	        tinf_decode_trees(d, d.ltree, d.dtree);
	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
	        break;
	      default:
	        res = TINF_DATA_ERROR;
	    }

	    if (res !== TINF_OK)
	      { throw new Error('Data error'); }

	  } while (!bfinal);

	  if (d.destLen < d.dest.length) {
	    if (typeof d.dest.slice === 'function')
	      { return d.dest.slice(0, d.destLen); }
	    else
	      { return d.dest.subarray(0, d.destLen); }
	  }
	  
	  return d.dest;
	}

	/* -------------------- *
	 * -- initialization -- *
	 * -------------------- */

	/* build fixed huffman trees */
	tinf_build_fixed_trees(sltree, sdtree);

	/* build extra bits and base tables */
	tinf_build_bits_base(length_bits, length_base, 4, 3);
	tinf_build_bits_base(dist_bits, dist_base, 2, 1);

	/* fix a special case */
	length_bits[28] = 0;
	length_base[28] = 258;

	var tinyInflate = tinf_uncompress;

	// The Bounding Box object

	function derive(v0, v1, v2, v3, t) {
	    return Math.pow(1 - t, 3) * v0 +
	        3 * Math.pow(1 - t, 2) * t * v1 +
	        3 * (1 - t) * Math.pow(t, 2) * v2 +
	        Math.pow(t, 3) * v3;
	}
	/**
	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
	 * It is used to calculate the bounding box of a glyph or text path.
	 *
	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
	 *
	 * @exports opentype.BoundingBox
	 * @class
	 * @constructor
	 */
	function BoundingBox() {
	    this.x1 = Number.NaN;
	    this.y1 = Number.NaN;
	    this.x2 = Number.NaN;
	    this.y2 = Number.NaN;
	}

	/**
	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
	 */
	BoundingBox.prototype.isEmpty = function() {
	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
	};

	/**
	 * Add the point to the bounding box.
	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
	 * @param {number} x - The X coordinate of the point.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addPoint = function(x, y) {
	    if (typeof x === 'number') {
	        if (isNaN(this.x1) || isNaN(this.x2)) {
	            this.x1 = x;
	            this.x2 = x;
	        }
	        if (x < this.x1) {
	            this.x1 = x;
	        }
	        if (x > this.x2) {
	            this.x2 = x;
	        }
	    }
	    if (typeof y === 'number') {
	        if (isNaN(this.y1) || isNaN(this.y2)) {
	            this.y1 = y;
	            this.y2 = y;
	        }
	        if (y < this.y1) {
	            this.y1 = y;
	        }
	        if (y > this.y2) {
	            this.y2 = y;
	        }
	    }
	};

	/**
	 * Add a X coordinate to the bounding box.
	 * This extends the bounding box to include the X coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} x - The X coordinate of the point.
	 */
	BoundingBox.prototype.addX = function(x) {
	    this.addPoint(x, null);
	};

	/**
	 * Add a Y coordinate to the bounding box.
	 * This extends the bounding box to include the Y coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addY = function(y) {
	    this.addPoint(null, y);
	};

	/**
	 * Add a Bézier curve to the bounding box.
	 * This extends the bounding box to include the entire Bézier.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the first control point.
	 * @param {number} y1 - The Y coordinate of the first control point.
	 * @param {number} x2 - The X coordinate of the second control point.
	 * @param {number} y2 - The Y coordinate of the second control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
	    // and https://github.com/icons8/svg-path-bounding-box

	    var p0 = [x0, y0];
	    var p1 = [x1, y1];
	    var p2 = [x2, y2];
	    var p3 = [x, y];

	    this.addPoint(x0, y0);
	    this.addPoint(x, y);

	    for (var i = 0; i <= 1; i++) {
	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
	        var c = 3 * p1[i] - 3 * p0[i];

	        if (a === 0) {
	            if (b === 0) { continue; }
	            var t = -c / b;
	            if (0 < t && t < 1) {
	                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	            }
	            continue;
	        }

	        var b2ac = Math.pow(b, 2) - 4 * c * a;
	        if (b2ac < 0) { continue; }
	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t1 && t1 < 1) {
	            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	        }
	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t2 && t2 < 1) {
	            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	        }
	    }
	};

	/**
	 * Add a quadratic curve to the bounding box.
	 * This extends the bounding box to include the entire quadratic curve.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the control point.
	 * @param {number} y1 - The Y coordinate of the control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
	    var cp1x = x0 + 2 / 3 * (x1 - x0);
	    var cp1y = y0 + 2 / 3 * (y1 - y0);
	    var cp2x = cp1x + 1 / 3 * (x - x0);
	    var cp2y = cp1y + 1 / 3 * (y - y0);
	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
	};

	// Geometric objects

	/**
	 * A bézier path containing a set of path commands similar to a SVG path.
	 * Paths can be drawn on a context using `draw`.
	 * @exports opentype.Path
	 * @class
	 * @constructor
	 */
	function Path() {
	    this.commands = [];
	    this.fill = 'black';
	    this.stroke = null;
	    this.strokeWidth = 1;
	}

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.moveTo = function(x, y) {
	    this.commands.push({
	        type: 'M',
	        x: x,
	        y: y
	    });
	};

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.lineTo = function(x, y) {
	    this.commands.push({
	        type: 'L',
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws cubic curve
	 * @function
	 * curveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws cubic curve
	 * @function
	 * bezierCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 * @see curveTo
	 */
	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
	    this.commands.push({
	        type: 'C',
	        x1: x1,
	        y1: y1,
	        x2: x2,
	        y2: y2,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws quadratic curve
	 * @function
	 * quadraticCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws quadratic curve
	 * @function
	 * quadTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */
	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
	    this.commands.push({
	        type: 'Q',
	        x1: x1,
	        y1: y1,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Closes the path
	 * @function closePath
	 * @memberof opentype.Path.prototype
	 */

	/**
	 * Close the path
	 * @function close
	 * @memberof opentype.Path.prototype
	 */
	Path.prototype.close = Path.prototype.closePath = function() {
	    this.commands.push({
	        type: 'Z'
	    });
	};

	/**
	 * Add the given path or list of commands to the commands of this path.
	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
	 */
	Path.prototype.extend = function(pathOrCommands) {
	    if (pathOrCommands.commands) {
	        pathOrCommands = pathOrCommands.commands;
	    } else if (pathOrCommands instanceof BoundingBox) {
	        var box = pathOrCommands;
	        this.moveTo(box.x1, box.y1);
	        this.lineTo(box.x2, box.y1);
	        this.lineTo(box.x2, box.y2);
	        this.lineTo(box.x1, box.y2);
	        this.close();
	        return;
	    }

	    Array.prototype.push.apply(this.commands, pathOrCommands);
	};

	/**
	 * Calculate the bounding box of the path.
	 * @returns {opentype.BoundingBox}
	 */
	Path.prototype.getBoundingBox = function() {
	    var box = new BoundingBox();

	    var startX = 0;
	    var startY = 0;
	    var prevX = 0;
	    var prevY = 0;
	    for (var i = 0; i < this.commands.length; i++) {
	        var cmd = this.commands[i];
	        switch (cmd.type) {
	            case 'M':
	                box.addPoint(cmd.x, cmd.y);
	                startX = prevX = cmd.x;
	                startY = prevY = cmd.y;
	                break;
	            case 'L':
	                box.addPoint(cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Q':
	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'C':
	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Z':
	                prevX = startX;
	                prevY = startY;
	                break;
	            default:
	                throw new Error('Unexpected path command ' + cmd.type);
	        }
	    }
	    if (box.isEmpty()) {
	        box.addPoint(0, 0);
	    }
	    return box;
	};

	/**
	 * Draw the path to a 2D context.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
	 */
	Path.prototype.draw = function(ctx) {
	    ctx.beginPath();
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this.commands[i];
	        if (cmd.type === 'M') {
	            ctx.moveTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            ctx.lineTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            ctx.closePath();
	        }
	    }

	    if (this.fill) {
	        ctx.fillStyle = this.fill;
	        ctx.fill();
	    }

	    if (this.stroke) {
	        ctx.strokeStyle = this.stroke;
	        ctx.lineWidth = this.strokeWidth;
	        ctx.stroke();
	    }
	};

	/**
	 * Convert the Path to a string of path data instructions
	 * See http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toPathData = function(decimalPlaces) {
	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

	    function floatToString(v) {
	        if (Math.round(v) === v) {
	            return '' + Math.round(v);
	        } else {
	            return v.toFixed(decimalPlaces);
	        }
	    }

	    function packValues() {
	        var arguments$1 = arguments;

	        var s = '';
	        for (var i = 0; i < arguments.length; i += 1) {
	            var v = arguments$1[i];
	            if (v >= 0 && i > 0) {
	                s += ' ';
	            }

	            s += floatToString(v);
	        }

	        return s;
	    }

	    var d = '';
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this.commands[i];
	        if (cmd.type === 'M') {
	            d += 'M' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            d += 'L' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            d += 'Z';
	        }
	    }

	    return d;
	};

	/**
	 * Convert the path to an SVG <path> element, as a string.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toSVG = function(decimalPlaces) {
	    var svg = '<path d="';
	    svg += this.toPathData(decimalPlaces);
	    svg += '"';
	    if (this.fill && this.fill !== 'black') {
	        if (this.fill === null) {
	            svg += ' fill="none"';
	        } else {
	            svg += ' fill="' + this.fill + '"';
	        }
	    }

	    if (this.stroke) {
	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
	    }

	    svg += '/>';
	    return svg;
	};

	/**
	 * Convert the path to a DOM element.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {SVGPathElement}
	 */
	Path.prototype.toDOMElement = function(decimalPlaces) {
	    var temporaryPath = this.toPathData(decimalPlaces);
	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

	    newPath.setAttribute('d', temporaryPath);

	    return newPath;
	};

	// Run-time checking of preconditions.

	function fail(message) {
	    throw new Error(message);
	}

	// Precondition function that checks if the given predicate is true.
	// If not, it will throw an error.
	function argument(predicate, message) {
	    if (!predicate) {
	        fail(message);
	    }
	}
	var check = { fail: fail, argument: argument, assert: argument };

	// Data types used in the OpenType font file.

	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

	/**
	 * @exports opentype.decode
	 * @class
	 */
	var decode = {};
	/**
	 * @exports opentype.encode
	 * @class
	 */
	var encode = {};
	/**
	 * @exports opentype.sizeOf
	 * @class
	 */
	var sizeOf = {};

	// Return a function that always returns the same value.
	function constant(v) {
	    return function() {
	        return v;
	    };
	}

	// OpenType data types //////////////////////////////////////////////////////

	/**
	 * Convert an 8-bit unsigned integer to a list of 1 byte.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.BYTE = function(v) {
	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
	    return [v];
	};
	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.BYTE = constant(1);

	/**
	 * Convert a 8-bit signed integer to a list of 1 byte.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHAR = function(v) {
	    return [v.charCodeAt(0)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.CHAR = constant(1);

	/**
	 * Convert an ASCII string to a list of bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHARARRAY = function(v) {
	    if (typeof v === 'undefined') {
	        v = '';
	        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');
	    }
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        b[i] = v.charCodeAt(i);
	    }

	    return b;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARARRAY = function(v) {
	    if (typeof v === 'undefined') {
	        return 0;
	    }
	    return v.length;
	};

	/**
	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.USHORT = function(v) {
	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.USHORT = constant(2);

	/**
	 * Convert a 16-bit signed integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.SHORT = function(v) {
	    // Two's complement
	    if (v >= LIMIT16) {
	        v = -(2 * LIMIT16 - v);
	    }

	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.SHORT = constant(2);

	/**
	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.UINT24 = function(v) {
	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.UINT24 = constant(3);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.ULONG = function(v) {
	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.ULONG = constant(4);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONG = function(v) {
	    // Two's complement
	    if (v >= LIMIT32) {
	        v = -(2 * LIMIT32 - v);
	    }

	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONG = constant(4);

	encode.FIXED = encode.ULONG;
	sizeOf.FIXED = sizeOf.ULONG;

	encode.FWORD = encode.SHORT;
	sizeOf.FWORD = sizeOf.SHORT;

	encode.UFWORD = encode.USHORT;
	sizeOf.UFWORD = sizeOf.USHORT;

	/**
	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONGDATETIME = function(v) {
	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONGDATETIME = constant(8);

	/**
	 * Convert a 4-char tag to a list of 4 bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.TAG = function(v) {
	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
	    return [v.charCodeAt(0),
	            v.charCodeAt(1),
	            v.charCodeAt(2),
	            v.charCodeAt(3)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.TAG = constant(4);

	// CFF data types ///////////////////////////////////////////////////////////

	encode.Card8 = encode.BYTE;
	sizeOf.Card8 = sizeOf.BYTE;

	encode.Card16 = encode.USHORT;
	sizeOf.Card16 = sizeOf.USHORT;

	encode.OffSize = encode.BYTE;
	sizeOf.OffSize = sizeOf.BYTE;

	encode.SID = encode.USHORT;
	sizeOf.SID = sizeOf.USHORT;

	// Convert a numeric operand or charstring number to a variable-size list of bytes.
	/**
	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER = function(v) {
	    if (v >= -107 && v <= 107) {
	        return [v + 139];
	    } else if (v >= 108 && v <= 1131) {
	        v = v - 108;
	        return [(v >> 8) + 247, v & 0xFF];
	    } else if (v >= -1131 && v <= -108) {
	        v = -v - 108;
	        return [(v >> 8) + 251, v & 0xFF];
	    } else if (v >= -32768 && v <= 32767) {
	        return encode.NUMBER16(v);
	    } else {
	        return encode.NUMBER32(v);
	    }
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.NUMBER = function(v) {
	    return encode.NUMBER(v).length;
	};

	/**
	 * Convert a signed number between -32768 and +32767 to a three-byte value.
	 * This ensures we always use three bytes, but is not the most compact format.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER16 = function(v) {
	    return [28, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER16 = constant(3);

	/**
	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
	 * This is useful if you want to be sure you always use four bytes,
	 * at the expense of wasting a few bytes for smaller numbers.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER32 = function(v) {
	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER32 = constant(5);

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.REAL = function(v) {
	    var value = v.toString();

	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
	    // This code converts it back to a number without the epsilon.
	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
	    if (m) {
	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
	        value = (Math.round(v * epsilon) / epsilon).toString();
	    }

	    var nibbles = '';
	    for (var i = 0, ii = value.length; i < ii; i += 1) {
	        var c = value[i];
	        if (c === 'e') {
	            nibbles += value[++i] === '-' ? 'c' : 'b';
	        } else if (c === '.') {
	            nibbles += 'a';
	        } else if (c === '-') {
	            nibbles += 'e';
	        } else {
	            nibbles += c;
	        }
	    }

	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
	    var out = [30];
	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
	    }

	    return out;
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.REAL = function(v) {
	    return encode.REAL(v).length;
	};

	encode.NAME = encode.CHARARRAY;
	sizeOf.NAME = sizeOf.CHARARRAY;

	encode.STRING = encode.CHARARRAY;
	sizeOf.STRING = sizeOf.CHARARRAY;

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF8 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes;
	    for (var j = 0; j < numChars; j++, offset += 1) {
	        codePoints[j] = data.getUint8(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF16 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes / 2;
	    for (var j = 0; j < numChars; j++, offset += 2) {
	        codePoints[j] = data.getUint16(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * Convert a JavaScript string to UTF16-BE.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.UTF16 = function(v) {
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        var codepoint = v.charCodeAt(i);
	        b[b.length] = (codepoint >> 8) & 0xFF;
	        b[b.length] = codepoint & 0xFF;
	    }

	    return b;
	};

	/**
	 * @param {string}
	 * @returns {number}
	 */
	sizeOf.UTF16 = function(v) {
	    return v.length * 2;
	};

	// Data for converting old eight-bit Macintosh encodings to Unicode.
	// This representation is optimized for decoding; encoding is slower
	// and needs more memory. The assumption is that all opentype.js users
	// want to open fonts, but saving a font will be comparatively rare
	// so it can be more expensive. Keyed by IANA character set name.
	//
	// Python script for generating these strings:
	//
	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
	//     print(s.encode('utf-8'))
	/**
	 * @private
	 */
	var eightBitMacEncodings = {
	    'x-mac-croatian':  // Python: 'mac_croatian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
	    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
	    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
	    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
	    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
	    'x-mac-greek':  // Python: 'mac_greek'
	    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
	    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
	    'x-mac-icelandic':  // Python: 'mac_iceland'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
	    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
	    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
	    'x-mac-ce':  // Python: 'mac_latin2'
	    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
	    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
	    macintosh:  // Python: 'mac_roman'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-romanian':  // Python: 'mac_romanian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-turkish':  // Python: 'mac_turkish'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
	};

	/**
	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
	 * string, or 'undefined' if the encoding is unsupported. For example, we do
	 * not support Chinese, Japanese or Korean because these would need large
	 * mapping tables.
	 * @param {DataView} dataView
	 * @param {number} offset
	 * @param {number} dataLength
	 * @param {string} encoding
	 * @returns {string}
	 */
	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
	    var table = eightBitMacEncodings[encoding];
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = '';
	    for (var i = 0; i < dataLength; i++) {
	        var c = dataView.getUint8(offset + i);
	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c <= 0x7F) {
	            result += String.fromCharCode(c);
	        } else {
	            result += table[c & 0x7F];
	        }
	    }

	    return result;
	};

	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
	// Unicode character codes to their 8-bit MacOS equivalent. This table
	// is not exactly a super cheap data structure, but we do not care because
	// encoding Macintosh strings is only rarely needed in typical applications.
	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
	var macEncodingCacheKeys;
	var getMacEncodingTable = function (encoding) {
	    // Since we use encoding as a cache key for WeakMap, it has to be
	    // a String object and not a literal. And at least on NodeJS 2.10.1,
	    // WeakMap requires that the same String instance is passed for cache hits.
	    if (!macEncodingCacheKeys) {
	        macEncodingCacheKeys = {};
	        for (var e in eightBitMacEncodings) {
	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
	            macEncodingCacheKeys[e] = new String(e);
	        }
	    }

	    var cacheKey = macEncodingCacheKeys[encoding];
	    if (cacheKey === undefined) {
	        return undefined;
	    }

	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
	    // since garbage collection may run at any time, it could also kick in
	    // between the calls to cache.has() and cache.get(). In that case,
	    // we would return 'undefined' even though we do support the encoding.
	    if (macEncodingTableCache) {
	        var cachedTable = macEncodingTableCache.get(cacheKey);
	        if (cachedTable !== undefined) {
	            return cachedTable;
	        }
	    }

	    var decodingTable = eightBitMacEncodings[encoding];
	    if (decodingTable === undefined) {
	        return undefined;
	    }

	    var encodingTable = {};
	    for (var i = 0; i < decodingTable.length; i++) {
	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
	    }

	    if (macEncodingTableCache) {
	        macEncodingTableCache.set(cacheKey, encodingTable);
	    }

	    return encodingTable;
	};

	/**
	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
	 * If the requested encoding is unsupported, or if the input string contains
	 * a character that cannot be expressed in the encoding, the function returns
	 * 'undefined'.
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {Array}
	 */
	encode.MACSTRING = function(str, encoding) {
	    var table = getMacEncodingTable(encoding);
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = [];
	    for (var i = 0; i < str.length; i++) {
	        var c = str.charCodeAt(i);

	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c >= 0x80) {
	            c = table[c];
	            if (c === undefined) {
	                // str contains a Unicode character that cannot be encoded
	                // in the requested encoding.
	                return undefined;
	            }
	        }
	        result[i] = c;
	        // result.push(c);
	    }

	    return result;
	};

	/**
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {number}
	 */
	sizeOf.MACSTRING = function(str, encoding) {
	    var b = encode.MACSTRING(str, encoding);
	    if (b !== undefined) {
	        return b.length;
	    } else {
	        return 0;
	    }
	};

	// Helper for encode.VARDELTAS
	function isByteEncodable(value) {
	    return value >= -128 && value <= 127;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
	        ++pos;
	        ++runLength;
	    }
	    result.push(0x80 | (runLength - 1));
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];
	        if (!isByteEncodable(value)) {
	            break;
	        }

	        // Within a byte-encoded run of deltas, a single zero is best
	        // stored literally as 0x00 value. However, if we have two or
	        // more zeroes in a sequence, it is better to start a new run.
	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
	        // when starting a new run.
	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(runLength - 1);
	    for (var i = offset; i < pos; ++i) {
	        result.push((deltas[i] + 256) & 0xff);
	    }
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsWords(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];

	        // Within a word-encoded run of deltas, it is easiest to start
	        // a new run (with a different encoding) whenever we encounter
	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
	        // needs 7 bytes when storing the zero inside the current run
	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
	        // new run (40 66 66 80 40 77 77).
	        if (value === 0) {
	            break;
	        }

	        // Within a word-encoded run of deltas, a single value in the
	        // range (-128..127) should be encoded within the current run
	        // because it is more compact. For example, the sequence
	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
	        // a new run (40 66 66 00 02 40 77 77).
	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(0x40 | (runLength - 1));
	    for (var i = offset; i < pos; ++i) {
	        var val = deltas[i];
	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
	    }
	    return pos;
	}

	/**
	 * Encode a list of variation adjustment deltas.
	 *
	 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
	 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
	 * when generating instances of variation fonts.
	 *
	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
	 * @param {Array}
	 * @return {Array}
	 */
	encode.VARDELTAS = function(deltas) {
	    var pos = 0;
	    var result = [];
	    while (pos < deltas.length) {
	        var value = deltas[pos];
	        if (value === 0) {
	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
	        } else if (value >= -128 && value <= 127) {
	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
	        } else {
	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
	        }
	    }
	    return result;
	};

	// Convert a list of values to a CFF INDEX structure.
	// The values should be objects containing name / type / value.
	/**
	 * @param {Array} l
	 * @returns {Array}
	 */
	encode.INDEX = function(l) {
	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
	    //    i, v;
	    // Because we have to know which data type to use to encode the offsets,
	    // we have to go through the values twice: once to encode the data and
	    // calculate the offsets, then again to encode the offsets using the fitting data type.
	    var offset = 1; // First offset is always 1.
	    var offsets = [offset];
	    var data = [];
	    for (var i = 0; i < l.length; i += 1) {
	        var v = encode.OBJECT(l[i]);
	        Array.prototype.push.apply(data, v);
	        offset += v.length;
	        offsets.push(offset);
	    }

	    if (data.length === 0) {
	        return [0, 0];
	    }

	    var encodedOffsets = [];
	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
	        var encodedOffset = offsetEncoder(offsets[i$1]);
	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
	    }

	    return Array.prototype.concat(encode.Card16(l.length),
	                           encode.OffSize(offSize),
	                           encodedOffsets,
	                           data);
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.INDEX = function(v) {
	    return encode.INDEX(v).length;
	};

	/**
	 * Convert an object to a CFF DICT structure.
	 * The keys should be numeric.
	 * The values should be objects containing name / type / value.
	 * @param {Object} m
	 * @returns {Array}
	 */
	encode.DICT = function(m) {
	    var d = [];
	    var keys = Object.keys(m);
	    var length = keys.length;

	    for (var i = 0; i < length; i += 1) {
	        // Object.keys() return string keys, but our keys are always numeric.
	        var k = parseInt(keys[i], 0);
	        var v = m[k];
	        // Value comes before the key.
	        d = d.concat(encode.OPERAND(v.value, v.type));
	        d = d.concat(encode.OPERATOR(k));
	    }

	    return d;
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.DICT = function(m) {
	    return encode.DICT(m).length;
	};

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.OPERATOR = function(v) {
	    if (v < 1200) {
	        return [v];
	    } else {
	        return [12, v - 1200];
	    }
	};

	/**
	 * @param {Array} v
	 * @param {string}
	 * @returns {Array}
	 */
	encode.OPERAND = function(v, type) {
	    var d = [];
	    if (Array.isArray(type)) {
	        for (var i = 0; i < type.length; i += 1) {
	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
	            d = d.concat(encode.OPERAND(v[i], type[i]));
	        }
	    } else {
	        if (type === 'SID') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'offset') {
	            // We make it easy for ourselves and always encode offsets as
	            // 4 bytes. This makes offset calculation for the top dict easier.
	            d = d.concat(encode.NUMBER32(v));
	        } else if (type === 'number') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'real') {
	            d = d.concat(encode.REAL(v));
	        } else {
	            throw new Error('Unknown operand type ' + type);
	            // FIXME Add support for booleans
	        }
	    }

	    return d;
	};

	encode.OP = encode.BYTE;
	sizeOf.OP = sizeOf.BYTE;

	// memoize charstring encoding using WeakMap if available
	var wmm = typeof WeakMap === 'function' && new WeakMap();

	/**
	 * Convert a list of CharString operations to bytes.
	 * @param {Array}
	 * @returns {Array}
	 */
	encode.CHARSTRING = function(ops) {
	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
	    if (wmm) {
	        var cachedValue = wmm.get(ops);
	        if (cachedValue !== undefined) {
	            return cachedValue;
	        }
	    }

	    var d = [];
	    var length = ops.length;

	    for (var i = 0; i < length; i += 1) {
	        var op = ops[i];
	        d = d.concat(encode[op.type](op.value));
	    }

	    if (wmm) {
	        wmm.set(ops, d);
	    }

	    return d;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARSTRING = function(ops) {
	    return encode.CHARSTRING(ops).length;
	};

	// Utility functions ////////////////////////////////////////////////////////

	/**
	 * Convert an object containing name / type / value to bytes.
	 * @param {Object}
	 * @returns {Array}
	 */
	encode.OBJECT = function(v) {
	    var encodingFunction = encode[v.type];
	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
	    return encodingFunction(v.value);
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.OBJECT = function(v) {
	    var sizeOfFunction = sizeOf[v.type];
	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
	    return sizeOfFunction(v.value);
	};

	/**
	 * Convert a table object to bytes.
	 * A table contains a list of fields containing the metadata (name, type and default value).
	 * The table itself has the field values set as attributes.
	 * @param {opentype.Table}
	 * @returns {Array}
	 */
	encode.TABLE = function(table) {
	    var d = [];
	    var length = table.fields.length;
	    var subtables = [];
	    var subtableOffsets = [];

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var encodingFunction = encode[field.type];
	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        var bytes = encodingFunction(value);

	        if (field.type === 'TABLE') {
	            subtableOffsets.push(d.length);
	            d = d.concat([0, 0]);
	            subtables.push(bytes);
	        } else {
	            d = d.concat(bytes);
	        }
	    }

	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
	        var o = subtableOffsets[i$1];
	        var offset = d.length;
	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
	        d[o] = offset >> 8;
	        d[o + 1] = offset & 0xff;
	        d = d.concat(subtables[i$1]);
	    }

	    return d;
	};

	/**
	 * @param {opentype.Table}
	 * @returns {number}
	 */
	sizeOf.TABLE = function(table) {
	    var numBytes = 0;
	    var length = table.fields.length;

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var sizeOfFunction = sizeOf[field.type];
	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        numBytes += sizeOfFunction(value);

	        // Subtables take 2 more bytes for offsets.
	        if (field.type === 'TABLE') {
	            numBytes += 2;
	        }
	    }

	    return numBytes;
	};

	encode.RECORD = encode.TABLE;
	sizeOf.RECORD = sizeOf.TABLE;

	// Merge in a list of bytes.
	encode.LITERAL = function(v) {
	    return v;
	};

	sizeOf.LITERAL = function(v) {
	    return v.length;
	};

	// Table metadata

	/**
	 * @exports opentype.Table
	 * @class
	 * @param {string} tableName
	 * @param {Array} fields
	 * @param {Object} options
	 * @constructor
	 */
	function Table(tableName, fields, options) {
	    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,
	    // as this will result in wrong encoding order of the coverage data on serialization to bytes.
	    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.
	    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {
	        for (var i = 0; i < fields.length; i += 1) {
	            var field = fields[i];
	            this[field.name] = field.value;
	        }
	    }

	    this.tableName = tableName;
	    this.fields = fields;
	    if (options) {
	        var optionKeys = Object.keys(options);
	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
	            var k = optionKeys[i$1];
	            var v = options[k];
	            if (this[k] !== undefined) {
	                this[k] = v;
	            }
	        }
	    }
	}

	/**
	 * Encodes the table and returns an array of bytes
	 * @return {Array}
	 */
	Table.prototype.encode = function() {
	    return encode.TABLE(this);
	};

	/**
	 * Get the size of the table.
	 * @return {number}
	 */
	Table.prototype.sizeOf = function() {
	    return sizeOf.TABLE(this);
	};

	/**
	 * @private
	 */
	function ushortList(itemName, list, count) {
	    if (count === undefined) {
	        count = list.length;
	    }
	    var fields = new Array(list.length + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < list.length; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function tableList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = new Array(count + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function recordList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = [];
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields = fields.concat(itemCallback(records[i], i));
	    }
	    return fields;
	}

	// Common Layout Tables

	/**
	 * @exports opentype.Coverage
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function Coverage(coverageTable) {
	    if (coverageTable.format === 1) {
	        Table.call(this, 'coverageTable',
	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
	            .concat(ushortList('glyph', coverageTable.glyphs))
	        );
	    } else if (coverageTable.format === 2) {
	        Table.call(this, 'coverageTable',
	            [{name: 'coverageFormat', type: 'USHORT', value: 2}]
	            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {
	                return [
	                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},
	                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},
	                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];
	            }))
	        );
	    } else {
	        check.assert(false, 'Coverage format must be 1 or 2.');
	    }
	}
	Coverage.prototype = Object.create(Table.prototype);
	Coverage.prototype.constructor = Coverage;

	function ScriptList(scriptListTable) {
	    Table.call(this, 'scriptListTable',
	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
	            var script = scriptRecord.script;
	            var defaultLangSys = script.defaultLangSys;
	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
	            return [
	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
	                        var langSys = langSysRecord.langSys;
	                        return [
	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
	                        ];
	                    })))}
	            ];
	        })
	    );
	}
	ScriptList.prototype = Object.create(Table.prototype);
	ScriptList.prototype.constructor = ScriptList;

	/**
	 * @exports opentype.FeatureList
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function FeatureList(featureListTable) {
	    Table.call(this, 'featureListTable',
	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
	            var feature = featureRecord.feature;
	            return [
	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
	            ];
	        })
	    );
	}
	FeatureList.prototype = Object.create(Table.prototype);
	FeatureList.prototype.constructor = FeatureList;

	/**
	 * @exports opentype.LookupList
	 * @class
	 * @param {opentype.Table}
	 * @param {Object}
	 * @constructor
	 * @extends opentype.Table
	 */
	function LookupList(lookupListTable, subtableMakers) {
	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
	        var subtableCallback = subtableMakers[lookupTable.lookupType];
	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
	        return new Table('lookupTable', [
	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
	    }));
	}
	LookupList.prototype = Object.create(Table.prototype);
	LookupList.prototype.constructor = LookupList;

	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
	// Don't use offsets inside Records (probable bug), only in Tables.
	var table = {
	    Table: Table,
	    Record: Table,
	    Coverage: Coverage,
	    ScriptList: ScriptList,
	    FeatureList: FeatureList,
	    LookupList: LookupList,
	    ushortList: ushortList,
	    tableList: tableList,
	    recordList: recordList,
	};

	// Parsing utility functions

	// Retrieve an unsigned byte from the DataView.
	function getByte(dataView, offset) {
	    return dataView.getUint8(offset);
	}

	// Retrieve an unsigned 16-bit short from the DataView.
	// The value is stored in big endian.
	function getUShort(dataView, offset) {
	    return dataView.getUint16(offset, false);
	}

	// Retrieve a signed 16-bit short from the DataView.
	// The value is stored in big endian.
	function getShort(dataView, offset) {
	    return dataView.getInt16(offset, false);
	}

	// Retrieve an unsigned 32-bit long from the DataView.
	// The value is stored in big endian.
	function getULong(dataView, offset) {
	    return dataView.getUint32(offset, false);
	}

	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
	// The value is stored in big endian.
	function getFixed(dataView, offset) {
	    var decimal = dataView.getInt16(offset, false);
	    var fraction = dataView.getUint16(offset + 2, false);
	    return decimal + fraction / 65535;
	}

	// Retrieve a 4-character tag from the DataView.
	// Tags are used to identify tables.
	function getTag(dataView, offset) {
	    var tag = '';
	    for (var i = offset; i < offset + 4; i += 1) {
	        tag += String.fromCharCode(dataView.getInt8(i));
	    }

	    return tag;
	}

	// Retrieve an offset from the DataView.
	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
	function getOffset(dataView, offset, offSize) {
	    var v = 0;
	    for (var i = 0; i < offSize; i += 1) {
	        v <<= 8;
	        v += dataView.getUint8(offset + i);
	    }

	    return v;
	}

	// Retrieve a number of bytes from start offset to the end offset from the DataView.
	function getBytes(dataView, startOffset, endOffset) {
	    var bytes = [];
	    for (var i = startOffset; i < endOffset; i += 1) {
	        bytes.push(dataView.getUint8(i));
	    }

	    return bytes;
	}

	// Convert the list of bytes to a string.
	function bytesToString(bytes) {
	    var s = '';
	    for (var i = 0; i < bytes.length; i += 1) {
	        s += String.fromCharCode(bytes[i]);
	    }

	    return s;
	}

	var typeOffsets = {
	    byte: 1,
	    uShort: 2,
	    short: 2,
	    uLong: 4,
	    fixed: 4,
	    longDateTime: 8,
	    tag: 4
	};

	// A stateful parser that changes the offset whenever a value is retrieved.
	// The data is a DataView.
	function Parser(data, offset) {
	    this.data = data;
	    this.offset = offset;
	    this.relativeOffset = 0;
	}

	Parser.prototype.parseByte = function() {
	    var v = this.data.getUint8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseChar = function() {
	    var v = this.data.getInt8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseCard8 = Parser.prototype.parseByte;

	Parser.prototype.parseUShort = function() {
	    var v = this.data.getUint16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
	Parser.prototype.parseSID = Parser.prototype.parseUShort;
	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

	Parser.prototype.parseShort = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseF2Dot14 = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseULong = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

	Parser.prototype.parseFixed = function() {
	    var v = getFixed(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseString = function(length) {
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    var string = '';
	    this.relativeOffset += length;
	    for (var i = 0; i < length; i++) {
	        string += String.fromCharCode(dataView.getUint8(offset + i));
	    }

	    return string;
	};

	Parser.prototype.parseTag = function() {
	    return this.parseString(4);
	};

	// LONGDATETIME is a 64-bit integer.
	// JavaScript and unix timestamps traditionally use 32 bits, so we
	// only take the last 32 bits.
	// + Since until 2038 those bits will be filled by zeros we can ignore them.
	Parser.prototype.parseLongDateTime = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
	    // Subtract seconds between 01/01/1904 and 01/01/1970
	    // to convert Apple Mac timestamp to Standard Unix timestamp
	    v -= 2082844800;
	    this.relativeOffset += 8;
	    return v;
	};

	Parser.prototype.parseVersion = function(minorBase) {
	    var major = getUShort(this.data, this.offset + this.relativeOffset);

	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
	    // Default returns the correct number if minor = 0xN000 where N is 0-9
	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
	    this.relativeOffset += 4;
	    if (minorBase === undefined) { minorBase = 0x1000; }
	    return major + minor / minorBase / 10;
	};

	Parser.prototype.skip = function(type, amount) {
	    if (amount === undefined) {
	        amount = 1;
	    }

	    this.relativeOffset += typeOffsets[type] * amount;
	};

	///// Parsing lists and records ///////////////////////////////

	// Parse a list of 32 bit unsigned integers.
	Parser.prototype.parseULongList = function(count) {
	    if (count === undefined) { count = this.parseULong(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint32(offset);
	        offset += 4;
	    }

	    this.relativeOffset += count * 4;
	    return offsets;
	};

	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
	// or provided as an argument.
	Parser.prototype.parseOffset16List =
	Parser.prototype.parseUShortList = function(count) {
	    if (count === undefined) { count = this.parseUShort(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return offsets;
	};

	// Parses a list of 16 bit signed integers.
	Parser.prototype.parseShortList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getInt16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return list;
	};

	// Parses a list of bytes.
	Parser.prototype.parseByteList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getUint8(offset++);
	    }

	    this.relativeOffset += count;
	    return list;
	};

	/**
	 * Parse a list of items.
	 * Record count is optional, if omitted it is read from the stream.
	 * itemCallback is one of the Parser methods.
	 */
	Parser.prototype.parseList = function(count, itemCallback) {
	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseUShort();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this);
	    }
	    return list;
	};

	Parser.prototype.parseList32 = function(count, itemCallback) {
	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseULong();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this);
	    }
	    return list;
	};

	/**
	 * Parse a list of records.
	 * Record count is optional, if omitted it is read from the stream.
	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	 */
	Parser.prototype.parseRecordList = function(count, recordDescription) {
	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseUShort();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseULong();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	// Parse a data structure into an object
	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	Parser.prototype.parseStruct = function(description) {
	    if (typeof description === 'function') {
	        return description.call(this);
	    } else {
	        var fields = Object.keys(description);
	        var struct = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = description[fieldName];
	            struct[fieldName] = fieldType.call(this);
	        }
	        return struct;
	    }
	};

	/**
	 * Parse a GPOS valueRecord
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat is optional, if omitted it is read from the stream.
	 */
	Parser.prototype.parseValueRecord = function(valueFormat) {
	    if (valueFormat === undefined) {
	        valueFormat = this.parseUShort();
	    }
	    if (valueFormat === 0) {
	        // valueFormat2 in kerning pairs is most often 0
	        // in this case return undefined instead of an empty object, to save space
	        return;
	    }
	    var valueRecord = {};

	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

	    return valueRecord;
	};

	/**
	 * Parse a list of GPOS valueRecords
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat and valueCount are read from the stream.
	 */
	Parser.prototype.parseValueRecordList = function() {
	    var valueFormat = this.parseUShort();
	    var valueCount = this.parseUShort();
	    var values = new Array(valueCount);
	    for (var i = 0; i < valueCount; i++) {
	        values[i] = this.parseValueRecord(valueFormat);
	    }
	    return values;
	};

	Parser.prototype.parsePointer = function(description) {
	    var structOffset = this.parseOffset16();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	Parser.prototype.parsePointer32 = function(description) {
	    var structOffset = this.parseOffset32();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	/**
	 * Parse a list of offsets to lists of 16-bit integers,
	 * or a list of offsets to lists of offsets to any kind of items.
	 * If itemCallback is not provided, a list of list of UShort is assumed.
	 * If provided, itemCallback is called on each item and must parse the item.
	 * See examples in tables/gsub.js
	 */
	Parser.prototype.parseListOfLists = function(itemCallback) {
	    var offsets = this.parseOffset16List();
	    var count = offsets.length;
	    var relativeOffset = this.relativeOffset;
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        var start = offsets[i];
	        if (start === 0) {
	            // NULL offset
	            // Add i as owned property to list. Convenient with assert.
	            list[i] = undefined;
	            continue;
	        }
	        this.relativeOffset = start;
	        if (itemCallback) {
	            var subOffsets = this.parseOffset16List();
	            var subList = new Array(subOffsets.length);
	            for (var j = 0; j < subOffsets.length; j++) {
	                this.relativeOffset = start + subOffsets[j];
	                subList[j] = itemCallback.call(this);
	            }
	            list[i] = subList;
	        } else {
	            list[i] = this.parseUShortList();
	        }
	    }
	    this.relativeOffset = relativeOffset;
	    return list;
	};

	///// Complex tables parsing //////////////////////////////////

	// Parse a coverage table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	// parser.offset must point to the start of the table containing the coverage.
	Parser.prototype.parseCoverage = function() {
	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    var count = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            glyphs: this.parseUShortList(count)
	        };
	    } else if (format === 2) {
	        var ranges = new Array(count);
	        for (var i = 0; i < count; i++) {
	            ranges[i] = {
	                start: this.parseUShort(),
	                end: this.parseUShort(),
	                index: this.parseUShort()
	            };
	        }
	        return {
	            format: 2,
	            ranges: ranges
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
	};

	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	Parser.prototype.parseClassDef = function() {
	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            startGlyph: this.parseUShort(),
	            classes: this.parseUShortList()
	        };
	    } else if (format === 2) {
	        return {
	            format: 2,
	            ranges: this.parseRecordList({
	                start: Parser.uShort,
	                end: Parser.uShort,
	                classId: Parser.uShort
	            })
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
	};

	///// Static methods ///////////////////////////////////
	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

	Parser.list = function(count, itemCallback) {
	    return function() {
	        return this.parseList(count, itemCallback);
	    };
	};

	Parser.list32 = function(count, itemCallback) {
	    return function() {
	        return this.parseList32(count, itemCallback);
	    };
	};

	Parser.recordList = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList(count, recordDescription);
	    };
	};

	Parser.recordList32 = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList32(count, recordDescription);
	    };
	};

	Parser.pointer = function(description) {
	    return function() {
	        return this.parsePointer(description);
	    };
	};

	Parser.pointer32 = function(description) {
	    return function() {
	        return this.parsePointer32(description);
	    };
	};

	Parser.tag = Parser.prototype.parseTag;
	Parser.byte = Parser.prototype.parseByte;
	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
	Parser.uShortList = Parser.prototype.parseUShortList;
	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
	Parser.uLongList = Parser.prototype.parseULongList;
	Parser.struct = Parser.prototype.parseStruct;
	Parser.coverage = Parser.prototype.parseCoverage;
	Parser.classDef = Parser.prototype.parseClassDef;

	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

	var langSysTable = {
	    reserved: Parser.uShort,
	    reqFeatureIndex: Parser.uShort,
	    featureIndexes: Parser.uShortList
	};

	Parser.prototype.parseScriptList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        script: Parser.pointer({
	            defaultLangSys: Parser.pointer(langSysTable),
	            langSysRecords: Parser.recordList({
	                tag: Parser.tag,
	                langSys: Parser.pointer(langSysTable)
	            })
	        })
	    })) || [];
	};

	Parser.prototype.parseFeatureList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        feature: Parser.pointer({
	            featureParams: Parser.offset16,
	            lookupListIndexes: Parser.uShortList
	        })
	    })) || [];
	};

	Parser.prototype.parseLookupList = function(lookupTableParsers) {
	    return this.parsePointer(Parser.list(Parser.pointer(function() {
	        var lookupType = this.parseUShort();
	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
	        var lookupFlag = this.parseUShort();
	        var useMarkFilteringSet = lookupFlag & 0x10;
	        return {
	            lookupType: lookupType,
	            lookupFlag: lookupFlag,
	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
	        };
	    }))) || [];
	};

	Parser.prototype.parseFeatureVariationsList = function() {
	    return this.parsePointer32(function() {
	        var majorVersion = this.parseUShort();
	        var minorVersion = this.parseUShort();
	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
	        var featureVariations = this.parseRecordList32({
	            conditionSetOffset: Parser.offset32,
	            featureTableSubstitutionOffset: Parser.offset32
	        });
	        return featureVariations;
	    }) || [];
	};

	var parse = {
	    getByte: getByte,
	    getCard8: getByte,
	    getUShort: getUShort,
	    getCard16: getUShort,
	    getShort: getShort,
	    getULong: getULong,
	    getFixed: getFixed,
	    getTag: getTag,
	    getOffset: getOffset,
	    getBytes: getBytes,
	    bytesToString: bytesToString,
	    Parser: Parser,
	};

	// The `cmap` table stores the mappings from characters to glyphs.

	function parseCmapTableFormat12(cmap, p) {
	    //Skip reserved.
	    p.parseUShort();

	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseULong();
	    cmap.language = p.parseULong();

	    var groupCount;
	    cmap.groupCount = groupCount = p.parseULong();
	    cmap.glyphIndexMap = {};

	    for (var i = 0; i < groupCount; i += 1) {
	        var startCharCode = p.parseULong();
	        var endCharCode = p.parseULong();
	        var startGlyphId = p.parseULong();

	        for (var c = startCharCode; c <= endCharCode; c += 1) {
	            cmap.glyphIndexMap[c] = startGlyphId;
	            startGlyphId++;
	        }
	    }
	}

	function parseCmapTableFormat4(cmap, p, data, start, offset) {
	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseUShort();
	    cmap.language = p.parseUShort();

	    // segCount is stored x 2.
	    var segCount;
	    cmap.segCount = segCount = p.parseUShort() >> 1;

	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);

	    // The "unrolled" mapping from character codes to glyph indices.
	    cmap.glyphIndexMap = {};
	    var endCountParser = new parse.Parser(data, start + offset + 14);
	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
	    for (var i = 0; i < segCount - 1; i += 1) {
	        var glyphIndex = (void 0);
	        var endCount = endCountParser.parseUShort();
	        var startCount = startCountParser.parseUShort();
	        var idDelta = idDeltaParser.parseShort();
	        var idRangeOffset = idRangeOffsetParser.parseUShort();
	        for (var c = startCount; c <= endCount; c += 1) {
	            if (idRangeOffset !== 0) {
	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
	                // Take the current offset in the idRangeOffset array.
	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
	                glyphIndexOffset += idRangeOffset;

	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
	                glyphIndexOffset += (c - startCount) * 2;
	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
	                if (glyphIndex !== 0) {
	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
	                }
	            } else {
	                glyphIndex = (c + idDelta) & 0xFFFF;
	            }

	            cmap.glyphIndexMap[c] = glyphIndex;
	        }
	    }
	}

	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
	// There are many available formats, but we only support the Windows format 4 and 12.
	// This function returns a `CmapEncoding` object or null if no supported format could be found.
	function parseCmapTable(data, start) {
	    var cmap = {};
	    cmap.version = parse.getUShort(data, start);
	    check.argument(cmap.version === 0, 'cmap table version should be 0.');

	    // The cmap table can contain many sub-tables, each with their own format.
	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
	    cmap.numTables = parse.getUShort(data, start + 2);
	    var offset = -1;
	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
	            break;
	        }
	    }

	    if (offset === -1) {
	        // There is no cmap table in the font that we support.
	        throw new Error('No valid cmap sub-tables found.');
	    }

	    var p = new parse.Parser(data, start + offset);
	    cmap.format = p.parseUShort();

	    if (cmap.format === 12) {
	        parseCmapTableFormat12(cmap, p);
	    } else if (cmap.format === 4) {
	        parseCmapTableFormat4(cmap, p, data, start, offset);
	    } else {
	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
	    }

	    return cmap;
	}

	function addSegment(t, code, glyphIndex) {
	    t.segments.push({
	        end: code,
	        start: code,
	        delta: -(code - glyphIndex),
	        offset: 0,
	        glyphIndex: glyphIndex
	    });
	}

	function addTerminatorSegment(t) {
	    t.segments.push({
	        end: 0xFFFF,
	        start: 0xFFFF,
	        delta: 1,
	        offset: 0
	    });
	}

	// Make cmap table, format 4 by default, 12 if needed only
	function makeCmapTable(glyphs) {
	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
	    var isPlan0Only = true;
	    var i;

	    // Check if we need to add cmap format 12 or if format 4 only is fine
	    for (i = glyphs.length - 1; i > 0; i -= 1) {
	        var g = glyphs.get(i);
	        if (g.unicode > 65535) {
	            console.log('Adding CMAP format 12 (needed!)');
	            isPlan0Only = false;
	            break;
	        }
	    }

	    var cmapTable = [
	        {name: 'version', type: 'USHORT', value: 0},
	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

	        // CMAP 4 header
	        {name: 'platformID', type: 'USHORT', value: 3},
	        {name: 'encodingID', type: 'USHORT', value: 1},
	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
	    ];

	    if (!isPlan0Only)
	        { cmapTable = cmapTable.concat([
	            // CMAP 12 header
	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
	        ]); }

	    cmapTable = cmapTable.concat([
	        // CMAP 4 Subtable
	        {name: 'format', type: 'USHORT', value: 4},
	        {name: 'cmap4Length', type: 'USHORT', value: 0},
	        {name: 'language', type: 'USHORT', value: 0},
	        {name: 'segCountX2', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);

	    var t = new table.Table('cmap', cmapTable);

	    t.segments = [];
	    for (i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
	            addSegment(t, glyph.unicodes[j], i);
	        }

	        t.segments = t.segments.sort(function (a, b) {
	            return a.start - b.start;
	        });
	    }

	    addTerminatorSegment(t);

	    var segCount = t.segments.length;
	    var segCountToRemove = 0;

	    // CMAP 4
	    // Set up parallel segment arrays.
	    var endCounts = [];
	    var startCounts = [];
	    var idDeltas = [];
	    var idRangeOffsets = [];
	    var glyphIds = [];

	    // CMAP 12
	    var cmap12Groups = [];

	    // Reminder this loop is not following the specification at 100%
	    // The specification -> find suites of characters and make a group
	    // Here we're doing one group for each letter
	    // Doing as the spec can save 8 times (or more) space
	    for (i = 0; i < segCount; i += 1) {
	        var segment = t.segments[i];

	        // CMAP 4
	        if (segment.end <= 65535 && segment.start <= 65535) {
	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
	            if (segment.glyphId !== undefined) {
	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
	            }
	        } else {
	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
	            segCountToRemove += 1;
	        }

	        // CMAP 12
	        // Skip Terminator Segment
	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
	        }
	    }

	    // CMAP 4 Subtable
	    t.segCountX2 = (segCount - segCountToRemove) * 2;
	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
	    t.rangeShift = t.segCountX2 - t.searchRange;

	    t.fields = t.fields.concat(endCounts);
	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
	    t.fields = t.fields.concat(startCounts);
	    t.fields = t.fields.concat(idDeltas);
	    t.fields = t.fields.concat(idRangeOffsets);
	    t.fields = t.fields.concat(glyphIds);

	    t.cmap4Length = 14 + // Subtable header
	        endCounts.length * 2 +
	        2 + // reservedPad
	        startCounts.length * 2 +
	        idDeltas.length * 2 +
	        idRangeOffsets.length * 2 +
	        glyphIds.length * 2;

	    if (!isPlan0Only) {
	        // CMAP 12 Subtable
	        var cmap12Length = 16 + // Subtable header
	            cmap12Groups.length * 4;

	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
	        t.fields = t.fields.concat([
	            {name: 'cmap12Format', type: 'USHORT', value: 12},
	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
	            {name: 'cmap12Language', type: 'ULONG', value: 0},
	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
	        ]);

	        t.fields = t.fields.concat(cmap12Groups);
	    }

	    return t;
	}

	var cmap = { parse: parseCmapTable, make: makeCmapTable };

	// Glyph encoding

	var cffStandardStrings = [
	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

	var cffStandardEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
	    'lslash', 'oslash', 'oe', 'germandbls'];

	var cffExpertEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

	var standardNames = [
	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

	/**
	 * This is the encoding used for fonts created from scratch.
	 * It loops through all glyphs and finds the appropriate unicode value.
	 * Since it's linear time, other encodings will be faster.
	 * @exports opentype.DefaultEncoding
	 * @class
	 * @constructor
	 * @param {opentype.Font}
	 */
	function DefaultEncoding(font) {
	    this.font = font;
	}

	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
	    var code = c.codePointAt(0);
	    var glyphs = this.font.glyphs;
	    if (glyphs) {
	        for (var i = 0; i < glyphs.length; i += 1) {
	            var glyph = glyphs.get(i);
	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
	                if (glyph.unicodes[j] === code) {
	                    return i;
	                }
	            }
	        }
	    }
	    return null;
	};

	/**
	 * @exports opentype.CmapEncoding
	 * @class
	 * @constructor
	 * @param {Object} cmap - a object with the cmap encoded data
	 */
	function CmapEncoding(cmap) {
	    this.cmap = cmap;
	}

	/**
	 * @param  {string} c - the character
	 * @return {number} The glyph index.
	 */
	CmapEncoding.prototype.charToGlyphIndex = function(c) {
	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
	};

	/**
	 * @exports opentype.CffEncoding
	 * @class
	 * @constructor
	 * @param {string} encoding - The encoding
	 * @param {Array} charset - The character set.
	 */
	function CffEncoding(encoding, charset) {
	    this.encoding = encoding;
	    this.charset = charset;
	}

	/**
	 * @param  {string} s - The character
	 * @return {number} The index.
	 */
	CffEncoding.prototype.charToGlyphIndex = function(s) {
	    var code = s.codePointAt(0);
	    var charName = this.encoding[code];
	    return this.charset.indexOf(charName);
	};

	/**
	 * @exports opentype.GlyphNames
	 * @class
	 * @constructor
	 * @param {Object} post
	 */
	function GlyphNames(post) {
	    switch (post.version) {
	        case 1:
	            this.names = standardNames.slice();
	            break;
	        case 2:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                if (post.glyphNameIndex[i] < standardNames.length) {
	                    this.names[i] = standardNames[post.glyphNameIndex[i]];
	                } else {
	                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
	                }
	            }

	            break;
	        case 2.5:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
	            }

	            break;
	        case 3:
	            this.names = [];
	            break;
	        default:
	            this.names = [];
	            break;
	    }
	}

	/**
	 * Gets the index of a glyph by name.
	 * @param  {string} name - The glyph name
	 * @return {number} The index
	 */
	GlyphNames.prototype.nameToGlyphIndex = function(name) {
	    return this.names.indexOf(name);
	};

	/**
	 * @param  {number} gid
	 * @return {string}
	 */
	GlyphNames.prototype.glyphIndexToName = function(gid) {
	    return this.names[gid];
	};

	function addGlyphNamesAll(font) {
	    var glyph;
	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
	    var charCodes = Object.keys(glyphIndexMap);

	    for (var i = 0; i < charCodes.length; i += 1) {
	        var c = charCodes[i];
	        var glyphIndex = glyphIndexMap[c];
	        glyph = font.glyphs.get(glyphIndex);
	        glyph.addUnicode(parseInt(c));
	    }

	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
	        glyph = font.glyphs.get(i$1);
	        if (font.cffEncoding) {
	            if (font.isCIDFont) {
	                glyph.name = 'gid' + i$1;
	            } else {
	                glyph.name = font.cffEncoding.charset[i$1];
	            }
	        } else if (font.glyphNames.names) {
	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
	        }
	    }
	}

	function addGlyphNamesToUnicodeMap(font) {
	    font._IndexToUnicodeMap = {};

	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
	    var charCodes = Object.keys(glyphIndexMap);

	    for (var i = 0; i < charCodes.length; i += 1) {
	        var c = charCodes[i];
	        var glyphIndex = glyphIndexMap[c];
	        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {
	            font._IndexToUnicodeMap[glyphIndex] = {
	                unicodes: [parseInt(c)]
	            };
	        } else {
	            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
	        }
	    }
	}

	/**
	 * @alias opentype.addGlyphNames
	 * @param {opentype.Font}
	 * @param {Object}
	 */
	function addGlyphNames(font, opt) {
	    if (opt.lowMemory) {
	        addGlyphNamesToUnicodeMap(font);
	    } else {
	        addGlyphNamesAll(font);
	    }
	}

	// Drawing utility functions.

	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
	function line(ctx, x1, y1, x2, y2) {
	    ctx.beginPath();
	    ctx.moveTo(x1, y1);
	    ctx.lineTo(x2, y2);
	    ctx.stroke();
	}

	var draw = { line: line };

	// The Glyph object
	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

	function getPathDefinition(glyph, path) {
	    var _path = path || new Path();
	    return {
	        configurable: true,

	        get: function() {
	            if (typeof _path === 'function') {
	                _path = _path();
	            }

	            return _path;
	        },

	        set: function(p) {
	            _path = p;
	        }
	    };
	}
	/**
	 * @typedef GlyphOptions
	 * @type Object
	 * @property {string} [name] - The glyph name
	 * @property {number} [unicode]
	 * @property {Array} [unicodes]
	 * @property {number} [xMin]
	 * @property {number} [yMin]
	 * @property {number} [xMax]
	 * @property {number} [yMax]
	 * @property {number} [advanceWidth]
	 */

	// A Glyph is an individual mark that often corresponds to a character.
	// Some glyphs, such as ligatures, are a combination of many characters.
	// Glyphs are the basic building blocks of a font.
	//
	// The `Glyph` class contains utility methods for drawing the path and its points.
	/**
	 * @exports opentype.Glyph
	 * @class
	 * @param {GlyphOptions}
	 * @constructor
	 */
	function Glyph(options) {
	    // By putting all the code on a prototype function (which is only declared once)
	    // we reduce the memory requirements for larger fonts by some 2%
	    this.bindConstructorValues(options);
	}

	/**
	 * @param  {GlyphOptions}
	 */
	Glyph.prototype.bindConstructorValues = function(options) {
	    this.index = options.index || 0;

	    // These three values cannot be deferred for memory optimization:
	    this.name = options.name || null;
	    this.unicode = options.unicode || undefined;
	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

	    // But by binding these values only when necessary, we reduce can
	    // the memory requirements by almost 3% for larger fonts.
	    if ('xMin' in options) {
	        this.xMin = options.xMin;
	    }

	    if ('yMin' in options) {
	        this.yMin = options.yMin;
	    }

	    if ('xMax' in options) {
	        this.xMax = options.xMax;
	    }

	    if ('yMax' in options) {
	        this.yMax = options.yMax;
	    }

	    if ('advanceWidth' in options) {
	        this.advanceWidth = options.advanceWidth;
	    }

	    // The path for a glyph is the most memory intensive, and is bound as a value
	    // with a getter/setter to ensure we actually do path parsing only once the
	    // path is actually needed by anything.
	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
	};

	/**
	 * @param {number}
	 */
	Glyph.prototype.addUnicode = function(unicode) {
	    if (this.unicodes.length === 0) {
	        this.unicode = unicode;
	    }

	    this.unicodes.push(unicode);
	};

	/**
	 * Calculate the minimum bounding box for this glyph.
	 * @return {opentype.BoundingBox}
	 */
	Glyph.prototype.getBoundingBox = function() {
	    return this.path.getBoundingBox();
	};

	/**
	 * Convert the glyph to a Path we can draw on a drawing context.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 * @param  {opentype.Font} if hinting is to be used, the font
	 * @return {opentype.Path}
	 */
	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    var commands;
	    var hPoints;
	    if (!options) { options = { }; }
	    var xScale = options.xScale;
	    var yScale = options.yScale;

	    if (options.hinting && font && font.hinting) {
	        // in case of hinting, the hinting engine takes care
	        // of scaling the points (not the path) before hinting.
	        hPoints = this.path && font.hinting.exec(this, fontSize);
	        // in case the hinting engine failed hPoints is undefined
	        // and thus reverts to plain rending
	    }

	    if (hPoints) {
	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
	        commands = font.hinting.getCommands(hPoints);
	        x = Math.round(x);
	        y = Math.round(y);
	        // TODO in case of hinting xyScaling is not yet supported
	        xScale = yScale = 1;
	    } else {
	        commands = this.path.commands;
	        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;
	        if (xScale === undefined) { xScale = scale; }
	        if (yScale === undefined) { yScale = scale; }
	    }

	    var p = new Path();
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type === 'M') {
	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'L') {
	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Q') {
	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'C') {
	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Z') {
	            p.closePath();
	        }
	    }

	    return p;
	};

	/**
	 * Split the glyph into contours.
	 * This function is here for backwards compatibility, and to
	 * provide raw access to the TrueType glyph outlines.
	 * @return {Array}
	 */
	Glyph.prototype.getContours = function() {
	    if (this.points === undefined) {
	        return [];
	    }

	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < this.points.length; i += 1) {
	        var pt = this.points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	};

	/**
	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
	 * @return {Object}
	 */
	Glyph.prototype.getMetrics = function() {
	    var commands = this.path.commands;
	    var xCoords = [];
	    var yCoords = [];
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type !== 'Z') {
	            xCoords.push(cmd.x);
	            yCoords.push(cmd.y);
	        }

	        if (cmd.type === 'Q' || cmd.type === 'C') {
	            xCoords.push(cmd.x1);
	            yCoords.push(cmd.y1);
	        }

	        if (cmd.type === 'C') {
	            xCoords.push(cmd.x2);
	            yCoords.push(cmd.y2);
	        }
	    }

	    var metrics = {
	        xMin: Math.min.apply(null, xCoords),
	        yMin: Math.min.apply(null, yCoords),
	        xMax: Math.max.apply(null, xCoords),
	        yMax: Math.max.apply(null, yCoords),
	        leftSideBearing: this.leftSideBearing
	    };

	    if (!isFinite(metrics.xMin)) {
	        metrics.xMin = 0;
	    }

	    if (!isFinite(metrics.xMax)) {
	        metrics.xMax = this.advanceWidth;
	    }

	    if (!isFinite(metrics.yMin)) {
	        metrics.yMin = 0;
	    }

	    if (!isFinite(metrics.yMax)) {
	        metrics.yMax = 0;
	    }

	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
	    return metrics;
	};

	/**
	 * Draw the glyph on the given context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 */
	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
	    this.getPath(x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of the glyph.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
	    function drawCircles(l, x, y, scale) {
	        ctx.beginPath();
	        for (var j = 0; j < l.length; j += 1) {
	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);
	        }

	        ctx.closePath();
	        ctx.fill();
	    }

	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    var scale = 1 / this.path.unitsPerEm * fontSize;

	    var blueCircles = [];
	    var redCircles = [];
	    var path = this.path;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var cmd = path.commands[i];
	        if (cmd.x !== undefined) {
	            blueCircles.push({x: cmd.x, y: -cmd.y});
	        }

	        if (cmd.x1 !== undefined) {
	            redCircles.push({x: cmd.x1, y: -cmd.y1});
	        }

	        if (cmd.x2 !== undefined) {
	            redCircles.push({x: cmd.x2, y: -cmd.y2});
	        }
	    }

	    ctx.fillStyle = 'blue';
	    drawCircles(blueCircles, x, y, scale);
	    ctx.fillStyle = 'red';
	    drawCircles(redCircles, x, y, scale);
	};

	/**
	 * Draw lines indicating important font measurements.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
	    var scale;
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    scale = 1 / this.path.unitsPerEm * fontSize;
	    ctx.lineWidth = 1;

	    // Draw the origin
	    ctx.strokeStyle = 'black';
	    draw.line(ctx, x, -10000, x, 10000);
	    draw.line(ctx, -10000, y, 10000, y);

	    // This code is here due to memory optimization: by not using
	    // defaults in the constructor, we save a notable amount of memory.
	    var xMin = this.xMin || 0;
	    var yMin = this.yMin || 0;
	    var xMax = this.xMax || 0;
	    var yMax = this.yMax || 0;
	    var advanceWidth = this.advanceWidth || 0;

	    // Draw the glyph box
	    ctx.strokeStyle = 'blue';
	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

	    // Draw the advance width
	    ctx.strokeStyle = 'green';
	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
	};

	// The GlyphSet object

	// Define a property on the glyph that depends on the path being loaded.
	function defineDependentProperty(glyph, externalName, internalName) {
	    Object.defineProperty(glyph, externalName, {
	        get: function() {
	            // Request the path property to make sure the path is loaded.
	            glyph.path; // jshint ignore:line
	            return glyph[internalName];
	        },
	        set: function(newValue) {
	            glyph[internalName] = newValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	}

	/**
	 * A GlyphSet represents all glyphs available in the font, but modelled using
	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
	 * necessary, to keep the memory footprint down.
	 * @exports opentype.GlyphSet
	 * @class
	 * @param {opentype.Font}
	 * @param {Array}
	 */
	function GlyphSet(font, glyphs) {
	    this.font = font;
	    this.glyphs = {};
	    if (Array.isArray(glyphs)) {
	        for (var i = 0; i < glyphs.length; i++) {
	            var glyph = glyphs[i];
	            glyph.path.unitsPerEm = font.unitsPerEm;
	            this.glyphs[i] = glyph;
	        }
	    }

	    this.length = (glyphs && glyphs.length) || 0;
	}

	/**
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	GlyphSet.prototype.get = function(index) {
	    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.
	    if (this.glyphs[index] === undefined) {
	        this.font._push(index);
	        if (typeof this.glyphs[index] === 'function') {
	            this.glyphs[index] = this.glyphs[index]();
	        }

	        var glyph = this.glyphs[index];
	        var unicodeObj = this.font._IndexToUnicodeMap[index];

	        if (unicodeObj) {
	            for (var j = 0; j < unicodeObj.unicodes.length; j++)
	                { glyph.addUnicode(unicodeObj.unicodes[j]); }
	        }

	        if (this.font.cffEncoding) {
	            if (this.font.isCIDFont) {
	                glyph.name = 'gid' + index;
	            } else {
	                glyph.name = this.font.cffEncoding.charset[index];
	            }
	        } else if (this.font.glyphNames.names) {
	            glyph.name = this.font.glyphNames.glyphIndexToName(index);
	        }

	        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
	        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
	    } else {
	        if (typeof this.glyphs[index] === 'function') {
	            this.glyphs[index] = this.glyphs[index]();
	        }
	    }

	    return this.glyphs[index];
	};

	/**
	 * @param  {number} index
	 * @param  {Object}
	 */
	GlyphSet.prototype.push = function(index, loader) {
	    this.glyphs[index] = loader;
	    this.length++;
	};

	/**
	 * @alias opentype.glyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	function glyphLoader(font, index) {
	    return new Glyph({index: index, font: font});
	}

	/**
	 * Generate a stub glyph that can be filled with all metadata *except*
	 * the "points" and "path" properties, which must be loaded only once
	 * the glyph's path is actually requested for text shaping.
	 * @alias opentype.ttfGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseGlyph
	 * @param  {Object} data
	 * @param  {number} position
	 * @param  {Function} buildPath
	 * @return {opentype.Glyph}
	 */
	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            parseGlyph(glyph, data, position);
	            var path = buildPath(font.glyphs, glyph);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        defineDependentProperty(glyph, 'xMin', '_xMin');
	        defineDependentProperty(glyph, 'xMax', '_xMax');
	        defineDependentProperty(glyph, 'yMin', '_yMin');
	        defineDependentProperty(glyph, 'yMax', '_yMax');

	        return glyph;
	    };
	}
	/**
	 * @alias opentype.cffGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseCFFCharstring
	 * @param  {string} charstring
	 * @return {opentype.Glyph}
	 */
	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            var path = parseCFFCharstring(font, glyph, charstring);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        return glyph;
	    };
	}

	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

	// The `CFF` table contains the glyph outlines in PostScript format.

	// Custom equals function that can also check lists.
	function equals(a, b) {
	    if (a === b) {
	        return true;
	    } else if (Array.isArray(a) && Array.isArray(b)) {
	        if (a.length !== b.length) {
	            return false;
	        }

	        for (var i = 0; i < a.length; i += 1) {
	            if (!equals(a[i], b[i])) {
	                return false;
	            }
	        }

	        return true;
	    } else {
	        return false;
	    }
	}

	// Subroutines are encoded using the negative half of the number space.
	// See type 2 chapter 4.7 "Subroutine operators".
	function calcCFFSubroutineBias(subrs) {
	    var bias;
	    if (subrs.length < 1240) {
	        bias = 107;
	    } else if (subrs.length < 33900) {
	        bias = 1131;
	    } else {
	        bias = 32768;
	    }

	    return bias;
	}

	// Parse a `CFF` INDEX array.
	// An index array consists of a list of offsets, then a list of objects at those offsets.
	function parseCFFIndex(data, start, conversionFn) {
	    var offsets = [];
	    var objects = [];
	    var count = parse.getCard16(data, start);
	    var objectOffset;
	    var endOffset;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	        var pos = start + 3;
	        for (var i = 0; i < count + 1; i += 1) {
	            offsets.push(parse.getOffset(data, pos, offsetSize));
	            pos += offsetSize;
	        }

	        // The total size of the index array is 4 header bytes + the value of the last offset.
	        endOffset = objectOffset + offsets[count];
	    } else {
	        endOffset = start + 2;
	    }

	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
	        if (conversionFn) {
	            value = conversionFn(value);
	        }

	        objects.push(value);
	    }

	    return {objects: objects, startOffset: start, endOffset: endOffset};
	}

	function parseCFFIndexLowMemory(data, start) {
	    var offsets = [];
	    var count = parse.getCard16(data, start);
	    var objectOffset;
	    var endOffset;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	        var pos = start + 3;
	        for (var i = 0; i < count + 1; i += 1) {
	            offsets.push(parse.getOffset(data, pos, offsetSize));
	            pos += offsetSize;
	        }

	        // The total size of the index array is 4 header bytes + the value of the last offset.
	        endOffset = objectOffset + offsets[count];
	    } else {
	        endOffset = start + 2;
	    }

	    return {offsets: offsets, startOffset: start, endOffset: endOffset};
	}
	function getCffIndexObject(i, offsets, data, start, conversionFn) {
	    var count = parse.getCard16(data, start);
	    var objectOffset = 0;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	    }

	    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
	    if (conversionFn) {
	        value = conversionFn(value);
	    }
	    return value;
	}

	// Parse a `CFF` DICT real value.
	function parseFloatOperand(parser) {
	    var s = '';
	    var eof = 15;
	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
	    while (true) {
	        var b = parser.parseByte();
	        var n1 = b >> 4;
	        var n2 = b & 15;

	        if (n1 === eof) {
	            break;
	        }

	        s += lookup[n1];

	        if (n2 === eof) {
	            break;
	        }

	        s += lookup[n2];
	    }

	    return parseFloat(s);
	}

	// Parse a `CFF` DICT operand.
	function parseOperand(parser, b0) {
	    var b1;
	    var b2;
	    var b3;
	    var b4;
	    if (b0 === 28) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        return b1 << 8 | b2;
	    }

	    if (b0 === 29) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        b3 = parser.parseByte();
	        b4 = parser.parseByte();
	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
	    }

	    if (b0 === 30) {
	        return parseFloatOperand(parser);
	    }

	    if (b0 >= 32 && b0 <= 246) {
	        return b0 - 139;
	    }

	    if (b0 >= 247 && b0 <= 250) {
	        b1 = parser.parseByte();
	        return (b0 - 247) * 256 + b1 + 108;
	    }

	    if (b0 >= 251 && b0 <= 254) {
	        b1 = parser.parseByte();
	        return -(b0 - 251) * 256 - b1 - 108;
	    }

	    throw new Error('Invalid b0 ' + b0);
	}

	// Convert the entries returned by `parseDict` to a proper dictionary.
	// If a value is a list of one, it is unpacked.
	function entriesToObject(entries) {
	    var o = {};
	    for (var i = 0; i < entries.length; i += 1) {
	        var key = entries[i][0];
	        var values = entries[i][1];
	        var value = (void 0);
	        if (values.length === 1) {
	            value = values[0];
	        } else {
	            value = values;
	        }

	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
	            throw new Error('Object ' + o + ' already has key ' + key);
	        }

	        o[key] = value;
	    }

	    return o;
	}

	// Parse a `CFF` DICT object.
	// A dictionary contains key-value pairs in a compact tokenized format.
	function parseCFFDict(data, start, size) {
	    start = start !== undefined ? start : 0;
	    var parser = new parse.Parser(data, start);
	    var entries = [];
	    var operands = [];
	    size = size !== undefined ? size : data.length;

	    while (parser.relativeOffset < size) {
	        var op = parser.parseByte();

	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
	        // Values <= 21 are operators.
	        if (op <= 21) {
	            // Two-byte operators have an initial escape byte of 12.
	            if (op === 12) {
	                op = 1200 + parser.parseByte();
	            }

	            entries.push([op, operands]);
	            operands = [];
	        } else {
	            // Since the operands (values) come before the operators (keys), we store all operands in a list
	            // until we encounter an operator.
	            operands.push(parseOperand(parser, op));
	        }
	    }

	    return entriesToObject(entries);
	}

	// Given a String Index (SID), return the value of the string.
	// Strings below index 392 are standard CFF strings and are not encoded in the font.
	function getCFFString(strings, index) {
	    if (index <= 390) {
	        index = cffStandardStrings[index];
	    } else {
	        index = strings[index - 391];
	    }

	    return index;
	}

	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
	function interpretDict(dict, meta, strings) {
	    var newDict = {};
	    var value;

	    // Because we also want to include missing values, we start out from the meta list
	    // and lookup values in the dict.
	    for (var i = 0; i < meta.length; i += 1) {
	        var m = meta[i];

	        if (Array.isArray(m.type)) {
	            var values = [];
	            values.length = m.type.length;
	            for (var j = 0; j < m.type.length; j++) {
	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
	                if (value === undefined) {
	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
	                }
	                if (m.type[j] === 'SID') {
	                    value = getCFFString(strings, value);
	                }
	                values[j] = value;
	            }
	            newDict[m.name] = values;
	        } else {
	            value = dict[m.op];
	            if (value === undefined) {
	                value = m.value !== undefined ? m.value : null;
	            }

	            if (m.type === 'SID') {
	                value = getCFFString(strings, value);
	            }
	            newDict[m.name] = value;
	        }
	    }

	    return newDict;
	}

	// Parse the CFF header.
	function parseCFFHeader(data, start) {
	    var header = {};
	    header.formatMajor = parse.getCard8(data, start);
	    header.formatMinor = parse.getCard8(data, start + 1);
	    header.size = parse.getCard8(data, start + 2);
	    header.offsetSize = parse.getCard8(data, start + 3);
	    header.startOffset = start;
	    header.endOffset = start + 4;
	    return header;
	}

	var TOP_DICT_META = [
	    {name: 'version', op: 0, type: 'SID'},
	    {name: 'notice', op: 1, type: 'SID'},
	    {name: 'copyright', op: 1200, type: 'SID'},
	    {name: 'fullName', op: 2, type: 'SID'},
	    {name: 'familyName', op: 3, type: 'SID'},
	    {name: 'weight', op: 4, type: 'SID'},
	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
	    {name: 'paintType', op: 1205, type: 'number', value: 0},
	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
	    {
	        name: 'fontMatrix',
	        op: 1207,
	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
	        value: [0.001, 0, 0, 0.001, 0, 0]
	    },
	    {name: 'uniqueId', op: 13, type: 'number'},
	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
	    {name: 'xuid', op: 14, type: [], value: null},
	    {name: 'charset', op: 15, type: 'offset', value: 0},
	    {name: 'encoding', op: 16, type: 'offset', value: 0},
	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
	    {name: 'uidBase', op: 1235, type: 'number'},
	    {name: 'fdArray', op: 1236, type: 'offset'},
	    {name: 'fdSelect', op: 1237, type: 'offset'},
	    {name: 'fontName', op: 1238, type: 'SID'}
	];

	var PRIVATE_DICT_META = [
	    {name: 'subrs', op: 19, type: 'offset', value: 0},
	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
	];

	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
	function parseCFFTopDict(data, strings) {
	    var dict = parseCFFDict(data, 0, data.byteLength);
	    return interpretDict(dict, TOP_DICT_META, strings);
	}

	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
	function parseCFFPrivateDict(data, start, size, strings) {
	    var dict = parseCFFDict(data, start, size);
	    return interpretDict(dict, PRIVATE_DICT_META, strings);
	}

	// Returns a list of "Top DICT"s found using an INDEX list.
	// Used to read both the usual high-level Top DICTs and also the FDArray
	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
	// a Private DICT that is read and saved into the Top DICT.
	//
	// In addition to the expected/optional values as outlined in TOP_DICT_META
	// the following values might be saved into the Top DICT.
	//
	//    _subrs []        array of local CFF subroutines from Private DICT
	//    _subrsBias       bias value computed from number of subroutines
	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
	//    _defaultWidthX   default widths for CFF characters
	//    _nominalWidthX   bias added to width embedded within glyph description
	//
	//    _privateDict     saved copy of parsed Private DICT from Top DICT
	function gatherCFFTopDicts(data, start, cffIndex, strings) {
	    var topDictArray = [];
	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
	        var topDict = parseCFFTopDict(topDictData, strings);
	        topDict._subrs = [];
	        topDict._subrsBias = 0;
	        topDict._defaultWidthX = 0;
	        topDict._nominalWidthX = 0;
	        var privateSize = topDict.private[0];
	        var privateOffset = topDict.private[1];
	        if (privateSize !== 0 && privateOffset !== 0) {
	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
	            topDict._defaultWidthX = privateDict.defaultWidthX;
	            topDict._nominalWidthX = privateDict.nominalWidthX;
	            if (privateDict.subrs !== 0) {
	                var subrOffset = privateOffset + privateDict.subrs;
	                var subrIndex = parseCFFIndex(data, subrOffset + start);
	                topDict._subrs = subrIndex.objects;
	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
	            }
	            topDict._privateDict = privateDict;
	        }
	        topDictArray.push(topDict);
	    }
	    return topDictArray;
	}

	// Parse the CFF charset table, which contains internal names for all the glyphs.
	// This function will return a list of glyph names.
	// See Adobe TN #5176 chapter 13, "Charsets".
	function parseCFFCharset(data, start, nGlyphs, strings) {
	    var sid;
	    var count;
	    var parser = new parse.Parser(data, start);

	    // The .notdef glyph is not included, so subtract 1.
	    nGlyphs -= 1;
	    var charset = ['.notdef'];

	    var format = parser.parseCard8();
	    if (format === 0) {
	        for (var i = 0; i < nGlyphs; i += 1) {
	            sid = parser.parseSID();
	            charset.push(getCFFString(strings, sid));
	        }
	    } else if (format === 1) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard8();
	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else if (format === 2) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard16();
	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown charset format ' + format);
	    }

	    return charset;
	}

	// Parse the CFF encoding data. Only one encoding can be specified per font.
	// See Adobe TN #5176 chapter 12, "Encodings".
	function parseCFFEncoding(data, start, charset) {
	    var code;
	    var enc = {};
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        var nCodes = parser.parseCard8();
	        for (var i = 0; i < nCodes; i += 1) {
	            code = parser.parseCard8();
	            enc[code] = i;
	        }
	    } else if (format === 1) {
	        var nRanges = parser.parseCard8();
	        code = 1;
	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
	            var first = parser.parseCard8();
	            var nLeft = parser.parseCard8();
	            for (var j = first; j <= first + nLeft; j += 1) {
	                enc[j] = code;
	                code += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown encoding format ' + format);
	    }

	    return new CffEncoding(enc, charset);
	}

	// Take in charstring code and return a Glyph object.
	// The encoding is described in the Type 2 Charstring Format
	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
	function parseCFFCharstring(font, glyph, code) {
	    var c1x;
	    var c1y;
	    var c2x;
	    var c2y;
	    var p = new Path();
	    var stack = [];
	    var nStems = 0;
	    var haveWidth = false;
	    var open = false;
	    var x = 0;
	    var y = 0;
	    var subrs;
	    var subrsBias;
	    var defaultWidthX;
	    var nominalWidthX;
	    if (font.isCIDFont) {
	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
	        subrs = fdDict._subrs;
	        subrsBias = fdDict._subrsBias;
	        defaultWidthX = fdDict._defaultWidthX;
	        nominalWidthX = fdDict._nominalWidthX;
	    } else {
	        subrs = font.tables.cff.topDict._subrs;
	        subrsBias = font.tables.cff.topDict._subrsBias;
	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
	    }
	    var width = defaultWidthX;

	    function newContour(x, y) {
	        if (open) {
	            p.closePath();
	        }

	        p.moveTo(x, y);
	        open = true;
	    }

	    function parseStems() {
	        var hasWidthArg;

	        // The number of stem operators on the stack is always even.
	        // If the value is uneven, that means a width is specified.
	        hasWidthArg = stack.length % 2 !== 0;
	        if (hasWidthArg && !haveWidth) {
	            width = stack.shift() + nominalWidthX;
	        }

	        nStems += stack.length >> 1;
	        stack.length = 0;
	        haveWidth = true;
	    }

	    function parse(code) {
	        var b1;
	        var b2;
	        var b3;
	        var b4;
	        var codeIndex;
	        var subrCode;
	        var jpx;
	        var jpy;
	        var c3x;
	        var c3y;
	        var c4x;
	        var c4y;

	        var i = 0;
	        while (i < code.length) {
	            var v = code[i];
	            i += 1;
	            switch (v) {
	                case 1: // hstem
	                    parseStems();
	                    break;
	                case 3: // vstem
	                    parseStems();
	                    break;
	                case 4: // vmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 5: // rlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 6: // hlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 7: // vlineto
	                    while (stack.length > 0) {
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        x += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 8: // rrcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 10: // callsubr
	                    codeIndex = stack.pop() + subrsBias;
	                    subrCode = subrs[codeIndex];
	                    if (subrCode) {
	                        parse(subrCode);
	                    }

	                    break;
	                case 11: // return
	                    return;
	                case 12: // flex operators
	                    v = code[i];
	                    i += 1;
	                    switch (v) {
	                        case 35: // flex
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x   + stack.shift();    // dx6
	                            y = c4y   + stack.shift();    // dy6
	                            stack.shift();                // flex depth
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 34: // hflex
	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y;                      // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = y;                      // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 36: // hflex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 37: // flex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
	                                x = c4x + stack.shift();
	                            } else {
	                                y = c4y + stack.shift();
	                            }

	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        default:
	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
	                            stack.length = 0;
	                    }
	                    break;
	                case 14: // endchar
	                    if (stack.length > 0 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    if (open) {
	                        p.closePath();
	                        open = false;
	                    }

	                    break;
	                case 18: // hstemhm
	                    parseStems();
	                    break;
	                case 19: // hintmask
	                case 20: // cntrmask
	                    parseStems();
	                    i += (nStems + 7) >> 3;
	                    break;
	                case 21: // rmoveto
	                    if (stack.length > 2 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 22: // hmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 23: // vstemhm
	                    parseStems();
	                    break;
	                case 24: // rcurveline
	                    while (stack.length > 2) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    x += stack.shift();
	                    y += stack.shift();
	                    p.lineTo(x, y);
	                    break;
	                case 25: // rlinecurve
	                    while (stack.length > 6) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    c1x = x + stack.shift();
	                    c1y = y + stack.shift();
	                    c2x = c1x + stack.shift();
	                    c2y = c1y + stack.shift();
	                    x = c2x + stack.shift();
	                    y = c2y + stack.shift();
	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    break;
	                case 26: // vvcurveto
	                    if (stack.length % 2) {
	                        x += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x;
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 27: // hhcurveto
	                    if (stack.length % 2) {
	                        y += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y;
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 28: // shortint
	                    b1 = code[i];
	                    b2 = code[i + 1];
	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
	                    i += 2;
	                    break;
	                case 29: // callgsubr
	                    codeIndex = stack.pop() + font.gsubrsBias;
	                    subrCode = font.gsubrs[codeIndex];
	                    if (subrCode) {
	                        parse(subrCode);
	                    }

	                    break;
	                case 30: // vhcurveto
	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 31: // hvcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                default:
	                    if (v < 32) {
	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
	                    } else if (v < 247) {
	                        stack.push(v - 139);
	                    } else if (v < 251) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push((v - 247) * 256 + b1 + 108);
	                    } else if (v < 255) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push(-(v - 251) * 256 - b1 - 108);
	                    } else {
	                        b1 = code[i];
	                        b2 = code[i + 1];
	                        b3 = code[i + 2];
	                        b4 = code[i + 3];
	                        i += 4;
	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
	                    }
	            }
	        }
	    }

	    parse(code);

	    glyph.advanceWidth = width;
	    return p;
	}

	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
	    var fdSelect = [];
	    var fdIndex;
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        // Simple list of nGlyphs elements
	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
	            fdIndex = parser.parseCard8();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            fdSelect.push(fdIndex);
	        }
	    } else if (format === 3) {
	        // Ranges
	        var nRanges = parser.parseCard16();
	        var first = parser.parseCard16();
	        if (first !== 0) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
	        }
	        var next;
	        for (var iRange = 0; iRange < nRanges; iRange++) {
	            fdIndex = parser.parseCard8();
	            next = parser.parseCard16();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            if (next > nGlyphs) {
	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
	            }
	            for (; first < next; first++) {
	                fdSelect.push(fdIndex);
	            }
	            first = next;
	        }
	        if (next !== nGlyphs) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
	        }
	    } else {
	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
	    }
	    return fdSelect;
	}

	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
	function parseCFFTable(data, start, font, opt) {
	    font.tables.cff = {};
	    var header = parseCFFHeader(data, start);
	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
	    font.gsubrs = globalSubrIndex.objects;
	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
	    if (topDictArray.length !== 1) {
	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
	    }

	    var topDict = topDictArray[0];
	    font.tables.cff.topDict = topDict;

	    if (topDict._privateDict) {
	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
	    }

	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
	        font.isCIDFont = true;
	    }

	    if (font.isCIDFont) {
	        var fdArrayOffset = topDict.fdArray;
	        var fdSelectOffset = topDict.fdSelect;
	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
	        }
	        fdArrayOffset += start;
	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
	        topDict._fdArray = fdArray;
	        fdSelectOffset += start;
	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
	    }

	    var privateDictOffset = start + topDict.private[1];
	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
	    font.defaultWidthX = privateDict.defaultWidthX;
	    font.nominalWidthX = privateDict.nominalWidthX;

	    if (privateDict.subrs !== 0) {
	        var subrOffset = privateDictOffset + privateDict.subrs;
	        var subrIndex = parseCFFIndex(data, subrOffset);
	        font.subrs = subrIndex.objects;
	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
	    } else {
	        font.subrs = [];
	        font.subrsBias = 0;
	    }

	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
	    var charStringsIndex;
	    if (opt.lowMemory) {
	        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
	        font.nGlyphs = charStringsIndex.offsets.length;
	    } else {
	        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
	        font.nGlyphs = charStringsIndex.objects.length;
	    }

	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
	    if (topDict.encoding === 0) {
	        // Standard encoding
	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
	    } else if (topDict.encoding === 1) {
	        // Expert encoding
	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
	    } else {
	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
	    }

	    // Prefer the CMAP encoding to the CFF encoding.
	    font.encoding = font.encoding || font.cffEncoding;

	    font.glyphs = new glyphset.GlyphSet(font);
	    if (opt.lowMemory) {
	        font._push = function(i) {
	            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);
	            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
	        };
	    } else {
	        for (var i = 0; i < font.nGlyphs; i += 1) {
	            var charString = charStringsIndex.objects[i];
	            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
	        }
	    }
	}

	// Convert a string to a String ID (SID).
	// The list of strings is modified in place.
	function encodeString(s, strings) {
	    var sid;

	    // Is the string in the CFF standard strings?
	    var i = cffStandardStrings.indexOf(s);
	    if (i >= 0) {
	        sid = i;
	    }

	    // Is the string already in the string index?
	    i = strings.indexOf(s);
	    if (i >= 0) {
	        sid = i + cffStandardStrings.length;
	    } else {
	        sid = cffStandardStrings.length + strings.length;
	        strings.push(s);
	    }

	    return sid;
	}

	function makeHeader() {
	    return new table.Record('Header', [
	        {name: 'major', type: 'Card8', value: 1},
	        {name: 'minor', type: 'Card8', value: 0},
	        {name: 'hdrSize', type: 'Card8', value: 4},
	        {name: 'major', type: 'Card8', value: 1}
	    ]);
	}

	function makeNameIndex(fontNames) {
	    var t = new table.Record('Name INDEX', [
	        {name: 'names', type: 'INDEX', value: []}
	    ]);
	    t.names = [];
	    for (var i = 0; i < fontNames.length; i += 1) {
	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
	    }

	    return t;
	}

	// Given a dictionary's metadata, create a DICT structure.
	function makeDict(meta, attrs, strings) {
	    var m = {};
	    for (var i = 0; i < meta.length; i += 1) {
	        var entry = meta[i];
	        var value = attrs[entry.name];
	        if (value !== undefined && !equals(value, entry.value)) {
	            if (entry.type === 'SID') {
	                value = encodeString(value, strings);
	            }

	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
	        }
	    }

	    return m;
	}

	// The Top DICT houses the global font attributes.
	function makeTopDict(attrs, strings) {
	    var t = new table.Record('Top DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
	    return t;
	}

	function makeTopDictIndex(topDict) {
	    var t = new table.Record('Top DICT INDEX', [
	        {name: 'topDicts', type: 'INDEX', value: []}
	    ]);
	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
	    return t;
	}

	function makeStringIndex(strings) {
	    var t = new table.Record('String INDEX', [
	        {name: 'strings', type: 'INDEX', value: []}
	    ]);
	    t.strings = [];
	    for (var i = 0; i < strings.length; i += 1) {
	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
	    }

	    return t;
	}

	function makeGlobalSubrIndex() {
	    // Currently we don't use subroutines.
	    return new table.Record('Global Subr INDEX', [
	        {name: 'subrs', type: 'INDEX', value: []}
	    ]);
	}

	function makeCharsets(glyphNames, strings) {
	    var t = new table.Record('Charsets', [
	        {name: 'format', type: 'Card8', value: 0}
	    ]);
	    for (var i = 0; i < glyphNames.length; i += 1) {
	        var glyphName = glyphNames[i];
	        var glyphSID = encodeString(glyphName, strings);
	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
	    }

	    return t;
	}

	function glyphToOps(glyph) {
	    var ops = [];
	    var path = glyph.path;
	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
	    var x = 0;
	    var y = 0;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var dx = (void 0);
	        var dy = (void 0);
	        var cmd = path.commands[i];
	        if (cmd.type === 'Q') {
	            // CFF only supports bézier curves, so convert the quad to a bézier.
	            var _13 = 1 / 3;
	            var _23 = 2 / 3;

	            // We're going to create a new command so we don't change the original path.
	            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.
	            cmd = {
	                type: 'C',
	                x: cmd.x,
	                y: cmd.y,
	                x1: Math.round(_13 * x + _23 * cmd.x1),
	                y1: Math.round(_13 * y + _23 * cmd.y1),
	                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
	                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
	            };
	        }

	        if (cmd.type === 'M') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'L') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rlineto', type: 'OP', value: 5});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'C') {
	            var dx1 = Math.round(cmd.x1 - x);
	            var dy1 = Math.round(cmd.y1 - y);
	            var dx2 = Math.round(cmd.x2 - cmd.x1);
	            var dy2 = Math.round(cmd.y2 - cmd.y1);
	            dx = Math.round(cmd.x - cmd.x2);
	            dy = Math.round(cmd.y - cmd.y2);
	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        }

	        // Contours are closed automatically.
	    }

	    ops.push({name: 'endchar', type: 'OP', value: 14});
	    return ops;
	}

	function makeCharStringsIndex(glyphs) {
	    var t = new table.Record('CharStrings INDEX', [
	        {name: 'charStrings', type: 'INDEX', value: []}
	    ]);

	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var ops = glyphToOps(glyph);
	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
	    }

	    return t;
	}

	function makePrivateDict(attrs, strings) {
	    var t = new table.Record('Private DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
	    return t;
	}

	function makeCFFTable(glyphs, options) {
	    var t = new table.Table('CFF ', [
	        {name: 'header', type: 'RECORD'},
	        {name: 'nameIndex', type: 'RECORD'},
	        {name: 'topDictIndex', type: 'RECORD'},
	        {name: 'stringIndex', type: 'RECORD'},
	        {name: 'globalSubrIndex', type: 'RECORD'},
	        {name: 'charsets', type: 'RECORD'},
	        {name: 'charStringsIndex', type: 'RECORD'},
	        {name: 'privateDict', type: 'RECORD'}
	    ]);

	    var fontScale = 1 / options.unitsPerEm;
	    // We use non-zero values for the offsets so that the DICT encodes them.
	    // This is important because the size of the Top DICT plays a role in offset calculation,
	    // and the size shouldn't change after we've written correct offsets.
	    var attrs = {
	        version: options.version,
	        fullName: options.fullName,
	        familyName: options.familyName,
	        weight: options.weightName,
	        fontBBox: options.fontBBox || [0, 0, 0, 0],
	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
	        charset: 999,
	        encoding: 0,
	        charStrings: 999,
	        private: [0, 999]
	    };

	    var privateAttrs = {};

	    var glyphNames = [];
	    var glyph;

	    // Skip first glyph (.notdef)
	    for (var i = 1; i < glyphs.length; i += 1) {
	        glyph = glyphs.get(i);
	        glyphNames.push(glyph.name);
	    }

	    var strings = [];

	    t.header = makeHeader();
	    t.nameIndex = makeNameIndex([options.postScriptName]);
	    var topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);
	    t.globalSubrIndex = makeGlobalSubrIndex();
	    t.charsets = makeCharsets(glyphNames, strings);
	    t.charStringsIndex = makeCharStringsIndex(glyphs);
	    t.privateDict = makePrivateDict(privateAttrs, strings);

	    // Needs to come at the end, to encode all custom strings used in the font.
	    t.stringIndex = makeStringIndex(strings);

	    var startOffset = t.header.sizeOf() +
	        t.nameIndex.sizeOf() +
	        t.topDictIndex.sizeOf() +
	        t.stringIndex.sizeOf() +
	        t.globalSubrIndex.sizeOf();
	    attrs.charset = startOffset;

	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
	    attrs.encoding = 0;
	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

	    // Recreate the Top DICT INDEX with the correct offsets.
	    topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);

	    return t;
	}

	var cff = { parse: parseCFFTable, make: makeCFFTable };

	// The `head` table contains global information about the font.

	// Parse the header `head` table
	function parseHeadTable(data, start) {
	    var head = {};
	    var p = new parse.Parser(data, start);
	    head.version = p.parseVersion();
	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
	    head.checkSumAdjustment = p.parseULong();
	    head.magicNumber = p.parseULong();
	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
	    head.flags = p.parseUShort();
	    head.unitsPerEm = p.parseUShort();
	    head.created = p.parseLongDateTime();
	    head.modified = p.parseLongDateTime();
	    head.xMin = p.parseShort();
	    head.yMin = p.parseShort();
	    head.xMax = p.parseShort();
	    head.yMax = p.parseShort();
	    head.macStyle = p.parseUShort();
	    head.lowestRecPPEM = p.parseUShort();
	    head.fontDirectionHint = p.parseShort();
	    head.indexToLocFormat = p.parseShort();
	    head.glyphDataFormat = p.parseShort();
	    return head;
	}

	function makeHeadTable(options) {
	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
	    var createdTimestamp = timestamp;

	    if (options.createdTimestamp) {
	        createdTimestamp = options.createdTimestamp + 2082844800;
	    }

	    return new table.Table('head', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
	        {name: 'flags', type: 'USHORT', value: 0},
	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
	        {name: 'xMin', type: 'SHORT', value: 0},
	        {name: 'yMin', type: 'SHORT', value: 0},
	        {name: 'xMax', type: 'SHORT', value: 0},
	        {name: 'yMax', type: 'SHORT', value: 0},
	        {name: 'macStyle', type: 'USHORT', value: 0},
	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
	    ], options);
	}

	var head = { parse: parseHeadTable, make: makeHeadTable };

	// The `hhea` table contains information for horizontal layout.

	// Parse the horizontal header `hhea` table
	function parseHheaTable(data, start) {
	    var hhea = {};
	    var p = new parse.Parser(data, start);
	    hhea.version = p.parseVersion();
	    hhea.ascender = p.parseShort();
	    hhea.descender = p.parseShort();
	    hhea.lineGap = p.parseShort();
	    hhea.advanceWidthMax = p.parseUShort();
	    hhea.minLeftSideBearing = p.parseShort();
	    hhea.minRightSideBearing = p.parseShort();
	    hhea.xMaxExtent = p.parseShort();
	    hhea.caretSlopeRise = p.parseShort();
	    hhea.caretSlopeRun = p.parseShort();
	    hhea.caretOffset = p.parseShort();
	    p.relativeOffset += 8;
	    hhea.metricDataFormat = p.parseShort();
	    hhea.numberOfHMetrics = p.parseUShort();
	    return hhea;
	}

	function makeHheaTable(options) {
	    return new table.Table('hhea', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'ascender', type: 'FWORD', value: 0},
	        {name: 'descender', type: 'FWORD', value: 0},
	        {name: 'lineGap', type: 'FWORD', value: 0},
	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
	        {name: 'caretOffset', type: 'SHORT', value: 0},
	        {name: 'reserved1', type: 'SHORT', value: 0},
	        {name: 'reserved2', type: 'SHORT', value: 0},
	        {name: 'reserved3', type: 'SHORT', value: 0},
	        {name: 'reserved4', type: 'SHORT', value: 0},
	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
	    ], options);
	}

	var hhea = { parse: parseHheaTable, make: makeHheaTable };

	// The `hmtx` table contains the horizontal metrics for all glyphs.

	function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
	    var advanceWidth;
	    var leftSideBearing;
	    var p = new parse.Parser(data, start);
	    for (var i = 0; i < numGlyphs; i += 1) {
	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
	        if (i < numMetrics) {
	            advanceWidth = p.parseUShort();
	            leftSideBearing = p.parseShort();
	        }

	        var glyph = glyphs.get(i);
	        glyph.advanceWidth = advanceWidth;
	        glyph.leftSideBearing = leftSideBearing;
	    }
	}

	function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
	    font._hmtxTableData = {};

	    var advanceWidth;
	    var leftSideBearing;
	    var p = new parse.Parser(data, start);
	    for (var i = 0; i < numGlyphs; i += 1) {
	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
	        if (i < numMetrics) {
	            advanceWidth = p.parseUShort();
	            leftSideBearing = p.parseShort();
	        }

	        font._hmtxTableData[i] = {
	            advanceWidth: advanceWidth,
	            leftSideBearing: leftSideBearing
	        };
	    }
	}

	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
	function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
	    if (opt.lowMemory)
	        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }
	    else
	        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }
	}

	function makeHmtxTable(glyphs) {
	    var t = new table.Table('hmtx', []);
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var advanceWidth = glyph.advanceWidth || 0;
	        var leftSideBearing = glyph.leftSideBearing || 0;
	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
	    }

	    return t;
	}

	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting

	function makeLtagTable(tags) {
	    var result = new table.Table('ltag', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'numTags', type: 'ULONG', value: tags.length}
	    ]);

	    var stringPool = '';
	    var stringPoolOffset = 12 + tags.length * 4;
	    for (var i = 0; i < tags.length; ++i) {
	        var pos = stringPool.indexOf(tags[i]);
	        if (pos < 0) {
	            pos = stringPool.length;
	            stringPool += tags[i];
	        }

	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
	    return result;
	}

	function parseLtagTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
	    // The 'ltag' specification does not define any flags; skip the field.
	    p.skip('uLong', 1);
	    var numTags = p.parseULong();

	    var tags = [];
	    for (var i = 0; i < numTags; i++) {
	        var tag = '';
	        var offset = start + p.parseUShort();
	        var length = p.parseUShort();
	        for (var j = offset; j < offset + length; ++j) {
	            tag += String.fromCharCode(data.getInt8(j));
	        }

	        tags.push(tag);
	    }

	    return tags;
	}

	var ltag = { make: makeLtagTable, parse: parseLtagTable };

	// The `maxp` table establishes the memory requirements for the font.

	// Parse the maximum profile `maxp` table.
	function parseMaxpTable(data, start) {
	    var maxp = {};
	    var p = new parse.Parser(data, start);
	    maxp.version = p.parseVersion();
	    maxp.numGlyphs = p.parseUShort();
	    if (maxp.version === 1.0) {
	        maxp.maxPoints = p.parseUShort();
	        maxp.maxContours = p.parseUShort();
	        maxp.maxCompositePoints = p.parseUShort();
	        maxp.maxCompositeContours = p.parseUShort();
	        maxp.maxZones = p.parseUShort();
	        maxp.maxTwilightPoints = p.parseUShort();
	        maxp.maxStorage = p.parseUShort();
	        maxp.maxFunctionDefs = p.parseUShort();
	        maxp.maxInstructionDefs = p.parseUShort();
	        maxp.maxStackElements = p.parseUShort();
	        maxp.maxSizeOfInstructions = p.parseUShort();
	        maxp.maxComponentElements = p.parseUShort();
	        maxp.maxComponentDepth = p.parseUShort();
	    }

	    return maxp;
	}

	function makeMaxpTable(numGlyphs) {
	    return new table.Table('maxp', [
	        {name: 'version', type: 'FIXED', value: 0x00005000},
	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
	    ]);
	}

	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

	// The `name` naming table.

	// NameIDs for the name table.
	var nameTableNames = [
	    'copyright',              // 0
	    'fontFamily',             // 1
	    'fontSubfamily',          // 2
	    'uniqueID',               // 3
	    'fullName',               // 4
	    'version',                // 5
	    'postScriptName',         // 6
	    'trademark',              // 7
	    'manufacturer',           // 8
	    'designer',               // 9
	    'description',            // 10
	    'manufacturerURL',        // 11
	    'designerURL',            // 12
	    'license',                // 13
	    'licenseURL',             // 14
	    'reserved',               // 15
	    'preferredFamily',        // 16
	    'preferredSubfamily',     // 17
	    'compatibleFullName',     // 18
	    'sampleText',             // 19
	    'postScriptFindFontName', // 20
	    'wwsFamily',              // 21
	    'wwsSubfamily'            // 22
	];

	var macLanguages = {
	    0: 'en',
	    1: 'fr',
	    2: 'de',
	    3: 'it',
	    4: 'nl',
	    5: 'sv',
	    6: 'es',
	    7: 'da',
	    8: 'pt',
	    9: 'no',
	    10: 'he',
	    11: 'ja',
	    12: 'ar',
	    13: 'fi',
	    14: 'el',
	    15: 'is',
	    16: 'mt',
	    17: 'tr',
	    18: 'hr',
	    19: 'zh-Hant',
	    20: 'ur',
	    21: 'hi',
	    22: 'th',
	    23: 'ko',
	    24: 'lt',
	    25: 'pl',
	    26: 'hu',
	    27: 'es',
	    28: 'lv',
	    29: 'se',
	    30: 'fo',
	    31: 'fa',
	    32: 'ru',
	    33: 'zh',
	    34: 'nl-BE',
	    35: 'ga',
	    36: 'sq',
	    37: 'ro',
	    38: 'cz',
	    39: 'sk',
	    40: 'si',
	    41: 'yi',
	    42: 'sr',
	    43: 'mk',
	    44: 'bg',
	    45: 'uk',
	    46: 'be',
	    47: 'uz',
	    48: 'kk',
	    49: 'az-Cyrl',
	    50: 'az-Arab',
	    51: 'hy',
	    52: 'ka',
	    53: 'mo',
	    54: 'ky',
	    55: 'tg',
	    56: 'tk',
	    57: 'mn-CN',
	    58: 'mn',
	    59: 'ps',
	    60: 'ks',
	    61: 'ku',
	    62: 'sd',
	    63: 'bo',
	    64: 'ne',
	    65: 'sa',
	    66: 'mr',
	    67: 'bn',
	    68: 'as',
	    69: 'gu',
	    70: 'pa',
	    71: 'or',
	    72: 'ml',
	    73: 'kn',
	    74: 'ta',
	    75: 'te',
	    76: 'si',
	    77: 'my',
	    78: 'km',
	    79: 'lo',
	    80: 'vi',
	    81: 'id',
	    82: 'tl',
	    83: 'ms',
	    84: 'ms-Arab',
	    85: 'am',
	    86: 'ti',
	    87: 'om',
	    88: 'so',
	    89: 'sw',
	    90: 'rw',
	    91: 'rn',
	    92: 'ny',
	    93: 'mg',
	    94: 'eo',
	    128: 'cy',
	    129: 'eu',
	    130: 'ca',
	    131: 'la',
	    132: 'qu',
	    133: 'gn',
	    134: 'ay',
	    135: 'tt',
	    136: 'ug',
	    137: 'dz',
	    138: 'jv',
	    139: 'su',
	    140: 'gl',
	    141: 'af',
	    142: 'br',
	    143: 'iu',
	    144: 'gd',
	    145: 'gv',
	    146: 'ga',
	    147: 'to',
	    148: 'el-polyton',
	    149: 'kl',
	    150: 'az',
	    151: 'nn'
	};

	// MacOS language ID → MacOS script ID
	//
	// Note that the script ID is not sufficient to determine what encoding
	// to use in TrueType files. For some languages, MacOS used a modification
	// of a mainstream script. For example, an Icelandic name would be stored
	// with smRoman in the TrueType naming table, but the actual encoding
	// is a special Icelandic version of the normal Macintosh Roman encoding.
	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
	// Syllables but MacOS had run out of available script codes, so this was
	// done as a (pretty radical) "modification" of Ethiopic.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageToScript = {
	    0: 0,  // langEnglish → smRoman
	    1: 0,  // langFrench → smRoman
	    2: 0,  // langGerman → smRoman
	    3: 0,  // langItalian → smRoman
	    4: 0,  // langDutch → smRoman
	    5: 0,  // langSwedish → smRoman
	    6: 0,  // langSpanish → smRoman
	    7: 0,  // langDanish → smRoman
	    8: 0,  // langPortuguese → smRoman
	    9: 0,  // langNorwegian → smRoman
	    10: 5,  // langHebrew → smHebrew
	    11: 1,  // langJapanese → smJapanese
	    12: 4,  // langArabic → smArabic
	    13: 0,  // langFinnish → smRoman
	    14: 6,  // langGreek → smGreek
	    15: 0,  // langIcelandic → smRoman (modified)
	    16: 0,  // langMaltese → smRoman
	    17: 0,  // langTurkish → smRoman (modified)
	    18: 0,  // langCroatian → smRoman (modified)
	    19: 2,  // langTradChinese → smTradChinese
	    20: 4,  // langUrdu → smArabic
	    21: 9,  // langHindi → smDevanagari
	    22: 21,  // langThai → smThai
	    23: 3,  // langKorean → smKorean
	    24: 29,  // langLithuanian → smCentralEuroRoman
	    25: 29,  // langPolish → smCentralEuroRoman
	    26: 29,  // langHungarian → smCentralEuroRoman
	    27: 29,  // langEstonian → smCentralEuroRoman
	    28: 29,  // langLatvian → smCentralEuroRoman
	    29: 0,  // langSami → smRoman
	    30: 0,  // langFaroese → smRoman (modified)
	    31: 4,  // langFarsi → smArabic (modified)
	    32: 7,  // langRussian → smCyrillic
	    33: 25,  // langSimpChinese → smSimpChinese
	    34: 0,  // langFlemish → smRoman
	    35: 0,  // langIrishGaelic → smRoman (modified)
	    36: 0,  // langAlbanian → smRoman
	    37: 0,  // langRomanian → smRoman (modified)
	    38: 29,  // langCzech → smCentralEuroRoman
	    39: 29,  // langSlovak → smCentralEuroRoman
	    40: 0,  // langSlovenian → smRoman (modified)
	    41: 5,  // langYiddish → smHebrew
	    42: 7,  // langSerbian → smCyrillic
	    43: 7,  // langMacedonian → smCyrillic
	    44: 7,  // langBulgarian → smCyrillic
	    45: 7,  // langUkrainian → smCyrillic (modified)
	    46: 7,  // langByelorussian → smCyrillic
	    47: 7,  // langUzbek → smCyrillic
	    48: 7,  // langKazakh → smCyrillic
	    49: 7,  // langAzerbaijani → smCyrillic
	    50: 4,  // langAzerbaijanAr → smArabic
	    51: 24,  // langArmenian → smArmenian
	    52: 23,  // langGeorgian → smGeorgian
	    53: 7,  // langMoldavian → smCyrillic
	    54: 7,  // langKirghiz → smCyrillic
	    55: 7,  // langTajiki → smCyrillic
	    56: 7,  // langTurkmen → smCyrillic
	    57: 27,  // langMongolian → smMongolian
	    58: 7,  // langMongolianCyr → smCyrillic
	    59: 4,  // langPashto → smArabic
	    60: 4,  // langKurdish → smArabic
	    61: 4,  // langKashmiri → smArabic
	    62: 4,  // langSindhi → smArabic
	    63: 26,  // langTibetan → smTibetan
	    64: 9,  // langNepali → smDevanagari
	    65: 9,  // langSanskrit → smDevanagari
	    66: 9,  // langMarathi → smDevanagari
	    67: 13,  // langBengali → smBengali
	    68: 13,  // langAssamese → smBengali
	    69: 11,  // langGujarati → smGujarati
	    70: 10,  // langPunjabi → smGurmukhi
	    71: 12,  // langOriya → smOriya
	    72: 17,  // langMalayalam → smMalayalam
	    73: 16,  // langKannada → smKannada
	    74: 14,  // langTamil → smTamil
	    75: 15,  // langTelugu → smTelugu
	    76: 18,  // langSinhalese → smSinhalese
	    77: 19,  // langBurmese → smBurmese
	    78: 20,  // langKhmer → smKhmer
	    79: 22,  // langLao → smLao
	    80: 30,  // langVietnamese → smVietnamese
	    81: 0,  // langIndonesian → smRoman
	    82: 0,  // langTagalog → smRoman
	    83: 0,  // langMalayRoman → smRoman
	    84: 4,  // langMalayArabic → smArabic
	    85: 28,  // langAmharic → smEthiopic
	    86: 28,  // langTigrinya → smEthiopic
	    87: 28,  // langOromo → smEthiopic
	    88: 0,  // langSomali → smRoman
	    89: 0,  // langSwahili → smRoman
	    90: 0,  // langKinyarwanda → smRoman
	    91: 0,  // langRundi → smRoman
	    92: 0,  // langNyanja → smRoman
	    93: 0,  // langMalagasy → smRoman
	    94: 0,  // langEsperanto → smRoman
	    128: 0,  // langWelsh → smRoman (modified)
	    129: 0,  // langBasque → smRoman
	    130: 0,  // langCatalan → smRoman
	    131: 0,  // langLatin → smRoman
	    132: 0,  // langQuechua → smRoman
	    133: 0,  // langGuarani → smRoman
	    134: 0,  // langAymara → smRoman
	    135: 7,  // langTatar → smCyrillic
	    136: 4,  // langUighur → smArabic
	    137: 26,  // langDzongkha → smTibetan
	    138: 0,  // langJavaneseRom → smRoman
	    139: 0,  // langSundaneseRom → smRoman
	    140: 0,  // langGalician → smRoman
	    141: 0,  // langAfrikaans → smRoman
	    142: 0,  // langBreton → smRoman (modified)
	    143: 28,  // langInuktitut → smEthiopic (modified)
	    144: 0,  // langScottishGaelic → smRoman (modified)
	    145: 0,  // langManxGaelic → smRoman (modified)
	    146: 0,  // langIrishGaelicScript → smRoman (modified)
	    147: 0,  // langTongan → smRoman
	    148: 6,  // langGreekAncient → smRoman
	    149: 0,  // langGreenlandic → smRoman
	    150: 0,  // langAzerbaijanRoman → smRoman
	    151: 0   // langNynorsk → smRoman
	};

	// While Microsoft indicates a region/country for all its language
	// IDs, we omit the region code if it's equal to the "most likely
	// region subtag" according to Unicode CLDR. For scripts, we omit
	// the subtag if it is equal to the Suppress-Script entry in the
	// IANA language subtag registry for IETF BCP 47.
	//
	// For example, Microsoft states that its language code 0x041A is
	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
	// and not 'hr-HR' because Croatia is the default country for Croatian,
	// according to Unicode CLDR. As another example, Microsoft states
	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
	// for the Croatian language, according to IANA.
	//
	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
	var windowsLanguages = {
	    0x0436: 'af',
	    0x041C: 'sq',
	    0x0484: 'gsw',
	    0x045E: 'am',
	    0x1401: 'ar-DZ',
	    0x3C01: 'ar-BH',
	    0x0C01: 'ar',
	    0x0801: 'ar-IQ',
	    0x2C01: 'ar-JO',
	    0x3401: 'ar-KW',
	    0x3001: 'ar-LB',
	    0x1001: 'ar-LY',
	    0x1801: 'ary',
	    0x2001: 'ar-OM',
	    0x4001: 'ar-QA',
	    0x0401: 'ar-SA',
	    0x2801: 'ar-SY',
	    0x1C01: 'aeb',
	    0x3801: 'ar-AE',
	    0x2401: 'ar-YE',
	    0x042B: 'hy',
	    0x044D: 'as',
	    0x082C: 'az-Cyrl',
	    0x042C: 'az',
	    0x046D: 'ba',
	    0x042D: 'eu',
	    0x0423: 'be',
	    0x0845: 'bn',
	    0x0445: 'bn-IN',
	    0x201A: 'bs-Cyrl',
	    0x141A: 'bs',
	    0x047E: 'br',
	    0x0402: 'bg',
	    0x0403: 'ca',
	    0x0C04: 'zh-HK',
	    0x1404: 'zh-MO',
	    0x0804: 'zh',
	    0x1004: 'zh-SG',
	    0x0404: 'zh-TW',
	    0x0483: 'co',
	    0x041A: 'hr',
	    0x101A: 'hr-BA',
	    0x0405: 'cs',
	    0x0406: 'da',
	    0x048C: 'prs',
	    0x0465: 'dv',
	    0x0813: 'nl-BE',
	    0x0413: 'nl',
	    0x0C09: 'en-AU',
	    0x2809: 'en-BZ',
	    0x1009: 'en-CA',
	    0x2409: 'en-029',
	    0x4009: 'en-IN',
	    0x1809: 'en-IE',
	    0x2009: 'en-JM',
	    0x4409: 'en-MY',
	    0x1409: 'en-NZ',
	    0x3409: 'en-PH',
	    0x4809: 'en-SG',
	    0x1C09: 'en-ZA',
	    0x2C09: 'en-TT',
	    0x0809: 'en-GB',
	    0x0409: 'en',
	    0x3009: 'en-ZW',
	    0x0425: 'et',
	    0x0438: 'fo',
	    0x0464: 'fil',
	    0x040B: 'fi',
	    0x080C: 'fr-BE',
	    0x0C0C: 'fr-CA',
	    0x040C: 'fr',
	    0x140C: 'fr-LU',
	    0x180C: 'fr-MC',
	    0x100C: 'fr-CH',
	    0x0462: 'fy',
	    0x0456: 'gl',
	    0x0437: 'ka',
	    0x0C07: 'de-AT',
	    0x0407: 'de',
	    0x1407: 'de-LI',
	    0x1007: 'de-LU',
	    0x0807: 'de-CH',
	    0x0408: 'el',
	    0x046F: 'kl',
	    0x0447: 'gu',
	    0x0468: 'ha',
	    0x040D: 'he',
	    0x0439: 'hi',
	    0x040E: 'hu',
	    0x040F: 'is',
	    0x0470: 'ig',
	    0x0421: 'id',
	    0x045D: 'iu',
	    0x085D: 'iu-Latn',
	    0x083C: 'ga',
	    0x0434: 'xh',
	    0x0435: 'zu',
	    0x0410: 'it',
	    0x0810: 'it-CH',
	    0x0411: 'ja',
	    0x044B: 'kn',
	    0x043F: 'kk',
	    0x0453: 'km',
	    0x0486: 'quc',
	    0x0487: 'rw',
	    0x0441: 'sw',
	    0x0457: 'kok',
	    0x0412: 'ko',
	    0x0440: 'ky',
	    0x0454: 'lo',
	    0x0426: 'lv',
	    0x0427: 'lt',
	    0x082E: 'dsb',
	    0x046E: 'lb',
	    0x042F: 'mk',
	    0x083E: 'ms-BN',
	    0x043E: 'ms',
	    0x044C: 'ml',
	    0x043A: 'mt',
	    0x0481: 'mi',
	    0x047A: 'arn',
	    0x044E: 'mr',
	    0x047C: 'moh',
	    0x0450: 'mn',
	    0x0850: 'mn-CN',
	    0x0461: 'ne',
	    0x0414: 'nb',
	    0x0814: 'nn',
	    0x0482: 'oc',
	    0x0448: 'or',
	    0x0463: 'ps',
	    0x0415: 'pl',
	    0x0416: 'pt',
	    0x0816: 'pt-PT',
	    0x0446: 'pa',
	    0x046B: 'qu-BO',
	    0x086B: 'qu-EC',
	    0x0C6B: 'qu',
	    0x0418: 'ro',
	    0x0417: 'rm',
	    0x0419: 'ru',
	    0x243B: 'smn',
	    0x103B: 'smj-NO',
	    0x143B: 'smj',
	    0x0C3B: 'se-FI',
	    0x043B: 'se',
	    0x083B: 'se-SE',
	    0x203B: 'sms',
	    0x183B: 'sma-NO',
	    0x1C3B: 'sms',
	    0x044F: 'sa',
	    0x1C1A: 'sr-Cyrl-BA',
	    0x0C1A: 'sr',
	    0x181A: 'sr-Latn-BA',
	    0x081A: 'sr-Latn',
	    0x046C: 'nso',
	    0x0432: 'tn',
	    0x045B: 'si',
	    0x041B: 'sk',
	    0x0424: 'sl',
	    0x2C0A: 'es-AR',
	    0x400A: 'es-BO',
	    0x340A: 'es-CL',
	    0x240A: 'es-CO',
	    0x140A: 'es-CR',
	    0x1C0A: 'es-DO',
	    0x300A: 'es-EC',
	    0x440A: 'es-SV',
	    0x100A: 'es-GT',
	    0x480A: 'es-HN',
	    0x080A: 'es-MX',
	    0x4C0A: 'es-NI',
	    0x180A: 'es-PA',
	    0x3C0A: 'es-PY',
	    0x280A: 'es-PE',
	    0x500A: 'es-PR',

	    // Microsoft has defined two different language codes for
	    // “Spanish with modern sorting” and “Spanish with traditional
	    // sorting”. This makes sense for collation APIs, and it would be
	    // possible to express this in BCP 47 language tags via Unicode
	    // extensions (eg., es-u-co-trad is Spanish with traditional
	    // sorting). However, for storing names in fonts, the distinction
	    // does not make sense, so we give “es” in both cases.
	    0x0C0A: 'es',
	    0x040A: 'es',

	    0x540A: 'es-US',
	    0x380A: 'es-UY',
	    0x200A: 'es-VE',
	    0x081D: 'sv-FI',
	    0x041D: 'sv',
	    0x045A: 'syr',
	    0x0428: 'tg',
	    0x085F: 'tzm',
	    0x0449: 'ta',
	    0x0444: 'tt',
	    0x044A: 'te',
	    0x041E: 'th',
	    0x0451: 'bo',
	    0x041F: 'tr',
	    0x0442: 'tk',
	    0x0480: 'ug',
	    0x0422: 'uk',
	    0x042E: 'hsb',
	    0x0420: 'ur',
	    0x0843: 'uz-Cyrl',
	    0x0443: 'uz',
	    0x042A: 'vi',
	    0x0452: 'cy',
	    0x0488: 'wo',
	    0x0485: 'sah',
	    0x0478: 'ii',
	    0x046A: 'yo'
	};

	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
	// for 'Chinese in the traditional script'.
	function getLanguageCode(platformID, languageID, ltag) {
	    switch (platformID) {
	        case 0:  // Unicode
	            if (languageID === 0xFFFF) {
	                return 'und';
	            } else if (ltag) {
	                return ltag[languageID];
	            }

	            break;

	        case 1:  // Macintosh
	            return macLanguages[languageID];

	        case 3:  // Windows
	            return windowsLanguages[languageID];
	    }

	    return undefined;
	}

	var utf16 = 'utf-16';

	// MacOS script ID → encoding. This table stores the default case,
	// which can be overridden by macLanguageEncodings.
	var macScriptEncodings = {
	    0: 'macintosh',           // smRoman
	    1: 'x-mac-japanese',      // smJapanese
	    2: 'x-mac-chinesetrad',   // smTradChinese
	    3: 'x-mac-korean',        // smKorean
	    6: 'x-mac-greek',         // smGreek
	    7: 'x-mac-cyrillic',      // smCyrillic
	    9: 'x-mac-devanagai',     // smDevanagari
	    10: 'x-mac-gurmukhi',     // smGurmukhi
	    11: 'x-mac-gujarati',     // smGujarati
	    12: 'x-mac-oriya',        // smOriya
	    13: 'x-mac-bengali',      // smBengali
	    14: 'x-mac-tamil',        // smTamil
	    15: 'x-mac-telugu',       // smTelugu
	    16: 'x-mac-kannada',      // smKannada
	    17: 'x-mac-malayalam',    // smMalayalam
	    18: 'x-mac-sinhalese',    // smSinhalese
	    19: 'x-mac-burmese',      // smBurmese
	    20: 'x-mac-khmer',        // smKhmer
	    21: 'x-mac-thai',         // smThai
	    22: 'x-mac-lao',          // smLao
	    23: 'x-mac-georgian',     // smGeorgian
	    24: 'x-mac-armenian',     // smArmenian
	    25: 'x-mac-chinesesimp',  // smSimpChinese
	    26: 'x-mac-tibetan',      // smTibetan
	    27: 'x-mac-mongolian',    // smMongolian
	    28: 'x-mac-ethiopic',     // smEthiopic
	    29: 'x-mac-ce',           // smCentralEuroRoman
	    30: 'x-mac-vietnamese',   // smVietnamese
	    31: 'x-mac-extarabic'     // smExtArabic
	};

	// MacOS language ID → encoding. This table stores the exceptional
	// cases, which override macScriptEncodings. For writing MacOS naming
	// tables, we need to emit a MacOS script ID. Therefore, we cannot
	// merge macScriptEncodings into macLanguageEncodings.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageEncodings = {
	    15: 'x-mac-icelandic',    // langIcelandic
	    17: 'x-mac-turkish',      // langTurkish
	    18: 'x-mac-croatian',     // langCroatian
	    24: 'x-mac-ce',           // langLithuanian
	    25: 'x-mac-ce',           // langPolish
	    26: 'x-mac-ce',           // langHungarian
	    27: 'x-mac-ce',           // langEstonian
	    28: 'x-mac-ce',           // langLatvian
	    30: 'x-mac-icelandic',    // langFaroese
	    37: 'x-mac-romanian',     // langRomanian
	    38: 'x-mac-ce',           // langCzech
	    39: 'x-mac-ce',           // langSlovak
	    40: 'x-mac-ce',           // langSlovenian
	    143: 'x-mac-inuit',       // langInuktitut
	    146: 'x-mac-gaelic'       // langIrishGaelicScript
	};

	function getEncoding(platformID, encodingID, languageID) {
	    switch (platformID) {
	        case 0:  // Unicode
	            return utf16;

	        case 1:  // Apple Macintosh
	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

	        case 3:  // Microsoft Windows
	            if (encodingID === 1 || encodingID === 10) {
	                return utf16;
	            }

	            break;
	    }

	    return undefined;
	}

	// Parse the naming `name` table.
	// FIXME: Format 1 additional fields are not supported yet.
	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
	function parseNameTable(data, start, ltag) {
	    var name = {};
	    var p = new parse.Parser(data, start);
	    var format = p.parseUShort();
	    var count = p.parseUShort();
	    var stringOffset = p.offset + p.parseUShort();
	    for (var i = 0; i < count; i++) {
	        var platformID = p.parseUShort();
	        var encodingID = p.parseUShort();
	        var languageID = p.parseUShort();
	        var nameID = p.parseUShort();
	        var property = nameTableNames[nameID] || nameID;
	        var byteLength = p.parseUShort();
	        var offset = p.parseUShort();
	        var language = getLanguageCode(platformID, languageID, ltag);
	        var encoding = getEncoding(platformID, encodingID, languageID);
	        if (encoding !== undefined && language !== undefined) {
	            var text = (void 0);
	            if (encoding === utf16) {
	                text = decode.UTF16(data, stringOffset + offset, byteLength);
	            } else {
	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
	            }

	            if (text) {
	                var translations = name[property];
	                if (translations === undefined) {
	                    translations = name[property] = {};
	                }

	                translations[language] = text;
	            }
	        }
	    }

	    var langTagCount = 0;
	    if (format === 1) {
	        // FIXME: Also handle Microsoft's 'name' table 1.
	        langTagCount = p.parseUShort();
	    }

	    return name;
	}

	// {23: 'foo'} → {'foo': 23}
	// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
	function reverseDict(dict) {
	    var result = {};
	    for (var key in dict) {
	        result[dict[key]] = parseInt(key);
	    }

	    return result;
	}

	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
	    return new table.Record('NameRecord', [
	        {name: 'platformID', type: 'USHORT', value: platformID},
	        {name: 'encodingID', type: 'USHORT', value: encodingID},
	        {name: 'languageID', type: 'USHORT', value: languageID},
	        {name: 'nameID', type: 'USHORT', value: nameID},
	        {name: 'length', type: 'USHORT', value: length},
	        {name: 'offset', type: 'USHORT', value: offset}
	    ]);
	}

	// Finds the position of needle in haystack, or -1 if not there.
	// Like String.indexOf(), but for arrays.
	function findSubArray(needle, haystack) {
	    var needleLength = needle.length;
	    var limit = haystack.length - needleLength + 1;

	    loop:
	    for (var pos = 0; pos < limit; pos++) {
	        for (; pos < limit; pos++) {
	            for (var k = 0; k < needleLength; k++) {
	                if (haystack[pos + k] !== needle[k]) {
	                    continue loop;
	                }
	            }

	            return pos;
	        }
	    }

	    return -1;
	}

	function addStringToPool(s, pool) {
	    var offset = findSubArray(s, pool);
	    if (offset < 0) {
	        offset = pool.length;
	        var i = 0;
	        var len = s.length;
	        for (; i < len; ++i) {
	            pool.push(s[i]);
	        }

	    }

	    return offset;
	}

	function makeNameTable(names, ltag) {
	    var nameID;
	    var nameIDs = [];

	    var namesWithNumericKeys = {};
	    var nameTableIds = reverseDict(nameTableNames);
	    for (var key in names) {
	        var id = nameTableIds[key];
	        if (id === undefined) {
	            id = key;
	        }

	        nameID = parseInt(id);

	        if (isNaN(nameID)) {
	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
	        }

	        namesWithNumericKeys[nameID] = names[key];
	        nameIDs.push(nameID);
	    }

	    var macLanguageIds = reverseDict(macLanguages);
	    var windowsLanguageIds = reverseDict(windowsLanguages);

	    var nameRecords = [];
	    var stringPool = [];

	    for (var i = 0; i < nameIDs.length; i++) {
	        nameID = nameIDs[i];
	        var translations = namesWithNumericKeys[nameID];
	        for (var lang in translations) {
	            var text = translations[lang];

	            // For MacOS, we try to emit the name in the form that was introduced
	            // in the initial version of the TrueType spec (in the late 1980s).
	            // However, this can fail for various reasons: the requested BCP 47
	            // language code might not have an old-style Mac equivalent;
	            // we might not have a codec for the needed character encoding;
	            // or the name might contain characters that cannot be expressed
	            // in the old-style Macintosh encoding. In case of failure, we emit
	            // the name in a more modern fashion (Unicode encoding with BCP 47
	            // language tags) that is recognized by MacOS 10.5, released in 2009.
	            // If fonts were only read by operating systems, we could simply
	            // emit all names in the modern form; this would be much easier.
	            // However, there are many applications and libraries that read
	            // 'name' tables directly, and these will usually only recognize
	            // the ancient form (silently skipping the unrecognized names).
	            var macPlatform = 1;  // Macintosh
	            var macLanguage = macLanguageIds[lang];
	            var macScript = macLanguageToScript[macLanguage];
	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
	            var macName = encode.MACSTRING(text, macEncoding);
	            if (macName === undefined) {
	                macPlatform = 0;  // Unicode
	                macLanguage = ltag.indexOf(lang);
	                if (macLanguage < 0) {
	                    macLanguage = ltag.length;
	                    ltag.push(lang);
	                }

	                macScript = 4;  // Unicode 2.0 and later
	                macName = encode.UTF16(text);
	            }

	            var macNameOffset = addStringToPool(macName, stringPool);
	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
	                                            nameID, macName.length, macNameOffset));

	            var winLanguage = windowsLanguageIds[lang];
	            if (winLanguage !== undefined) {
	                var winName = encode.UTF16(text);
	                var winNameOffset = addStringToPool(winName, stringPool);
	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
	                                                nameID, winName.length, winNameOffset));
	            }
	        }
	    }

	    nameRecords.sort(function(a, b) {
	        return ((a.platformID - b.platformID) ||
	                (a.encodingID - b.encodingID) ||
	                (a.languageID - b.languageID) ||
	                (a.nameID - b.nameID));
	    });

	    var t = new table.Table('name', [
	        {name: 'format', type: 'USHORT', value: 0},
	        {name: 'count', type: 'USHORT', value: nameRecords.length},
	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
	    ]);

	    for (var r = 0; r < nameRecords.length; r++) {
	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
	    }

	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
	    return t;
	}

	var _name = { parse: parseNameTable, make: makeNameTable };

	// The `OS/2` table contains metrics required in OpenType fonts.

	var unicodeRanges = [
	    {begin: 0x0000, end: 0x007F}, // Basic Latin
	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
	    {begin: 0x0530, end: 0x058F}, // Armenian
	    {begin: 0x0590, end: 0x05FF}, // Hebrew
	    {begin: 0xA500, end: 0xA63F}, // Vai
	    {begin: 0x0600, end: 0x06FF}, // Arabic
	    {begin: 0x07C0, end: 0x07FF}, // NKo
	    {begin: 0x0900, end: 0x097F}, // Devanagari
	    {begin: 0x0980, end: 0x09FF}, // Bengali
	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
	    {begin: 0x0E00, end: 0x0E7F}, // Thai
	    {begin: 0x0E80, end: 0x0EFF}, // Lao
	    {begin: 0x10A0, end: 0x10FF}, // Georgian
	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
	    {begin: 0x2000, end: 0x206F}, // General Punctuation
	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
	    {begin: 0x2150, end: 0x218F}, // Number Forms
	    {begin: 0x2190, end: 0x21FF}, // Arrows
	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
	    {begin: 0x2400, end: 0x243F}, // Control Pictures
	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
	    {begin: 0x2500, end: 0x257F}, // Box Drawing
	    {begin: 0x2580, end: 0x259F}, // Block Elements
	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
	    {begin: 0x2700, end: 0x27BF}, // Dingbats
	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
	    {begin: 0x3040, end: 0x309F}, // Hiragana
	    {begin: 0x30A0, end: 0x30FF}, // Katakana
	    {begin: 0x3100, end: 0x312F}, // Bopomofo
	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
	    {begin: 0x0700, end: 0x074F}, // Syriac
	    {begin: 0x0780, end: 0x07BF}, // Thaana
	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
	    {begin: 0x1000, end: 0x109F}, // Myanmar
	    {begin: 0x1200, end: 0x137F}, // Ethiopic
	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
	    {begin: 0x1680, end: 0x169F}, // Ogham
	    {begin: 0x16A0, end: 0x16FF}, // Runic
	    {begin: 0x1780, end: 0x17FF}, // Khmer
	    {begin: 0x1800, end: 0x18AF}, // Mongolian
	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
	    {begin: 0x1700, end: 0x171F}, // Tagalog
	    {begin: 0x10300, end: 0x1032F}, // Old Italic
	    {begin: 0x10330, end: 0x1034F}, // Gothic
	    {begin: 0x10400, end: 0x1044F}, // Deseret
	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
	    {begin: 0xE0000, end: 0xE007F}, // Tags
	    {begin: 0x1900, end: 0x194F}, // Limbu
	    {begin: 0x1950, end: 0x197F}, // Tai Le
	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
	    {begin: 0x10450, end: 0x1047F}, // Shavian
	    {begin: 0x10480, end: 0x104AF}, // Osmanya
	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
	    {begin: 0xA930, end: 0xA95F}, // Rejang
	    {begin: 0xAA00, end: 0xAA5F}, // Cham
	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
	    {begin: 0x102A0, end: 0x102DF}, // Carian
	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
	];

	function getUnicodeRange(unicode) {
	    for (var i = 0; i < unicodeRanges.length; i += 1) {
	        var range = unicodeRanges[i];
	        if (unicode >= range.begin && unicode < range.end) {
	            return i;
	        }
	    }

	    return -1;
	}

	// Parse the OS/2 and Windows metrics `OS/2` table
	function parseOS2Table(data, start) {
	    var os2 = {};
	    var p = new parse.Parser(data, start);
	    os2.version = p.parseUShort();
	    os2.xAvgCharWidth = p.parseShort();
	    os2.usWeightClass = p.parseUShort();
	    os2.usWidthClass = p.parseUShort();
	    os2.fsType = p.parseUShort();
	    os2.ySubscriptXSize = p.parseShort();
	    os2.ySubscriptYSize = p.parseShort();
	    os2.ySubscriptXOffset = p.parseShort();
	    os2.ySubscriptYOffset = p.parseShort();
	    os2.ySuperscriptXSize = p.parseShort();
	    os2.ySuperscriptYSize = p.parseShort();
	    os2.ySuperscriptXOffset = p.parseShort();
	    os2.ySuperscriptYOffset = p.parseShort();
	    os2.yStrikeoutSize = p.parseShort();
	    os2.yStrikeoutPosition = p.parseShort();
	    os2.sFamilyClass = p.parseShort();
	    os2.panose = [];
	    for (var i = 0; i < 10; i++) {
	        os2.panose[i] = p.parseByte();
	    }

	    os2.ulUnicodeRange1 = p.parseULong();
	    os2.ulUnicodeRange2 = p.parseULong();
	    os2.ulUnicodeRange3 = p.parseULong();
	    os2.ulUnicodeRange4 = p.parseULong();
	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
	    os2.fsSelection = p.parseUShort();
	    os2.usFirstCharIndex = p.parseUShort();
	    os2.usLastCharIndex = p.parseUShort();
	    os2.sTypoAscender = p.parseShort();
	    os2.sTypoDescender = p.parseShort();
	    os2.sTypoLineGap = p.parseShort();
	    os2.usWinAscent = p.parseUShort();
	    os2.usWinDescent = p.parseUShort();
	    if (os2.version >= 1) {
	        os2.ulCodePageRange1 = p.parseULong();
	        os2.ulCodePageRange2 = p.parseULong();
	    }

	    if (os2.version >= 2) {
	        os2.sxHeight = p.parseShort();
	        os2.sCapHeight = p.parseShort();
	        os2.usDefaultChar = p.parseUShort();
	        os2.usBreakChar = p.parseUShort();
	        os2.usMaxContent = p.parseUShort();
	    }

	    return os2;
	}

	function makeOS2Table(options) {
	    return new table.Table('OS/2', [
	        {name: 'version', type: 'USHORT', value: 0x0003},
	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
	        {name: 'usWeightClass', type: 'USHORT', value: 0},
	        {name: 'usWidthClass', type: 'USHORT', value: 0},
	        {name: 'fsType', type: 'USHORT', value: 0},
	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
	        {name: 'bFamilyType', type: 'BYTE', value: 0},
	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
	        {name: 'bWeight', type: 'BYTE', value: 0},
	        {name: 'bProportion', type: 'BYTE', value: 0},
	        {name: 'bContrast', type: 'BYTE', value: 0},
	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
	        {name: 'bArmStyle', type: 'BYTE', value: 0},
	        {name: 'bLetterform', type: 'BYTE', value: 0},
	        {name: 'bMidline', type: 'BYTE', value: 0},
	        {name: 'bXHeight', type: 'BYTE', value: 0},
	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
	        {name: 'fsSelection', type: 'USHORT', value: 0},
	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
	        {name: 'usWinAscent', type: 'USHORT', value: 0},
	        {name: 'usWinDescent', type: 'USHORT', value: 0},
	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
	        {name: 'sxHeight', type: 'SHORT', value: 0},
	        {name: 'sCapHeight', type: 'SHORT', value: 0},
	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
	        {name: 'usBreakChar', type: 'USHORT', value: 0},
	        {name: 'usMaxContext', type: 'USHORT', value: 0}
	    ], options);
	}

	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

	// The `post` table stores additional PostScript information, such as glyph names.

	// Parse the PostScript `post` table
	function parsePostTable(data, start) {
	    var post = {};
	    var p = new parse.Parser(data, start);
	    post.version = p.parseVersion();
	    post.italicAngle = p.parseFixed();
	    post.underlinePosition = p.parseShort();
	    post.underlineThickness = p.parseShort();
	    post.isFixedPitch = p.parseULong();
	    post.minMemType42 = p.parseULong();
	    post.maxMemType42 = p.parseULong();
	    post.minMemType1 = p.parseULong();
	    post.maxMemType1 = p.parseULong();
	    switch (post.version) {
	        case 1:
	            post.names = standardNames.slice();
	            break;
	        case 2:
	            post.numberOfGlyphs = p.parseUShort();
	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                post.glyphNameIndex[i] = p.parseUShort();
	            }

	            post.names = [];
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
	                    var nameLength = p.parseChar();
	                    post.names.push(p.parseString(nameLength));
	                }
	            }

	            break;
	        case 2.5:
	            post.numberOfGlyphs = p.parseUShort();
	            post.offset = new Array(post.numberOfGlyphs);
	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
	                post.offset[i$2] = p.parseChar();
	            }

	            break;
	    }
	    return post;
	}

	function makePostTable() {
	    return new table.Table('post', [
	        {name: 'version', type: 'FIXED', value: 0x00030000},
	        {name: 'italicAngle', type: 'FIXED', value: 0},
	        {name: 'underlinePosition', type: 'FWORD', value: 0},
	        {name: 'underlineThickness', type: 'FWORD', value: 0},
	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
	        {name: 'minMemType42', type: 'ULONG', value: 0},
	        {name: 'maxMemType42', type: 'ULONG', value: 0},
	        {name: 'minMemType1', type: 'ULONG', value: 0},
	        {name: 'maxMemType1', type: 'ULONG', value: 0}
	    ]);
	}

	var post = { parse: parsePostTable, make: makePostTable };

	// The `GSUB` table contains ligatures, among other things.

	var subtableParsers = new Array(9);         // subtableParsers[0] is unused

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
	subtableParsers[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            deltaGlyphId: this.parseUShort()
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            substitute: this.parseOffset16List()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
	subtableParsers[2] = function parseLookup2() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        sequences: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
	subtableParsers[3] = function parseLookup3() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        alternateSets: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
	subtableParsers[4] = function parseLookup4() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        ligatureSets: this.parseListOfLists(function() {
	            return {
	                ligGlyph: this.parseUShort(),
	                components: this.parseUShortList(this.parseUShort() - 1)
	            };
	        })
	    };
	};

	var lookupRecordDesc = {
	    sequenceIndex: Parser.uShort,
	    lookupListIndex: Parser.uShort
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
	subtableParsers[5] = function parseLookup5() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();

	    if (substFormat === 1) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            ruleSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    input: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            classDef: this.parsePointer(Parser.classDef),
	            classSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    classes: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        var glyphCount = this.parseUShort();
	        var substCount = this.parseUShort();
	        return {
	            substFormat: substFormat,
	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
	subtableParsers[6] = function parseLookup6() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            chainRuleSets: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            backtrackClassDef: this.parsePointer(Parser.classDef),
	            inputClassDef: this.parsePointer(Parser.classDef),
	            lookaheadClassDef: this.parsePointer(Parser.classDef),
	            chainClassSet: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        return {
	            substFormat: 3,
	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
	subtableParsers[7] = function parseLookup7() {
	    // Extension Substitution subtable
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
	    var extensionLookupType = this.parseUShort();
	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
	    return {
	        substFormat: 1,
	        lookupType: extensionLookupType,
	        extension: subtableParsers[extensionLookupType].call(extensionParser)
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
	subtableParsers[8] = function parseLookup8() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        substitutes: this.parseUShortList()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
	function parseGsubTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GSUB Writing //////////////////////////////////////////////
	var subtableMakers = new Array(9);

	subtableMakers[1] = function makeLookup1(subtable) {
	    if (subtable.substFormat === 1) {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 1},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
	        ]);
	    } else {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 2},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	        ].concat(table.ushortList('substitute', subtable.substitute)));
	    }
	};

	subtableMakers[2] = function makeLookup2(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {
	        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));
	    })));
	};

	subtableMakers[3] = function makeLookup3(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
	    })));
	};

	subtableMakers[4] = function makeLookup4(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
	            return new table.Table('ligatureTable',
	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
	            );
	        }));
	    })));
	};

	subtableMakers[6] = function makeLookup6(subtable) {
	    if (subtable.substFormat === 1) {
	        var returnTable = new table.Table('chainContextTable', [
	            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {
	            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {
	                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)
	                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))
	                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))
	                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));

	                chainRule.lookupRecords.forEach(function (record, i) {
	                    tableData = tableData
	                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
	                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
	                });
	                return new table.Table('chainRuleTable', tableData);
	            }));
	        })));
	        return returnTable;
	    } else if (subtable.substFormat === 2) {
	        check.assert(false, 'lookup type 6 format 2 is not yet supported.');
	    } else if (subtable.substFormat === 3) {
	        var tableData = [
	            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];

	        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});
	        subtable.backtrackCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });
	        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});
	        subtable.inputCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });
	        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});
	        subtable.lookaheadCoverage.forEach(function (coverage, i) {
	            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});
	        });

	        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});
	        subtable.lookupRecords.forEach(function (record, i) {
	            tableData = tableData
	                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
	                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
	        });

	        var returnTable$1 = new table.Table('chainContextTable', tableData);

	        return returnTable$1;
	    }

	    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');
	};

	function makeGsubTable(gsub) {
	    return new table.Table('GSUB', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
	    ]);
	}

	var gsub = { parse: parseGsubTable, make: makeGsubTable };

	// The `GPOS` table contains kerning pairs, among other things.

	// Parse the metadata `meta` table.
	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
	function parseMetaTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported META table version.');
	    p.parseULong(); // flags - currently unused and set to 0
	    p.parseULong(); // tableOffset
	    var numDataMaps = p.parseULong();

	    var tags = {};
	    for (var i = 0; i < numDataMaps; i++) {
	        var tag = p.parseTag();
	        var dataOffset = p.parseULong();
	        var dataLength = p.parseULong();
	        var text = decode.UTF8(data, start + dataOffset, dataLength);

	        tags[tag] = text;
	    }
	    return tags;
	}

	function makeMetaTable(tags) {
	    var numTags = Object.keys(tags).length;
	    var stringPool = '';
	    var stringPoolOffset = 16 + numTags * 12;

	    var result = new table.Table('meta', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
	        {name: 'numTags', type: 'ULONG', value: numTags}
	    ]);

	    for (var tag in tags) {
	        var pos = stringPool.length;
	        stringPool += tags[tag];

	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

	    return result;
	}

	var meta = { parse: parseMetaTable, make: makeMetaTable };

	// The `sfnt` wrapper provides organization for the tables in the font.

	function log2(v) {
	    return Math.log(v) / Math.log(2) | 0;
	}

	function computeCheckSum(bytes) {
	    while (bytes.length % 4 !== 0) {
	        bytes.push(0);
	    }

	    var sum = 0;
	    for (var i = 0; i < bytes.length; i += 4) {
	        sum += (bytes[i] << 24) +
	            (bytes[i + 1] << 16) +
	            (bytes[i + 2] << 8) +
	            (bytes[i + 3]);
	    }

	    sum %= Math.pow(2, 32);
	    return sum;
	}

	function makeTableRecord(tag, checkSum, offset, length) {
	    return new table.Record('Table Record', [
	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
	    ]);
	}

	function makeSfntTable(tables) {
	    var sfnt = new table.Table('sfnt', [
	        {name: 'version', type: 'TAG', value: 'OTTO'},
	        {name: 'numTables', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);
	    sfnt.tables = tables;
	    sfnt.numTables = tables.length;
	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
	    sfnt.searchRange = 16 * highestPowerOf2;
	    sfnt.entrySelector = log2(highestPowerOf2);
	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

	    var recordFields = [];
	    var tableFields = [];

	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
	    while (offset % 4 !== 0) {
	        offset += 1;
	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	    }

	    for (var i = 0; i < tables.length; i += 1) {
	        var t = tables[i];
	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
	        var tableLength = t.sizeOf();
	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
	        offset += tableLength;
	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
	        while (offset % 4 !== 0) {
	            offset += 1;
	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	        }
	    }

	    // Table records need to be sorted alphabetically.
	    recordFields.sort(function(r1, r2) {
	        if (r1.value.tag > r2.value.tag) {
	            return 1;
	        } else {
	            return -1;
	        }
	    });

	    sfnt.fields = sfnt.fields.concat(recordFields);
	    sfnt.fields = sfnt.fields.concat(tableFields);
	    return sfnt;
	}

	// Get the metrics for a character. If the string has more than one character
	// this function returns metrics for the first available character.
	// You can provide optional fallback metrics if no characters are available.
	function metricsForChar(font, chars, notFoundMetrics) {
	    for (var i = 0; i < chars.length; i += 1) {
	        var glyphIndex = font.charToGlyphIndex(chars[i]);
	        if (glyphIndex > 0) {
	            var glyph = font.glyphs.get(glyphIndex);
	            return glyph.getMetrics();
	        }
	    }

	    return notFoundMetrics;
	}

	function average(vs) {
	    var sum = 0;
	    for (var i = 0; i < vs.length; i += 1) {
	        sum += vs[i];
	    }

	    return sum / vs.length;
	}

	// Convert the font object to a SFNT data structure.
	// This structure contains all the necessary tables and metadata to create a binary OTF file.
	function fontToSfntTable(font) {
	    var xMins = [];
	    var yMins = [];
	    var xMaxs = [];
	    var yMaxs = [];
	    var advanceWidths = [];
	    var leftSideBearings = [];
	    var rightSideBearings = [];
	    var firstCharIndex;
	    var lastCharIndex = 0;
	    var ulUnicodeRange1 = 0;
	    var ulUnicodeRange2 = 0;
	    var ulUnicodeRange3 = 0;
	    var ulUnicodeRange4 = 0;

	    for (var i = 0; i < font.glyphs.length; i += 1) {
	        var glyph = font.glyphs.get(i);
	        var unicode = glyph.unicode | 0;

	        if (isNaN(glyph.advanceWidth)) {
	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
	        }

	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
	            // ignore .notdef char
	            if (unicode > 0) {
	                firstCharIndex = unicode;
	            }
	        }

	        if (lastCharIndex < unicode) {
	            lastCharIndex = unicode;
	        }

	        var position = os2.getUnicodeRange(unicode);
	        if (position < 32) {
	            ulUnicodeRange1 |= 1 << position;
	        } else if (position < 64) {
	            ulUnicodeRange2 |= 1 << position - 32;
	        } else if (position < 96) {
	            ulUnicodeRange3 |= 1 << position - 64;
	        } else if (position < 123) {
	            ulUnicodeRange4 |= 1 << position - 96;
	        } else {
	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
	        }
	        // Skip non-important characters.
	        if (glyph.name === '.notdef') { continue; }
	        var metrics = glyph.getMetrics();
	        xMins.push(metrics.xMin);
	        yMins.push(metrics.yMin);
	        xMaxs.push(metrics.xMax);
	        yMaxs.push(metrics.yMax);
	        leftSideBearings.push(metrics.leftSideBearing);
	        rightSideBearings.push(metrics.rightSideBearing);
	        advanceWidths.push(glyph.advanceWidth);
	    }

	    var globals = {
	        xMin: Math.min.apply(null, xMins),
	        yMin: Math.min.apply(null, yMins),
	        xMax: Math.max.apply(null, xMaxs),
	        yMax: Math.max.apply(null, yMaxs),
	        advanceWidthMax: Math.max.apply(null, advanceWidths),
	        advanceWidthAvg: average(advanceWidths),
	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
	    };
	    globals.ascender = font.ascender;
	    globals.descender = font.descender;

	    var headTable = head.make({
	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
	        unitsPerEm: font.unitsPerEm,
	        xMin: globals.xMin,
	        yMin: globals.yMin,
	        xMax: globals.xMax,
	        yMax: globals.yMax,
	        lowestRecPPEM: 3,
	        createdTimestamp: font.createdTimestamp
	    });

	    var hheaTable = hhea.make({
	        ascender: globals.ascender,
	        descender: globals.descender,
	        advanceWidthMax: globals.advanceWidthMax,
	        minLeftSideBearing: globals.minLeftSideBearing,
	        minRightSideBearing: globals.minRightSideBearing,
	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
	        numberOfHMetrics: font.glyphs.length
	    });

	    var maxpTable = maxp.make(font.glyphs.length);

	    var os2Table = os2.make(Object.assign({
	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
	        usFirstCharIndex: firstCharIndex,
	        usLastCharIndex: lastCharIndex,
	        ulUnicodeRange1: ulUnicodeRange1,
	        ulUnicodeRange2: ulUnicodeRange2,
	        ulUnicodeRange3: ulUnicodeRange3,
	        ulUnicodeRange4: ulUnicodeRange4,
	        // See http://typophile.com/node/13081 for more info on vertical metrics.
	        // We get metrics for typical characters (such as "x" for xHeight).
	        // We provide some fallback characters if characters are unavailable: their
	        // ordering was chosen experimentally.
	        sTypoAscender: globals.ascender,
	        sTypoDescender: globals.descender,
	        sTypoLineGap: 0,
	        usWinAscent: globals.yMax,
	        usWinDescent: Math.abs(globals.yMin),
	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
	        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.
	    }, font.tables.os2));

	    var hmtxTable = hmtx.make(font.glyphs);
	    var cmapTable = cmap.make(font.glyphs);

	    var englishFamilyName = font.getEnglishName('fontFamily');
	    var englishStyleName = font.getEnglishName('fontSubfamily');
	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
	    var postScriptName = font.getEnglishName('postScriptName');
	    if (!postScriptName) {
	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
	    }

	    var names = {};
	    for (var n in font.names) {
	        names[n] = font.names[n];
	    }

	    if (!names.uniqueID) {
	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
	    }

	    if (!names.postScriptName) {
	        names.postScriptName = {en: postScriptName};
	    }

	    if (!names.preferredFamily) {
	        names.preferredFamily = font.names.fontFamily;
	    }

	    if (!names.preferredSubfamily) {
	        names.preferredSubfamily = font.names.fontSubfamily;
	    }

	    var languageTags = [];
	    var nameTable = _name.make(names, languageTags);
	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

	    var postTable = post.make();
	    var cffTable = cff.make(font.glyphs, {
	        version: font.getEnglishName('version'),
	        fullName: englishFullName,
	        familyName: englishFamilyName,
	        weightName: englishStyleName,
	        postScriptName: postScriptName,
	        unitsPerEm: font.unitsPerEm,
	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
	    });

	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

	    // The order does not matter because makeSfntTable() will sort them.
	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
	    if (ltagTable) {
	        tables.push(ltagTable);
	    }
	    // Optional tables
	    if (font.tables.gsub) {
	        tables.push(gsub.make(font.tables.gsub));
	    }
	    if (metaTable) {
	        tables.push(metaTable);
	    }

	    var sfntTable = makeSfntTable(tables);

	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
	    var bytes = sfntTable.encode();
	    var checkSum = computeCheckSum(bytes);
	    var tableFields = sfntTable.fields;
	    var checkSumAdjusted = false;
	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
	        if (tableFields[i$1].name === 'head table') {
	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
	            checkSumAdjusted = true;
	            break;
	        }
	    }

	    if (!checkSumAdjusted) {
	        throw new Error('Could not find head table with checkSum to adjust.');
	    }

	    return sfntTable;
	}

	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

	// The Layout object is the prototype of Substitution objects, and provides

	function searchTag(arr, tag) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid].tag;
	        if (val === tag) {
	            return imid;
	        } else if (val < tag) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	function binSearch(arr, value) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid];
	        if (val === value) {
	            return imid;
	        } else if (val < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	// binary search in a list of ranges (coverage, class definition)
	function searchRange(ranges, value) {
	    // jshint bitwise: false
	    var range;
	    var imin = 0;
	    var imax = ranges.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        range = ranges[imid];
	        var start = range.start;
	        if (start === value) {
	            return range;
	        } else if (start < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    if (imin > 0) {
	        range = ranges[imin - 1];
	        if (value > range.end) { return 0; }
	        return range;
	    }
	}

	/**
	 * @exports opentype.Layout
	 * @class
	 */
	function Layout(font, tableName) {
	    this.font = font;
	    this.tableName = tableName;
	}

	Layout.prototype = {

	    /**
	     * Binary search an object by "tag" property
	     * @instance
	     * @function searchTag
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {string} tag
	     * @return {number}
	     */
	    searchTag: searchTag,

	    /**
	     * Binary search in a list of numbers
	     * @instance
	     * @function binSearch
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {number} value
	     * @return {number}
	     */
	    binSearch: binSearch,

	    /**
	     * Get or create the Layout table (GSUB, GPOS etc).
	     * @param  {boolean} create - Whether to create a new one.
	     * @return {Object} The GSUB or GPOS table.
	     */
	    getTable: function(create) {
	        var layout = this.font.tables[this.tableName];
	        if (!layout && create) {
	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
	        }
	        return layout;
	    },

	    /**
	     * Returns all scripts in the substitution table.
	     * @instance
	     * @return {Array}
	     */
	    getScriptNames: function() {
	        var layout = this.getTable();
	        if (!layout) { return []; }
	        return layout.scripts.map(function(script) {
	            return script.tag;
	        });
	    },

	    /**
	     * Returns the best bet for a script name.
	     * Returns 'DFLT' if it exists.
	     * If not, returns 'latn' if it exists.
	     * If neither exist, returns undefined.
	     */
	    getDefaultScriptName: function() {
	        var layout = this.getTable();
	        if (!layout) { return; }
	        var hasLatn = false;
	        for (var i = 0; i < layout.scripts.length; i++) {
	            var name = layout.scripts[i].tag;
	            if (name === 'DFLT') { return name; }
	            if (name === 'latn') { hasLatn = true; }
	        }
	        if (hasLatn) { return 'latn'; }
	    },

	    /**
	     * Returns all LangSysRecords in the given script.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
	     * @return {Object} An object with tag and script properties.
	     */
	    getScriptTable: function(script, create) {
	        var layout = this.getTable(create);
	        if (layout) {
	            script = script || 'DFLT';
	            var scripts = layout.scripts;
	            var pos = searchTag(layout.scripts, script);
	            if (pos >= 0) {
	                return scripts[pos].script;
	            } else if (create) {
	                var scr = {
	                    tag: script,
	                    script: {
	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
	                        langSysRecords: []
	                    }
	                };
	                scripts.splice(-1 - pos, 0, scr);
	                return scr.script;
	            }
	        }
	    },

	    /**
	     * Returns a language system table
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
	     * @return {Object}
	     */
	    getLangSysTable: function(script, language, create) {
	        var scriptTable = this.getScriptTable(script, create);
	        if (scriptTable) {
	            if (!language || language === 'dflt' || language === 'DFLT') {
	                return scriptTable.defaultLangSys;
	            }
	            var pos = searchTag(scriptTable.langSysRecords, language);
	            if (pos >= 0) {
	                return scriptTable.langSysRecords[pos].langSys;
	            } else if (create) {
	                var langSysRecord = {
	                    tag: language,
	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
	                };
	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
	                return langSysRecord.langSys;
	            }
	        }
	    },

	    /**
	     * Get a specific feature table.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
	     * @return {Object}
	     */
	    getFeatureTable: function(script, language, feature, create) {
	        var langSysTable = this.getLangSysTable(script, language, create);
	        if (langSysTable) {
	            var featureRecord;
	            var featIndexes = langSysTable.featureIndexes;
	            var allFeatures = this.font.tables[this.tableName].features;
	            // The FeatureIndex array of indices is in arbitrary order,
	            // even if allFeatures is sorted alphabetically by feature tag.
	            for (var i = 0; i < featIndexes.length; i++) {
	                featureRecord = allFeatures[featIndexes[i]];
	                if (featureRecord.tag === feature) {
	                    return featureRecord.feature;
	                }
	            }
	            if (create) {
	                var index = allFeatures.length;
	                // Automatic ordering of features would require to shift feature indexes in the script list.
	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
	                featureRecord = {
	                    tag: feature,
	                    feature: { params: 0, lookupListIndexes: [] }
	                };
	                allFeatures.push(featureRecord);
	                featIndexes.push(index);
	                return featureRecord.feature;
	            }
	        }
	    },

	    /**
	     * Get the lookup tables of a given type for a script/language/feature.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - 4-letter feature code
	     * @param {number} lookupType - 1 to 9
	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
	     * @return {Object[]}
	     */
	    getLookupTables: function(script, language, feature, lookupType, create) {
	        var featureTable = this.getFeatureTable(script, language, feature, create);
	        var tables = [];
	        if (featureTable) {
	            var lookupTable;
	            var lookupListIndexes = featureTable.lookupListIndexes;
	            var allLookups = this.font.tables[this.tableName].lookups;
	            // lookupListIndexes are in no particular order, so use naive search.
	            for (var i = 0; i < lookupListIndexes.length; i++) {
	                lookupTable = allLookups[lookupListIndexes[i]];
	                if (lookupTable.lookupType === lookupType) {
	                    tables.push(lookupTable);
	                }
	            }
	            if (tables.length === 0 && create) {
	                lookupTable = {
	                    lookupType: lookupType,
	                    lookupFlag: 0,
	                    subtables: [],
	                    markFilteringSet: undefined
	                };
	                var index = allLookups.length;
	                allLookups.push(lookupTable);
	                lookupListIndexes.push(index);
	                return [lookupTable];
	            }
	        }
	        return tables;
	    },

	    /**
	     * Find a glyph in a class definition table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
	     * @param {object} classDefTable - an OpenType Layout class definition table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getGlyphClass: function(classDefTable, glyphIndex) {
	        switch (classDefTable.format) {
	            case 1:
	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
	                }
	                return 0;
	            case 2:
	                var range = searchRange(classDefTable.ranges, glyphIndex);
	                return range ? range.classId : 0;
	        }
	    },

	    /**
	     * Find a glyph in a coverage table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
	     * @param {object} coverageTable - an OpenType Layout coverage table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getCoverageIndex: function(coverageTable, glyphIndex) {
	        switch (coverageTable.format) {
	            case 1:
	                var index = binSearch(coverageTable.glyphs, glyphIndex);
	                return index >= 0 ? index : -1;
	            case 2:
	                var range = searchRange(coverageTable.ranges, glyphIndex);
	                return range ? range.index + glyphIndex - range.start : -1;
	        }
	    },

	    /**
	     * Returns the list of glyph indexes of a coverage table.
	     * Format 1: the list is stored raw
	     * Format 2: compact list as range records.
	     * @instance
	     * @param  {Object} coverageTable
	     * @return {Array}
	     */
	    expandCoverage: function(coverageTable) {
	        if (coverageTable.format === 1) {
	            return coverageTable.glyphs;
	        } else {
	            var glyphs = [];
	            var ranges = coverageTable.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                var start = range.start;
	                var end = range.end;
	                for (var j = start; j <= end; j++) {
	                    glyphs.push(j);
	                }
	            }
	            return glyphs;
	        }
	    }

	};

	// The Position object provides utility methods to manipulate

	/**
	 * @exports opentype.Position
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Position(font) {
	    Layout.call(this, font, 'gpos');
	}

	Position.prototype = Layout.prototype;

	/**
	 * Init some data for faster and easier access later.
	 */
	Position.prototype.init = function() {
	    var script = this.getDefaultScriptName();
	    this.defaultKerningTables = this.getKerningTables(script);
	};

	/**
	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
	 *
	 * @param {integer} leftIndex - left glyph index
	 * @param {integer} rightIndex - right glyph index
	 * @returns {integer}
	 */
	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
	    for (var i = 0; i < kerningLookups.length; i++) {
	        var subtables = kerningLookups[i].subtables;
	        for (var j = 0; j < subtables.length; j++) {
	            var subtable = subtables[j];
	            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
	            if (covIndex < 0) { continue; }
	            switch (subtable.posFormat) {
	                case 1:
	                    // Search Pair Adjustment Positioning Format 1
	                    var pairSet = subtable.pairSets[covIndex];
	                    for (var k = 0; k < pairSet.length; k++) {
	                        var pair = pairSet[k];
	                        if (pair.secondGlyph === rightIndex) {
	                            return pair.value1 && pair.value1.xAdvance || 0;
	                        }
	                    }
	                    break;      // left glyph found, not right glyph - try next subtable
	                case 2:
	                    // Search Pair Adjustment Positioning Format 2
	                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
	                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
	                    var pair$1 = subtable.classRecords[class1][class2];
	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
	            }
	        }
	    }
	    return 0;
	};

	/**
	 * List all kerning lookup tables.
	 *
	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
	 * @param {string} [language='dflt']
	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
	 */
	Position.prototype.getKerningTables = function(script, language) {
	    if (this.font.tables.gpos) {
	        return this.getLookupTables(script, language, 'kern', 2);
	    }
	};

	// The Substitution object provides utility methods to manipulate

	/**
	 * @exports opentype.Substitution
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Substitution(font) {
	    Layout.call(this, font, 'gsub');
	}

	// Check if 2 arrays of primitives are equal.
	function arraysEqual(ar1, ar2) {
	    var n = ar1.length;
	    if (n !== ar2.length) { return false; }
	    for (var i = 0; i < n; i++) {
	        if (ar1[i] !== ar2[i]) { return false; }
	    }
	    return true;
	}

	// Find the first subtable of a lookup table in a particular format.
	function getSubstFormat(lookupTable, format, defaultSubtable) {
	    var subtables = lookupTable.subtables;
	    for (var i = 0; i < subtables.length; i++) {
	        var subtable = subtables[i];
	        if (subtable.substFormat === format) {
	            return subtable;
	        }
	    }
	    if (defaultSubtable) {
	        subtables.push(defaultSubtable);
	        return defaultSubtable;
	    }
	    return undefined;
	}

	Substitution.prototype = Layout.prototype;

	/**
	 * Create a default GSUB table.
	 * @return {Object} gsub - The GSUB table.
	 */
	Substitution.prototype.createDefaultTable = function() {
	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
	    return {
	        version: 1,
	        scripts: [{
	            tag: 'DFLT',
	            script: {
	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
	                langSysRecords: []
	            }
	        }],
	        features: [],
	        lookups: []
	    };
	};

	/**
	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getSingle = function(feature, script, language) {
	    var substitutions = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 1);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var j = (void 0);
	            if (subtable.substFormat === 1) {
	                var delta = subtable.deltaGlyphId;
	                for (j = 0; j < glyphs.length; j++) {
	                    var glyph = glyphs[j];
	                    substitutions.push({ sub: glyph, by: glyph + delta });
	                }
	            } else {
	                var substitute = subtable.substitute;
	                for (j = 0; j < glyphs.length; j++) {
	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
	                }
	            }
	        }
	    }
	    return substitutions;
	};

	/**
	 * List all multiple substitutions (lookup type 2) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('ccmp', 'stch')
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getMultiple = function(feature, script, language) {
	    var substitutions = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 2);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var j = (void 0);

	            for (j = 0; j < glyphs.length; j++) {
	                var glyph = glyphs[j];
	                var replacements = subtable.sequences[j];
	                substitutions.push({ sub: glyph, by: replacements });
	            }
	        }
	    }
	    return substitutions;
	};

	/**
	 * List all alternates (lookup type 3) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
	 * @return {Array} alternates - The list of alternates
	 */
	Substitution.prototype.getAlternates = function(feature, script, language) {
	    var alternates = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 3);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var alternateSets = subtable.alternateSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
	            }
	        }
	    }
	    return alternates;
	};

	/**
	 * List all ligatures (lookup type 4) for a given script, language, and feature.
	 * The result is an array of ligature objects like { sub: [ids], by: id }
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} ligatures - The list of ligatures.
	 */
	Substitution.prototype.getLigatures = function(feature, script, language) {
	    var ligatures = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 4);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this.expandCoverage(subtable.coverage);
	            var ligatureSets = subtable.ligatureSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                var startGlyph = glyphs[j];
	                var ligSet = ligatureSets[j];
	                for (var k = 0; k < ligSet.length; k++) {
	                    var lig = ligSet[k];
	                    ligatures.push({
	                        sub: [startGlyph].concat(lig.components),
	                        by: lig.ligGlyph
	                    });
	                }
	            }
	        }
	    }
	    return ligatures;
	};

	/**
	 * Add or modify a single substitution (lookup type 1)
	 * Format 2, more flexible, is always used.
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
	        substFormat: 2,
	        coverage: {format: 1, glyphs: []},
	        substitute: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.substitute.splice(pos, 0, 0);
	    }
	    subtable.substitute[pos] = substitution.by;
	};

	/**
	 * Add or modify a multiple substitution (lookup type 2)
	 * @param {string} feature - 4-letter feature name ('ccmp', 'stch')
	 * @param {Object} substitution - { sub: id, by: [id] } for format 2.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
	    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
	    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1
	        substFormat: 1,
	        coverage: {format: 1, glyphs: []},
	        sequences: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.sequences.splice(pos, 0, 0);
	    }
	    subtable.sequences[pos] = substitution.by;
	};

	/**
	 * Add or modify an alternate substitution (lookup type 3)
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, by: [ids] }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
	        substFormat: 1,
	        coverage: {format: 1, glyphs: []},
	        alternateSets: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.alternateSets.splice(pos, 0, 0);
	    }
	    subtable.alternateSets[pos] = substitution.by;
	};

	/**
	 * Add a ligature (lookup type 4)
	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} ligature - { sub: [ids], by: id }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
	    var subtable = lookupTable.subtables[0];
	    if (!subtable) {
	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
	            substFormat: 1,
	            coverage: { format: 1, glyphs: [] },
	            ligatureSets: []
	        };
	        lookupTable.subtables[0] = subtable;
	    }
	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = ligature.sub[0];
	    var ligComponents = ligature.sub.slice(1);
	    var ligatureTable = {
	        ligGlyph: ligature.by,
	        components: ligComponents
	    };
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos >= 0) {
	        // ligatureSet already exists
	        var ligatureSet = subtable.ligatureSets[pos];
	        for (var i = 0; i < ligatureSet.length; i++) {
	            // If ligature already exists, return.
	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
	                return;
	            }
	        }
	        // ligature does not exist: add it.
	        ligatureSet.push(ligatureTable);
	    } else {
	        // Create a new ligatureSet and add coverage for the first glyph.
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
	    }
	};

	/**
	 * List all feature data for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getFeature = function(feature, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.getSingle(feature, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            return this.getSingle(feature, script, language)
	                    .concat(this.getAlternates(feature, script, language));
	        case 'dlig':
	        case 'liga':
	        case 'rlig':
	            return this.getLigatures(feature, script, language);
	        case 'ccmp':
	            return this.getMultiple(feature, script, language)
	                .concat(this.getLigatures(feature, script, language));
	        case 'stch':
	            return this.getMultiple(feature, script, language);
	    }
	    return undefined;
	};

	/**
	 * Add a substitution to a feature for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.add = function(feature, sub, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.addSingle(feature, sub, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            if (typeof sub.by === 'number') {
	                return this.addSingle(feature, sub, script, language);
	            }
	            return this.addAlternate(feature, sub, script, language);
	        case 'dlig':
	        case 'liga':
	        case 'rlig':
	            return this.addLigature(feature, sub, script, language);
	        case 'ccmp':
	            if (sub.by instanceof Array) {
	                return this.addMultiple(feature, sub, script, language);
	            }
	            return this.addLigature(feature, sub, script, language);
	    }
	    return undefined;
	};

	function isBrowser() {
	    return typeof window !== 'undefined';
	}

	function nodeBufferToArrayBuffer(buffer) {
	    var ab = new ArrayBuffer(buffer.length);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        view[i] = buffer[i];
	    }

	    return ab;
	}

	function arrayBufferToNodeBuffer(ab) {
	    var buffer = new Buffer(ab.byteLength);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        buffer[i] = view[i];
	    }

	    return buffer;
	}

	function checkArgument(expression, message) {
	    if (!expression) {
	        throw message;
	    }
	}

	// The `glyf` table describes the glyphs in TrueType outline format.

	// Parse the coordinate data for a glyph.
	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
	    var v;
	    if ((flag & shortVectorBitMask) > 0) {
	        // The coordinate is 1 byte long.
	        v = p.parseByte();
	        // The `same` bit is re-used for short values to signify the sign of the value.
	        if ((flag & sameBitMask) === 0) {
	            v = -v;
	        }

	        v = previousValue + v;
	    } else {
	        //  The coordinate is 2 bytes long.
	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
	        if ((flag & sameBitMask) > 0) {
	            v = previousValue;
	        } else {
	            // Parse the coordinate as a signed 16-bit delta value.
	            v = previousValue + p.parseShort();
	        }
	    }

	    return v;
	}

	// Parse a TrueType glyph.
	function parseGlyph(glyph, data, start) {
	    var p = new parse.Parser(data, start);
	    glyph.numberOfContours = p.parseShort();
	    glyph._xMin = p.parseShort();
	    glyph._yMin = p.parseShort();
	    glyph._xMax = p.parseShort();
	    glyph._yMax = p.parseShort();
	    var flags;
	    var flag;

	    if (glyph.numberOfContours > 0) {
	        // This glyph is not a composite.
	        var endPointIndices = glyph.endPointIndices = [];
	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
	            endPointIndices.push(p.parseUShort());
	        }

	        glyph.instructionLength = p.parseUShort();
	        glyph.instructions = [];
	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
	            glyph.instructions.push(p.parseByte());
	        }

	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
	        flags = [];
	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
	            flag = p.parseByte();
	            flags.push(flag);
	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
	            if ((flag & 8) > 0) {
	                var repeatCount = p.parseByte();
	                for (var j = 0; j < repeatCount; j += 1) {
	                    flags.push(flag);
	                    i$2 += 1;
	                }
	            }
	        }

	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

	        if (endPointIndices.length > 0) {
	            var points = [];
	            var point;
	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
	            if (numberOfCoordinates > 0) {
	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
	                    flag = flags[i$3];
	                    point = {};
	                    point.onCurve = !!(flag & 1);
	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
	                    points.push(point);
	                }

	                var px = 0;
	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
	                    flag = flags[i$4];
	                    point = points[i$4];
	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
	                    px = point.x;
	                }

	                var py = 0;
	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
	                    flag = flags[i$5];
	                    point = points[i$5];
	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
	                    py = point.y;
	                }
	            }

	            glyph.points = points;
	        } else {
	            glyph.points = [];
	        }
	    } else if (glyph.numberOfContours === 0) {
	        glyph.points = [];
	    } else {
	        glyph.isComposite = true;
	        glyph.points = [];
	        glyph.components = [];
	        var moreComponents = true;
	        while (moreComponents) {
	            flags = p.parseUShort();
	            var component = {
	                glyphIndex: p.parseUShort(),
	                xScale: 1,
	                scale01: 0,
	                scale10: 0,
	                yScale: 1,
	                dx: 0,
	                dy: 0
	            };
	            if ((flags & 1) > 0) {
	                // The arguments are words
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseShort();
	                    component.dy = p.parseShort();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
	                }

	            } else {
	                // The arguments are bytes
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseChar();
	                    component.dy = p.parseChar();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
	                }
	            }

	            if ((flags & 8) > 0) {
	                // We have a scale
	                component.xScale = component.yScale = p.parseF2Dot14();
	            } else if ((flags & 64) > 0) {
	                // We have an X / Y scale
	                component.xScale = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            } else if ((flags & 128) > 0) {
	                // We have a 2x2 transformation
	                component.xScale = p.parseF2Dot14();
	                component.scale01 = p.parseF2Dot14();
	                component.scale10 = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            }

	            glyph.components.push(component);
	            moreComponents = !!(flags & 32);
	        }
	        if (flags & 0x100) {
	            // We have instructions
	            glyph.instructionLength = p.parseUShort();
	            glyph.instructions = [];
	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
	                glyph.instructions.push(p.parseByte());
	            }
	        }
	    }
	}

	// Transform an array of points and return a new array.
	function transformPoints(points, transform) {
	    var newPoints = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        var newPt = {
	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
	            onCurve: pt.onCurve,
	            lastPointOfContour: pt.lastPointOfContour
	        };
	        newPoints.push(newPt);
	    }

	    return newPoints;
	}

	function getContours(points) {
	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	}

	// Convert the TrueType glyph outline to a Path.
	function getPath(points) {
	    var p = new Path();
	    if (!points) {
	        return p;
	    }

	    var contours = getContours(points);

	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
	        var contour = contours[contourIndex];

	        var prev = null;
	        var curr = contour[contour.length - 1];
	        var next = contour[0];

	        if (curr.onCurve) {
	            p.moveTo(curr.x, curr.y);
	        } else {
	            if (next.onCurve) {
	                p.moveTo(next.x, next.y);
	            } else {
	                // If both first and last points are off-curve, start at their middle.
	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
	                p.moveTo(start.x, start.y);
	            }
	        }

	        for (var i = 0; i < contour.length; ++i) {
	            prev = curr;
	            curr = next;
	            next = contour[(i + 1) % contour.length];

	            if (curr.onCurve) {
	                // This is a straight line.
	                p.lineTo(curr.x, curr.y);
	            } else {
	                var prev2 = prev;
	                var next2 = next;

	                if (!prev.onCurve) {
	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
	                }

	                if (!next.onCurve) {
	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
	                }

	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
	            }
	        }

	        p.closePath();
	    }
	    return p;
	}

	function buildPath(glyphs, glyph) {
	    if (glyph.isComposite) {
	        for (var j = 0; j < glyph.components.length; j += 1) {
	            var component = glyph.components[j];
	            var componentGlyph = glyphs.get(component.glyphIndex);
	            // Force the ttfGlyphLoader to parse the glyph.
	            componentGlyph.getPath();
	            if (componentGlyph.points) {
	                var transformedPoints = (void 0);
	                if (component.matchedPoints === undefined) {
	                    // component positioned by offset
	                    transformedPoints = transformPoints(componentGlyph.points, component);
	                } else {
	                    // component positioned by matched points
	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
	                        throw Error('Matched points out of range in ' + glyph.name);
	                    }
	                    var firstPt = glyph.points[component.matchedPoints[0]];
	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
	                    var transform = {
	                        xScale: component.xScale, scale01: component.scale01,
	                        scale10: component.scale10, yScale: component.yScale,
	                        dx: 0, dy: 0
	                    };
	                    secondPt = transformPoints([secondPt], transform)[0];
	                    transform.dx = firstPt.x - secondPt.x;
	                    transform.dy = firstPt.y - secondPt.y;
	                    transformedPoints = transformPoints(componentGlyph.points, transform);
	                }
	                glyph.points = glyph.points.concat(transformedPoints);
	            }
	        }
	    }

	    return getPath(glyph.points);
	}

	function parseGlyfTableAll(data, start, loca, font) {
	    var glyphs = new glyphset.GlyphSet(font);

	    // The last element of the loca table is invalid.
	    for (var i = 0; i < loca.length - 1; i += 1) {
	        var offset = loca[i];
	        var nextOffset = loca[i + 1];
	        if (offset !== nextOffset) {
	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
	        } else {
	            glyphs.push(i, glyphset.glyphLoader(font, i));
	        }
	    }

	    return glyphs;
	}

	function parseGlyfTableOnLowMemory(data, start, loca, font) {
	    var glyphs = new glyphset.GlyphSet(font);

	    font._push = function(i) {
	        var offset = loca[i];
	        var nextOffset = loca[i + 1];
	        if (offset !== nextOffset) {
	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
	        } else {
	            glyphs.push(i, glyphset.glyphLoader(font, i));
	        }
	    };

	    return glyphs;
	}

	// Parse all the glyphs according to the offsets from the `loca` table.
	function parseGlyfTable(data, start, loca, font, opt) {
	    if (opt.lowMemory)
	        { return parseGlyfTableOnLowMemory(data, start, loca, font); }
	    else
	        { return parseGlyfTableAll(data, start, loca, font); }
	}

	var glyf = { getPath: getPath, parse: parseGlyfTable};

	/* A TrueType font hinting interpreter.
	*
	* (c) 2017 Axel Kittenberger
	*
	* This interpreter has been implemented according to this documentation:
	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
	*
	* According to the documentation F24DOT6 values are used for pixels.
	* That means calculation is 1/64 pixel accurate and uses integer operations.
	* However, Javascript has floating point operations by default and only
	* those are available. One could make a case to simulate the 1/64 accuracy
	* exactly by truncating after every division operation
	* (for example with << 0) to get pixel exactly results as other TrueType
	* implementations. It may make sense since some fonts are pixel optimized
	* by hand using DELTAP instructions. The current implementation doesn't
	* and rather uses full floating point precision.
	*
	* xScale, yScale and rotation is currently ignored.
	*
	* A few non-trivial instructions are missing as I didn't encounter yet
	* a font that used them to test a possible implementation.
	*
	* Some fonts seem to use undocumented features regarding the twilight zone.
	* Only some of them are implemented as they were encountered.
	*
	* The exports.DEBUG statements are removed on the minified distribution file.
	*/

	var instructionTable;
	var exec;
	var execGlyph;
	var execComponent;

	/*
	* Creates a hinting object.
	*
	* There ought to be exactly one
	* for each truetype font that is used for hinting.
	*/
	function Hinting(font) {
	    // the font this hinting object is for
	    this.font = font;

	    this.getCommands = function (hPoints) {
	        return glyf.getPath(hPoints).commands;
	    };

	    // cached states
	    this._fpgmState  =
	    this._prepState  =
	        undefined;

	    // errorState
	    // 0 ... all okay
	    // 1 ... had an error in a glyf,
	    //       continue working but stop spamming
	    //       the console
	    // 2 ... error at prep, stop hinting at this ppem
	    // 3 ... error at fpeg, stop hinting for this font at all
	    this._errorState = 0;
	}

	/*
	* Not rounding.
	*/
	function roundOff(v) {
	    return v;
	}

	/*
	* Rounding to grid.
	*/
	function roundToGrid(v) {
	    //Rounding in TT is supposed to "symmetrical around zero"
	    return Math.sign(v) * Math.round(Math.abs(v));
	}

	/*
	* Rounding to double grid.
	*/
	function roundToDoubleGrid(v) {
	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
	}

	/*
	* Rounding to half grid.
	*/
	function roundToHalfGrid(v) {
	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
	}

	/*
	* Rounding to up to grid.
	*/
	function roundUpToGrid(v) {
	    return Math.sign(v) * Math.ceil(Math.abs(v));
	}

	/*
	* Rounding to down to grid.
	*/
	function roundDownToGrid(v) {
	    return Math.sign(v) * Math.floor(Math.abs(v));
	}

	/*
	* Super rounding.
	*/
	var roundSuper = function (v) {
	    var period = this.srPeriod;
	    var phase = this.srPhase;
	    var threshold = this.srThreshold;
	    var sign = 1;

	    if (v < 0) {
	        v = -v;
	        sign = -1;
	    }

	    v += threshold - phase;

	    v = Math.trunc(v / period) * period;

	    v += phase;

	    // according to http://xgridfit.sourceforge.net/round.html
	    if (v < 0) { return phase * sign; }

	    return v * sign;
	};

	/*
	* Unit vector of x-axis.
	*/
	var xUnitVector = {
	    x: 1,

	    y: 0,

	    axis: 'x',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.xo - rp1.xo;
	            do2 = p.xo - rp2.xo;
	            dm1 = rp1.x - rp1.xo;
	            dm2 = rp2.x - rp2.xo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.x = p.xo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this
	    normalSlope: Number.NEGATIVE_INFINITY,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'.
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.x = (org ? rp.xo : rp.x) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
	    },

	    // Slope of vector line.
	    slope: 0,

	    // Touches the point p.
	    touch: function (p) {
	        p.xTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.xTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.xTouched = false;
	    }
	};

	/*
	* Unit vector of y-axis.
	*/
	var yUnitVector = {
	    x: 0,

	    y: 1,

	    axis: 'y',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.yo - rp1.yo;
	            do2 = p.yo - rp2.yo;
	            dm1 = rp1.y - rp1.yo;
	            dm2 = rp2.y - rp2.yo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.y = p.yo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this.
	    normalSlope: 0,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.y = (org ? rp.yo : rp.y) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
	    },

	    // Slope of vector line.
	    slope: Number.POSITIVE_INFINITY,

	    // Touches the point p.
	    touch: function (p) {
	        p.yTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.yTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.yTouched = false;
	    }
	};

	Object.freeze(xUnitVector);
	Object.freeze(yUnitVector);

	/*
	* Creates a unit vector that is not x- or y-axis.
	*/
	function UnitVector(x, y) {
	    this.x = x;
	    this.y = y;
	    this.axis = undefined;
	    this.slope = y / x;
	    this.normalSlope = -x / y;
	    Object.freeze(this);
	}

	/*
	* Gets the projected distance between two points.
	* o1/o2 ... if true, respective original position is used.
	*/
	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
	    return (
	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
	        this.y * yUnitVector.distance(p1, p2, o1, o2)
	    );
	};

	/*
	* Moves point p so the moved position has the same relative
	* position to the moved positions of rp1 and rp2 than the
	* original positions had.
	*
	* See APPENDIX on INTERPOLATE at the bottom of this file.
	*/
	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
	    var dm1;
	    var dm2;
	    var do1;
	    var do2;
	    var doa1;
	    var doa2;
	    var dt;

	    do1 = pv.distance(p, rp1, true, true);
	    do2 = pv.distance(p, rp2, true, true);
	    dm1 = pv.distance(rp1, rp1, false, true);
	    dm2 = pv.distance(rp2, rp2, false, true);
	    doa1 = Math.abs(do1);
	    doa2 = Math.abs(do2);
	    dt = doa1 + doa2;

	    if (dt === 0) {
	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	        return;
	    }

	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	};

	/*
	* Sets the point 'p' relative to point 'rp'
	* by the distance 'd'
	*
	* See APPENDIX on SETRELATIVE at the bottom of this file.
	*
	* p   ...  point to set
	* rp  ... reference point
	* d   ... distance on projection vector
	* pv  ... projection vector (undefined = this)
	* org ... if true, uses the original position of rp as reference.
	*/
	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
	    pv = pv || this;

	    var rpx = org ? rp.xo : rp.x;
	    var rpy = org ? rp.yo : rp.y;
	    var rpdx = rpx + d * pv.x;
	    var rpdy = rpy + d * pv.y;

	    var pvns = pv.normalSlope;
	    var fvs = this.slope;

	    var px = p.x;
	    var py = p.y;

	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
	    p.y = fvs * (p.x - px) + py;
	};

	/*
	* Touches the point p.
	*/
	UnitVector.prototype.touch = function(p) {
	    p.xTouched = true;
	    p.yTouched = true;
	};

	/*
	* Returns a unit vector with x/y coordinates.
	*/
	function getUnitVector(x, y) {
	    var d = Math.sqrt(x * x + y * y);

	    x /= d;
	    y /= d;

	    if (x === 1 && y === 0) { return xUnitVector; }
	    else if (x === 0 && y === 1) { return yUnitVector; }
	    else { return new UnitVector(x, y); }
	}

	/*
	* Creates a point in the hinting engine.
	*/
	function HPoint(
	    x,
	    y,
	    lastPointOfContour,
	    onCurve
	) {
	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

	    this.lastPointOfContour = lastPointOfContour;
	    this.onCurve = onCurve;
	    this.prevPointOnContour = undefined;
	    this.nextPointOnContour = undefined;
	    this.xTouched = false;
	    this.yTouched = false;

	    Object.preventExtensions(this);
	}

	/*
	* Returns the next touched point on the contour.
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.nextTouched = function(v) {
	    var p = this.nextPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

	    return p;
	};

	/*
	* Returns the previous touched point on the contour
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.prevTouched = function(v) {
	    var p = this.prevPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

	    return p;
	};

	/*
	* The zero point.
	*/
	var HPZero = Object.freeze(new HPoint(0, 0));

	/*
	* The default state of the interpreter.
	*
	* Note: Freezing the defaultState and then deriving from it
	* makes the V8 Javascript engine going awkward,
	* so this is avoided, albeit the defaultState shouldn't
	* ever change.
	*/
	var defaultState = {
	    cvCutIn: 17 / 16,    // control value cut in
	    deltaBase: 9,
	    deltaShift: 0.125,
	    loop: 1,             // loops some instructions
	    minDis: 1,           // minimum distance
	    autoFlip: true
	};

	/*
	* The current state of the interpreter.
	*
	* env  ... 'fpgm' or 'prep' or 'glyf'
	* prog ... the program
	*/
	function State(env, prog) {
	    this.env = env;
	    this.stack = [];
	    this.prog = prog;

	    switch (env) {
	        case 'glyf' :
	            this.zp0 = this.zp1 = this.zp2 = 1;
	            this.rp0 = this.rp1 = this.rp2 = 0;
	            /* fall through */
	        case 'prep' :
	            this.fv = this.pv = this.dpv = xUnitVector;
	            this.round = roundToGrid;
	    }
	}

	/*
	* Executes a glyph program.
	*
	* This does the hinting for each glyph.
	*
	* Returns an array of moved points.
	*
	* glyph: the glyph to hint
	* ppem: the size the glyph is rendered for
	*/
	Hinting.prototype.exec = function(glyph, ppem) {
	    if (typeof ppem !== 'number') {
	        throw new Error('Point size is not a number!');
	    }

	    // Received a fatal error, don't do any hinting anymore.
	    if (this._errorState > 2) { return; }

	    var font = this.font;
	    var prepState = this._prepState;

	    if (!prepState || prepState.ppem !== ppem) {
	        var fpgmState = this._fpgmState;

	        if (!fpgmState) {
	            // Executes the fpgm state.
	            // This is used by fonts to define functions.
	            State.prototype = defaultState;

	            fpgmState =
	            this._fpgmState =
	                new State('fpgm', font.tables.fpgm);

	            fpgmState.funcs = [ ];
	            fpgmState.font = font;

	            if (exports.DEBUG) {
	                console.log('---EXEC FPGM---');
	                fpgmState.step = -1;
	            }

	            try {
	                exec(fpgmState);
	            } catch (e) {
	                console.log('Hinting error in FPGM:' + e);
	                this._errorState = 3;
	                return;
	            }
	        }

	        // Executes the prep program for this ppem setting.
	        // This is used by fonts to set cvt values
	        // depending on to be rendered font size.

	        State.prototype = fpgmState;
	        prepState =
	        this._prepState =
	            new State('prep', font.tables.prep);

	        prepState.ppem = ppem;

	        // Creates a copy of the cvt table
	        // and scales it to the current ppem setting.
	        var oCvt = font.tables.cvt;
	        if (oCvt) {
	            var cvt = prepState.cvt = new Array(oCvt.length);
	            var scale = ppem / font.unitsPerEm;
	            for (var c = 0; c < oCvt.length; c++) {
	                cvt[c] = oCvt[c] * scale;
	            }
	        } else {
	            prepState.cvt = [];
	        }

	        if (exports.DEBUG) {
	            console.log('---EXEC PREP---');
	            prepState.step = -1;
	        }

	        try {
	            exec(prepState);
	        } catch (e) {
	            if (this._errorState < 2) {
	                console.log('Hinting error in PREP:' + e);
	            }
	            this._errorState = 2;
	        }
	    }

	    if (this._errorState > 1) { return; }

	    try {
	        return execGlyph(glyph, prepState);
	    } catch (e) {
	        if (this._errorState < 1) {
	            console.log('Hinting error:' + e);
	            console.log('Note: further hinting errors are silenced');
	        }
	        this._errorState = 1;
	        return undefined;
	    }
	};

	/*
	* Executes the hinting program for a glyph.
	*/
	execGlyph = function(glyph, prepState) {
	    // original point positions
	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
	    var yScale = xScale;
	    var components = glyph.components;
	    var contours;
	    var gZone;
	    var state;

	    State.prototype = prepState;
	    if (!components) {
	        state = new State('glyf', glyph.instructions);
	        if (exports.DEBUG) {
	            console.log('---EXEC GLYPH---');
	            state.step = -1;
	        }
	        execComponent(glyph, state, xScale, yScale);
	        gZone = state.gZone;
	    } else {
	        var font = prepState.font;
	        gZone = [];
	        contours = [];
	        for (var i = 0; i < components.length; i++) {
	            var c = components[i];
	            var cg = font.glyphs.get(c.glyphIndex);

	            state = new State('glyf', cg.instructions);

	            if (exports.DEBUG) {
	                console.log('---EXEC COMP ' + i + '---');
	                state.step = -1;
	            }

	            execComponent(cg, state, xScale, yScale);
	            // appends the computed points to the result array
	            // post processes the component points
	            var dx = Math.round(c.dx * xScale);
	            var dy = Math.round(c.dy * yScale);
	            var gz = state.gZone;
	            var cc = state.contours;
	            for (var pi = 0; pi < gz.length; pi++) {
	                var p = gz[pi];
	                p.xTouched = p.yTouched = false;
	                p.xo = p.x = p.x + dx;
	                p.yo = p.y = p.y + dy;
	            }

	            var gLen = gZone.length;
	            gZone.push.apply(gZone, gz);
	            for (var j = 0; j < cc.length; j++) {
	                contours.push(cc[j] + gLen);
	            }
	        }

	        if (glyph.instructions && !state.inhibitGridFit) {
	            // the composite has instructions on its own
	            state = new State('glyf', glyph.instructions);

	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

	            state.contours = contours;

	            // note: HPZero cannot be used here, since
	            //       the point might be modified
	            gZone.push(
	                new HPoint(0, 0),
	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	            );

	            if (exports.DEBUG) {
	                console.log('---EXEC COMPOSITE---');
	                state.step = -1;
	            }

	            exec(state);

	            gZone.length -= 2;
	        }
	    }

	    return gZone;
	};

	/*
	* Executes the hinting program for a component of a multi-component glyph
	* or of the glyph itself for a non-component glyph.
	*/
	execComponent = function(glyph, state, xScale, yScale)
	{
	    var points = glyph.points || [];
	    var pLen = points.length;
	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
	    var contours = state.contours = [];

	    // Scales the original points and
	    // makes copies for the hinted points.
	    var cp; // current point
	    for (var i = 0; i < pLen; i++) {
	        cp = points[i];

	        gZone[i] = new HPoint(
	            cp.x * xScale,
	            cp.y * yScale,
	            cp.lastPointOfContour,
	            cp.onCurve
	        );
	    }

	    // Chain links the contours.
	    var sp; // start point
	    var np; // next point

	    for (var i$1 = 0; i$1 < pLen; i$1++) {
	        cp = gZone[i$1];

	        if (!sp) {
	            sp = cp;
	            contours.push(i$1);
	        }

	        if (cp.lastPointOfContour) {
	            cp.nextPointOnContour = sp;
	            sp.prevPointOnContour = cp;
	            sp = undefined;
	        } else {
	            np = gZone[i$1 + 1];
	            cp.nextPointOnContour = np;
	            np.prevPointOnContour = cp;
	        }
	    }

	    if (state.inhibitGridFit) { return; }

	    if (exports.DEBUG) {
	        console.log('PROCESSING GLYPH', state.stack);
	        for (var i$2 = 0; i$2 < pLen; i$2++) {
	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
	        }
	    }

	    gZone.push(
	        new HPoint(0, 0),
	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	    );

	    exec(state);

	    // Removes the extra points.
	    gZone.length -= 2;

	    if (exports.DEBUG) {
	        console.log('FINISHED GLYPH', state.stack);
	        for (var i$3 = 0; i$3 < pLen; i$3++) {
	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
	        }
	    }
	};

	/*
	* Executes the program loaded in state.
	*/
	exec = function(state) {
	    var prog = state.prog;

	    if (!prog) { return; }

	    var pLen = prog.length;
	    var ins;

	    for (state.ip = 0; state.ip < pLen; state.ip++) {
	        if (exports.DEBUG) { state.step++; }
	        ins = instructionTable[prog[state.ip]];

	        if (!ins) {
	            throw new Error(
	                'unknown instruction: 0x' +
	                Number(prog[state.ip]).toString(16)
	            );
	        }

	        ins(state);

	        // very extensive debugging for each step
	        /*
	        if (exports.DEBUG) {
	            var da;
	            if (state.gZone) {
	                da = [];
	                for (let i = 0; i < state.gZone.length; i++)
	                {
	                    da.push(i + ' ' +
	                        state.gZone[i].x * 64 + ' ' +
	                        state.gZone[i].y * 64 + ' ' +
	                        (state.gZone[i].xTouched ? 'x' : '') +
	                        (state.gZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('GZ', da);
	            }

	            if (state.tZone) {
	                da = [];
	                for (let i = 0; i < state.tZone.length; i++) {
	                    da.push(i + ' ' +
	                        state.tZone[i].x * 64 + ' ' +
	                        state.tZone[i].y * 64 + ' ' +
	                        (state.tZone[i].xTouched ? 'x' : '') +
	                        (state.tZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('TZ', da);
	            }

	            if (state.stack.length > 10) {
	                console.log(
	                    state.stack.length,
	                    '...', state.stack.slice(state.stack.length - 10)
	                );
	            } else {
	                console.log(state.stack.length, state.stack);
	            }
	        }
	        */
	    }
	};

	/*
	* Initializes the twilight zone.
	*
	* This is only done if a SZPx instruction
	* refers to the twilight zone.
	*/
	function initTZone(state)
	{
	    var tZone = state.tZone = new Array(state.gZone.length);

	    // no idea if this is actually correct...
	    for (var i = 0; i < tZone.length; i++)
	    {
	        tZone[i] = new HPoint(0, 0);
	    }
	}

	/*
	* Skips the instruction pointer ahead over an IF/ELSE block.
	* handleElse .. if true breaks on matching ELSE
	*/
	function skip(state, handleElse)
	{
	    var prog = state.prog;
	    var ip = state.ip;
	    var nesting = 1;
	    var ins;

	    do {
	        ins = prog[++ip];
	        if (ins === 0x58) // IF
	            { nesting++; }
	        else if (ins === 0x59) // EIF
	            { nesting--; }
	        else if (ins === 0x40) // NPUSHB
	            { ip += prog[ip + 1] + 1; }
	        else if (ins === 0x41) // NPUSHW
	            { ip += 2 * prog[ip + 1] + 1; }
	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
	            { ip += ins - 0xB0 + 1; }
	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
	            { ip += (ins - 0xB8 + 1) * 2; }
	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
	            { break; }
	    } while (nesting > 0);

	    state.ip = ip;
	}

	/*----------------------------------------------------------*
	*          And then a lot of instructions...                *
	*----------------------------------------------------------*/

	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
	// 0x00-0x01
	function SVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

	    state.fv = state.pv = state.dpv = v;
	}

	// SPVTCA[a] Set Projection Vector to Coordinate Axis
	// 0x02-0x03
	function SPVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

	    state.pv = state.dpv = v;
	}

	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
	// 0x04-0x05
	function SFVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

	    state.fv = v;
	}

	// SPVTL[a] Set Projection Vector To Line
	// 0x06-0x07
	function SPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.pv = state.dpv = getUnitVector(dx, dy);
	}

	// SFVTL[a] Set Freedom Vector To Line
	// 0x08-0x09
	function SFVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.fv = getUnitVector(dx, dy);
	}

	// SPVFS[] Set Projection Vector From Stack
	// 0x0A
	function SPVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.pv = state.dpv = getUnitVector(x, y);
	}

	// SFVFS[] Set Freedom Vector From Stack
	// 0x0B
	function SFVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.fv = getUnitVector(x, y);
	}

	// GPV[] Get Projection Vector
	// 0x0C
	function GPV(state) {
	    var stack = state.stack;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

	    stack.push(pv.x * 0x4000);
	    stack.push(pv.y * 0x4000);
	}

	// GFV[] Get Freedom Vector
	// 0x0C
	function GFV(state) {
	    var stack = state.stack;
	    var fv = state.fv;

	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

	    stack.push(fv.x * 0x4000);
	    stack.push(fv.y * 0x4000);
	}

	// SFVTPV[] Set Freedom Vector To Projection Vector
	// 0x0E
	function SFVTPV(state) {
	    state.fv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
	}

	// ISECT[] moves point p to the InterSECTion of two lines
	// 0x0F
	function ISECT(state)
	{
	    var stack = state.stack;
	    var pa0i = stack.pop();
	    var pa1i = stack.pop();
	    var pb0i = stack.pop();
	    var pb1i = stack.pop();
	    var pi = stack.pop();
	    var z0 = state.z0;
	    var z1 = state.z1;
	    var pa0 = z0[pa0i];
	    var pa1 = z0[pa1i];
	    var pb0 = z1[pb0i];
	    var pb1 = z1[pb1i];
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

	    // math from
	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

	    var x1 = pa0.x;
	    var y1 = pa0.y;
	    var x2 = pa1.x;
	    var y2 = pa1.y;
	    var x3 = pb0.x;
	    var y3 = pb0.y;
	    var x4 = pb1.x;
	    var y4 = pb1.y;

	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	    var f1 = x1 * y2 - y1 * x2;
	    var f2 = x3 * y4 - y3 * x4;

	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
	}

	// SRP0[] Set Reference Point 0
	// 0x10
	function SRP0(state) {
	    state.rp0 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
	}

	// SRP1[] Set Reference Point 1
	// 0x11
	function SRP1(state) {
	    state.rp1 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
	}

	// SRP1[] Set Reference Point 2
	// 0x12
	function SRP2(state) {
	    state.rp2 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
	}

	// SZP0[] Set Zone Pointer 0
	// 0x13
	function SZP0(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

	    state.zp0 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP1[] Set Zone Pointer 1
	// 0x14
	function SZP1(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

	    state.zp1 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z1 = state.tZone;
	            break;
	        case 1 :
	            state.z1 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP2[] Set Zone Pointer 2
	// 0x15
	function SZP2(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

	    state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZPS[] Set Zone PointerS
	// 0x16
	function SZPS(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

	    state.zp0 = state.zp1 = state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.z1 = state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.z1 = state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SLOOP[] Set LOOP variable
	// 0x17
	function SLOOP(state) {
	    state.loop = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
	}

	// RTG[] Round To Grid
	// 0x18
	function RTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

	    state.round = roundToGrid;
	}

	// RTHG[] Round To Half Grid
	// 0x19
	function RTHG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

	    state.round = roundToHalfGrid;
	}

	// SMD[] Set Minimum Distance
	// 0x1A
	function SMD(state) {
	    var d = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

	    state.minDis = d / 0x40;
	}

	// ELSE[] ELSE clause
	// 0x1B
	function ELSE(state) {
	    // This instruction has been reached by executing a then branch
	    // so it just skips ahead until matching EIF.
	    //
	    // In case the IF was negative the IF[] instruction already
	    // skipped forward over the ELSE[]

	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

	    skip(state, false);
	}

	// JMPR[] JuMP Relative
	// 0x1C
	function JMPR(state) {
	    var o = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

	    // A jump by 1 would do nothing.
	    state.ip += o - 1;
	}

	// SCVTCI[] Set Control Value Table Cut-In
	// 0x1D
	function SCVTCI(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

	    state.cvCutIn = n / 0x40;
	}

	// DUP[] DUPlicate top stack element
	// 0x20
	function DUP(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

	    stack.push(stack[stack.length - 1]);
	}

	// POP[] POP top stack element
	// 0x21
	function POP(state) {
	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

	    state.stack.pop();
	}

	// CLEAR[] CLEAR the stack
	// 0x22
	function CLEAR(state) {
	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

	    state.stack.length = 0;
	}

	// SWAP[] SWAP the top two elements on the stack
	// 0x23
	function SWAP(state) {
	    var stack = state.stack;

	    var a = stack.pop();
	    var b = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

	    stack.push(a);
	    stack.push(b);
	}

	// DEPTH[] DEPTH of the stack
	// 0x24
	function DEPTH(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

	    stack.push(stack.length);
	}

	// LOOPCALL[] LOOPCALL function
	// 0x2A
	function LOOPCALL(state) {
	    var stack = state.stack;
	    var fn = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    for (var i = 0; i < c; i++) {
	        exec(state);

	        if (exports.DEBUG) { console.log(
	            ++state.step,
	            i + 1 < c ? 'next loopcall' : 'done loopcall',
	            i
	        ); }
	    }

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;
	}

	// CALL[] CALL function
	// 0x2B
	function CALL(state) {
	    var fn = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    exec(state);

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;

	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
	}

	// CINDEX[] Copy the INDEXed element to the top of the stack
	// 0x25
	function CINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

	    // In case of k == 1, it copies the last element after popping
	    // thus stack.length - k.
	    stack.push(stack[stack.length - k]);
	}

	// MINDEX[] Move the INDEXed element to the top of the stack
	// 0x26
	function MINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

	    stack.push(stack.splice(stack.length - k, 1)[0]);
	}

	// FDEF[] Function DEFinition
	// 0x2C
	function FDEF(state) {
	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    var fn = stack.pop();
	    var ipBegin = ip;

	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

	    while (prog[++ip] !== 0x2D){ }

	    state.ip = ip;
	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
	}

	// MDAP[a] Move Direct Absolute Point
	// 0x2E-0x2F
	function MDAP(round, state) {
	    var pi = state.stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

	    var d = pv.distance(p, HPZero);

	    if (round) { d = state.round(d); }

	    fv.setRelative(p, HPZero, d, pv);
	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// IUP[a] Interpolate Untouched Points through the outline
	// 0x30
	function IUP(v, state) {
	    var z2 = state.z2;
	    var pLen = z2.length - 2;
	    var cp;
	    var pp;
	    var np;

	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

	    for (var i = 0; i < pLen; i++) {
	        cp = z2[i]; // current point

	        // if this point has been touched go on
	        if (v.touched(cp)) { continue; }

	        pp = cp.prevTouched(v);

	        // no point on the contour has been touched?
	        if (pp === cp) { continue; }

	        np = cp.nextTouched(v);

	        if (pp === np) {
	            // only one point on the contour has been touched
	            // so simply moves the point like that

	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
	        }

	        v.interpolate(cp, pp, np, v);
	    }
	}

	// SHP[] SHift Point using reference point
	// 0x32-0x33
	function SHP(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var loop = state.loop;
	    var z2 = state.z2;

	    while (loop--)
	    {
	        var pi = stack.pop();
	        var p = z2[pi];

	        var d = pv.distance(rp, rp, false, true);
	        fv.setRelative(p, p, d, pv);
	        fv.touch(p);

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ?
	                   'loop ' + (state.loop - loop) + ': ' :
	                   ''
	                ) +
	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
	            );
	        }
	    }

	    state.loop = 1;
	}

	// SHC[] SHift Contour using reference point
	// 0x36-0x37
	function SHC(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var ci = stack.pop();
	    var sp = state.z2[state.contours[ci]];
	    var p = sp;

	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

	    var d = pv.distance(rp, rp, false, true);

	    do {
	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
	        p = p.nextPointOnContour;
	    } while (p !== sp);
	}

	// SHZ[] SHift Zone using reference point
	// 0x36-0x37
	function SHZ(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;

	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

	    var z;
	    switch (e) {
	        case 0 : z = state.tZone; break;
	        case 1 : z = state.gZone; break;
	        default : throw new Error('Invalid zone');
	    }

	    var p;
	    var d = pv.distance(rp, rp, false, true);
	    var pLen = z.length - 2;
	    for (var i = 0; i < pLen; i++)
	    {
	        p = z[i];
	        fv.setRelative(p, p, d, pv);
	        //if (p !== rp) fv.setRelative(p, p, d, pv);
	    }
	}

	// SHPIX[] SHift point by a PIXel amount
	// 0x38
	function SHPIX(state) {
	    var stack = state.stack;
	    var loop = state.loop;
	    var fv = state.fv;
	    var d = stack.pop() / 0x40;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'SHPIX[]', pi, d
	            );
	        }

	        fv.setRelative(p, p, d);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// IP[] Interpolate Point
	// 0x39
	function IP(state) {
	    var stack = state.stack;
	    var rp1i = state.rp1;
	    var rp2i = state.rp2;
	    var loop = state.loop;
	    var rp1 = state.z0[rp1i];
	    var rp2 = state.z1[rp2i];
	    var fv = state.fv;
	    var pv = state.dpv;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'IP[]', pi, rp1i, '<->', rp2i
	            );
	        }

	        fv.interpolate(p, rp1, rp2, pv);

	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// MSIRP[a] Move Stack Indirect Relative Point
	// 0x3A-0x3B
	function MSIRP(a, state) {
	    var stack = state.stack;
	    var d = stack.pop() / 64;
	    var pi = stack.pop();
	    var p = state.z1[pi];
	    var rp0 = state.z0[state.rp0];
	    var fv = state.fv;
	    var pv = state.pv;

	    fv.setRelative(p, rp0, d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (a) { state.rp0 = pi; }
	}

	// ALIGNRP[] Align to reference point.
	// 0x3C
	function ALIGNRP(state) {
	    var stack = state.stack;
	    var rp0i = state.rp0;
	    var rp0 = state.z0[rp0i];
	    var loop = state.loop;
	    var fv = state.fv;
	    var pv = state.pv;
	    var z1 = state.z1;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z1[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'ALIGNRP[]', pi
	            );
	        }

	        fv.setRelative(p, rp0, 0, pv);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// RTG[] Round To Double Grid
	// 0x3D
	function RTDG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

	    state.round = roundToDoubleGrid;
	}

	// MIAP[a] Move Indirect Absolute Point
	// 0x3E-0x3F
	function MIAP(round, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var pi = stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var cv = state.cvt[n];

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            'MIAP[' + round + ']',
	            n, '(', cv, ')', pi
	        );
	    }

	    var d = pv.distance(p, HPZero);

	    if (round) {
	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

	        d = state.round(d);
	    }

	    fv.setRelative(p, HPZero, d, pv);

	    if (state.zp0 === 0) {
	        p.xo = p.x;
	        p.yo = p.y;
	    }

	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// NPUSB[] PUSH N Bytes
	// 0x40
	function NPUSHB(state) {
	    var prog = state.prog;
	    var ip = state.ip;
	    var stack = state.stack;

	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// NPUSHW[] PUSH N Words
	// 0x41
	function NPUSHW(state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;
	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// WS[] Write Store
	// 0x42
	function WS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    if (!store) { store = state.store = []; }

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

	    store[l] = v;
	}

	// RS[] Read Store
	// 0x43
	function RS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

	    var v = (store && store[l]) || 0;

	    stack.push(v);
	}

	// WCVTP[] Write Control Value Table in Pixel units
	// 0x44
	function WCVTP(state) {
	    var stack = state.stack;

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

	    state.cvt[l] = v / 0x40;
	}

	// RCVT[] Read Control Value Table entry
	// 0x45
	function RCVT(state) {
	    var stack = state.stack;
	    var cvte = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

	    stack.push(state.cvt[cvte] * 0x40);
	}

	// GC[] Get Coordinate projected onto the projection vector
	// 0x46-0x47
	function GC(a, state) {
	    var stack = state.stack;
	    var pi = stack.pop();
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
	}

	// MD[a] Measure Distance
	// 0x49-0x4A
	function MD(a, state) {
	    var stack = state.stack;
	    var pi2 = stack.pop();
	    var pi1 = stack.pop();
	    var p2 = state.z1[pi2];
	    var p1 = state.z0[pi1];
	    var d = state.dpv.distance(p1, p2, a, a);

	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

	    state.stack.push(Math.round(d * 64));
	}

	// MPPEM[] Measure Pixels Per EM
	// 0x4B
	function MPPEM(state) {
	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
	    state.stack.push(state.ppem);
	}

	// FLIPON[] set the auto FLIP Boolean to ON
	// 0x4D
	function FLIPON(state) {
	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
	    state.autoFlip = true;
	}

	// LT[] Less Than
	// 0x50
	function LT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

	    stack.push(e1 < e2 ? 1 : 0);
	}

	// LTEQ[] Less Than or EQual
	// 0x53
	function LTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

	    stack.push(e1 <= e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than
	// 0x52
	function GT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

	    stack.push(e1 > e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than or EQual
	// 0x53
	function GTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

	    stack.push(e1 >= e2 ? 1 : 0);
	}

	// EQ[] EQual
	// 0x54
	function EQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

	    stack.push(e2 === e1 ? 1 : 0);
	}

	// NEQ[] Not EQual
	// 0x55
	function NEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

	    stack.push(e2 !== e1 ? 1 : 0);
	}

	// ODD[] ODD
	// 0x56
	function ODD(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
	}

	// EVEN[] EVEN
	// 0x57
	function EVEN(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
	}

	// IF[] IF test
	// 0x58
	function IF(state) {
	    var test = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

	    // if test is true it just continues
	    // if not the ip is skipped until matching ELSE or EIF
	    if (!test) {
	        skip(state, true);

	        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }
	    }
	}

	// EIF[] End IF
	// 0x59
	function EIF(state) {
	    // this can be reached normally when
	    // executing an else branch.
	    // -> just ignore it

	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
	}

	// AND[] logical AND
	// 0x5A
	function AND(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

	    stack.push(e2 && e1 ? 1 : 0);
	}

	// OR[] logical OR
	// 0x5B
	function OR(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

	    stack.push(e2 || e1 ? 1 : 0);
	}

	// NOT[] logical NOT
	// 0x5C
	function NOT(state) {
	    var stack = state.stack;
	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

	    stack.push(e ? 0 : 1);
	}

	// DELTAP1[] DELTA exception P1
	// DELTAP2[] DELTA exception P2
	// DELTAP3[] DELTA exception P3
	// 0x5D, 0x71, 0x72
	function DELTAP123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var fv = state.fv;
	    var pv = state.pv;
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;
	    var z0 = state.z0;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var pi = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }
	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

	        var p = z0[pi];
	        fv.setRelative(p, p, mag * ds, pv);
	    }
	}

	// SDB[] Set Delta Base in the graphics state
	// 0x5E
	function SDB(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

	    state.deltaBase = n;
	}

	// SDS[] Set Delta Shift in the graphics state
	// 0x5F
	function SDS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

	    state.deltaShift = Math.pow(0.5, n);
	}

	// ADD[] ADD
	// 0x60
	function ADD(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

	    stack.push(n1 + n2);
	}

	// SUB[] SUB
	// 0x61
	function SUB(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

	    stack.push(n1 - n2);
	}

	// DIV[] DIV
	// 0x62
	function DIV(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

	    stack.push(n1 * 64 / n2);
	}

	// MUL[] MUL
	// 0x63
	function MUL(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

	    stack.push(n1 * n2 / 64);
	}

	// ABS[] ABSolute value
	// 0x64
	function ABS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

	    stack.push(Math.abs(n));
	}

	// NEG[] NEGate
	// 0x65
	function NEG(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

	    stack.push(-n);
	}

	// FLOOR[] FLOOR
	// 0x66
	function FLOOR(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

	    stack.push(Math.floor(n / 0x40) * 0x40);
	}

	// CEILING[] CEILING
	// 0x67
	function CEILING(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

	    stack.push(Math.ceil(n / 0x40) * 0x40);
	}

	// ROUND[ab] ROUND value
	// 0x68-0x6B
	function ROUND(dt, state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

	    stack.push(state.round(n / 0x40) * 0x40);
	}

	// WCVTF[] Write Control Value Table in Funits
	// 0x70
	function WCVTF(state) {
	    var stack = state.stack;
	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
	}

	// DELTAC1[] DELTA exception C1
	// DELTAC2[] DELTA exception C2
	// DELTAC3[] DELTA exception C3
	// 0x73, 0x74, 0x75
	function DELTAC123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var c = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }

	        var delta = mag * ds;

	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

	        state.cvt[c] += delta;
	    }
	}

	// SROUND[] Super ROUND
	// 0x76
	function SROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = 0.5;
	            break;
	        case 0x40:
	            period = 1;
	            break;
	        case 0x80:
	            period = 2;
	            break;
	        default:
	            throw new Error('invalid SROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default: throw new Error('invalid SROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// S45ROUND[] Super ROUND 45 degrees
	// 0x77
	function S45ROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = Math.sqrt(2) / 2;
	            break;
	        case 0x40:
	            period = Math.sqrt(2);
	            break;
	        case 0x80:
	            period = 2 * Math.sqrt(2);
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// ROFF[] Round Off
	// 0x7A
	function ROFF(state) {
	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

	    state.round = roundOff;
	}

	// RUTG[] Round Up To Grid
	// 0x7C
	function RUTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

	    state.round = roundUpToGrid;
	}

	// RDTG[] Round Down To Grid
	// 0x7D
	function RDTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

	    state.round = roundDownToGrid;
	}

	// SCANCTRL[] SCAN conversion ConTRoL
	// 0x85
	function SCANCTRL(state) {
	    var n = state.stack.pop();

	    // ignored by opentype.js

	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
	}

	// SDPVTL[a] Set Dual Projection Vector To Line
	// 0x86-0x87
	function SDPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.dpv = getUnitVector(dx, dy);
	}

	// GETINFO[] GET INFOrmation
	// 0x88
	function GETINFO(state) {
	    var stack = state.stack;
	    var sel = stack.pop();
	    var r = 0;

	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

	    // v35 as in no subpixel hinting
	    if (sel & 0x01) { r = 35; }

	    // TODO rotation and stretch currently not supported
	    // and thus those GETINFO are always 0.

	    // opentype.js is always gray scaling
	    if (sel & 0x20) { r |= 0x1000; }

	    stack.push(r);
	}

	// ROLL[] ROLL the top three stack elements
	// 0x8A
	function ROLL(state) {
	    var stack = state.stack;
	    var a = stack.pop();
	    var b = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

	    stack.push(b);
	    stack.push(a);
	    stack.push(c);
	}

	// MAX[] MAXimum of top two stack elements
	// 0x8B
	function MAX(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

	    stack.push(Math.max(e1, e2));
	}

	// MIN[] MINimum of top two stack elements
	// 0x8C
	function MIN(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

	    stack.push(Math.min(e1, e2));
	}

	// SCANTYPE[] SCANTYPE
	// 0x8D
	function SCANTYPE(state) {
	    var n = state.stack.pop();
	    // ignored by opentype.js
	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
	}

	// INSTCTRL[] INSTCTRL
	// 0x8D
	function INSTCTRL(state) {
	    var s = state.stack.pop();
	    var v = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

	    switch (s) {
	        case 1 : state.inhibitGridFit = !!v; return;
	        case 2 : state.ignoreCvt = !!v; return;
	        default: throw new Error('invalid INSTCTRL[] selector');
	    }
	}

	// PUSHB[abc] PUSH Bytes
	// 0xB0-0xB7
	function PUSHB(n, state) {
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// PUSHW[abc] PUSH Words
	// 0xB8-0xBF
	function PUSHW(n, state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// MDRP[abcde] Move Direct Relative Point
	// 0xD0-0xEF
	// (if indirect is 0)
	//
	// and
	//
	// MIRP[abcde] Move Indirect Relative Point
	// 0xE0-0xFF
	// (if indirect is 1)

	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
	    var stack = state.stack;
	    var cvte = indirect && stack.pop();
	    var pi = stack.pop();
	    var rp0i = state.rp0;
	    var rp = state.z0[rp0i];
	    var p = state.z1[pi];

	    var md = state.minDis;
	    var fv = state.fv;
	    var pv = state.dpv;
	    var od; // original distance
	    var d; // moving distance
	    var sign; // sign of distance
	    var cv;

	    d = od = pv.distance(p, rp, true, true);
	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

	    // TODO consider autoFlip
	    d = Math.abs(d);

	    if (indirect) {
	        cv = state.cvt[cvte];

	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
	    }

	    if (keepD && d < md) { d = md; }

	    if (ro) { d = state.round(d); }

	    fv.setRelative(p, rp, sign * d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            (indirect ? 'MIRP[' : 'MDRP[') +
	            (setRp0 ? 'M' : 'm') +
	            (keepD ? '>' : '_') +
	            (ro ? 'R' : '_') +
	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
	            ']',
	            indirect ?
	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
	                '',
	            pi,
	            '(d =', od, '->', sign * d, ')'
	        );
	    }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (setRp0) { state.rp0 = pi; }
	}

	/*
	* The instruction table.
	*/
	instructionTable = [
	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
	    /* 0x06 */ SPVTL.bind(undefined, 0),
	    /* 0x07 */ SPVTL.bind(undefined, 1),
	    /* 0x08 */ SFVTL.bind(undefined, 0),
	    /* 0x09 */ SFVTL.bind(undefined, 1),
	    /* 0x0A */ SPVFS,
	    /* 0x0B */ SFVFS,
	    /* 0x0C */ GPV,
	    /* 0x0D */ GFV,
	    /* 0x0E */ SFVTPV,
	    /* 0x0F */ ISECT,
	    /* 0x10 */ SRP0,
	    /* 0x11 */ SRP1,
	    /* 0x12 */ SRP2,
	    /* 0x13 */ SZP0,
	    /* 0x14 */ SZP1,
	    /* 0x15 */ SZP2,
	    /* 0x16 */ SZPS,
	    /* 0x17 */ SLOOP,
	    /* 0x18 */ RTG,
	    /* 0x19 */ RTHG,
	    /* 0x1A */ SMD,
	    /* 0x1B */ ELSE,
	    /* 0x1C */ JMPR,
	    /* 0x1D */ SCVTCI,
	    /* 0x1E */ undefined,   // TODO SSWCI
	    /* 0x1F */ undefined,   // TODO SSW
	    /* 0x20 */ DUP,
	    /* 0x21 */ POP,
	    /* 0x22 */ CLEAR,
	    /* 0x23 */ SWAP,
	    /* 0x24 */ DEPTH,
	    /* 0x25 */ CINDEX,
	    /* 0x26 */ MINDEX,
	    /* 0x27 */ undefined,   // TODO ALIGNPTS
	    /* 0x28 */ undefined,
	    /* 0x29 */ undefined,   // TODO UTP
	    /* 0x2A */ LOOPCALL,
	    /* 0x2B */ CALL,
	    /* 0x2C */ FDEF,
	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
	    /* 0x2E */ MDAP.bind(undefined, 0),
	    /* 0x2F */ MDAP.bind(undefined, 1),
	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
	    /* 0x32 */ SHP.bind(undefined, 0),
	    /* 0x33 */ SHP.bind(undefined, 1),
	    /* 0x34 */ SHC.bind(undefined, 0),
	    /* 0x35 */ SHC.bind(undefined, 1),
	    /* 0x36 */ SHZ.bind(undefined, 0),
	    /* 0x37 */ SHZ.bind(undefined, 1),
	    /* 0x38 */ SHPIX,
	    /* 0x39 */ IP,
	    /* 0x3A */ MSIRP.bind(undefined, 0),
	    /* 0x3B */ MSIRP.bind(undefined, 1),
	    /* 0x3C */ ALIGNRP,
	    /* 0x3D */ RTDG,
	    /* 0x3E */ MIAP.bind(undefined, 0),
	    /* 0x3F */ MIAP.bind(undefined, 1),
	    /* 0x40 */ NPUSHB,
	    /* 0x41 */ NPUSHW,
	    /* 0x42 */ WS,
	    /* 0x43 */ RS,
	    /* 0x44 */ WCVTP,
	    /* 0x45 */ RCVT,
	    /* 0x46 */ GC.bind(undefined, 0),
	    /* 0x47 */ GC.bind(undefined, 1),
	    /* 0x48 */ undefined,   // TODO SCFS
	    /* 0x49 */ MD.bind(undefined, 0),
	    /* 0x4A */ MD.bind(undefined, 1),
	    /* 0x4B */ MPPEM,
	    /* 0x4C */ undefined,   // TODO MPS
	    /* 0x4D */ FLIPON,
	    /* 0x4E */ undefined,   // TODO FLIPOFF
	    /* 0x4F */ undefined,   // TODO DEBUG
	    /* 0x50 */ LT,
	    /* 0x51 */ LTEQ,
	    /* 0x52 */ GT,
	    /* 0x53 */ GTEQ,
	    /* 0x54 */ EQ,
	    /* 0x55 */ NEQ,
	    /* 0x56 */ ODD,
	    /* 0x57 */ EVEN,
	    /* 0x58 */ IF,
	    /* 0x59 */ EIF,
	    /* 0x5A */ AND,
	    /* 0x5B */ OR,
	    /* 0x5C */ NOT,
	    /* 0x5D */ DELTAP123.bind(undefined, 1),
	    /* 0x5E */ SDB,
	    /* 0x5F */ SDS,
	    /* 0x60 */ ADD,
	    /* 0x61 */ SUB,
	    /* 0x62 */ DIV,
	    /* 0x63 */ MUL,
	    /* 0x64 */ ABS,
	    /* 0x65 */ NEG,
	    /* 0x66 */ FLOOR,
	    /* 0x67 */ CEILING,
	    /* 0x68 */ ROUND.bind(undefined, 0),
	    /* 0x69 */ ROUND.bind(undefined, 1),
	    /* 0x6A */ ROUND.bind(undefined, 2),
	    /* 0x6B */ ROUND.bind(undefined, 3),
	    /* 0x6C */ undefined,   // TODO NROUND[ab]
	    /* 0x6D */ undefined,   // TODO NROUND[ab]
	    /* 0x6E */ undefined,   // TODO NROUND[ab]
	    /* 0x6F */ undefined,   // TODO NROUND[ab]
	    /* 0x70 */ WCVTF,
	    /* 0x71 */ DELTAP123.bind(undefined, 2),
	    /* 0x72 */ DELTAP123.bind(undefined, 3),
	    /* 0x73 */ DELTAC123.bind(undefined, 1),
	    /* 0x74 */ DELTAC123.bind(undefined, 2),
	    /* 0x75 */ DELTAC123.bind(undefined, 3),
	    /* 0x76 */ SROUND,
	    /* 0x77 */ S45ROUND,
	    /* 0x78 */ undefined,   // TODO JROT[]
	    /* 0x79 */ undefined,   // TODO JROF[]
	    /* 0x7A */ ROFF,
	    /* 0x7B */ undefined,
	    /* 0x7C */ RUTG,
	    /* 0x7D */ RDTG,
	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
	    /* 0x80 */ undefined,   // TODO FLIPPT
	    /* 0x81 */ undefined,   // TODO FLIPRGON
	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
	    /* 0x83 */ undefined,
	    /* 0x84 */ undefined,
	    /* 0x85 */ SCANCTRL,
	    /* 0x86 */ SDPVTL.bind(undefined, 0),
	    /* 0x87 */ SDPVTL.bind(undefined, 1),
	    /* 0x88 */ GETINFO,
	    /* 0x89 */ undefined,   // TODO IDEF
	    /* 0x8A */ ROLL,
	    /* 0x8B */ MAX,
	    /* 0x8C */ MIN,
	    /* 0x8D */ SCANTYPE,
	    /* 0x8E */ INSTCTRL,
	    /* 0x8F */ undefined,
	    /* 0x90 */ undefined,
	    /* 0x91 */ undefined,
	    /* 0x92 */ undefined,
	    /* 0x93 */ undefined,
	    /* 0x94 */ undefined,
	    /* 0x95 */ undefined,
	    /* 0x96 */ undefined,
	    /* 0x97 */ undefined,
	    /* 0x98 */ undefined,
	    /* 0x99 */ undefined,
	    /* 0x9A */ undefined,
	    /* 0x9B */ undefined,
	    /* 0x9C */ undefined,
	    /* 0x9D */ undefined,
	    /* 0x9E */ undefined,
	    /* 0x9F */ undefined,
	    /* 0xA0 */ undefined,
	    /* 0xA1 */ undefined,
	    /* 0xA2 */ undefined,
	    /* 0xA3 */ undefined,
	    /* 0xA4 */ undefined,
	    /* 0xA5 */ undefined,
	    /* 0xA6 */ undefined,
	    /* 0xA7 */ undefined,
	    /* 0xA8 */ undefined,
	    /* 0xA9 */ undefined,
	    /* 0xAA */ undefined,
	    /* 0xAB */ undefined,
	    /* 0xAC */ undefined,
	    /* 0xAD */ undefined,
	    /* 0xAE */ undefined,
	    /* 0xAF */ undefined,
	    /* 0xB0 */ PUSHB.bind(undefined, 1),
	    /* 0xB1 */ PUSHB.bind(undefined, 2),
	    /* 0xB2 */ PUSHB.bind(undefined, 3),
	    /* 0xB3 */ PUSHB.bind(undefined, 4),
	    /* 0xB4 */ PUSHB.bind(undefined, 5),
	    /* 0xB5 */ PUSHB.bind(undefined, 6),
	    /* 0xB6 */ PUSHB.bind(undefined, 7),
	    /* 0xB7 */ PUSHB.bind(undefined, 8),
	    /* 0xB8 */ PUSHW.bind(undefined, 1),
	    /* 0xB9 */ PUSHW.bind(undefined, 2),
	    /* 0xBA */ PUSHW.bind(undefined, 3),
	    /* 0xBB */ PUSHW.bind(undefined, 4),
	    /* 0xBC */ PUSHW.bind(undefined, 5),
	    /* 0xBD */ PUSHW.bind(undefined, 6),
	    /* 0xBE */ PUSHW.bind(undefined, 7),
	    /* 0xBF */ PUSHW.bind(undefined, 8),
	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
	];

	/*****************************
	  Mathematical Considerations
	******************************

	fv ... refers to freedom vector
	pv ... refers to projection vector
	rp ... refers to reference point
	p  ... refers to to point being operated on
	d  ... refers to distance

	SETRELATIVE:
	============

	case freedom vector == x-axis:
	------------------------------

	                        (pv)
	                     .-'
	              rpd .-'
	               .-*
	          d .-'90°'
	         .-'       '
	      .-'           '
	   *-'               ' b
	  rp                  '
	                       '
	                        '
	            p *----------*-------------- (fv)
	                          pm

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b

	   y - rpdy = pvns * (x- rpdx)

	   y = p.y

	   x = rpdx + ( p.y - rpdy ) / pvns


	case freedom vector == y-axis:
	------------------------------

	    * pm
	    |\
	    | \
	    |  \
	    |   \
	    |    \
	    |     \
	    |      \
	    |       \
	    |        \
	    |         \ b
	    |          \
	    |           \
	    |            \    .-' (pv)
	    |         90° \.-'
	    |           .-'* rpd
	    |        .-'
	    *     *-'  d
	    p     rp

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b:
	           pvns ... normal slope to pv

	   y - rpdy = pvns * (x - rpdx)

	   x = p.x

	   y = rpdy +  pvns * (p.x - rpdx)



	generic case:
	-------------


	                              .'(fv)
	                            .'
	                          .* pm
	                        .' !
	                      .'    .
	                    .'      !
	                  .'         . b
	                .'           !
	               *              .
	              p               !
	                         90°   .    ... (pv)
	                           ...-*-'''
	                  ...---'''    rpd
	         ...---'''   d
	   *--'''
	  rp

	    rpdx = rpx + d * pv.x
	    rpdy = rpy + d * pv.y

	 equation of line b:
	    pvns... normal slope to pv

	    y - rpdy = pvns * (x - rpdx)

	 equation of freedom vector line:
	    fvs ... slope of freedom vector (=fy/fx)

	    y - py = fvs * (x - px)


	  on pm both equations are true for same x/y

	    y - rpdy = pvns * (x - rpdx)

	    y - py = fvs * (x - px)

	  form to y and set equal:

	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

	  expand:

	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

	  switch:

	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

	  solve for x:

	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



	          fvs * px - pvns * rpdx + rpdy - py
	    x =  -----------------------------------
	                 fvs - pvns

	  and:

	    y = fvs * (x - px) + py



	INTERPOLATE:
	============

	Examples of point interpolation.

	The weight of the movement of the reference point gets bigger
	the further the other reference point is away, thus the safest
	option (that is avoiding 0/0 divisions) is to weight the
	original distance of the other point by the sum of both distances.

	If the sum of both distances is 0, then move the point by the
	arithmetic average of the movement of both reference points.




	           (+6)
	    rp1o *---->*rp1
	         .     .                          (+12)
	         .     .                  rp2o *---------->* rp2
	         .     .                       .           .
	         .     .                       .           .
	         .    10          20           .           .
	         |.........|...................|           .
	               .   .                               .
	               .   . (+8)                          .
	                po *------>*p                      .
	               .           .                       .
	               .    12     .          24           .
	               |...........|.......................|
	                                  36


	-------



	           (+10)
	    rp1o *-------->*rp1
	         .         .                      (-10)
	         .         .              rp2 *<---------* rpo2
	         .         .                   .         .
	         .         .                   .         .
	         .    10   .          30       .         .
	         |.........|.............................|
	                   .                   .
	                   . (+5)              .
	                po *--->* p            .
	                   .    .              .
	                   .    .   20         .
	                   |....|..............|
	                     5        15


	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .
	    rp2o *-------->*rp2


	                               (+10)
	                          po *-------->* p

	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .(+30)
	    rp2o *---------------------------->*rp2


	                                        (+25)
	                          po *----------------------->* p



	vim: set ts=4 sw=4 expandtab:
	*****/

	/**
	 * Converts a string into a list of tokens.
	 */

	/**
	 * Create a new token
	 * @param {string} char a single char
	 */
	function Token(char) {
	    this.char = char;
	    this.state = {};
	    this.activeState = null;
	}

	/**
	 * Create a new context range
	 * @param {number} startIndex range start index
	 * @param {number} endOffset range end index offset
	 * @param {string} contextName owner context name
	 */
	function ContextRange(startIndex, endOffset, contextName) {
	    this.contextName = contextName;
	    this.startIndex = startIndex;
	    this.endOffset = endOffset;
	}

	/**
	 * Check context start and end
	 * @param {string} contextName a unique context name
	 * @param {function} checkStart a predicate function the indicates a context's start
	 * @param {function} checkEnd a predicate function the indicates a context's end
	 */
	function ContextChecker(contextName, checkStart, checkEnd) {
	    this.contextName = contextName;
	    this.openRange = null;
	    this.ranges = [];
	    this.checkStart = checkStart;
	    this.checkEnd = checkEnd;
	}

	/**
	 * @typedef ContextParams
	 * @type Object
	 * @property {array} context context items
	 * @property {number} currentIndex current item index
	 */

	/**
	 * Create a context params
	 * @param {array} context a list of items
	 * @param {number} currentIndex current item index
	 */
	function ContextParams(context, currentIndex) {
	    this.context = context;
	    this.index = currentIndex;
	    this.length = context.length;
	    this.current = context[currentIndex];
	    this.backtrack = context.slice(0, currentIndex);
	    this.lookahead = context.slice(currentIndex + 1);
	}

	/**
	 * Create an event instance
	 * @param {string} eventId event unique id
	 */
	function Event(eventId) {
	    this.eventId = eventId;
	    this.subscribers = [];
	}

	/**
	 * Initialize a core events and auto subscribe required event handlers
	 * @param {any} events an object that enlists core events handlers
	 */
	function initializeCoreEvents(events) {
	    var this$1 = this;

	    var coreEvents = [
	        'start', 'end', 'next', 'newToken', 'contextStart',
	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
	    ];

	    coreEvents.forEach(function (eventId) {
	        Object.defineProperty(this$1.events, eventId, {
	            value: new Event(eventId)
	        });
	    });

	    if (!!events) {
	        coreEvents.forEach(function (eventId) {
	            var event = events[eventId];
	            if (typeof event === 'function') {
	                this$1.events[eventId].subscribe(event);
	            }
	        });
	    }
	    var requiresContextUpdate = [
	        'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD'
	    ];
	    requiresContextUpdate.forEach(function (eventId) {
	        this$1.events[eventId].subscribe(
	            this$1.updateContextsRanges
	        );
	    });
	}

	/**
	 * Converts a string into a list of tokens
	 * @param {any} events tokenizer core events
	 */
	function Tokenizer(events) {
	    this.tokens = [];
	    this.registeredContexts = {};
	    this.contextCheckers = [];
	    this.events = {};
	    this.registeredModifiers = [];

	    initializeCoreEvents.call(this, events);
	}

	/**
	 * Sets the state of a token, usually called by a state modifier.
	 * @param {string} key state item key
	 * @param {any} value state item value
	 */
	Token.prototype.setState = function(key, value) {
	    this.state[key] = value;
	    this.activeState = { key: key, value: this.state[key] };
	    return this.activeState;
	};

	Token.prototype.getState = function (stateId) {
	    return this.state[stateId] || null;
	};

	/**
	 * Checks if an index exists in the tokens list.
	 * @param {number} index token index
	 */
	Tokenizer.prototype.inboundIndex = function(index) {
	    return index >= 0 && index < this.tokens.length;
	};

	/**
	 * Compose and apply a list of operations (replace, update, delete)
	 * @param {array} RUDs replace, update and delete operations
	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
	 */
	Tokenizer.prototype.composeRUD = function (RUDs) {
	    var this$1 = this;

	    var silent = true;
	    var state = RUDs.map(function (RUD) { return (
	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
	    ); });
	    var hasFAILObject = function (obj) { return (
	        typeof obj === 'object' &&
	        obj.hasOwnProperty('FAIL')
	    ); };
	    if (state.every(hasFAILObject)) {
	        return {
	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
	            report: state.filter(hasFAILObject)
	        };
	    }
	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
	};

	/**
	 * Replace a range of tokens with a list of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {token} tokens a list of tokens to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
	    offset = offset !== null ? offset : this.tokens.length;
	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
	        var replaced = this.tokens.splice.apply(
	            this.tokens, [startIndex, offset].concat(tokens)
	        );
	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
	        return [replaced, tokens];
	    } else {
	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
	    }
	};

	/**
	 * Replace a token with another token
	 * @param {number} index token index
	 * @param {token} token a token to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceToken = function (index, token, silent) {
	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
	        var replaced = this.tokens.splice(index, 1, token);
	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
	        return [replaced[0], token];
	    } else {
	        return { FAIL: 'replaceToken: invalid token or index.' };
	    }
	};

	/**
	 * Removes a range of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
	    offset = !isNaN(offset) ? offset : this.tokens.length;
	    var tokens = this.tokens.splice(startIndex, offset);
	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
	    return tokens;
	};

	/**
	 * Remove a token at a certain index
	 * @param {number} index token index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeToken = function(index, silent) {
	    if (!isNaN(index) && this.inboundIndex(index)) {
	        var token = this.tokens.splice(index, 1);
	        if (!silent) { this.dispatch('removeToken', [token, index]); }
	        return token;
	    } else {
	        return { FAIL: 'removeToken: invalid token index.' };
	    }
	};

	/**
	 * Insert a list of tokens at a certain index
	 * @param {array} tokens a list of tokens to insert
	 * @param {number} index insert the list of tokens at index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
	    var tokenType = tokens.every(
	        function (token) { return token instanceof Token; }
	    );
	    if (tokenType) {
	        this.tokens.splice.apply(
	            this.tokens, [index, 0].concat(tokens)
	        );
	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
	        return tokens;
	    } else {
	        return { FAIL: 'insertToken: invalid token(s).' };
	    }
	};

	/**
	 * A state modifier that is called on 'newToken' event
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a function to update token state
	 */
	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
	    this.events.newToken.subscribe(function(token, contextParams) {
	        var conditionParams = [token, contextParams];
	        var canApplyModifier = (
	            condition === null ||
	            condition.apply(this, conditionParams) === true
	        );
	        var modifierParams = [token, contextParams];
	        if (canApplyModifier) {
	            var newStateValue = modifier.apply(this, modifierParams);
	            token.setState(modifierId, newStateValue);
	        }
	    });
	    this.registeredModifiers.push(modifierId);
	};

	/**
	 * Subscribe a handler to an event
	 * @param {function} eventHandler an event handler function
	 */
	Event.prototype.subscribe = function (eventHandler) {
	    if (typeof eventHandler === 'function') {
	        return ((this.subscribers.push(eventHandler)) - 1);
	    } else {
	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
	    }
	};

	/**
	 * Unsubscribe an event handler
	 * @param {string} subsId subscription id
	 */
	Event.prototype.unsubscribe = function (subsId) {
	    this.subscribers.splice(subsId, 1);
	};

	/**
	 * Sets context params current value index
	 * @param {number} index context params current value index
	 */
	ContextParams.prototype.setCurrentIndex = function(index) {
	    this.index = index;
	    this.current = this.context[index];
	    this.backtrack = this.context.slice(0, index);
	    this.lookahead = this.context.slice(index + 1);
	};

	/**
	 * Get an item at an offset from the current value
	 * example (current value is 3):
	 *  1    2   [3]   4    5   |   items values
	 * -2   -1    0    1    2   |   offset values
	 * @param {number} offset an offset from current value index
	 */
	ContextParams.prototype.get = function (offset) {
	    switch (true) {
	        case (offset === 0):
	            return this.current;
	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
	            return this.backtrack.slice(offset)[0];
	        case (offset > 0 && offset <= this.lookahead.length):
	            return this.lookahead[offset - 1];
	        default:
	            return null;
	    }
	};

	/**
	 * Converts a context range into a string value
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.rangeToText = function (range) {
	    if (range instanceof ContextRange) {
	        return (
	            this.getRangeTokens(range)
	                .map(function (token) { return token.char; }).join('')
	        );
	    }
	};

	/**
	 * Converts all tokens into a string
	 */
	Tokenizer.prototype.getText = function () {
	    return this.tokens.map(function (token) { return token.char; }).join('');
	};

	/**
	 * Get a context by name
	 * @param {string} contextName context name to get
	 */
	Tokenizer.prototype.getContext = function (contextName) {
	    var context = this.registeredContexts[contextName];
	    return !!context ? context : null;
	};

	/**
	 * Subscribes a new event handler to an event
	 * @param {string} eventName event name to subscribe to
	 * @param {function} eventHandler a function to be invoked on event
	 */
	Tokenizer.prototype.on = function(eventName, eventHandler) {
	    var event = this.events[eventName];
	    if (!!event) {
	        return event.subscribe(eventHandler);
	    } else {
	        return null;
	    }
	};

	/**
	 * Dispatches an event
	 * @param {string} eventName event name
	 * @param {any} args event handler arguments
	 */
	Tokenizer.prototype.dispatch = function(eventName, args) {
	    var this$1 = this;

	    var event = this.events[eventName];
	    if (event instanceof Event) {
	        event.subscribers.forEach(function (subscriber) {
	            subscriber.apply(this$1, args || []);
	        });
	    }
	};

	/**
	 * Register a new context checker
	 * @param {string} contextName a unique context name
	 * @param {function} contextStartCheck a predicate function that returns true on context start
	 * @param {function} contextEndCheck  a predicate function that returns true on context end
	 * TODO: call tokenize on registration to update context ranges with the new context.
	 */
	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
	    if (!!this.getContext(contextName)) { return {
	        FAIL:
	        ("context name '" + contextName + "' is already registered.")
	    }; }
	    if (typeof contextStartCheck !== 'function') { return {
	        FAIL:
	        "missing context start check."
	    }; }
	    if (typeof contextEndCheck !== 'function') { return {
	        FAIL:
	        "missing context end check."
	    }; }
	    var contextCheckers = new ContextChecker(
	        contextName, contextStartCheck, contextEndCheck
	    );
	    this.registeredContexts[contextName] = contextCheckers;
	    this.contextCheckers.push(contextCheckers);
	    return contextCheckers;
	};

	/**
	 * Gets a context range tokens
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.getRangeTokens = function(range) {
	    var endIndex = range.startIndex + range.endOffset;
	    return [].concat(
	        this.tokens
	            .slice(range.startIndex, endIndex)
	    );
	};

	/**
	 * Gets the ranges of a context
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.getContextRanges = function(contextName) {
	    var context = this.getContext(contextName);
	    if (!!context) {
	        return context.ranges;
	    } else {
	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
	    }
	};

	/**
	 * Resets context ranges to run context update
	 */
	Tokenizer.prototype.resetContextsRanges = function () {
	    var registeredContexts = this.registeredContexts;
	    for (var contextName in registeredContexts) {
	        if (registeredContexts.hasOwnProperty(contextName)) {
	            var context = registeredContexts[contextName];
	            context.ranges = [];
	        }
	    }
	};

	/**
	 * Updates context ranges
	 */
	Tokenizer.prototype.updateContextsRanges = function () {
	    this.resetContextsRanges();
	    var chars = this.tokens.map(function (token) { return token.char; });
	    for (var i = 0; i < chars.length; i++) {
	        var contextParams = new ContextParams(chars, i);
	        this.runContextCheck(contextParams);
	    }
	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
	};

	/**
	 * Sets the end offset of an open range
	 * @param {number} offset range end offset
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
	    var startIndex = this.getContext(contextName).openRange.startIndex;
	    var range = new ContextRange(startIndex, offset, contextName);
	    var ranges = this.getContext(contextName).ranges;
	    range.rangeId = contextName + "." + (ranges.length);
	    ranges.push(range);
	    this.getContext(contextName).openRange = null;
	    return range;
	};

	/**
	 * Runs a context check on the current context
	 * @param {contextParams} contextParams current context params
	 */
	Tokenizer.prototype.runContextCheck = function(contextParams) {
	    var this$1 = this;

	    var index = contextParams.index;
	    this.contextCheckers.forEach(function (contextChecker) {
	        var contextName = contextChecker.contextName;
	        var openRange = this$1.getContext(contextName).openRange;
	        if (!openRange && contextChecker.checkStart(contextParams)) {
	            openRange = new ContextRange(index, null, contextName);
	            this$1.getContext(contextName).openRange = openRange;
	            this$1.dispatch('contextStart', [contextName, index]);
	        }
	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
	            var offset = (index - openRange.startIndex) + 1;
	            var range = this$1.setEndOffset(offset, contextName);
	            this$1.dispatch('contextEnd', [contextName, range]);
	        }
	    });
	};

	/**
	 * Converts a text into a list of tokens
	 * @param {string} text a text to tokenize
	 */
	Tokenizer.prototype.tokenize = function (text) {
	    this.tokens = [];
	    this.resetContextsRanges();
	    var chars = Array.from(text);
	    this.dispatch('start');
	    for (var i = 0; i < chars.length; i++) {
	        var char = chars[i];
	        var contextParams = new ContextParams(chars, i);
	        this.dispatch('next', [contextParams]);
	        this.runContextCheck(contextParams);
	        var token = new Token(char);
	        this.tokens.push(token);
	        this.dispatch('newToken', [token, contextParams]);
	    }
	    this.dispatch('end', [this.tokens]);
	    return this.tokens;
	};

	// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮
	// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊
	// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯
	// jscs:disable maximumLineLength
	/**
	 * Check if a char is Arabic
	 * @param {string} c a single char
	 */
	function isArabicChar(c) {
	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
	}

	/**
	 * Check if a char is an isolated arabic char
	 * @param {string} c a single char
	 */
	function isIsolatedArabicChar(char) {
	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
	}

	/**
	 * Check if a char is an Arabic Tashkeel char
	 * @param {string} c a single char
	 */
	function isTashkeelArabicChar(char) {
	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
	}

	/**
	 * Check if a char is Latin
	 * @param {string} c a single char
	 */
	function isLatinChar(c) {
	    return /[A-z]/.test(c);
	}

	/**
	 * Check if a char is whitespace char
	 * @param {string} c a single char
	 */
	function isWhiteSpace(c) {
	    return /\s/.test(c);
	}

	/**
	 * Query a feature by some of it's properties to lookup a glyph substitution.
	 */

	/**
	 * Create feature query instance
	 * @param {Font} font opentype font instance
	 */
	function FeatureQuery(font) {
	    this.font = font;
	    this.features = {};
	}

	/**
	 * @typedef SubstitutionAction
	 * @type Object
	 * @property {number} id substitution type
	 * @property {string} tag feature tag
	 * @property {any} substitution substitution value(s)
	 */

	/**
	 * Create a substitution action instance
	 * @param {SubstitutionAction} action
	 */
	function SubstitutionAction(action) {
	    this.id = action.id;
	    this.tag = action.tag;
	    this.substitution = action.substitution;
	}

	/**
	 * Lookup a coverage table
	 * @param {number} glyphIndex glyph index
	 * @param {CoverageTable} coverage coverage table
	 */
	function lookupCoverage(glyphIndex, coverage) {
	    if (!glyphIndex) { return -1; }
	    switch (coverage.format) {
	        case 1:
	            return coverage.glyphs.indexOf(glyphIndex);

	        case 2:
	            var ranges = coverage.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
	                    var offset = glyphIndex - range.start;
	                    return range.index + offset;
	                }
	            }
	            break;
	        default:
	            return -1; // not found
	    }
	    return -1;
	}

	/**
	 * Handle a single substitution - format 1
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function singleSubstitutionFormat1(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return glyphIndex + subtable.deltaGlyphId;
	}

	/**
	 * Handle a single substitution - format 2
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function singleSubstitutionFormat2(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return subtable.substitute[substituteIndex];
	}

	/**
	 * Lookup a list of coverage tables
	 * @param {any} coverageList a list of coverage tables
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function lookupCoverageList(coverageList, contextParams) {
	    var lookupList = [];
	    for (var i = 0; i < coverageList.length; i++) {
	        var coverage = coverageList[i];
	        var glyphIndex = contextParams.current;
	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
	        var lookupIndex = lookupCoverage(glyphIndex, coverage);
	        if (lookupIndex !== -1) {
	            lookupList.push(lookupIndex);
	        }
	    }
	    if (lookupList.length !== coverageList.length) { return -1; }
	    return lookupList;
	}

	/**
	 * Handle chaining context substitution - format 3
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function chainingSubstitutionFormat3(contextParams, subtable) {
	    var lookupsCount = (
	        subtable.inputCoverage.length +
	        subtable.lookaheadCoverage.length +
	        subtable.backtrackCoverage.length
	    );
	    if (contextParams.context.length < lookupsCount) { return []; }
	    // INPUT LOOKUP //
	    var inputLookups = lookupCoverageList(
	        subtable.inputCoverage, contextParams
	    );
	    if (inputLookups === -1) { return []; }
	    // LOOKAHEAD LOOKUP //
	    var lookaheadOffset = subtable.inputCoverage.length - 1;
	    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }
	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
	        lookaheadContext.shift();
	    }
	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
	    var lookaheadLookups = lookupCoverageList(
	        subtable.lookaheadCoverage, lookaheadParams
	    );
	    // BACKTRACK LOOKUP //
	    var backtrackContext = [].concat(contextParams.backtrack);
	    backtrackContext.reverse();
	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
	        backtrackContext.shift();
	    }
	    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }
	    var backtrackParams = new ContextParams(backtrackContext, 0);
	    var backtrackLookups = lookupCoverageList(
	        subtable.backtrackCoverage, backtrackParams
	    );
	    var contextRulesMatch = (
	        inputLookups.length === subtable.inputCoverage.length &&
	        lookaheadLookups.length === subtable.lookaheadCoverage.length &&
	        backtrackLookups.length === subtable.backtrackCoverage.length
	    );
	    var substitutions = [];
	    if (contextRulesMatch) {
	        for (var i = 0; i < subtable.lookupRecords.length; i++) {
	            var lookupRecord = subtable.lookupRecords[i];
	            var lookupListIndex = lookupRecord.lookupListIndex;
	            var lookupTable = this.getLookupByIndex(lookupListIndex);
	            for (var s = 0; s < lookupTable.subtables.length; s++) {
	                var subtable$1 = lookupTable.subtables[s];
	                var lookup = this.getLookupMethod(lookupTable, subtable$1);
	                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
	                if (substitutionType === '12') {
	                    for (var n = 0; n < inputLookups.length; n++) {
	                        var glyphIndex = contextParams.get(n);
	                        var substitution = lookup(glyphIndex);
	                        if (substitution) { substitutions.push(substitution); }
	                    }
	                }
	            }
	        }
	    }
	    return substitutions;
	}

	/**
	 * Handle ligature substitution - format 1
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function ligatureSubstitutionFormat1(contextParams, subtable) {
	    // COVERAGE LOOKUP //
	    var glyphIndex = contextParams.current;
	    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (ligSetIndex === -1) { return null; }
	    // COMPONENTS LOOKUP
	    // (!) note, components are ordered in the written direction.
	    var ligature;
	    var ligatureSet = subtable.ligatureSets[ligSetIndex];
	    for (var s = 0; s < ligatureSet.length; s++) {
	        ligature = ligatureSet[s];
	        for (var l = 0; l < ligature.components.length; l++) {
	            var lookaheadItem = contextParams.lookahead[l];
	            var component = ligature.components[l];
	            if (lookaheadItem !== component) { break; }
	            if (l === ligature.components.length - 1) { return ligature; }
	        }
	    }
	    return null;
	}

	/**
	 * Handle decomposition substitution - format 1
	 * @param {number} glyphIndex glyph index
	 * @param {any} subtable subtable
	 */
	function decompositionSubstitutionFormat1(glyphIndex, subtable) {
	    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
	    if (substituteIndex === -1) { return null; }
	    return subtable.sequences[substituteIndex];
	}

	/**
	 * Get default script features indexes
	 */
	FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {
	    var scripts = this.font.tables.gsub.scripts;
	    for (var s = 0; s < scripts.length; s++) {
	        var script = scripts[s];
	        if (script.tag === 'DFLT') { return (
	            script.script.defaultLangSys.featureIndexes
	        ); }
	    }
	    return [];
	};

	/**
	 * Get feature indexes of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
	    var tables = this.font.tables;
	    if (!tables.gsub) { return []; }
	    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }
	    var scripts = this.font.tables.gsub.scripts;
	    for (var i = 0; i < scripts.length; i++) {
	        var script = scripts[i];
	        if (script.tag === scriptTag && script.script.defaultLangSys) {
	            return script.script.defaultLangSys.featureIndexes;
	        } else {
	            var langSysRecords = script.langSysRecords;
	            if (!!langSysRecords) {
	                for (var j = 0; j < langSysRecords.length; j++) {
	                    var langSysRecord = langSysRecords[j];
	                    if (langSysRecord.tag === scriptTag) {
	                        var langSys = langSysRecord.langSys;
	                        return langSys.featureIndexes;
	                    }
	                }
	            }
	        }
	    }
	    return this.getDefaultScriptFeaturesIndexes();
	};

	/**
	 * Map a feature tag to a gsub feature
	 * @param {any} features gsub features
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
	    var tags = {};
	    for (var i = 0; i < features.length; i++) {
	        var tag = features[i].tag;
	        var feature = features[i].feature;
	        tags[tag] = feature;
	    }
	    this.features[scriptTag].tags = tags;
	};

	/**
	 * Get features of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
	    var features = this.features[scriptTag];
	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
	    if (!featuresIndexes) { return null; }
	    var gsub = this.font.tables.gsub;
	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
	    this.features[scriptTag] = features;
	    this.mapTagsToFeatures(features, scriptTag);
	    return features;
	};

	/**
	 * Get substitution type
	 * @param {any} lookupTable lookup table
	 * @param {any} subtable subtable
	 */
	FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
	    var lookupType = lookupTable.lookupType.toString();
	    var substFormat = subtable.substFormat.toString();
	    return lookupType + substFormat;
	};

	/**
	 * Get lookup method
	 * @param {any} lookupTable lookup table
	 * @param {any} subtable subtable
	 */
	FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
	    var this$1 = this;

	    var substitutionType = this.getSubstitutionType(lookupTable, subtable);
	    switch (substitutionType) {
	        case '11':
	            return function (glyphIndex) { return singleSubstitutionFormat1.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        case '12':
	            return function (glyphIndex) { return singleSubstitutionFormat2.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        case '63':
	            return function (contextParams) { return chainingSubstitutionFormat3.apply(
	                this$1, [contextParams, subtable]
	            ); };
	        case '41':
	            return function (contextParams) { return ligatureSubstitutionFormat1.apply(
	                this$1, [contextParams, subtable]
	            ); };
	        case '21':
	            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(
	                this$1, [glyphIndex, subtable]
	            ); };
	        default:
	            throw new Error(
	                "lookupType: " + (lookupTable.lookupType) + " - " +
	                "substFormat: " + (subtable.substFormat) + " " +
	                "is not yet supported"
	            );
	    }
	};

	/**
	 * [ LOOKUP TYPES ]
	 * -------------------------------
	 * Single                        1;
	 * Multiple                      2;
	 * Alternate                     3;
	 * Ligature                      4;
	 * Context                       5;
	 * ChainingContext               6;
	 * ExtensionSubstitution         7;
	 * ReverseChainingContext        8;
	 * -------------------------------
	 *
	 */

	/**
	 * @typedef FQuery
	 * @type Object
	 * @param {string} tag feature tag
	 * @param {string} script feature script
	 * @param {ContextParams} contextParams context params
	 */

	/**
	 * Lookup a feature using a query parameters
	 * @param {FQuery} query feature query
	 */
	FeatureQuery.prototype.lookupFeature = function (query) {
	    var contextParams = query.contextParams;
	    var currentIndex = contextParams.index;
	    var feature = this.getFeature({
	        tag: query.tag, script: query.script
	    });
	    if (!feature) { return new Error(
	        "font '" + (this.font.names.fullName.en) + "' " +
	        "doesn't support feature '" + (query.tag) + "' " +
	        "for script '" + (query.script) + "'."
	    ); }
	    var lookups = this.getFeatureLookups(feature);
	    var substitutions = [].concat(contextParams.context);
	    for (var l = 0; l < lookups.length; l++) {
	        var lookupTable = lookups[l];
	        var subtables = this.getLookupSubtables(lookupTable);
	        for (var s = 0; s < subtables.length; s++) {
	            var subtable = subtables[s];
	            var substType = this.getSubstitutionType(lookupTable, subtable);
	            var lookup = this.getLookupMethod(lookupTable, subtable);
	            var substitution = (void 0);
	            switch (substType) {
	                case '11':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 11, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '12':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 12, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '63':
	                    substitution = lookup(contextParams);
	                    if (Array.isArray(substitution) && substitution.length) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 63, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '41':
	                    substitution = lookup(contextParams);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 41, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	                case '21':
	                    substitution = lookup(contextParams.current);
	                    if (substitution) {
	                        substitutions.splice(currentIndex, 1, new SubstitutionAction({
	                            id: 21, tag: query.tag, substitution: substitution
	                        }));
	                    }
	                    break;
	            }
	            contextParams = new ContextParams(substitutions, currentIndex);
	            if (Array.isArray(substitution) && !substitution.length) { continue; }
	            substitution = null;
	        }
	    }
	    return substitutions.length ? substitutions : null;
	};

	/**
	 * Checks if a font supports a specific features
	 * @param {FQuery} query feature query object
	 */
	FeatureQuery.prototype.supports = function (query) {
	    if (!query.script) { return false; }
	    this.getScriptFeatures(query.script);
	    var supportedScript = this.features.hasOwnProperty(query.script);
	    if (!query.tag) { return supportedScript; }
	    var supportedFeature = (
	        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })
	    );
	    return supportedScript && supportedFeature;
	};

	/**
	 * Get lookup table subtables
	 * @param {any} lookupTable lookup table
	 */
	FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {
	    return lookupTable.subtables || null;
	};

	/**
	 * Get lookup table by index
	 * @param {number} index lookup table index
	 */
	FeatureQuery.prototype.getLookupByIndex = function (index) {
	    var lookups = this.font.tables.gsub.lookups;
	    return lookups[index] || null;
	};

	/**
	 * Get lookup tables for a feature
	 * @param {string} feature
	 */
	FeatureQuery.prototype.getFeatureLookups = function (feature) {
	    // TODO: memoize
	    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
	};

	/**
	 * Query a feature by it's properties
	 * @param {any} query an object that describes the properties of a query
	 */
	FeatureQuery.prototype.getFeature = function getFeature(query) {
	    if (!this.font) { return { FAIL: "No font was found"}; }
	    if (!this.features.hasOwnProperty(query.script)) {
	        this.getScriptFeatures(query.script);
	    }
	    var scriptFeatures = this.features[query.script];
	    if (!scriptFeatures) { return (
	        { FAIL: ("No feature for script " + (query.script))}
	    ); }
	    if (!scriptFeatures.tags[query.tag]) { return null; }
	    return this.features[query.script].tags[query.tag];
	};

	/**
	 * Arabic word context checkers
	 */

	function arabicWordStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? arabic first char
	        (prevChar === null && isArabicChar(char)) ||
	        // ? arabic char preceded with a non arabic char
	        (!isArabicChar(prevChar) && isArabicChar(char))
	    );
	}

	function arabicWordEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    return (
	        // ? last arabic char
	        (nextChar === null) ||
	        // ? next char is not arabic
	        (!isArabicChar(nextChar))
	    );
	}

	var arabicWordCheck = {
	    startCheck: arabicWordStartCheck,
	    endCheck: arabicWordEndCheck
	};

	/**
	 * Arabic sentence context checkers
	 */

	function arabicSentenceStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? an arabic char preceded with a non arabic char
	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
	        !isArabicChar(prevChar)
	    );
	}

	function arabicSentenceEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    switch (true) {
	        case nextChar === null:
	            return true;
	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
	            var nextIsWhitespace = isWhiteSpace(nextChar);
	            if (!nextIsWhitespace) { return true; }
	            if (nextIsWhitespace) {
	                var arabicCharAhead = false;
	                arabicCharAhead = (
	                    contextParams.lookahead.some(
	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
	                    )
	                );
	                if (!arabicCharAhead) { return true; }
	            }
	            break;
	        default:
	            return false;
	    }
	}

	var arabicSentenceCheck = {
	    startCheck: arabicSentenceStartCheck,
	    endCheck: arabicSentenceEndCheck
	};

	/**
	 * Apply single substitution format 1
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function singleSubstitutionFormat1$1(action, tokens, index) {
	    tokens[index].setState(action.tag, action.substitution);
	}

	/**
	 * Apply single substitution format 2
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function singleSubstitutionFormat2$1(action, tokens, index) {
	    tokens[index].setState(action.tag, action.substitution);
	}

	/**
	 * Apply chaining context substitution format 3
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function chainingSubstitutionFormat3$1(action, tokens, index) {
	    action.substitution.forEach(function (subst, offset) {
	        var token = tokens[index + offset];
	        token.setState(action.tag, subst);
	    });
	}

	/**
	 * Apply ligature substitution format 1
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function ligatureSubstitutionFormat1$1(action, tokens, index) {
	    var token = tokens[index];
	    token.setState(action.tag, action.substitution.ligGlyph);
	    var compsCount = action.substitution.components.length;
	    for (var i = 0; i < compsCount; i++) {
	        token = tokens[index + i + 1];
	        token.setState('deleted', true);
	    }
	}

	/**
	 * Supported substitutions
	 */
	var SUBSTITUTIONS = {
	    11: singleSubstitutionFormat1$1,
	    12: singleSubstitutionFormat2$1,
	    63: chainingSubstitutionFormat3$1,
	    41: ligatureSubstitutionFormat1$1
	};

	/**
	 * Apply substitutions to a list of tokens
	 * @param {Array} substitutions substitutions
	 * @param {any} tokens a list of tokens
	 * @param {number} index token index
	 */
	function applySubstitution(action, tokens, index) {
	    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
	        SUBSTITUTIONS[action.id](action, tokens, index);
	    }
	}

	/**
	 * Apply Arabic presentation forms to a range of tokens
	 */

	/**
	 * Check if a char can be connected to it's preceding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectPrev(charContextParams) {
	    var backtrack = [].concat(charContextParams.backtrack);
	    for (var i = backtrack.length - 1; i >= 0; i--) {
	        var prevChar = backtrack[i];
	        var isolated = isIsolatedArabicChar(prevChar);
	        var tashkeel = isTashkeelArabicChar(prevChar);
	        if (!isolated && !tashkeel) { return true; }
	        if (isolated) { return false; }
	    }
	    return false;
	}

	/**
	 * Check if a char can be connected to it's proceeding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectNext(charContextParams) {
	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
	        var nextChar = charContextParams.lookahead[i];
	        var tashkeel = isTashkeelArabicChar(nextChar);
	        if (!tashkeel) { return true; }
	    }
	    return false;
	}

	/**
	 * Apply arabic presentation forms to a list of tokens
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicPresentationForms(range) {
	    var this$1 = this;

	    var script = 'arab';
	    var tags = this.featuresTags[script];
	    var tokens = this.tokenizer.getRangeTokens(range);
	    if (tokens.length === 1) { return; }
	    var contextParams = new ContextParams(
	        tokens.map(function (token) { return token.getState('glyphIndex'); }
	    ), 0);
	    var charContextParams = new ContextParams(
	        tokens.map(function (token) { return token.char; }
	    ), 0);
	    tokens.forEach(function (token, index) {
	        if (isTashkeelArabicChar(token.char)) { return; }
	        contextParams.setCurrentIndex(index);
	        charContextParams.setCurrentIndex(index);
	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
	        var tag;
	        switch (CONNECT) {
	            case 1: (tag = 'fina'); break;
	            case 2: (tag = 'init'); break;
	            case 3: (tag = 'medi'); break;
	        }
	        if (tags.indexOf(tag) === -1) { return; }
	        var substitutions = this$1.query.lookupFeature({
	            tag: tag, script: script, contextParams: contextParams
	        });
	        if (substitutions instanceof Error) { return console.info(substitutions.message); }
	        substitutions.forEach(function (action, index) {
	            if (action instanceof SubstitutionAction) {
	                applySubstitution(action, tokens, index);
	                contextParams.context[index] = action.substitution;
	            }
	        });
	    });
	}

	/**
	 * Apply Arabic required ligatures feature to a range of tokens
	 */

	/**
	 * Update context params
	 * @param {any} tokens a list of tokens
	 * @param {number} index current item index
	 */
	function getContextParams(tokens, index) {
	    var context = tokens.map(function (token) { return token.activeState.value; });
	    return new ContextParams(context, index || 0);
	}

	/**
	 * Apply Arabic required ligatures to a context range
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicRequiredLigatures(range) {
	    var this$1 = this;

	    var script = 'arab';
	    var tokens = this.tokenizer.getRangeTokens(range);
	    var contextParams = getContextParams(tokens);
	    contextParams.context.forEach(function (glyphIndex, index) {
	        contextParams.setCurrentIndex(index);
	        var substitutions = this$1.query.lookupFeature({
	            tag: 'rlig', script: script, contextParams: contextParams
	        });
	        if (substitutions.length) {
	            substitutions.forEach(
	                function (action) { return applySubstitution(action, tokens, index); }
	            );
	            contextParams = getContextParams(tokens);
	        }
	    });
	}

	/**
	 * Latin word context checkers
	 */

	function latinWordStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? latin first char
	        (prevChar === null && isLatinChar(char)) ||
	        // ? latin char preceded with a non latin char
	        (!isLatinChar(prevChar) && isLatinChar(char))
	    );
	}

	function latinWordEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    return (
	        // ? last latin char
	        (nextChar === null) ||
	        // ? next char is not latin
	        (!isLatinChar(nextChar))
	    );
	}

	var latinWordCheck = {
	    startCheck: latinWordStartCheck,
	    endCheck: latinWordEndCheck
	};

	/**
	 * Apply Latin ligature feature to a range of tokens
	 */

	/**
	 * Update context params
	 * @param {any} tokens a list of tokens
	 * @param {number} index current item index
	 */
	function getContextParams$1(tokens, index) {
	    var context = tokens.map(function (token) { return token.activeState.value; });
	    return new ContextParams(context, index || 0);
	}

	/**
	 * Apply Arabic required ligatures to a context range
	 * @param {ContextRange} range a range of tokens
	 */
	function latinLigature(range) {
	    var this$1 = this;

	    var script = 'latn';
	    var tokens = this.tokenizer.getRangeTokens(range);
	    var contextParams = getContextParams$1(tokens);
	    contextParams.context.forEach(function (glyphIndex, index) {
	        contextParams.setCurrentIndex(index);
	        var substitutions = this$1.query.lookupFeature({
	            tag: 'liga', script: script, contextParams: contextParams
	        });
	        if (substitutions.length) {
	            substitutions.forEach(
	                function (action) { return applySubstitution(action, tokens, index); }
	            );
	            contextParams = getContextParams$1(tokens);
	        }
	    });
	}

	/**
	 * Infer bidirectional properties for a given text and apply
	 * the corresponding layout rules.
	 */

	/**
	 * Create Bidi. features
	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
	 */
	function Bidi(baseDir) {
	    this.baseDir = baseDir || 'ltr';
	    this.tokenizer = new Tokenizer();
	    this.featuresTags = {};
	}

	/**
	 * Sets Bidi text
	 * @param {string} text a text input
	 */
	Bidi.prototype.setText = function (text) {
	    this.text = text;
	};

	/**
	 * Store essential context checks:
	 * arabic word check for applying gsub features
	 * arabic sentence check for adjusting arabic layout
	 */
	Bidi.prototype.contextChecks = ({
	    latinWordCheck: latinWordCheck,
	    arabicWordCheck: arabicWordCheck,
	    arabicSentenceCheck: arabicSentenceCheck
	});

	/**
	 * Register arabic word check
	 */
	function registerContextChecker(checkId) {
	    var check = this.contextChecks[(checkId + "Check")];
	    return this.tokenizer.registerContextChecker(
	        checkId, check.startCheck, check.endCheck
	    );
	}

	/**
	 * Perform pre tokenization procedure then
	 * tokenize text input
	 */
	function tokenizeText() {
	    registerContextChecker.call(this, 'latinWord');
	    registerContextChecker.call(this, 'arabicWord');
	    registerContextChecker.call(this, 'arabicSentence');
	    return this.tokenizer.tokenize(this.text);
	}

	/**
	 * Reverse arabic sentence layout
	 * TODO: check base dir before applying adjustments - priority low
	 */
	function reverseArabicSentences() {
	    var this$1 = this;

	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
	    ranges.forEach(function (range) {
	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
	        this$1.tokenizer.replaceRange(
	            range.startIndex,
	            range.endOffset,
	            rangeTokens.reverse()
	        );
	    });
	}

	/**
	 * Register supported features tags
	 * @param {script} script script tag
	 * @param {Array} tags features tags list
	 */
	Bidi.prototype.registerFeatures = function (script, tags) {
	    var this$1 = this;

	    var supportedTags = tags.filter(
	        function (tag) { return this$1.query.supports({script: script, tag: tag}); }
	    );
	    if (!this.featuresTags.hasOwnProperty(script)) {
	        this.featuresTags[script] = supportedTags;
	    } else {
	        this.featuresTags[script] =
	        this.featuresTags[script].concat(supportedTags);
	    }
	};

	/**
	 * Apply GSUB features
	 * @param {Array} tagsList a list of features tags
	 * @param {string} script a script tag
	 * @param {Font} font opentype font instance
	 */
	Bidi.prototype.applyFeatures = function (font, features) {
	    if (!font) { throw new Error(
	        'No valid font was provided to apply features'
	    ); }
	    if (!this.query) { this.query = new FeatureQuery(font); }
	    for (var f = 0; f < features.length; f++) {
	        var feature = features[f];
	        if (!this.query.supports({script: feature.script})) { continue; }
	        this.registerFeatures(feature.script, feature.tags);
	    }
	};

	/**
	 * Register a state modifier
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a modifier function to set token state
	 */
	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
	    this.tokenizer.registerModifier(modifierId, condition, modifier);
	};

	/**
	 * Check if 'glyphIndex' is registered
	 */
	function checkGlyphIndexStatus() {
	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
	        throw new Error(
	            'glyphIndex modifier is required to apply ' +
	            'arabic presentation features.'
	        );
	    }
	}

	/**
	 * Apply arabic presentation forms features
	 */
	function applyArabicPresentationForms() {
	    var this$1 = this;

	    var script = 'arab';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicPresentationForms.call(this$1, range);
	    });
	}

	/**
	 * Apply required arabic ligatures
	 */
	function applyArabicRequireLigatures() {
	    var this$1 = this;

	    var script = 'arab';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    var tags = this.featuresTags[script];
	    if (tags.indexOf('rlig') === -1) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicRequiredLigatures.call(this$1, range);
	    });
	}

	/**
	 * Apply required arabic ligatures
	 */
	function applyLatinLigatures() {
	    var this$1 = this;

	    var script = 'latn';
	    if (!this.featuresTags.hasOwnProperty(script)) { return; }
	    var tags = this.featuresTags[script];
	    if (tags.indexOf('liga') === -1) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('latinWord');
	    ranges.forEach(function (range) {
	        latinLigature.call(this$1, range);
	    });
	}

	/**
	 * Check if a context is registered
	 * @param {string} contextId context id
	 */
	Bidi.prototype.checkContextReady = function (contextId) {
	    return !!this.tokenizer.getContext(contextId);
	};

	/**
	 * Apply features to registered contexts
	 */
	Bidi.prototype.applyFeaturesToContexts = function () {
	    if (this.checkContextReady('arabicWord')) {
	        applyArabicPresentationForms.call(this);
	        applyArabicRequireLigatures.call(this);
	    }
	    if (this.checkContextReady('latinWord')) {
	        applyLatinLigatures.call(this);
	    }
	    if (this.checkContextReady('arabicSentence')) {
	        reverseArabicSentences.call(this);
	    }
	};

	/**
	 * process text input
	 * @param {string} text an input text
	 */
	Bidi.prototype.processText = function(text) {
	    if (!this.text || this.text !== text) {
	        this.setText(text);
	        tokenizeText.call(this);
	        this.applyFeaturesToContexts();
	    }
	};

	/**
	 * Process a string of text to identify and adjust
	 * bidirectional text entities.
	 * @param {string} text input text
	 */
	Bidi.prototype.getBidiText = function (text) {
	    this.processText(text);
	    return this.tokenizer.getText();
	};

	/**
	 * Get the current state index of each token
	 * @param {text} text an input text
	 */
	Bidi.prototype.getTextGlyphs = function (text) {
	    this.processText(text);
	    var indexes = [];
	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
	        var token = this.tokenizer.tokens[i];
	        if (token.state.deleted) { continue; }
	        var index = token.activeState.value;
	        indexes.push(Array.isArray(index) ? index[0] : index);
	    }
	    return indexes;
	};

	// The Font object

	/**
	 * @typedef FontOptions
	 * @type Object
	 * @property {Boolean} empty - whether to create a new empty font
	 * @property {string} familyName
	 * @property {string} styleName
	 * @property {string=} fullName
	 * @property {string=} postScriptName
	 * @property {string=} designer
	 * @property {string=} designerURL
	 * @property {string=} manufacturer
	 * @property {string=} manufacturerURL
	 * @property {string=} license
	 * @property {string=} licenseURL
	 * @property {string=} version
	 * @property {string=} description
	 * @property {string=} copyright
	 * @property {string=} trademark
	 * @property {Number} unitsPerEm
	 * @property {Number} ascender
	 * @property {Number} descender
	 * @property {Number} createdTimestamp
	 * @property {string=} weightClass
	 * @property {string=} widthClass
	 * @property {string=} fsSelection
	 */

	/**
	 * A Font represents a loaded OpenType font file.
	 * It contains a set of glyphs and methods to draw text on a drawing context,
	 * or to get a path representing the text.
	 * @exports opentype.Font
	 * @class
	 * @param {FontOptions}
	 * @constructor
	 */
	function Font(options) {
	    options = options || {};
	    options.tables = options.tables || {};

	    if (!options.empty) {
	        // Check that we've provided the minimum set of names.
	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
	        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');

	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
	        this.names = {
	            fontFamily: {en: options.familyName || ' '},
	            fontSubfamily: {en: options.styleName || ' '},
	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
	            // postScriptName may not contain any whitespace
	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
	            designer: {en: options.designer || ' '},
	            designerURL: {en: options.designerURL || ' '},
	            manufacturer: {en: options.manufacturer || ' '},
	            manufacturerURL: {en: options.manufacturerURL || ' '},
	            license: {en: options.license || ' '},
	            licenseURL: {en: options.licenseURL || ' '},
	            version: {en: options.version || 'Version 0.1'},
	            description: {en: options.description || ' '},
	            copyright: {en: options.copyright || ' '},
	            trademark: {en: options.trademark || ' '}
	        };
	        this.unitsPerEm = options.unitsPerEm || 1000;
	        this.ascender = options.ascender;
	        this.descender = options.descender;
	        this.createdTimestamp = options.createdTimestamp;
	        this.tables = Object.assign(options.tables, {
	            os2: Object.assign({
	                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
	                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
	                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,
	            }, options.tables.os2)
	        });
	    }

	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
	    this.encoding = new DefaultEncoding(this);
	    this.position = new Position(this);
	    this.substitution = new Substitution(this);
	    this.tables = this.tables || {};

	    // needed for low memory mode only.
	    this._push = null;
	    this._hmtxTableData = {};

	    Object.defineProperty(this, 'hinting', {
	        get: function() {
	            if (this._hinting) { return this._hinting; }
	            if (this.outlinesFormat === 'truetype') {
	                return (this._hinting = new Hinting(this));
	            }
	        }
	    });
	}

	/**
	 * Check if the font has a glyph for the given character.
	 * @param  {string}
	 * @return {Boolean}
	 */
	Font.prototype.hasChar = function(c) {
	    return this.encoding.charToGlyphIndex(c) !== null;
	};

	/**
	 * Convert the given character to a single glyph index.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.charToGlyphIndex = function(s) {
	    return this.encoding.charToGlyphIndex(s);
	};

	/**
	 * Convert the given character to a single Glyph object.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.charToGlyph = function(c) {
	    var glyphIndex = this.charToGlyphIndex(c);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * Update features
	 * @param {any} options features options
	 */
	Font.prototype.updateFeatures = function (options) {
	    // TODO: update all features options not only 'latn'.
	    return this.defaultRenderOptions.features.map(function (feature) {
	        if (feature.script === 'latn') {
	            return {
	                script: 'latn',
	                tags: feature.tags.filter(function (tag) { return options[tag]; })
	            };
	        } else {
	            return feature;
	        }
	    });
	};

	/**
	 * Convert the given text to a list of Glyph objects.
	 * Note that there is no strict one-to-one mapping between characters and
	 * glyphs, so the list of returned glyphs can be larger or smaller than the
	 * length of the given string.
	 * @param  {string}
	 * @param  {GlyphRenderOptions} [options]
	 * @return {opentype.Glyph[]}
	 */
	Font.prototype.stringToGlyphs = function(s, options) {
	    var this$1 = this;


	    var bidi = new Bidi();

	    // Create and register 'glyphIndex' state modifier
	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

	    // roll-back to default features
	    var features = options ?
	    this.updateFeatures(options.features) :
	    this.defaultRenderOptions.features;

	    bidi.applyFeatures(this, features);

	    var indexes = bidi.getTextGlyphs(s);

	    var length = indexes.length;

	    // convert glyph indexes to glyph objects
	    var glyphs = new Array(length);
	    var notdef = this.glyphs.get(0);
	    for (var i = 0; i < length; i += 1) {
	        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
	    }
	    return glyphs;
	};

	/**
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.nameToGlyphIndex = function(name) {
	    return this.glyphNames.nameToGlyphIndex(name);
	};

	/**
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.nameToGlyph = function(name) {
	    var glyphIndex = this.nameToGlyphIndex(name);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * @param  {Number}
	 * @return {String}
	 */
	Font.prototype.glyphIndexToName = function(gid) {
	    if (!this.glyphNames.glyphIndexToName) {
	        return '';
	    }

	    return this.glyphNames.glyphIndexToName(gid);
	};

	/**
	 * Retrieve the value of the kerning pair between the left glyph (or its index)
	 * and the right glyph (or its index). If no kerning pair is found, return 0.
	 * The kerning value gets added to the advance width when calculating the spacing
	 * between glyphs.
	 * For GPOS kerning, this method uses the default script and language, which covers
	 * most use cases. To have greater control, use font.position.getKerningValue .
	 * @param  {opentype.Glyph} leftGlyph
	 * @param  {opentype.Glyph} rightGlyph
	 * @return {Number}
	 */
	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
	    leftGlyph = leftGlyph.index || leftGlyph;
	    rightGlyph = rightGlyph.index || rightGlyph;
	    var gposKerning = this.position.defaultKerningTables;
	    if (gposKerning) {
	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
	    }
	    // "kern" table
	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
	};

	/**
	 * @typedef GlyphRenderOptions
	 * @type Object
	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
	 * @property {boolean} [kerning=true] - whether to include kerning values
	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
	 */
	Font.prototype.defaultRenderOptions = {
	    kerning: true,
	    features: [
	        /**
	         * these 4 features are required to render Arabic text properly
	         * and shouldn't be turned off when rendering arabic text.
	         */
	        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },
	        { script: 'latn', tags: ['liga', 'rlig'] }
	    ]
	};

	/**
	 * Helper function that invokes the given callback for each glyph in the given text.
	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
	 * @param {string} text - The text to apply.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @param  {Function} callback
	 */
	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    options = Object.assign({}, this.defaultRenderOptions, options);
	    var fontScale = 1 / this.unitsPerEm * fontSize;
	    var glyphs = this.stringToGlyphs(text, options);
	    var kerningLookups;
	    if (options.kerning) {
	        var script = options.script || this.position.getDefaultScriptName();
	        kerningLookups = this.position.getKerningTables(script, options.language);
	    }
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs[i];
	        callback.call(this, glyph, x, y, fontSize, options);
	        if (glyph.advanceWidth) {
	            x += glyph.advanceWidth * fontScale;
	        }

	        if (options.kerning && i < glyphs.length - 1) {
	            // We should apply position adjustment lookups in a more generic way.
	            // Here we only use the xAdvance value.
	            var kerningValue = kerningLookups ?
	                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
	                  this.getKerningValue(glyph, glyphs[i + 1]);
	            x += kerningValue * fontScale;
	        }

	        if (options.letterSpacing) {
	            x += options.letterSpacing * fontSize;
	        } else if (options.tracking) {
	            x += (options.tracking / 1000) * fontSize;
	        }
	    }
	    return x;
	};

	/**
	 * Create a Path object that represents the given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path}
	 */
	Font.prototype.getPath = function(text, x, y, fontSize, options) {
	    var fullPath = new Path();
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        fullPath.extend(glyphPath);
	    });
	    return fullPath;
	};

	/**
	 * Create an array of Path objects that represent the glyphs of a given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path[]}
	 */
	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
	    var glyphPaths = [];
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        glyphPaths.push(glyphPath);
	    });

	    return glyphPaths;
	};

	/**
	 * Returns the advance width of a text.
	 *
	 * This is something different than Path.getBoundingBox() as for example a
	 * suffixed whitespace increases the advanceWidth but not the bounding box
	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
	 * bounding box than its advance width.
	 *
	 * This corresponds to canvas2dContext.measureText(text).width
	 *
	 * @param  {string} text - The text to create.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return advance width
	 */
	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
	};

	/**
	 * Draw the text on the given drawing context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 */
	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
	    this.getPath(text, x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of all glyphs in the text.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawPoints(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * Draw lines indicating important font measurements for all glyphs in the text.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * @param  {string}
	 * @return {string}
	 */
	Font.prototype.getEnglishName = function(name) {
	    var translations = this.names[name];
	    if (translations) {
	        return translations.en;
	    }
	};

	/**
	 * Validate
	 */
	Font.prototype.validate = function() {
	    var _this = this;

	    function assert(predicate, message) {
	    }

	    function assertNamePresent(name) {
	        var englishName = _this.getEnglishName(name);
	        assert(englishName && englishName.trim().length > 0);
	    }

	    // Identification information
	    assertNamePresent('fontFamily');
	    assertNamePresent('weightName');
	    assertNamePresent('manufacturer');
	    assertNamePresent('copyright');
	    assertNamePresent('version');

	    // Dimension information
	    assert(this.unitsPerEm > 0);
	};

	/**
	 * Convert the font object to a SFNT data structure.
	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
	 * @return {opentype.Table}
	 */
	Font.prototype.toTables = function() {
	    return sfnt.fontToTable(this);
	};
	/**
	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
	 */
	Font.prototype.toBuffer = function() {
	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
	    return this.toArrayBuffer();
	};
	/**
	 * Converts a `opentype.Font` into an `ArrayBuffer`
	 * @return {ArrayBuffer}
	 */
	Font.prototype.toArrayBuffer = function() {
	    var sfntTable = this.toTables();
	    var bytes = sfntTable.encode();
	    var buffer = new ArrayBuffer(bytes.length);
	    var intArray = new Uint8Array(buffer);
	    for (var i = 0; i < bytes.length; i++) {
	        intArray[i] = bytes[i];
	    }

	    return buffer;
	};

	/**
	 * Initiate a download of the OpenType font.
	 */
	Font.prototype.download = function(fileName) {
	    var familyName = this.getEnglishName('fontFamily');
	    var styleName = this.getEnglishName('fontSubfamily');
	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
	    var arrayBuffer = this.toArrayBuffer();

	    if (isBrowser()) {
	        window.URL = window.URL || window.webkitURL;

	        if (window.URL) {
	            var dataView = new DataView(arrayBuffer);
	            var blob = new Blob([dataView], {type: 'font/opentype'});

	            var link = document.createElement('a');
	            link.href = window.URL.createObjectURL(blob);
	            link.download = fileName;

	            var event = document.createEvent('MouseEvents');
	            event.initEvent('click', true, false);
	            link.dispatchEvent(event);
	        } else {
	            console.warn('Font file could not be downloaded. Try using a different browser.');
	        }
	    } else {
	        var fs = require('fs');
	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
	        fs.writeFileSync(fileName, buffer);
	    }
	};
	/**
	 * @private
	 */
	Font.prototype.fsSelectionValues = {
	    ITALIC:              0x001, //1
	    UNDERSCORE:          0x002, //2
	    NEGATIVE:            0x004, //4
	    OUTLINED:            0x008, //8
	    STRIKEOUT:           0x010, //16
	    BOLD:                0x020, //32
	    REGULAR:             0x040, //64
	    USER_TYPO_METRICS:   0x080, //128
	    WWS:                 0x100, //256
	    OBLIQUE:             0x200  //512
	};

	/**
	 * @private
	 */
	Font.prototype.usWidthClasses = {
	    ULTRA_CONDENSED: 1,
	    EXTRA_CONDENSED: 2,
	    CONDENSED: 3,
	    SEMI_CONDENSED: 4,
	    MEDIUM: 5,
	    SEMI_EXPANDED: 6,
	    EXPANDED: 7,
	    EXTRA_EXPANDED: 8,
	    ULTRA_EXPANDED: 9
	};

	/**
	 * @private
	 */
	Font.prototype.usWeightClasses = {
	    THIN: 100,
	    EXTRA_LIGHT: 200,
	    LIGHT: 300,
	    NORMAL: 400,
	    MEDIUM: 500,
	    SEMI_BOLD: 600,
	    BOLD: 700,
	    EXTRA_BOLD: 800,
	    BLACK:    900
	};

	// The `fvar` table stores font variation axes and instances.

	function addName(name, names) {
	    var nameString = JSON.stringify(name);
	    var nameID = 256;
	    for (var nameKey in names) {
	        var n = parseInt(nameKey);
	        if (!n || n < 256) {
	            continue;
	        }

	        if (JSON.stringify(names[nameKey]) === nameString) {
	            return n;
	        }

	        if (nameID <= n) {
	            nameID = n + 1;
	        }
	    }

	    names[nameID] = name;
	    return nameID;
	}

	function makeFvarAxis(n, axis, names) {
	    var nameID = addName(axis.name, names);
	    return [
	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
	        {name: 'flags_' + n, type: 'USHORT', value: 0},
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
	    ];
	}

	function parseFvarAxis(data, start, names) {
	    var axis = {};
	    var p = new parse.Parser(data, start);
	    axis.tag = p.parseTag();
	    axis.minValue = p.parseFixed();
	    axis.defaultValue = p.parseFixed();
	    axis.maxValue = p.parseFixed();
	    p.skip('uShort', 1);  // reserved for flags; no values defined
	    axis.name = names[p.parseUShort()] || {};
	    return axis;
	}

	function makeFvarInstance(n, inst, axes, names) {
	    var nameID = addName(inst.name, names);
	    var fields = [
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
	        {name: 'flags_' + n, type: 'USHORT', value: 0}
	    ];

	    for (var i = 0; i < axes.length; ++i) {
	        var axisTag = axes[i].tag;
	        fields.push({
	            name: 'axis_' + n + ' ' + axisTag,
	            type: 'FIXED',
	            value: inst.coordinates[axisTag] << 16
	        });
	    }

	    return fields;
	}

	function parseFvarInstance(data, start, axes, names) {
	    var inst = {};
	    var p = new parse.Parser(data, start);
	    inst.name = names[p.parseUShort()] || {};
	    p.skip('uShort', 1);  // reserved for flags; no values defined

	    inst.coordinates = {};
	    for (var i = 0; i < axes.length; ++i) {
	        inst.coordinates[axes[i].tag] = p.parseFixed();
	    }

	    return inst;
	}

	function makeFvarTable(fvar, names) {
	    var result = new table.Table('fvar', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'offsetToData', type: 'USHORT', value: 0},
	        {name: 'countSizePairs', type: 'USHORT', value: 2},
	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
	        {name: 'axisSize', type: 'USHORT', value: 20},
	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
	    ]);
	    result.offsetToData = result.sizeOf();

	    for (var i = 0; i < fvar.axes.length; i++) {
	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
	    }

	    for (var j = 0; j < fvar.instances.length; j++) {
	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
	    }

	    return result;
	}

	function parseFvarTable(data, start, names) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
	    var offsetToData = p.parseOffset16();
	    // Skip countSizePairs.
	    p.skip('uShort', 1);
	    var axisCount = p.parseUShort();
	    var axisSize = p.parseUShort();
	    var instanceCount = p.parseUShort();
	    var instanceSize = p.parseUShort();

	    var axes = [];
	    for (var i = 0; i < axisCount; i++) {
	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
	    }

	    var instances = [];
	    var instanceStart = start + offsetToData + axisCount * axisSize;
	    for (var j = 0; j < instanceCount; j++) {
	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
	    }

	    return {axes: axes, instances: instances};
	}

	var fvar = { make: makeFvarTable, parse: parseFvarTable };

	// The `GDEF` table contains various glyph properties

	var attachList = function() {
	    return {
	        coverage: this.parsePointer(Parser.coverage),
	        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
	    };
	};

	var caretValue = function() {
	    var format = this.parseUShort();
	    check.argument(format === 1 || format === 2 || format === 3,
	        'Unsupported CaretValue table version.');
	    if (format === 1) {
	        return { coordinate: this.parseShort() };
	    } else if (format === 2) {
	        return { pointindex: this.parseShort() };
	    } else if (format === 3) {
	        // Device / Variation Index tables unsupported
	        return { coordinate: this.parseShort() };
	    }
	};

	var ligGlyph = function() {
	    return this.parseList(Parser.pointer(caretValue));
	};

	var ligCaretList = function() {
	    return {
	        coverage: this.parsePointer(Parser.coverage),
	        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
	    };
	};

	var markGlyphSets = function() {
	    this.parseUShort(); // Version
	    return this.parseList(Parser.pointer(Parser.coverage));
	};

	function parseGDEFTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
	        'Unsupported GDEF table version.');
	    var gdef = {
	        version: tableVersion,
	        classDef: p.parsePointer(Parser.classDef),
	        attachList: p.parsePointer(attachList),
	        ligCaretList: p.parsePointer(ligCaretList),
	        markAttachClassDef: p.parsePointer(Parser.classDef)
	    };
	    if (tableVersion >= 1.2) {
	        gdef.markGlyphSets = p.parsePointer(markGlyphSets);
	    }
	    return gdef;
	}
	var gdef = { parse: parseGDEFTable };

	// The `GPOS` table contains kerning pairs, among other things.

	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
	// this = Parser instance
	subtableParsers$1[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var posformat = this.parseUShort();
	    if (posformat === 1) {
	        return {
	            posFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            value: this.parseValueRecord()
	        };
	    } else if (posformat === 2) {
	        return {
	            posFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            values: this.parseValueRecordList()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
	};

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
	subtableParsers$1[2] = function parseLookup2() {
	    var start = this.offset + this.relativeOffset;
	    var posFormat = this.parseUShort();
	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
	    var coverage = this.parsePointer(Parser.coverage);
	    var valueFormat1 = this.parseUShort();
	    var valueFormat2 = this.parseUShort();
	    if (posFormat === 1) {
	        // Adjustments for Glyph Pairs
	        return {
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
	                return {        // pairValueRecord
	                    secondGlyph: this.parseUShort(),
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            })))
	        };
	    } else if (posFormat === 2) {
	        var classDef1 = this.parsePointer(Parser.classDef);
	        var classDef2 = this.parsePointer(Parser.classDef);
	        var class1Count = this.parseUShort();
	        var class2Count = this.parseUShort();
	        return {
	            // Class Pair Adjustment
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            classDef1: classDef1,
	            classDef2: classDef2,
	            class1Count: class1Count,
	            class2Count: class2Count,
	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
	                return {
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            }))
	        };
	    }
	};

	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
	function parseGposTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GPOS Writing //////////////////////////////////////////////
	// NOT SUPPORTED
	var subtableMakers$1 = new Array(10);

	function makeGposTable(gpos) {
	    return new table.Table('GPOS', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
	    ]);
	}

	var gpos = { parse: parseGposTable, make: makeGposTable };

	// The `kern` table contains kerning pairs.

	function parseWindowsKernTable(p) {
	    var pairs = {};
	    // Skip nTables.
	    p.skip('uShort');
	    var subtableVersion = p.parseUShort();
	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
	    // Skip subtableLength, subtableCoverage
	    p.skip('uShort', 2);
	    var nPairs = p.parseUShort();
	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);
	    for (var i = 0; i < nPairs; i += 1) {
	        var leftIndex = p.parseUShort();
	        var rightIndex = p.parseUShort();
	        var value = p.parseShort();
	        pairs[leftIndex + ',' + rightIndex] = value;
	    }
	    return pairs;
	}

	function parseMacKernTable(p) {
	    var pairs = {};
	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
	    // Skip the rest.
	    p.skip('uShort');
	    var nTables = p.parseULong();
	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
	    if (nTables > 1) {
	        console.warn('Only the first kern subtable is supported.');
	    }
	    p.skip('uLong');
	    var coverage = p.parseUShort();
	    var subtableVersion = coverage & 0xFF;
	    p.skip('uShort');
	    if (subtableVersion === 0) {
	        var nPairs = p.parseUShort();
	        // Skip searchRange, entrySelector, rangeShift.
	        p.skip('uShort', 3);
	        for (var i = 0; i < nPairs; i += 1) {
	            var leftIndex = p.parseUShort();
	            var rightIndex = p.parseUShort();
	            var value = p.parseShort();
	            pairs[leftIndex + ',' + rightIndex] = value;
	        }
	    }
	    return pairs;
	}

	// Parse the `kern` table which contains kerning pairs.
	function parseKernTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseUShort();
	    if (tableVersion === 0) {
	        return parseWindowsKernTable(p);
	    } else if (tableVersion === 1) {
	        return parseMacKernTable(p);
	    } else {
	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
	    }
	}

	var kern = { parse: parseKernTable };

	// The `loca` table stores the offsets to the locations of the glyphs in the font.

	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
	// relative to the beginning of the glyphData table.
	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
	// version where offsets are stored as uLongs. The `head` table specifies which version to use
	// (under indexToLocFormat).
	function parseLocaTable(data, start, numGlyphs, shortVersion) {
	    var p = new parse.Parser(data, start);
	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
	    // There is an extra entry after the last index element to compute the length of the last glyph.
	    // That's why we use numGlyphs + 1.
	    var glyphOffsets = [];
	    for (var i = 0; i < numGlyphs + 1; i += 1) {
	        var glyphOffset = parseFn.call(p);
	        if (shortVersion) {
	            // The short table version stores the actual offset divided by 2.
	            glyphOffset *= 2;
	        }

	        glyphOffsets.push(glyphOffset);
	    }

	    return glyphOffsets;
	}

	var loca = { parse: parseLocaTable };

	// opentype.js

	/**
	 * The opentype library.
	 * @namespace opentype
	 */

	// File loaders /////////////////////////////////////////////////////////
	/**
	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} path - The path of the file
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromFile(path, callback) {
	    var fs = require('fs');
	    fs.readFile(path, function(err, buffer) {
	        if (err) {
	            return callback(err.message);
	        }

	        callback(null, nodeBufferToArrayBuffer(buffer));
	    });
	}
	/**
	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} url - The URL of the font file.
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromUrl(url, callback) {
	    var request = new XMLHttpRequest();
	    request.open('get', url, true);
	    request.responseType = 'arraybuffer';
	    request.onload = function() {
	        if (request.response) {
	            return callback(null, request.response);
	        } else {
	            return callback('Font could not be loaded: ' + request.statusText);
	        }
	    };

	    request.onerror = function () {
	        callback('Font could not be loaded');
	    };

	    request.send();
	}

	// Table Directory Entries //////////////////////////////////////////////
	/**
	 * Parses OpenType table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseOpenTypeTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 12;
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var checksum = parse.getULong(data, p + 4);
	        var offset = parse.getULong(data, p + 8);
	        var length = parse.getULong(data, p + 12);
	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
	        p += 16;
	    }

	    return tableEntries;
	}

	/**
	 * Parses WOFF table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseWOFFTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 44; // offset to the first table directory entry.
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var offset = parse.getULong(data, p + 4);
	        var compLength = parse.getULong(data, p + 8);
	        var origLength = parse.getULong(data, p + 12);
	        var compression = (void 0);
	        if (compLength < origLength) {
	            compression = 'WOFF';
	        } else {
	            compression = false;
	        }

	        tableEntries.push({tag: tag, offset: offset, compression: compression,
	            compressedLength: compLength, length: origLength});
	        p += 20;
	    }

	    return tableEntries;
	}

	/**
	 * @typedef TableData
	 * @type Object
	 * @property {DataView} data - The DataView
	 * @property {number} offset - The data offset.
	 */

	/**
	 * @param  {DataView}
	 * @param  {Object}
	 * @return {TableData}
	 */
	function uncompressTable(data, tableEntry) {
	    if (tableEntry.compression === 'WOFF') {
	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
	        var outBuffer = new Uint8Array(tableEntry.length);
	        tinyInflate(inBuffer, outBuffer);
	        if (outBuffer.byteLength !== tableEntry.length) {
	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
	        }

	        var view = new DataView(outBuffer.buffer, 0);
	        return {data: view, offset: 0};
	    } else {
	        return {data: data, offset: tableEntry.offset};
	    }
	}

	// Public API ///////////////////////////////////////////////////////////

	/**
	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
	 * Throws an error if the font could not be parsed.
	 * @param  {ArrayBuffer}
	 * @param  {Object} opt - options for parsing
	 * @return {opentype.Font}
	 */
	function parseBuffer(buffer, opt) {
	    opt = (opt === undefined || opt === null) ?  {} : opt;

	    var indexToLocFormat;
	    var ltagTable;

	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
	    // should be an empty font that we'll fill with our own data.
	    var font = new Font({empty: true});

	    // OpenType fonts use big endian byte ordering.
	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
	    // Instead we use DataViews where we can specify endianness.
	    var data = new DataView(buffer, 0);
	    var numTables;
	    var tableEntries = [];
	    var signature = parse.getTag(data, 0);
	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
	        font.outlinesFormat = 'truetype';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'OTTO') {
	        font.outlinesFormat = 'cff';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'wOFF') {
	        var flavor = parse.getTag(data, 4);
	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
	            font.outlinesFormat = 'truetype';
	        } else if (flavor === 'OTTO') {
	            font.outlinesFormat = 'cff';
	        } else {
	            throw new Error('Unsupported OpenType flavor ' + signature);
	        }

	        numTables = parse.getUShort(data, 12);
	        tableEntries = parseWOFFTableEntries(data, numTables);
	    } else {
	        throw new Error('Unsupported OpenType signature ' + signature);
	    }

	    var cffTableEntry;
	    var fvarTableEntry;
	    var glyfTableEntry;
	    var gdefTableEntry;
	    var gposTableEntry;
	    var gsubTableEntry;
	    var hmtxTableEntry;
	    var kernTableEntry;
	    var locaTableEntry;
	    var nameTableEntry;
	    var metaTableEntry;
	    var p;

	    for (var i = 0; i < numTables; i += 1) {
	        var tableEntry = tableEntries[i];
	        var table = (void 0);
	        switch (tableEntry.tag) {
	            case 'cmap':
	                table = uncompressTable(data, tableEntry);
	                font.tables.cmap = cmap.parse(table.data, table.offset);
	                font.encoding = new CmapEncoding(font.tables.cmap);
	                break;
	            case 'cvt ' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
	                break;
	            case 'fvar':
	                fvarTableEntry = tableEntry;
	                break;
	            case 'fpgm' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.fpgm = p.parseByteList(tableEntry.length);
	                break;
	            case 'head':
	                table = uncompressTable(data, tableEntry);
	                font.tables.head = head.parse(table.data, table.offset);
	                font.unitsPerEm = font.tables.head.unitsPerEm;
	                indexToLocFormat = font.tables.head.indexToLocFormat;
	                break;
	            case 'hhea':
	                table = uncompressTable(data, tableEntry);
	                font.tables.hhea = hhea.parse(table.data, table.offset);
	                font.ascender = font.tables.hhea.ascender;
	                font.descender = font.tables.hhea.descender;
	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
	                break;
	            case 'hmtx':
	                hmtxTableEntry = tableEntry;
	                break;
	            case 'ltag':
	                table = uncompressTable(data, tableEntry);
	                ltagTable = ltag.parse(table.data, table.offset);
	                break;
	            case 'maxp':
	                table = uncompressTable(data, tableEntry);
	                font.tables.maxp = maxp.parse(table.data, table.offset);
	                font.numGlyphs = font.tables.maxp.numGlyphs;
	                break;
	            case 'name':
	                nameTableEntry = tableEntry;
	                break;
	            case 'OS/2':
	                table = uncompressTable(data, tableEntry);
	                font.tables.os2 = os2.parse(table.data, table.offset);
	                break;
	            case 'post':
	                table = uncompressTable(data, tableEntry);
	                font.tables.post = post.parse(table.data, table.offset);
	                font.glyphNames = new GlyphNames(font.tables.post);
	                break;
	            case 'prep' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.prep = p.parseByteList(tableEntry.length);
	                break;
	            case 'glyf':
	                glyfTableEntry = tableEntry;
	                break;
	            case 'loca':
	                locaTableEntry = tableEntry;
	                break;
	            case 'CFF ':
	                cffTableEntry = tableEntry;
	                break;
	            case 'kern':
	                kernTableEntry = tableEntry;
	                break;
	            case 'GDEF':
	                gdefTableEntry = tableEntry;
	                break;
	            case 'GPOS':
	                gposTableEntry = tableEntry;
	                break;
	            case 'GSUB':
	                gsubTableEntry = tableEntry;
	                break;
	            case 'meta':
	                metaTableEntry = tableEntry;
	                break;
	        }
	    }

	    var nameTable = uncompressTable(data, nameTableEntry);
	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
	    font.names = font.tables.name;

	    if (glyfTableEntry && locaTableEntry) {
	        var shortVersion = indexToLocFormat === 0;
	        var locaTable = uncompressTable(data, locaTableEntry);
	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
	        var glyfTable = uncompressTable(data, glyfTableEntry);
	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
	    } else if (cffTableEntry) {
	        var cffTable = uncompressTable(data, cffTableEntry);
	        cff.parse(cffTable.data, cffTable.offset, font, opt);
	    } else {
	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
	    }

	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
	    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
	    addGlyphNames(font, opt);

	    if (kernTableEntry) {
	        var kernTable = uncompressTable(data, kernTableEntry);
	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
	    } else {
	        font.kerningPairs = {};
	    }

	    if (gdefTableEntry) {
	        var gdefTable = uncompressTable(data, gdefTableEntry);
	        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
	    }

	    if (gposTableEntry) {
	        var gposTable = uncompressTable(data, gposTableEntry);
	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
	        font.position.init();
	    }

	    if (gsubTableEntry) {
	        var gsubTable = uncompressTable(data, gsubTableEntry);
	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
	    }

	    if (fvarTableEntry) {
	        var fvarTable = uncompressTable(data, fvarTableEntry);
	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
	    }

	    if (metaTableEntry) {
	        var metaTable = uncompressTable(data, metaTableEntry);
	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
	        font.metas = font.tables.meta;
	    }

	    return font;
	}

	/**
	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
	 * with two arguments `(err, font)`. The `err` will be null on success,
	 * the `font` is a Font object.
	 * We use the node.js callback convention so that
	 * opentype.js can integrate with frameworks like async.js.
	 * @alias opentype.load
	 * @param  {string} url - The URL of the font to load.
	 * @param  {Function} callback - The callback.
	 */
	function load(url, callback, opt) {
	    opt = (opt === undefined || opt === null) ?  {} : opt;
	    var isNode = typeof window === 'undefined';
	    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;

	    return new Promise(function (resolve, reject) {
	        loadFn(url, function(err, arrayBuffer) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                } else {
	                    reject(err);
	                }
	            }
	            var font;
	            try {
	                font = parseBuffer(arrayBuffer, opt);
	            } catch (e) {
	                if (callback) {
	                    return callback(e, null);
	                } else {
	                    reject(e);
	                }
	            }
	            if (callback) {
	                return callback(null, font);
	            } else {
	                resolve(font);
	            }
	        });
	    });
	}

	/**
	 * Synchronously load the font from a URL or file.
	 * When done, returns the font object or throws an error.
	 * @alias opentype.loadSync
	 * @param  {string} url - The URL of the font to load.
	 * @param  {Object} opt - opt.lowMemory
	 * @return {opentype.Font}
	 */
	function loadSync(url, opt) {
	    var fs = require('fs');
	    var buffer = fs.readFileSync(url);
	    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
	}

	var opentype = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Font: Font,
		Glyph: Glyph,
		Path: Path,
		BoundingBox: BoundingBox,
		_parse: parse,
		parse: parseBuffer,
		load: load,
		loadSync: loadSync
	});

	exports.BoundingBox = BoundingBox;
	exports.Font = Font;
	exports.Glyph = Glyph;
	exports.Path = Path;
	exports._parse = parse;
	exports.default = opentype;
	exports.load = load;
	exports.loadSync = loadSync;
	exports.parse = parseBuffer;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=opentype.js.map
;
define('opentype', ['opentype/dist/opentype'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/X3DTextContext',[
   "jquery",
   "x_ite/Components/Text/FontStyle",
   "opentype",
],
function ($,
          FontStyle,
          opentype)
{
"use strict";

   const
      _defaultFontStyle = Symbol (),
      _fontCache        = Symbol (),
      _glyphCache       = Symbol ();

   function X3DTextContext ()
   {
      this [_fontCache]  = new Map ();
      this [_glyphCache] = new Map (); // [font] [primitiveQuality] [glyphIndex]
   }

   X3DTextContext .prototype =
   {
      initialize: function ()
      { },
      getDefaultFontStyle: function ()
      {
         this [_defaultFontStyle] = new FontStyle (this .getPrivateScene ());
         this [_defaultFontStyle] .setup ();

         this .getDefaultFontStyle = function () { return this [_defaultFontStyle]; };

         Object .defineProperty (this, "getDefaultFontStyle", { enumerable: false });

         return this [_defaultFontStyle];
      },
      getFont: function (url)
      {
         url = url .toString ();

         let deferred = this [_fontCache] .get (url);

         if (deferred === undefined)
         {
            this [_fontCache] .set (url, deferred = $.Deferred ());

            opentype .load (url, this .setFont .bind (this, deferred));
         }

         return deferred;
      },
      setFont: function (deferred, error, font)
      {
         if (error)
            deferred .reject (error);
         else
            deferred .resolve (font);
      },
      getGlyph: function (font, primitiveQuality, glyphIndex)
      {
         let cachedFont = this [_glyphCache] .get (font);

         if (!cachedFont)
            this [_glyphCache] .set (font, cachedFont = [ ]);

         let cachedQuality = cachedFont [primitiveQuality];

         if (!cachedQuality)
            cachedQuality = cachedFont [primitiveQuality] = [ ];

         let cachedGlyph = cachedQuality [glyphIndex];

         if (!cachedGlyph)
            cachedGlyph = cachedQuality [glyphIndex] = { };

         return cachedGlyph;
      },
   };

   return X3DTextContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureTransformNode',[
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
],
function (X3DAppearanceChildNode,
          X3DConstants,
          Matrix4)
{
"use strict";

   function X3DTextureTransformNode (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTextureTransformNode);

      this .matrixArray = new Float32Array (Matrix4 .Identity);
   }

   X3DTextureTransformNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: X3DTextureTransformNode,
      setMatrix: function (value)
      {
         this .matrixArray .set (value);
      },
      setShaderUniformsToChannel: function (gl, shaderObject, i)
      {
         gl .uniformMatrix4fv (shaderObject .x3d_TextureMatrix [i], false, this .matrixArray);
      },
   });

   return X3DTextureTransformNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Texturing/X3DSingleTextureTransformNode',[
   "x_ite/Components/Texturing/X3DTextureTransformNode",
   "x_ite/Base/X3DConstants",
],
function (X3DTextureTransformNode,
          X3DConstants)
{
"use strict";

   function X3DSingleTextureTransformNode (executionContext)
   {
      X3DTextureTransformNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSingleTextureTransformNode);
   }

   X3DSingleTextureTransformNode .prototype = Object .assign (Object .create (X3DTextureTransformNode .prototype),
   {
      constructor: X3DSingleTextureTransformNode,
      getTextureMapping: function (textureTransformMapping, channel = 0)
      {
         if (this ._mapping .getValue ())
            textureTransformMapping .set (this ._mapping .getValue (), channel);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         for (let i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
            this .setShaderUniformsToChannel (gl, shaderObject, i);
      },
   });

   return X3DSingleTextureTransformNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureTransform',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DSingleTextureTransformNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSingleTextureTransformNode,
          X3DConstants,
          Vector2,
          Matrix3,
          Matrix4)
{
"use strict";

   function TextureTransform (executionContext)
   {
      X3DSingleTextureTransformNode .call (this, executionContext);

      this .addType (X3DConstants .TextureTransform);

      this ._rotation .setUnit ("angle");

      this .matrix = new Matrix4 ();
   }

   TextureTransform .prototype = Object .assign (Object .create (X3DSingleTextureTransformNode .prototype),
   {
      constructor: TextureTransform,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "mapping",     new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "translation", new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "rotation",    new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "scale",       new Fields .SFVec2f (1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "center",      new Fields .SFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "TextureTransform";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "textureTransform";
      },
      initialize: function ()
      {
         X3DSingleTextureTransformNode .prototype .initialize .call (this);

         this .addInterest ("eventsProcessed", this);

         this .eventsProcessed ();
      },
      getMatrix: function ()
      {
         return this .matrix;
      },
      eventsProcessed: (function ()
      {
         const
            vector  = new Vector2 (0, 0),
            matrix3 = new Matrix3 ();

         return function ()
         {
            const
               translation = this ._translation .getValue (),
               rotation    = this ._rotation .getValue (),
               scale       = this ._scale .getValue (),
               center      = this ._center .getValue (),
               matrix4     = this .matrix;

            matrix3 .identity ();

            if (! center .equals (Vector2 .Zero))
               matrix3 .translate (vector .assign (center) .negate ());

            if (! scale .equals (Vector2 .One))
               matrix3 .scale (scale);

            if (rotation !== 0)
               matrix3 .rotate (rotation);

            if (! center .equals (Vector2 .Zero))
               matrix3 .translate (center);

            if (! translation .equals (Vector2 .Zero))
               matrix3 .translate (translation);

            matrix4 [ 0] = matrix3 [0];
            matrix4 [ 1] = matrix3 [1];
            matrix4 [ 4] = matrix3 [3];
            matrix4 [ 5] = matrix3 [4];
            matrix4 [12] = matrix3 [6];
            matrix4 [13] = matrix3 [7];

            this .setMatrix (matrix4);
         };
      })(),
   });

   return TextureTransform;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/X3DTexturingContext',[
   "x_ite/Components/Texturing/TextureProperties",
   "x_ite/Components/Texturing/TextureTransform",
   "x_ite/Components/Texturing/TextureCoordinate",
],
function (TextureProperties,
          TextureTransform,
          TextureCoordinate)
{
"use strict";

   const
      _maxTextures              = Symbol (),
      _multiTexturing           = Symbol (),
      _projectiveTextureMapping = Symbol (),
      _maxTextureSize           = Symbol (),
      _maxCombinedTextureUnits  = Symbol (),
      _textureMemory            = Symbol (),
      _combinedTextureUnits     = Symbol (),
      _texture2DUnits           = Symbol (),
      _texture3DUnits           = Symbol (),
      _textureCubeUnits         = Symbol (),
      _texture2DUnitIndex       = Symbol (),
      _texture3DUnitIndex       = Symbol (),
      _textureCubeUnitIndex     = Symbol (),
      _defaultTexture2D         = Symbol (),
      _defaultTexture3D         = Symbol (),
      _defaultTextureCube       = Symbol (),
      _defaultTextureProperties = Symbol (),
      _defaultTextureTransform  = Symbol (),
      _defaultTextureCoordinate = Symbol ();

   function X3DTexturingContext ()
   {
      const
         gl                   = this .getContext (),
         maxTextureImageUnits = gl .getParameter (gl .MAX_TEXTURE_IMAGE_UNITS);

      // console .log (gl .getParameter (gl .MAX_TEXTURE_IMAGE_UNITS))
      // console .log (gl .getParameter (gl .MAX_ARRAY_TEXTURE_LAYERS))

      this [_maxTextures]              = maxTextureImageUnits > 8 ? 2 : 1;
      this [_multiTexturing]           = maxTextureImageUnits > 8;
      this [_projectiveTextureMapping] = maxTextureImageUnits > 8;
   }

   X3DTexturingContext .prototype =
   {
      initialize: function ()
      {
         const gl = this .getContext ();

         gl .pixelStorei (gl .UNPACK_ALIGNMENT, 1);

         this [_maxTextureSize]          = gl .getParameter (gl .MAX_TEXTURE_SIZE);
         this [_maxCombinedTextureUnits] = gl .getParameter (gl .MAX_COMBINED_TEXTURE_IMAGE_UNITS);
         this [_textureMemory]           = NaN;

         // Get texture Units

         this [_combinedTextureUnits] = [...Array (this [_maxCombinedTextureUnits]) .keys ()];
         this [_texture2DUnits]       = [this [_combinedTextureUnits] .pop ()];
         this [_texture3DUnits]       = [this [_combinedTextureUnits] .pop ()];
         this [_textureCubeUnits]     = [this [_combinedTextureUnits] .pop ()];

         // Default Texture 2D Unit

         const defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

         this [_defaultTexture2D] = gl .createTexture ();

         gl .activeTexture (gl .TEXTURE0 + this [_texture2DUnits] [0]);
         gl .bindTexture (gl .TEXTURE_2D, this [_defaultTexture2D]);
         gl .texImage2D (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

         // Default Texture 3D Unit

         if (gl .getVersion () >= 2)
         {
            this [_defaultTexture3D] = gl .createTexture ();

            gl .activeTexture (gl .TEXTURE0 + this [_texture3DUnits] [0]);
            gl .bindTexture (gl .TEXTURE_3D, this [_defaultTexture3D]);
            gl .texImage3D (gl .TEXTURE_3D, 0, gl .RGBA, 1, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         }

         // Default Texture Cube Unit

         this [_defaultTextureCube] = gl .createTexture ();

         gl .activeTexture (gl .TEXTURE0 + this [_textureCubeUnits] [0]);
         gl .bindTexture (gl .TEXTURE_CUBE_MAP, this [_defaultTextureCube]);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
         gl .texImage2D (gl .TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

         // Init texture units.

         this .resetTextureUnits ();
      },
      getMaxTextures: function ()
      {
         return this [_maxTextures];
      },
      getMinTextureSize: function ()
      {
         return 16;
      },
      getMaxTextureSize: function ()
      {
         return this [_maxTextureSize];
      },
      getMaxCombinedTextureUnits: function ()
      {
         return this [_maxCombinedTextureUnits];
      },
      popTexture2DUnit: function ()
      {
         if (this [_texture2DUnitIndex] > 0)
         {
            -- this [_texture2DUnitIndex];

            return this [_texture2DUnits] .pop ();
         }
         else
         {
            return this [_combinedTextureUnits] .pop ();
         }
      },
      pushTexture2DUnit: function (textureUnit)
      {
         if (textureUnit === undefined)
            return;

         ++ this [_texture2DUnitIndex];

         this [_texture2DUnits] .push (textureUnit);
      },
      getTexture2DUnit: function ()
      {
         if (this [_texture2DUnitIndex] > 0)
            return this [_texture2DUnits] [-- this [_texture2DUnitIndex]];

         const textureUnit = this [_combinedTextureUnits] .pop ();

         if (textureUnit !== undefined)
            this [_texture2DUnits] .push (textureUnit);

         return textureUnit;
      },
      getTexture3DUnit: function ()
      {
         if (this [_texture3DUnitIndex] > 0)
            return this [_texture3DUnits] [-- this [_texture3DUnitIndex]];

         const textureUnit = this [_combinedTextureUnits] .pop ();

         if (textureUnit !== undefined)
            this [_texture3DUnits] .push (textureUnit);

         return textureUnit;
      },
      getTextureCubeUnit: function ()
      {
         if (this [_textureCubeUnitIndex] > 0)
            return this [_textureCubeUnits] [-- this [_textureCubeUnitIndex]];

         const textureUnit = this [_combinedTextureUnits] .pop ();

         if (textureUnit !== undefined)
            this [_textureCubeUnits] .push (textureUnit);

         return textureUnit;
      },
      getTextureUnit: function (textureType)
      {
         switch (textureType)
         {
            case 2: return this .getTexture2DUnit ();
            case 3: return this .getTexture3DUnit ();
            case 4: return this .getTextureCubeUnit ();
         }
      },
      resetTextureUnits: function ()
      {
         this [_texture2DUnitIndex]   = this [_texture2DUnits]   .length;
         this [_texture3DUnitIndex]   = this [_texture3DUnits]   .length;
         this [_textureCubeUnitIndex] = this [_textureCubeUnits] .length;
      },
      getDefaultTexture2DUnit: function ()
      {
         return this [_texture2DUnits] [0];
      },
      getDefaultTexture3DUnit: function ()
      {
         return this [_texture3DUnits] [0];
      },
      getDefaultTextureCubeUnit: function ()
      {
         return this [_textureCubeUnits] [0];
      },
      getTextureMemory: function ()
      {
         return this [_textureMemory];
      },
      getMultiTexturing: function ()
      {
         return this [_multiTexturing];
      },
      getProjectiveTextureMapping: function ()
      {
         return this [_projectiveTextureMapping];
      },
      getDefaultTextureProperties: function ()
      {
         this [_defaultTextureProperties] = new TextureProperties (this .getPrivateScene ());
         this [_defaultTextureProperties] ._magnificationFilter = "NICEST";
         this [_defaultTextureProperties] ._minificationFilter  = "NEAREST_PIXEL_AVG_MIPMAP";
         this [_defaultTextureProperties] ._textureCompression  = "NICEST";
         this [_defaultTextureProperties] ._generateMipMaps     = true;

         this [_defaultTextureProperties] .setup ();

         this .getDefaultTextureProperties = function () { return this [_defaultTextureProperties]; };

         Object .defineProperty (this, "getDefaultTextureProperties", { enumerable: false });

         return this [_defaultTextureProperties];
      },
      getDefaultTextureTransform: function ()
      {
         this [_defaultTextureTransform] = new TextureTransform (this .getPrivateScene ());
         this [_defaultTextureTransform] .setup ();

         this .getDefaultTextureTransform = function () { return this [_defaultTextureTransform]; };

         Object .defineProperty (this, "getDefaultTextureTransform", { enumerable: false });

         return this [_defaultTextureTransform];
      },
      getDefaultTextureCoordinate: function ()
      {
         this [_defaultTextureCoordinate] = new TextureCoordinate (this .getPrivateScene ());
         this [_defaultTextureCoordinate] .setup ();

         this .getDefaultTextureCoordinate = function () { return this [_defaultTextureCoordinate]; };

         Object .defineProperty (this, "getDefaultTextureCoordinate", { enumerable: false });

         return this [_defaultTextureCoordinate];
      },
   };

   return X3DTexturingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Time/X3DTimeContext',[
   "standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

   const
      _currentTime      = Symbol (),
      _currentFrameRate = Symbol (),
      _currentPosition  = Symbol (),
      _currentSpeed     = Symbol ();

   function X3DTimeContext ()
   {
      this [_currentTime]      = 0;
      this [_currentFrameRate] = 60;
      this [_currentPosition]  = new Vector3 (0, 0, 0);
      this [_currentSpeed]     = 0;
   }

   X3DTimeContext .prototype =
   {
      initialize: function ()
      {
         this .advanceTime (performance .now ());
      },
      getCurrentTime: function ()
      {
         return this [_currentTime];
      },
      getCurrentFrameRate: function ()
      {
         return this [_currentFrameRate];
      },
      getCurrentSpeed: function ()
      {
         return this [_currentSpeed];
      },
      advanceTime: (function ()
      {
         const lastPosition = new Vector3 (0, 0, 0);

         return function (now)
         {
            const
               time     = (performance .timeOrigin + now) / 1000,
               interval = time - this [_currentTime];

            this [_currentTime]      = time;
            this [_currentFrameRate] = interval ? 1 / interval : 60;

            if (this .getWorld () && this .getActiveLayer ())
            {
               const cameraSpaceMatrix = this .getActiveLayer () .getViewpoint () .getCameraSpaceMatrix ();

               lastPosition .assign (this [_currentPosition]);
               this [_currentPosition] .set (cameraSpaceMatrix [12], cameraSpaceMatrix [13], cameraSpaceMatrix [14]);

               this [_currentSpeed] = lastPosition .subtract (this [_currentPosition]) .abs () * this [_currentFrameRate];
            }
            else
            {
               this [_currentSpeed] = 0;
            }
         };
      })(),
   };

   return X3DTimeContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/X3DBrowserContext',[
   "jquery",
   "x_ite/Fields/SFTime",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Browser/Core/X3DCoreContext",
   "x_ite/Routing/X3DRoutingContext",
   "x_ite/Browser/Scripting/X3DScriptingContext",
   "x_ite/Browser/Networking/X3DNetworkingContext",
   "x_ite/Browser/Shaders/X3DShadersContext",
   "x_ite/Browser/Rendering/X3DRenderingContext",
   "x_ite/Browser/Shape/X3DShapeContext",
   "x_ite/Browser/Grouping/X3DGroupingContext",
   "x_ite/Browser/Geometry3D/X3DGeometry3DContext",
   "x_ite/Browser/PointingDeviceSensor/X3DPointingDeviceSensorContext",
   "x_ite/Browser/Navigation/X3DNavigationContext",
   "x_ite/Browser/Layering/X3DLayeringContext",
   "x_ite/Browser/EnvironmentalEffects/X3DEnvironmentalEffectsContext",
   "x_ite/Browser/Lighting/X3DLightingContext",
   "x_ite/Browser/Picking/X3DPickingContext",
   "x_ite/Browser/Sound/X3DSoundContext",
   "x_ite/Browser/Text/X3DTextContext",
   "x_ite/Browser/Texturing/X3DTexturingContext",
   "x_ite/Browser/Time/X3DTimeContext",
   "x_ite/Execution/X3DWorld",
   "x_ite/Rendering/TraverseType",
],
function ($,
          SFTime,
          X3DBaseNode,
          X3DCoreContext,
          X3DRoutingContext,
          X3DScriptingContext,
          X3DNetworkingContext,
          X3DShadersContext,
          X3DRenderingContext,
          X3DShapeContext,
          X3DGroupingContext,
          X3DGeometry3DContext,
          X3DPointingDeviceSensorContext,
          X3DNavigationContext,
          X3DLayeringContext,
          X3DEnvironmentalEffectsContext,
          X3DLightingContext,
          X3DPickingContext,
          X3DSoundContext,
          X3DTextContext,
          X3DTexturingContext,
          X3DTimeContext,
          X3DWorld,
          TraverseType)
{
"use strict";

   const
      _world           = Symbol (),
      _changedTime     = Symbol (),
      _renderCallback  = Symbol (),
      _previousTime    = Symbol (),
      _systemTime      = Symbol (),
      _systemStartTime = Symbol (),
      _browserTime     = Symbol (),
      _cameraTime      = Symbol (),
      _collisionTime   = Symbol (),
      _displayTime     = Symbol ();

   const contexts = [ ];

   function X3DBrowserContext (element)
   {
      X3DBaseNode                    .call (this, this);
      X3DRoutingContext              .call (this);
      X3DCoreContext                 .call (this, element);
      X3DScriptingContext            .call (this);
      X3DNetworkingContext           .call (this);
      X3DShadersContext              .call (this);
      X3DRenderingContext            .call (this);
      X3DShapeContext                .call (this);
      X3DGroupingContext             .call (this);
      X3DGeometry3DContext           .call (this);
      X3DPointingDeviceSensorContext .call (this);
      X3DNavigationContext           .call (this);
      X3DLayeringContext             .call (this);
      X3DEnvironmentalEffectsContext .call (this);
      X3DLightingContext             .call (this);
      X3DPickingContext              .call (this);
      X3DSoundContext                .call (this);
      X3DTextContext                 .call (this);
      X3DTexturingContext            .call (this);
      X3DTimeContext                 .call (this);

      for (const context of contexts)
         context .call (this);

      this .addChildObjects ("initialized",   new SFTime (),
                             "shutdown",      new SFTime (),
                             "prepareEvents", new SFTime (),
                             "timeEvents",    new SFTime (),
                             "sensorEvents",  new SFTime (),
                             "finished",      new SFTime ());

      this [_changedTime]     = 0;
      this [_previousTime]    = 0;
      this [_renderCallback]  = this .traverse .bind (this);
      this [_systemTime]      = 0;
      this [_systemStartTime] = 0;
      this [_browserTime]     = 0;
      this [_cameraTime]      = 0;
      this [_collisionTime]   = 0;
      this [_displayTime]     = 0;
   };

   X3DBrowserContext .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
      X3DRoutingContext .prototype,
      X3DCoreContext .prototype,
      X3DScriptingContext .prototype,
      X3DNetworkingContext .prototype,
      X3DShadersContext .prototype,
      X3DRenderingContext .prototype,
      X3DShapeContext .prototype,
      X3DGroupingContext .prototype,
      X3DGeometry3DContext .prototype,
      X3DPointingDeviceSensorContext .prototype,
      X3DNavigationContext .prototype,
      X3DLayeringContext .prototype,
      X3DEnvironmentalEffectsContext .prototype,
      X3DLightingContext .prototype,
      X3DPickingContext .prototype,
      X3DSoundContext .prototype,
      X3DTextContext .prototype,
      X3DTexturingContext .prototype,
      X3DTimeContext .prototype,
   {
      constructor: X3DBrowserContext,
      initialize: function ()
      {
         X3DBaseNode                    .prototype .initialize .call (this);
         X3DRoutingContext              .prototype .initialize .call (this);
         X3DCoreContext                 .prototype .initialize .call (this);
         X3DScriptingContext            .prototype .initialize .call (this);
         X3DNetworkingContext           .prototype .initialize .call (this);
         X3DShadersContext              .prototype .initialize .call (this);
         X3DRenderingContext            .prototype .initialize .call (this);
         X3DShapeContext                .prototype .initialize .call (this);
         X3DGroupingContext             .prototype .initialize .call (this);
         X3DGeometry3DContext           .prototype .initialize .call (this);
         X3DPointingDeviceSensorContext .prototype .initialize .call (this);
         X3DNavigationContext           .prototype .initialize .call (this);
         X3DLayeringContext             .prototype .initialize .call (this);
         X3DEnvironmentalEffectsContext .prototype .initialize .call (this);
         X3DLightingContext             .prototype .initialize .call (this);
         X3DPickingContext              .prototype .initialize .call (this);
         X3DSoundContext                .prototype .initialize .call (this);
         X3DTextContext                 .prototype .initialize .call (this);
         X3DTexturingContext            .prototype .initialize .call (this);
         X3DTimeContext                 .prototype .initialize .call (this);

         for (const context of contexts)
         {
            if (context .prototype .initialize)
               context .prototype .initialize .call (this);
         }
      },
      initialized: function ()
      {
         return this ._initialized;
      },
      shutdown: function ()
      {
         return this ._shutdown;
      },
      prepareEvents: function ()
      {
         return this ._prepareEvents;
      },
      timeEvents: function ()
      {
         return this ._timeEvents;
      },
      sensorEvents: function ()
      {
         return this ._sensorEvents;
      },
      finished: function ()
      {
         return this ._finished;
      },
      getBrowser: function ()
      {
         return this;
      },
      getWorld: function ()
      {
         return this [_world];
      },
      setExecutionContext: function (executionContext)
      {
         this [_world] = new X3DWorld (executionContext);
         this [_world] .setup ();
      },
      getExecutionContext: function ()
      {
         return this [_world] .getExecutionContext ();
      },
      addBrowserEvent: function ()
      {
         if (this [_changedTime] === this .getCurrentTime ())
            return;

         this [_changedTime] = this .getCurrentTime ();

         requestAnimationFrame (this [_renderCallback]);
      },
      limitFrameRate: function (now)
      {
         if (now === this [_previousTime])
         {
            requestAnimationFrame (this [_renderCallback]);

            return true;
         }
         else
         {
            this [_previousTime] = now;

            return false;
         }
      },
      traverse: function (now)
      {
         // Limit frame rate.

         if (this .limitFrameRate (now))
            return;

         // Start rendering.

         const gl = this .getContext ();

         const t0 = performance .now ();
         this [_systemTime] = t0 - this [_systemStartTime];
         this .advanceTime (now);

         this ._prepareEvents .processInterests ();
         this .processEvents ();

         this ._timeEvents .processInterests ();
         this .processEvents ();

         const t1 = performance .now ();
         this [_world] .traverse (TraverseType .CAMERA, null);
         this [_cameraTime] = performance .now () - t1;

         const t2 = performance .now ();
         if (this .getCollisionCount ())
            this [_world] .traverse (TraverseType .COLLISION, null);
         this [_collisionTime] = performance .now () - t2;

         this ._sensorEvents .processInterests ();
         this .processEvents ();

         const t3 = performance .now ();
         gl .clearColor (0, 0, 0, 0);
         gl .clear (gl .COLOR_BUFFER_BIT);
         this [_world] .traverse (TraverseType .DISPLAY, null);
         this [_displayTime] = performance .now () - t3;

         this [_browserTime]     = performance .now () - t0;
         this [_systemStartTime] = performance .now ();

         this ._finished .processInterests ();
      },
      getSystemTime: function ()
      {
         return this [_systemTime];
      },
      getBrowserTime: function ()
      {
         return this [_browserTime];
      },
      getCameraTime: function ()
      {
         return this [_cameraTime];
      },
      getCollisionTime: function ()
      {
         return this [_collisionTime];
      },
      getDisplayTime: function ()
      {
         return this [_displayTime];
      },
   });

   for (const key of Reflect .ownKeys (X3DBrowserContext .prototype))
      Object .defineProperty (X3DBrowserContext .prototype, key, { enumerable: false });

   Object .assign (X3DBrowserContext,
   {
      addContext: function (context)
      {
         const X3D = require ("x_ite/X3D");

         contexts .push (context);

         for (const key of Object .keys (context .prototype) .concat (Object .getOwnPropertySymbols (context .prototype)))
         {
            if (X3DBrowserContext .prototype .hasOwnProperty (key))
               continue;

            Object .defineProperty (X3DBrowserContext .prototype, key,
            {
               value: context .prototype [key],
               enumerable: false,
               writable: true,
            });
         }

         $("x3d-canvas, X3DCanvas") .each (function (i, canvas)
         {
            const browser = X3D .getBrowser (canvas);

            context .call (browser);

            if (context .prototype .initialize)
               context .prototype .initialize .call (browser);
         });
      },
   });

   return X3DBrowserContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DMetadataObject',[
   "x_ite/Base/X3DConstants",
],
function (X3DConstants)
{
"use strict";

   function X3DMetadataObject (executionContext)
   {
      this .addType (X3DConstants .X3DMetadataObject);
   }

   X3DMetadataObject .prototype =
   {
      constructor: X3DMetadataObject,
      initialize: function () { },
   };

   return X3DMetadataObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataBoolean',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataBoolean (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataBoolean);
   }

   MetadataBoolean .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataBoolean,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFBool ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataBoolean";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataBoolean;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataDouble',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataDouble (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataDouble);
   }

   MetadataDouble .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataDouble,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFDouble ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataDouble";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataDouble;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataFloat',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataFloat (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataFloat);
   }

   MetadataFloat .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataFloat,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataFloat";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataFloat;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataInteger',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataInteger (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataInteger);
   }

   MetadataInteger .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataInteger,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFInt32 ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataInteger";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataInteger;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataSet (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataSet);
   }

   MetadataSet .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataSet";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataString',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DMetadataObject,
          X3DConstants)
{
"use strict";

   function MetadataString (executionContext)
   {
      X3DNode           .call (this, executionContext);
      X3DMetadataObject .call (this, executionContext);

      this .addType (X3DConstants .MetadataString);
   }

   MetadataString .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DMetadataObject .prototype,
   {
      constructor: MetadataString,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFString ()),
      ]),
      getTypeName: function ()
      {
         return "MetadataString";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "metadata";
      },
   });

   return MetadataString;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DInfoNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DInfoNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DInfoNode);
   }

   X3DInfoNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DInfoNode,
   });

   return X3DInfoNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/WorldInfo',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DInfoNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInfoNode,
          X3DConstants)
{
"use strict";

   function WorldInfo (executionContext)
   {
      X3DInfoNode .call (this, executionContext);

      this .addType (X3DConstants .WorldInfo);
   }

   WorldInfo .prototype = Object .assign (Object .create (X3DInfoNode .prototype),
   {
      constructor: WorldInfo,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "title",    new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "info",     new Fields .MFString ()),
      ]),
      getTypeName: function ()
      {
         return "WorldInfo";
      },
      getComponentName: function ()
      {
         return "Core";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInfoNode .prototype .initialize .call (this);

         this .getExecutionContext () .addWorldInfo (this);
      },
      dispose: function ()
      {
         this .getExecutionContext () .removeWorldInfo (this);

         X3DInfoNode .prototype .dispose .call (this);
      },
   });

   return WorldInfo;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Core/MetadataBoolean",
   "x_ite/Components/Core/MetadataDouble",
   "x_ite/Components/Core/MetadataFloat",
   "x_ite/Components/Core/MetadataInteger",
   "x_ite/Components/Core/MetadataSet",
   "x_ite/Components/Core/MetadataString",
   "x_ite/Components/Core/WorldInfo",
   "x_ite/Components/Core/X3DBindableNode",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Core/X3DInfoNode",
   "x_ite/Components/Core/X3DMetadataObject",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Core/X3DPrototypeInstance",
   "x_ite/Components/Core/X3DSensorNode",
],
function (SupportedNodes,
          MetadataBoolean,
          MetadataDouble,
          MetadataFloat,
          MetadataInteger,
          MetadataSet,
          MetadataString,
          WorldInfo,
          X3DBindableNode,
          X3DChildNode,
          X3DInfoNode,
          X3DMetadataObject,
          X3DNode,
          X3DPrototypeInstance,
          X3DSensorNode)
{
"use strict";

   const Types =
   {
      MetadataBoolean: MetadataBoolean,
      MetadataDouble:  MetadataDouble,
      MetadataFloat:   MetadataFloat,
      MetadataInteger: MetadataInteger,
      MetadataSet:     MetadataSet,
      MetadataString:  MetadataString,
      WorldInfo:       WorldInfo,
   };

   const AbstractTypes =
   {
      X3DBindableNode:      X3DBindableNode,
      X3DChildNode:         X3DChildNode,
      X3DInfoNode:          X3DInfoNode,
      X3DMetadataObject:    X3DMetadataObject,
      X3DNode:              X3DNode,
      X3DPrototypeInstance: X3DPrototypeInstance,
      X3DSensorNode:        X3DSensorNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/FogCoordinate',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

   function FogCoordinate (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .FogCoordinate);

      this ._depth .setUnit ("length");
   }

   FogCoordinate .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: FogCoordinate,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "depth",    new Fields .MFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "FogCoordinate";
      },
      getComponentName: function ()
      {
         return "EnvironmentalEffects";
      },
      getContainerField: function ()
      {
         return "fogCoord";
      },
      initialize: function ()
      {
         X3DGeometricPropertyNode .prototype .initialize .call (this);

         this ._depth .addInterest ("set_depth__", this);

         this .set_depth__ ();
      },
      set_depth__: function ()
      {
         this .depth  = this ._depth .getValue ();
         this .length = this ._depth .length;
      },
      isEmpty: function ()
      {
         return this .length === 0;
      },
      getSize: function ()
      {
         return this .length;
      },
      addDepth: function (index, array)
      {
         if (index < this .length)
            array .push (this .depth [index]);

         else if (this .length)
            array .push (this .depth [this .length - 1]);

         else
            array .push (0);
      },
      addDepths: function (array, min)
      {
         const length = this .length;

         if (length)
         {
            const depth = this .depth;

            for (let index = 0; index < length; ++ index)
               array .push (depth [index]);

            const last = depth [length - 1];

            for (let index = length; index < min; ++ index)
               array .push (last);
         }
         else
         {
            for (let index = 0; index < min; ++ index)
               array .push (0);
         }
      },
   });

   return FogCoordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/LocalFog',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/EnvironmentalEffects/X3DFogObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DFogObject,
          X3DConstants)
{
"use strict";

   function LocalFog (executionContext)
   {
      X3DChildNode .call (this, executionContext);
      X3DFogObject .call (this, executionContext);

      this .addType (X3DConstants .LocalFog);
   }

   LocalFog .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DFogObject .prototype,
   {
      constructor: LocalFog,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fogType",         new Fields .SFString ("LINEAR")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",           new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityRange", new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "LocalFog";
      },
      getComponentName: function ()
      {
         return "EnvironmentalEffects";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);
         X3DFogObject .prototype .initialize .call (this);
      },
      push: function (renderObject)
      {
         if (this ._enabled .getValue ())
         {
            const fogContainer = this .getFogs () .pop ();

            fogContainer .set (this, renderObject .getModelViewMatrix () .get ());

            renderObject .pushLocalFog (fogContainer);
         }
      },
      pop: function (renderObject)
      {
         if (this ._enabled .getValue ())
            renderObject .getBrowser () .getLocalObjects () .push (renderObject .popLocalFog ());
      },
   });

   return LocalFog;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/TextureBackground',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBackgroundNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function TextureBackground (executionContext)
   {
      X3DBackgroundNode .call (this, executionContext);

      this .addType (X3DConstants .TextureBackground);
   }

   TextureBackground .prototype = Object .assign (Object .create (X3DBackgroundNode .prototype),
   {
      constructor: TextureBackground,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",      new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "skyAngle",      new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "skyColor",      new Fields .MFColor (new Fields .SFColor ())),
         new X3DFieldDefinition (X3DConstants .inputOutput, "groundAngle",   new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "groundColor",   new Fields .MFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",       new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",      new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "frontTexture",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backTexture",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "leftTexture",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "rightTexture",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "topTexture",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "bottomTexture", new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "TextureBackground";
      },
      getComponentName: function ()
      {
         return "EnvironmentalEffects";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DBackgroundNode .prototype .initialize .call (this);

         this ._frontTexture  .addInterest ("set_frontTexture__", this);
         this ._backTexture   .addInterest ("set_backTexture__", this);
         this ._leftTexture   .addInterest ("set_leftTexture__", this);
         this ._rightTexture  .addInterest ("set_rightTexture__", this);
         this ._topTexture    .addInterest ("set_topTexture__", this);
         this ._bottomTexture .addInterest ("set_bottomTexture__", this);

         this .set_frontTexture__  (this ._frontTexture);
         this .set_backTexture__   (this ._backTexture);
         this .set_leftTexture__   (this ._leftTexture);
         this .set_rightTexture__  (this ._rightTexture);
         this .set_topTexture__    (this ._topTexture);
         this .set_bottomTexture__ (this ._bottomTexture);
      },
      set_frontTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_frontTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._frontTexture));
      },
      set_backTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_backTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._backTexture));
      },
      set_leftTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_leftTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._leftTexture));
      },
      set_rightTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_rightTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._rightTexture));
      },
      set_topTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_topTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._topTexture));
      },
      set_bottomTexture__: function ()
      {
         X3DBackgroundNode .prototype .set_bottomTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this ._bottomTexture));
      },
   });

   return TextureBackground;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/EnvironmentalEffects/Background",
   "x_ite/Components/EnvironmentalEffects/Fog",
   "x_ite/Components/EnvironmentalEffects/FogCoordinate",
   "x_ite/Components/EnvironmentalEffects/LocalFog",
   "x_ite/Components/EnvironmentalEffects/TextureBackground",
   "x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
   "x_ite/Components/EnvironmentalEffects/X3DFogObject",
],
function (SupportedNodes,
          Background,
          Fog,
          FogCoordinate,
          LocalFog,
          TextureBackground,
          X3DBackgroundNode,
          X3DFogObject)
{
"use strict";

   const Types =
   {
      Background:        Background,
      Fog:               Fog,
      FogCoordinate:     FogCoordinate,
      LocalFog:          LocalFog,
      TextureBackground: TextureBackground,
   };

   const AbstractTypes =
   {
      X3DBackgroundNode: X3DBackgroundNode,
      X3DFogObject:      X3DFogObject,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DSensorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DSensorNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function X3DEnvironmentalSensorNode (executionContext)
   {
      X3DSensorNode .call (this, executionContext);

      this .addType (X3DConstants .X3DEnvironmentalSensorNode);

      this .addChildObjects ("traversed", new Fields .SFBool (true));

      this ._size   .setUnit ("length");
      this ._center .setUnit ("length");

      this .zeroTest         = false;
      this .currentTraversed = true;
   }

   X3DEnvironmentalSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
   {
      constructor: X3DEnvironmentalSensorNode,
      initialize: function ()
      {
         X3DSensorNode .prototype .initialize .call (this);

         this .isLive () .addInterest ("set_live__", this);

         this ._enabled   .addInterest ("set_live__", this);
         this ._size      .addInterest ("set_live__", this);
         this ._traversed .addInterest ("set_live__", this);

         this .set_live__ ();
      },
      set_live__: function ()
      {
         if (this ._traversed .getValue () && this .isLive () .getValue () && this ._enabled .getValue () && ! (this .zeroTest && this ._size. getValue () .equals (Vector3 .Zero)))
         {
            this .getBrowser () .sensorEvents () .addInterest ("update", this);
         }
         else
         {
            this .getBrowser () .sensorEvents () .removeInterest ("update", this);

            if (this ._isActive .getValue ())
            {
               this ._isActive = false;
               this ._exitTime = this .getBrowser () .getCurrentTime ();
            }
         }
      },
      setZeroTest: function (value)
      {
         this .zeroTest = value;
      },
      getZeroTest: function ()
      {
         return this .zeroTest;
      },
      setTraversed: function (value)
      {
         if (value)
         {
            if (this ._traversed .getValue () === false)
               this ._traversed = true;
         }
         else
         {
            if (this .currentTraversed !== this ._traversed .getValue ())
               this ._traversed = this .currentTraversed;
         }

         this .currentTraversed = value;
      },
      getTraversed: function ()
      {
         return this .currentTraversed;
      },
      update: function () { },
   });

   return X3DEnvironmentalSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/ProximitySensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

   function ProximitySensor (executionContext)
   {
      X3DEnvironmentalSensorNode .call (this, executionContext);

      this .addType (X3DConstants .ProximitySensor);

      this .setCameraObject (true);

      this ._centerOfRotation_changed .setUnit ("length");
      this ._position_changed         .setUnit ("length");

      this .setZeroTest (true);

      this .min           = new Vector3 (0, 0, 0);
      this .max           = new Vector3 (0, 0, 0);
      this .viewpointNode = null;
      this .modelMatrix   = new Matrix4 ();
      this .inside        = false;
   }

   ProximitySensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
   {
      constructor: ProximitySensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                 new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",                  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "size",                     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "center",                   new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime",                new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",                 new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",                 new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "position_changed",         new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "orientation_changed",      new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "centerOfRotation_changed", new Fields .SFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "ProximitySensor";
      },
      getComponentName: function ()
      {
         return "EnvironmentalSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DEnvironmentalSensorNode .prototype .initialize .call (this);

         this ._enabled .addInterest ("set_enabled__", this);
         this ._size    .addInterest ("set_extents__", this);
         this ._center  .addInterest ("set_extents__", this);

         this ._traversed .addFieldInterest (this ._isCameraObject);

         this .set_enabled__ ();
         this .set_extents__ ();
      },
      set_enabled__: function ()
      {
         this .setCameraObject (this ._enabled .getValue ());

         if (this ._enabled .getValue ())
            delete this .traverse;
         else
            this .traverse = Function .prototype;
      },
      set_extents__: function ()
      {
         const
            s  = this ._size .getValue (),
            c  = this ._center .getValue (),
            sx = s .x / 2,
            sy = s .y / 2,
            sz = s .z / 2,
            cx = c .x,
            cy = c .y,
            cz = c .z;

         this .min .set (cx - sx, cy - sy, cz - sz);
         this .max .set (cx + sx, cy + sy, cz + sz);
      },
      update: (function ()
      {
         const
            invModelMatrix         = new Matrix4 (),
            centerOfRotationMatrix = new Matrix4 (),
            position               = new Vector3 (0, 0, 0),
            orientation            = new Rotation4 (0, 0, 1, 0),
            centerOfRotation       = new Vector3 (0, 0, 0);

         return function ()
         {
            if (this .inside && this .getTraversed ())
            {
               if (this .viewpointNode)
               {
                  const modelMatrix = this .modelMatrix;

                  centerOfRotationMatrix .assign (this .viewpointNode .getModelMatrix ());
                  centerOfRotationMatrix .translate (this .viewpointNode .getUserCenterOfRotation ());
                  centerOfRotationMatrix .multRight (invModelMatrix .assign (modelMatrix) .inverse ());

                  modelMatrix .multRight (this .viewpointNode .getViewMatrix ());
                  modelMatrix .get (null, orientation);
                  modelMatrix .inverse ();

                  position .set (modelMatrix [12], modelMatrix [13], modelMatrix [14]);

                  orientation .inverse ();

                  centerOfRotation .set (centerOfRotationMatrix [12], centerOfRotationMatrix [13], centerOfRotationMatrix [14]);

                  if (this ._isActive .getValue ())
                  {
                     if (! this ._position_changed .getValue () .equals (position))
                        this ._position_changed = position;

                     if (! this ._orientation_changed .getValue () .equals (orientation))
                        this ._orientation_changed = orientation;

                     if (! this ._centerOfRotation_changed .getValue () .equals (centerOfRotation))
                        this ._centerOfRotation_changed = centerOfRotation;
                  }
                  else
                  {
                     this ._isActive                 = true;
                     this ._enterTime                = this .getBrowser () .getCurrentTime ();
                     this ._position_changed         = position;
                     this ._orientation_changed      = orientation;
                     this ._centerOfRotation_changed = centerOfRotation;
                  }
               }
            }
            else
            {
               if (this ._isActive .getValue ())
               {
                  this ._isActive = false;
                  this ._exitTime = this .getBrowser () .getCurrentTime ();
               }
            }

            this .inside        = false;
            this .viewpointNode = null;

            this .setTraversed (false);
         };
      })(),
      traverse: (function ()
      {
         const
            invModelViewMatrix = new Matrix4 (),
            infinity           = new Vector3 (-1, -1, -1);

         return function (type, renderObject)
         {
            switch (type)
            {
               case TraverseType .CAMERA:
               {
                  this .viewpointNode = renderObject .getViewpoint ();
                  this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
                  return;
               }
               case TraverseType .DISPLAY:
               {
                  this .setTraversed (true);

                  if (this .inside)
                     return;

                  if (this ._size .getValue () .equals (infinity))
                  {
                     this .inside = true;
                  }
                  else
                  {
                     invModelViewMatrix .assign (renderObject .getModelViewMatrix () .get ()) .inverse ();

                     this .inside = this .containsPoint (invModelViewMatrix .origin);
                  }

                  return;
               }
            }
         };
      })(),
      containsPoint: function (point)
      {
         const
            min = this .min,
            max = this .max;

         return min .x <= point .x &&
                max .x >= point .x &&
                min .y <= point .y &&
                max .y >= point .y &&
                min .z <= point .z &&
                max .z >= point .z;
      },
   });

   return ProximitySensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/TransformSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          ObjectCache)
{
"use strict";

   const
      ModelMatrixCache  = ObjectCache (Matrix4),
      TargetMatrixCache = ObjectCache (Matrix4);

   function TransformSensor (executionContext)
   {
      X3DEnvironmentalSensorNode .call (this, executionContext);

      this .addType (X3DConstants .TransformSensor);

      this ._position_changed .setUnit ("length");

      this .setZeroTest (true);

      this .min              = new Vector3 ();
      this .max              = new Vector3 ();
      this .targetObjectNode = null;
      this .modelMatrices    = [ ];
      this .targetMatrices   = [ ];
   }

   TransformSensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
   {
      constructor: TransformSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "size",                new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "center",              new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime",           new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",            new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "position_changed",    new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "orientation_changed", new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "targetObject",        new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "TransformSensor";
      },
      getComponentName: function ()
      {
         return "EnvironmentalSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DEnvironmentalSensorNode .prototype .initialize .call (this);

         this .isLive () .addInterest ("set_enabled__", this);

         this ._enabled      .addInterest ("set_enabled__",      this);
         this ._size         .addInterest ("set_enabled__",      this);
         this ._size         .addInterest ("set_extents__",      this);
         this ._center       .addInterest ("set_extents__",      this);
         this ._targetObject .addInterest ("set_targetObject__", this);

         this .set_extents__ ();
         this .set_targetObject__ ();
      },
      set_live__: function ()
      { },
      set_enabled__: function ()
      {
         if (this .isLive () .getValue () && this .targetObjectNode && this ._enabled .getValue () && ! this ._size. getValue () .equals (Vector3 .Zero))
         {
            this .setPickableObject (true);
            this .getBrowser () .addTransformSensor (this);
            this .targetObjectNode .addTransformSensor (this);
         }
         else
         {
            this .setPickableObject (false);
            this .getBrowser () .removeTransformSensor (this);

            if (this .targetObjectNode)
               this .targetObjectNode .removeTransformSensor (this);

            if (this ._isActive .getValue ())
            {
               this ._isActive = false;
               this ._exitTime = this .getBrowser () .getCurrentTime ();
            }
         }
      },
      set_extents__: function ()
      {
         const
            s  = this ._size .getValue (),
            c  = this ._center .getValue (),
            sx = s .x / 2,
            sy = s .y / 2,
            sz = s .z / 2,
            cx = c .x,
            cy = c .y,
            cz = c .z;

         this .min .set (cx - sx, cy - sy, cz - sz);
         this .max .set (cx + sx, cy + sy, cz + sz);
      },
      set_targetObject__: function ()
      {
         this .targetObjectNode = null;

         try
         {
            const
               node = this ._targetObject .getValue () .getInnerNode (),
               type = node .getType ();

            for (let t = type .length - 1; t >= 0; -- t)
            {
               switch (type [t])
               {
                  case X3DConstants .X3DGroupingNode:
                  case X3DConstants .X3DShapeNode:
                  {
                     this .targetObjectNode = node;
                     break;
                  }
                  default:
                     continue;
               }

               break;
            }
         }
         catch (error)
         { }

         this .set_enabled__ ();
      },
      traverse: function (type, renderObject)
      {
         // TransformSensor nodes are sorted out and only traversed during PICKING, except if is child of a LOD or Switch node.

         if (type !== TraverseType .PICKING)
            return;

         if (this .getPickableObject ())
            this .modelMatrices .push (ModelMatrixCache .pop () .assign (renderObject .getModelViewMatrix () .get ()));
      },
      collect: function (targetMatrix)
      {
         this .targetMatrices .push (TargetMatrixCache .pop () .assign (targetMatrix));
      },
      process: (function ()
      {
         const
            position    = new Vector3 (0, 0, 0),
            orientation = new Rotation4 (0, 0, 1, 0);

         return function ()
         {
            const
               modelMatrices  = this .modelMatrices,
               targetMatrices = this .targetMatrices,
               matrix         = this .intersects ();

            if (matrix)
            {
               matrix .get (position, orientation);

               if (this ._isActive .getValue ())
               {
                  if (! this ._position_changed .getValue () .equals (position))
                     this ._position_changed = position;

                  if (! this ._orientation_changed .getValue () .equals (orientation))
                     this ._orientation_changed = orientation;
               }
               else
               {
                  this ._isActive            = true;
                  this ._enterTime           = this .getBrowser () .getCurrentTime ();
                  this ._position_changed    = position;
                  this ._orientation_changed = orientation;
               }
            }
            else
            {
               if (this ._isActive .getValue ())
               {
                  this ._isActive = false;
                  this ._exitTime = this .getBrowser () .getCurrentTime ();
               }
            }

            for (const modelMatrix of modelMatrices)
               ModelMatrixCache .push (modelMatrix);

            for (const targetMatrix of targetMatrices)
               TargetMatrixCache .push (targetMatrix);

            modelMatrices  .length = 0;
            targetMatrices .length = 0;
         };
      })(),
      intersects: (function ()
      {
         const infinity = new Vector3 (-1, -1, -1);

         return function ()
         {
            const
               modelMatrices  = this .modelMatrices,
               targetMatrices = this .targetMatrices,
               always         = this ._size .getValue () .equals (infinity);

            for (const modelMatrix of modelMatrices)
            {
               const invModelMatrix = modelMatrix .inverse ();

               for (const targetMatrix of targetMatrices)
               {
                  const matrix = targetMatrix .multRight (invModelMatrix);

                  if (always || this .containsPoint (matrix .origin))
                  {
                     return matrix;
                  }
               }
            }

            return null;
         };
      })(),
      containsPoint: function (point)
      {
         const
            min = this .min,
            max = this .max;

         return min .x <= point .x &&
                max .x >= point .x &&
                min .y <= point .y &&
                max .y >= point .y &&
                min .z <= point .z &&
                max .z >= point .z;
      },
   });

   return TransformSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/VisibilitySensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Geometry/Box3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode,
          TraverseType,
          X3DConstants,
          Vector3,
          Box3)
{
"use strict";

   function VisibilitySensor (executionContext)
   {
      X3DEnvironmentalSensorNode .call (this, executionContext);

      this .addType (X3DConstants .VisibilitySensor);

      this .setZeroTest (false);

      this .visible = false;
   }

   VisibilitySensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
   {
      constructor: VisibilitySensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",   new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "size",      new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "center",    new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime", new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",  new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",  new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "VisibilitySensor";
      },
      getComponentName: function ()
      {
         return "EnvironmentalSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DEnvironmentalSensorNode .prototype .initialize .call (this);

         this ._enabled .addInterest ("set_enabled__", this);

         this .set_enabled__ ();
      },
      set_enabled__: function ()
      {
         if (this ._enabled .getValue ())
            delete this .traverse;
         else
            this .traverse = Function .prototype;
      },
      update: function ()
      {
         if (this .visible && this .getTraversed ())
         {
            if (! this ._isActive .getValue ())
            {
               this ._isActive  = true;
               this ._enterTime = this .getBrowser () .getCurrentTime ();
            }

            this .visible = false;
         }
         else
         {
            if (this ._isActive .getValue ())
            {
               this ._isActive = false;
               this ._exitTime = this .getBrowser () .getCurrentTime ();
            }
         }

         this .setTraversed (false);
      },
      traverse: (function ()
      {
         const
            bbox     = new Box3 (),
            infinity = new Vector3 (-1, -1, -1);

         return function (type, renderObject)
         {
            if (type !== TraverseType .DISPLAY)
               return;

            this .setTraversed (true);

            if (this .visible)
               return;

            if (this ._size .getValue () .equals (infinity))
            {
               this .visible = true;
            }
            else
            {
               bbox
                  .set (this ._size .getValue (), this ._center .getValue ())
                  .multRight (renderObject .getModelViewMatrix () .get ());

               this .visible = renderObject .getViewVolume () .intersectsBox (bbox);
            }
         };
      })(),
   });

   return VisibilitySensor;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/EnvironmentalSensor/ProximitySensor",
   "x_ite/Components/EnvironmentalSensor/TransformSensor",
   "x_ite/Components/EnvironmentalSensor/VisibilitySensor",
   "x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
],
function (SupportedNodes,
          ProximitySensor,
          TransformSensor,
          VisibilitySensor,
          X3DEnvironmentalSensorNode)
{
"use strict";

   const Types =
   {
      ProximitySensor:  ProximitySensor,
      TransformSensor:  TransformSensor,
      VisibilitySensor: VisibilitySensor,
   };

   const AbstractTypes =
   {
      X3DEnvironmentalSensorNode: X3DEnvironmentalSensorNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ColorChaser',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Color3",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Color3,
          Vector3)
{
"use strict";

   var
      initialValue       = new Vector3 (0, 0, 0),
      initialDestination = new Vector3 (0, 0, 0),
      deltaOut           = new Vector3 (0, 0, 0),
      vector             = new Vector3 (0, 0, 0);

   function ColorChaser (executionContext)
   {
      X3DChaserNode .call (this, executionContext);

      this .addType (X3DConstants .ColorChaser);
   }

   ColorChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
   {
      constructor: ColorChaser,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFColor ()),
      ]),
      getTypeName: function ()
      {
         return "ColorChaser";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
      getValue: function ()
      {
         return this ._set_value .getValue () .getHSV (vector);
      },
      getDestination: function ()
      {
         return this ._set_destination .getValue () .getHSV (vector);
      },
      getInitialValue: function ()
      {
         return this ._initialValue .getValue () .getHSV (initialValue);
      },
      getInitialDestination: function ()
      {
         return this ._initialDestination .getValue () .getHSV (initialDestination);
      },
      setValue: function (value)
      {
         this ._value_changed .setHSV (value .x, value .y, value .z);
      },
      interpolate: function (source, destination, weight)
      {
         return Color3 .lerp (source, destination, weight, vector);
      },
      step: function (value1, value2, t)
      {
         deltaOut .assign (this .output) .add (value1) .subtract (value2);

         //step .x = Algorithm .interval (step .x, 0, 2 * Math .PI);

         Color3 .lerp (this .output, deltaOut, t, this .output);
      },
   });

   return ColorChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DDamperNode',[
   "x_ite/Components/Followers/X3DFollowerNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (X3DFollowerNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function X3DDamperNode (executionContext)
   {
      X3DFollowerNode .call (this, executionContext);

      this .addType (X3DConstants .X3DDamperNode);
   }

   X3DDamperNode .prototype = Object .assign (Object .create (X3DFollowerNode .prototype),
   {
      constructor: X3DDamperNode,
      initialize: function ()
      {
         X3DFollowerNode .prototype .initialize .call (this);

         this ._order           .addInterest ("set_order__", this);
         this ._set_value       .addInterest ("set_value__", this);
         this ._set_destination .addInterest ("set_destination__", this);

         var
            buffer             = this .getBuffer (),
            initialValue       = this .getInitialValue (),
            initialDestination = this .getInitialDestination ();

         buffer [0] = this .duplicate (initialDestination);

         for (var i = 1, length = this .getOrder () + 1; i < length; ++ i)
            buffer [i] = this .duplicate (initialValue);

         if (this .equals (initialDestination, initialValue, this .getTolerance ()))
            this .setValue (initialDestination);

         else
            this .set_active (true);
      },
      getOrder: function ()
      {
         return Algorithm .clamp (this ._order .getValue (), 0, 5);
      },
      getTolerance: function ()
      {
         if (this ._tolerance .getValue () < 0)
            return 1e-4;

         return this ._tolerance .getValue ();
      },
      prepareEvents: function ()
      {
         var
            buffer = this .getBuffer (),
            order  = buffer .length - 1;

         if (this ._tau .getValue ())
         {
            var
               delta = 1 / this .getBrowser () .currentFrameRate,
               alpha = Math .exp (-delta / this ._tau .getValue ());

            for (var i = 0; i < order; ++ i)
            {
               this .assign (buffer, i + 1, this .interpolate (buffer [i], buffer [i + 1], alpha));
            }

            this .setValue (buffer [order]);

            if (! this .equals (buffer [order], buffer [0], this .getTolerance ()))
               return;
         }
         else
         {
            this .setValue (buffer [0]);

            order = 0;
         }

         for (var i = 1, length = buffer .length; i < length; ++ i)
            this .assign (buffer, i, buffer [order]);

         this .set_active (false);
      },
      set_value__: function ()
      {
         var
            buffer = this .getBuffer (),
            value  = this .getValue ();

         for (var i = 1, length = buffer .length; i < length; ++ i)
            this .assign (buffer, i, value);

         this .setValue (value);

         this .set_active (true);
      },
      set_destination__: function ()
      {
         this .assign (this .getBuffer (), 0, this .getDestination ());

         this .set_active (true);
      },
      set_order__: function ()
      {
         var
            buffer = this .getBuffer (),
            value  = buffer [buffer .length - 1];

         for (var i = buffer .length, length = this .getOrder () + 1; i < length; ++ i)
            buffer [i] = this .duplicate (value);

         buffer .length = length;
      },
   });

   return X3DDamperNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ColorDamper',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Color3",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Color3,
          Vector3)
{
"use strict";

   var
      a                  = new Vector3 (0, 0, 0),
      initialValue       = new Vector3 (0, 0, 0),
      initialDestination = new Vector3 (0, 0, 0),
      vector             = new Vector3 (0, 0, 0);

   function ColorDamper (executionContext)
   {
      X3DDamperNode .call (this, executionContext);

      this .addType (X3DConstants .ColorDamper);
   }

   ColorDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
   {
      constructor: ColorDamper,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFColor ()),
      ]),
      getTypeName: function ()
      {
         return "ColorDamper";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
      getValue: function ()
      {
         return this ._set_value .getValue () .getHSV (vector);
      },
      getDestination: function ()
      {
         return this ._set_destination .getValue () .getHSV (vector);
      },
      getInitialValue: function ()
      {
         return this ._initialValue .getValue () .getHSV (initialValue);
      },
      getInitialDestination: function ()
      {
         return this ._initialDestination .getValue () .getHSV (initialDestination);
      },
      setValue: function (value)
      {
         this ._value_changed .setHSV (value .x, value .y, value .z);
      },
      equals: function (lhs, rhs, tolerance)
      {
         return a .assign (lhs) .subtract (rhs) .abs () < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return Color3 .lerp (source, destination, weight, vector);
      },
   });

   return ColorDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Followers/X3DArrayFollowerTemplate',[],function ()
{
"use strict";

   return function (Type)
   {
      function X3DArrayFollowerObject ()
      {
         this .array = this .getArray ();
         this .zero  = this .getVector ();
      }

      X3DArrayFollowerObject .prototype =
      {
         getArray: function ()
         {
            const array = [ ];

            array .assign = function (value)
            {
               if (Array .isArray (value))
               {
                  for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
                     this [i] .assign (value [i]);

                  for (var i = length, length = value .length; i < length; ++ i)
                     this [i] = value [i] .copy ();

                  this .length = length;
               }
               else
               {
                  for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
                     this [i] .assign (value [i] .getValue ());

                  for (var i = length, length = value .length; i < length; ++ i)
                     this [i] = value [i] .getValue () .copy ();

                  this .length = length;
               }
            };

            return array;
         },
         getValue: function ()
         {
            return this ._set_value;
         },
         getDestination: function ()
         {
            return this ._set_destination;
         },
         getInitialValue: function ()
         {
            return this ._initialValue;
         },
         getInitialDestination: function ()
         {
            return this ._initialDestination;
         },
         setValue: function (value)
         {
            if (Array .isArray (value))
            {
               const value_changed = this ._value_changed;

               for (var i = 0, length = value .length; i < length; ++ i)
                  value_changed [i] = value [i];

               value_changed .length = length;
            }
            else
            {
               this ._value_changed = value;
            }
         },
         duplicate: function (value)
         {
            const array = this .getArray ();

            array .assign (value);

            return array;
         },
         equals: function (lhs, rhs, tolerance)
         {
            if (lhs .length !== rhs .length)
               return false;

            const a = this .a;

            let distance = 0;

            for (let i = 0, length = lhs .length; i < length; ++ i)
              distance = Math .max (a .assign (lhs [i]) .subtract (rhs [i]) .abs ());

            return distance < tolerance;
         },
         interpolate: function (source, destination, weight)
         {
            const array = this .array;

            array .assign (source);

            for (let i = 0, length = array .length; i < length; ++ i)
               array [i] .lerp (destination [i] || this .zero, weight);

            return array;
         },
         set_destination__: function ()
         {
            const
               buffers = this .getBuffer (),
               l       = this ._set_destination .length;

            for (let i = 0, length = buffers .length; i < length; ++ i)
            {
               const buffer = buffers [i];

               for (let b = buffer .length; b < l; ++ b)
                  buffer [b] = this .getVector ();

               buffer .length = l;
            }

            Type .prototype .set_destination__ .call (this);
         },
      };

      return X3DArrayFollowerObject;
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Followers/X3DArrayChaserTemplate',[
   "x_ite/Browser/Followers/X3DArrayFollowerTemplate",
],
function (X3DArrayFollowerTemplate)
{
"use strict";

   return function (Type)
   {
      const X3DArrayFollower = X3DArrayFollowerTemplate (Type);

      function X3DArrayChaserObject ()
      {
         X3DArrayFollower .call (this);

         this .array = this .getArray ();
      }

      Object .assign (X3DArrayChaserObject .prototype,
         X3DArrayFollower .prototype,
      {
         step: function (value1, value2, t)
         {
            const
               output   = this .output,
               deltaOut = this .deltaOut;

            for (let i = 0, length = output .length; i < length; ++ i)
               output [i] .add (deltaOut .assign (value1 [i] || this .zero) .subtract (value2 [i] || this .zero) .multiply (t));
         },
      });

      return X3DArrayChaserObject;
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/CoordinateChaser',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Browser/Followers/X3DArrayChaserTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DArrayChaserTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

   var X3DArrayChaserObject = X3DArrayChaserTemplate (X3DChaserNode);

   function CoordinateChaser (executionContext)
   {
      X3DChaserNode        .call (this, executionContext);
      X3DArrayChaserObject .call (this, executionContext);

      this .addType (X3DConstants .CoordinateChaser);
   }

   CoordinateChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
      X3DArrayChaserObject .prototype,
   {
      constructor: CoordinateChaser,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec3f (new Vector3 (0, 0, 0))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec3f (new Vector3 (0, 0, 0))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "CoordinateChaser";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
   });

   return CoordinateChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/CoordinateDamper',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Browser/Followers/X3DArrayFollowerTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DArrayFollowerTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

   var X3DArrayFollowerObject = X3DArrayFollowerTemplate (X3DDamperNode);

   function CoordinateDamper (executionContext)
   {
      X3DDamperNode          .call (this, executionContext);
      X3DArrayFollowerObject .call (this, executionContext);

      this .addType (X3DConstants .CoordinateDamper);
   }

   CoordinateDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
      X3DArrayFollowerObject .prototype,
   {
      constructor: CoordinateDamper,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec3f (new Vector3 (0, 0, 0))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec3f (new Vector3 (0, 0, 0))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "CoordinateDamper";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
   });

   return CoordinateDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/OrientationDamper',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Rotation4)
{
"use strict";

   var
      a        = new Rotation4 (0, 0, 1, 0),
      rotation = new Rotation4 (0, 0, 1, 0);

   function OrientationDamper (executionContext)
   {
      X3DDamperNode .call (this, executionContext);

      this .addType (X3DConstants .OrientationDamper);

      this ._set_value          .setUnit ("angle");
      this ._set_destination    .setUnit ("angle");
      this ._initialValue       .setUnit ("angle");
      this ._initialDestination .setUnit ("angle");
      this ._value_changed      .setUnit ("angle");
   }

   OrientationDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
   {
      constructor: OrientationDamper,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFRotation ()),
      ]),
      getTypeName: function ()
      {
         return "OrientationDamper";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Rotation4 (0, 0, 1, 0);
      },
      equals: function (lhs, rhs, tolerance)
      {
         a .assign (lhs) .inverse () .multRight (rhs);

         return Math .abs (a .angle) < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return rotation .assign (source) .slerp (destination, weight);
      },
   });

   return OrientationDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionChaser2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Vector2)
{
"use strict";

   function PositionChaser2D (executionContext)
   {
      X3DChaserNode .call (this, executionContext);

      this .addType (X3DConstants .PositionChaser2D);
   }

   PositionChaser2D .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
   {
      constructor: PositionChaser2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "PositionChaser2D";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector2 (0, 0);
      },
   });

   return PositionChaser2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionDamper',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function PositionDamper (executionContext)
   {
      X3DDamperNode .call (this, executionContext);

      this .addType (X3DConstants .PositionDamper);
   }

   PositionDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
   {
      constructor: PositionDamper,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "PositionDamper";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector3 (0, 0, 0);
      },
   });

   return PositionDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionDamper2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Vector2)
{
"use strict";

   function PositionDamper2D (executionContext)
   {
      X3DDamperNode .call (this, executionContext);

      this .addType (X3DConstants .PositionDamper2D);
   }

   PositionDamper2D .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
   {
      constructor: PositionDamper2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "PositionDamper2D";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector2 (0, 0);
      },
   });

   return PositionDamper2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ScalarChaser',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function ScalarChaser (executionContext)
   {
      X3DChaserNode .call (this, executionContext);

      this .addType (X3DConstants .ScalarChaser);
   }

   ScalarChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
   {
      constructor: ScalarChaser,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "ScalarChaser";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return 0;
      },
      setPreviousValue: function (value)
      {
         this .previousValue = value;
      },
      setDestination: function (value)
      {
         this .destination = value;
      },
      duplicate: function (value)
      {
         return value;
      },
      assign: function (buffer, i, value)
      {
         buffer [i] = value;
      },
      equals: function (lhs, rhs, tolerance)
      {
         return Math .abs (lhs - rhs) < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return Algorithm .lerp (source, destination, weight);
      },
      step: function (value1, value2, t)
      {
         this .output += (value1 - value2) * t;
      },
   });

   return ScalarChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ScalarDamper',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function ScalarDamper (executionContext)
   {
      X3DDamperNode .call (this, executionContext);

      this .addType (X3DConstants .ScalarDamper);
   }

   ScalarDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
   {
      constructor: ScalarDamper,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "ScalarDamper";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return 0;
      },
      duplicate: function (value)
      {
         return value;
      },
      assign: function (buffer, i, value)
      {
         buffer [i] = value;
      },
      equals: function (lhs, rhs, tolerance)
      {
         return Math .abs (lhs - rhs) < tolerance;
      },
      interpolate: function (source, destination, weight)
      {
         return Algorithm .lerp (source, destination, weight);
      },
   });

   return ScalarDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/TexCoordChaser2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Browser/Followers/X3DArrayChaserTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DArrayChaserTemplate,
          X3DConstants,
          Vector2)
{
"use strict";

   var X3DArrayChaserObject = X3DArrayChaserTemplate (X3DChaserNode);

   function TexCoordChaser2D (executionContext)
   {
      X3DChaserNode        .call (this, executionContext);
      X3DArrayChaserObject .call (this, executionContext);

      this .addType (X3DConstants .TexCoordChaser2D);
   }

   TexCoordChaser2D .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
      X3DArrayChaserObject .prototype,
   {
      constructor: TexCoordChaser2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "TexCoordChaser2D";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector2 (0, 0);
      },
   });

   return TexCoordChaser2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/TexCoordDamper2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Browser/Followers/X3DArrayFollowerTemplate",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DArrayFollowerTemplate,
          X3DConstants,
          Vector2)
{
"use strict";

   var X3DArrayFollowerObject = X3DArrayFollowerTemplate (X3DDamperNode);

   function TexCoordDamper2D (executionContext)
   {
      X3DDamperNode          .call (this, executionContext);
      X3DArrayFollowerObject .call (this, executionContext);

      this .addType (X3DConstants .TexCoordDamper2D);
   }

   TexCoordDamper2D .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
      X3DArrayFollowerObject .prototype,
   {
      constructor: TexCoordDamper2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "TexCoordDamper2D";
      },
      getComponentName: function ()
      {
         return "Followers";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getVector: function ()
      {
         return new Vector2 (0, 0, 0);
      },
   });

   return TexCoordDamper2D;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Followers/ColorChaser",
   "x_ite/Components/Followers/ColorDamper",
   "x_ite/Components/Followers/CoordinateChaser",
   "x_ite/Components/Followers/CoordinateDamper",
   "x_ite/Components/Followers/OrientationChaser",
   "x_ite/Components/Followers/OrientationDamper",
   "x_ite/Components/Followers/PositionChaser",
   "x_ite/Components/Followers/PositionChaser2D",
   "x_ite/Components/Followers/PositionDamper",
   "x_ite/Components/Followers/PositionDamper2D",
   "x_ite/Components/Followers/ScalarChaser",
   "x_ite/Components/Followers/ScalarDamper",
   "x_ite/Components/Followers/TexCoordChaser2D",
   "x_ite/Components/Followers/TexCoordDamper2D",
   "x_ite/Components/Followers/X3DChaserNode",
   "x_ite/Components/Followers/X3DDamperNode",
   "x_ite/Components/Followers/X3DFollowerNode",
],
function (SupportedNodes,
          ColorChaser,
          ColorDamper,
          CoordinateChaser,
          CoordinateDamper,
          OrientationChaser,
          OrientationDamper,
          PositionChaser,
          PositionChaser2D,
          PositionDamper,
          PositionDamper2D,
          ScalarChaser,
          ScalarDamper,
          TexCoordChaser2D,
          TexCoordDamper2D,
          X3DChaserNode,
          X3DDamperNode,
          X3DFollowerNode)
{
"use strict";

   const Types =
   {
      ColorChaser:       ColorChaser,
      ColorDamper:       ColorDamper,
      CoordinateChaser:  CoordinateChaser,
      CoordinateDamper:  CoordinateDamper,
      OrientationChaser: OrientationChaser,
      OrientationDamper: OrientationDamper,
      PositionChaser:    PositionChaser,
      PositionChaser2D:  PositionChaser2D,
      PositionDamper:    PositionDamper,
      PositionDamper2D:  PositionDamper2D,
      ScalarChaser:      ScalarChaser,
      ScalarDamper:      ScalarDamper,
      TexCoordChaser2D:  TexCoordChaser2D,
      TexCoordDamper2D:  TexCoordDamper2D,
   };

   const AbstractTypes =
   {
      X3DChaserNode: X3DChaserNode,
      X3DDamperNode: X3DDamperNode,
      X3DFollowerNode: X3DFollowerNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Box',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function Box (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Box);

      this ._size .setUnit ("length");
   }

   Box .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Box,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "size",     new Fields .SFVec3f (2, 2, 2)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
      ]),
      getTypeName: function ()
      {
         return "Box";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      build: (function ()
      {
         const defaultSize = new Vector3 (2, 2, 2);

         return function ()
         {
            const
               options  = this .getBrowser () .getBoxOptions (),
               geometry = options .getGeometry (),
               size     = this ._size .getValue ();

            this .setMultiTexCoords (geometry .getMultiTexCoords ());
            this .setNormals        (geometry .getNormals ());

            if (size .equals (defaultSize))
            {
               this .setVertices (geometry .getVertices ());

               this .getMin () .assign (geometry .getMin ());
               this .getMax () .assign (geometry .getMax ());
            }
            else
            {
               const
                  scale           = Vector3 .divide (size, 2),
                  defaultVertices = geometry .getVertices () .getValue (),
                  vertexArray     = this .getVertices ();

               let
                  x = scale .x,
                  y = scale .y,
                  z = scale .z;

               for (let i = 0, length = defaultVertices .length; i < length; i += 4)
               {
                  vertexArray .push (x * defaultVertices [i],
                                     y * defaultVertices [i + 1],
                                     z * defaultVertices [i + 2],
                                     1);
               }

               x = Math .abs (x);
               y = Math .abs (y);
               z = Math .abs (z);

               this .getMin () .set (-x, -y, -z);
               this .getMax () .set ( x,  y,  z);
            }

            this .setSolid (this ._solid .getValue ());
         };
      })(),
   });

   return Box;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Cone',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Complex",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Complex,
          Vector2,
          Vector3)
{
"use strict";

   function Cone (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Cone);

      this ._height       .setUnit ("length");
      this ._bottomRadius .setUnit ("length");
   }

   Cone .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Cone,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",     new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "side",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bottom",       new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "height",       new Fields .SFFloat (2)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bottomRadius", new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",        new Fields .SFBool (true)),
      ]),
      getTypeName: function ()
      {
         return "Cone";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      set_live__: function ()
      {
         X3DGeometryNode .prototype .set_live__ .call (this);

         if (this .isLive () .getValue ())
            this .getBrowser () .getConeOptions () .addInterest ("requestRebuild", this);
         else
            this .getBrowser () .getConeOptions () .removeInterest ("requestRebuild", this);
      },
      build: function ()
      {
         const
            options       = this .getBrowser () .getConeOptions (),
            xDimension    = options ._xDimension .getValue (),
            height        = this ._height .getValue (),
            bottomRadius  = this ._bottomRadius .getValue (),
            texCoordArray = this .getTexCoords (),
            normalArray   = this .getNormals (),
            vertexArray   = this .getVertices ();

         this .getMultiTexCoords () .push (texCoordArray);

         const
            y1 = height / 2,
            y2 = -y1,
            nz = Complex .Polar (1, -Math .PI / 2 + Math .atan (bottomRadius / height));

         if (this ._side .getValue ())
         {
            for (let i = 0; i < xDimension; ++ i)
            {
               const
                  u1     = (i + 0.5) / xDimension,
                  theta1 = 2 * Math .PI * u1,
                  n1     = Complex .Polar (nz .imag, theta1);

               const
                  u2     = i / xDimension,
                  theta2 = 2 * Math .PI * u2,
                  p2     = Complex .Polar (-bottomRadius, theta2),
                  n2     = Complex .Polar (nz .imag, theta2);

               const
                  u3     = (i + 1) / xDimension,
                  theta3 = 2 * Math .PI * u3,
                  p3     = Complex .Polar (-bottomRadius, theta3),
                  n3     = Complex .Polar (nz .imag, theta3);

               /*    p1
                *   /  \
                *  /    \
                * p2 -- p3
                */

               // p1
               texCoordArray .push (u1, 1, 0, 1);
               normalArray   .push (n1 .imag, nz .real, n1 .real);
               vertexArray   .push (0, y1, 0, 1);

               // p2
               texCoordArray .push (u2, 0, 0, 1);
               normalArray   .push (n2 .imag, nz .real, n2 .real);
               vertexArray   .push (p2 .imag, y2, p2 .real, 1);

               // p3
               texCoordArray .push (u3, 0, 0, 1);
               normalArray   .push (n3 .imag , nz .real, n3 .real);
               vertexArray   .push (p3 .imag, y2, p3 .real, 1);
            }
         }

         if (this ._bottom .getValue ())
         {
            const
               texCoord = [ ],
               points   = [ ];

            for (let i = xDimension - 1; i > -1; -- i)
            {
               const
                  u     = i / xDimension,
                  theta = 2 * Math .PI * u,
                  t     = Complex .Polar (-1, theta),
                  p     = Complex .multiply (t, bottomRadius);

               texCoord .push (new Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
               points   .push (new Vector3 (p .imag, y2, p .real));
            }

            const
               t0 = texCoord [0],
               p0 = points [0];

            for (let i = 1, length = points .length - 1; i < length; ++ i)
            {
               const
                  t1 = texCoord [i],
                  t2 = texCoord [i + 1],
                  p1 = points [i],
                  p2 = points [i + 1];

               texCoordArray .push (t0 .x, t0 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

               texCoordArray .push (t1 .x, t1 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

               texCoordArray .push (t2 .x, t2 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
            }
         }

         this .setSolid (this ._solid .getValue ());
         this .setExtents ();
      },
      setExtents: function ()
      {
         const
            bottomRadius = this ._bottomRadius .getValue (),
            y1           = this ._height .getValue () / 2,
            y2           = -y1;

         if (!this ._side .getValue () && !this ._bottom .getValue ())
         {
            this .getMin () .set (0, 0, 0);
            this .getMax () .set (0, 0, 0);
         }
         else if (! this ._side .getValue ())
         {
            this .getMin () .set (-bottomRadius, y2, -bottomRadius);
            this .getMax () .set ( bottomRadius, y2,  bottomRadius);
         }
         else
         {
            this .getMin () .set (-bottomRadius, y2, -bottomRadius);
            this .getMax () .set ( bottomRadius, y1, bottomRadius);
         }
      },
   });

   return Cone;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Cylinder',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Complex",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Complex,
          Vector2,
          Vector3)
{
"use strict";

   function Cylinder (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Cylinder);

      this ._height .setUnit ("length");
      this ._radius .setUnit ("length");
   }

   Cylinder .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Cylinder,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "top",      new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "side",     new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bottom",   new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "height",   new Fields .SFFloat (2)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "radius",   new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
      ]),
      getTypeName: function ()
      {
         return "Cylinder";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      set_live__: function ()
      {
         X3DGeometryNode .prototype .set_live__ .call (this);

         if (this .isLive () .getValue ())
            this .getBrowser () .getCylinderOptions () .addInterest ("requestRebuild", this);
         else
            this .getBrowser () .getCylinderOptions () .removeInterest ("requestRebuild", this);
      },
      build: function ()
      {
         const
            options       = this .getBrowser () .getCylinderOptions (),
            xDimension    = options ._xDimension .getValue (),
            texCoordArray = this .getTexCoords (),
            normalArray   = this .getNormals (),
            vertexArray   = this .getVertices ();

         this .getMultiTexCoords () .push (texCoordArray);

         const
            radius = this ._radius .getValue (),
            y1     = this ._height .getValue () / 2,
            y2     = -y1;

         if (this ._side .getValue ())
         {
            for (let i = 0; i < xDimension; ++ i)
            {
               const
                  u1     = i / xDimension,
                  theta1 = 2 * Math .PI * u1,
                  n1     = Complex .Polar (-1, theta1),
                  p1     = Complex .multiply (n1, radius);

               const
                  u2     = (i + 1) / xDimension,
                  theta2 = 2 * Math .PI * u2,
                  n2     = Complex .Polar (-1, theta2),
                  p2     = Complex .multiply (n2, radius);

               // p1 - p4
               //  | \ |
               // p2 - p3

               // Triangle one

               // p1
               texCoordArray .push (u1, 1, 0, 1);
               normalArray   .push (n1 .imag,  0, n1 .real);
               vertexArray   .push (p1 .imag, y1, p1 .real, 1);

               // p2
               texCoordArray .push (u1, 0, 0, 1);
               normalArray   .push (n1 .imag,  0, n1 .real);
               vertexArray   .push (p1 .imag, y2, p1 .real, 1);

               // p3
               texCoordArray .push (u2, 0, 0, 1);
               normalArray   .push (n2 .imag,  0, n2 .real);
               vertexArray   .push (p2 .imag, y2, p2 .real, 1);

               // Triangle two

               // p1
               texCoordArray .push (u1, 1, 0, 1);
               normalArray   .push (n1 .imag,  0, n1 .real);
               vertexArray   .push (p1 .imag, y1, p1 .real, 1);

               // p3
               texCoordArray .push (u2, 0, 0, 1);
               normalArray   .push (n2 .imag,  0, n2 .real);
               vertexArray   .push (p2 .imag, y2, p2 .real, 1);

               // p4
               texCoordArray .push (u2, 1, 0, 1);
               normalArray   .push (n2 .imag,  0, n2 .real);
               vertexArray   .push (p2 .imag, y1, p2 .real, 1);
            }
         }

         if (this ._top .getValue ())
         {
            const
               texCoord = [ ],
               points   = [ ];

            for (let i = 0; i < xDimension; ++ i)
            {
               const
                  u     = i / xDimension,
                  theta = 2 * Math .PI * u,
                  t     = Complex .Polar (-1, theta);

               texCoord .push (new Vector2 ((t .imag + 1) / 2, -(t .real - 1) / 2));
               points   .push (new Vector3 (t .imag * radius, y1, t .real * radius));
            }

            const
               t0 = texCoord [0],
               p0 = points [0];

            for (let i = 1, length = points .length - 1; i < length; ++ i)
            {
               const
                  t1 = texCoord [i],
                  t2 = texCoord [i + 1],
                  p1 = points [i],
                  p2 = points [i + 1];

               texCoordArray .push (t0 .x, t0 .y, 0, 1);
               normalArray   .push (0, 1, 0);
               vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

               texCoordArray .push (t1 .x, t1 .y, 0, 1);
               normalArray   .push (0, 1, 0);
               vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

               texCoordArray .push (t2 .x, t2 .y, 0, 1);
               normalArray   .push (0, 1, 0);
               vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
            }
         }

         if (this ._bottom .getValue ())
         {
            const
               texCoord = [ ],
               points   = [ ];

            for (let i = xDimension - 1; i > -1; -- i)
            {
               const
                  u     = i / xDimension,
                  theta = 2 * Math .PI * u,
                  t     = Complex .Polar (-1, theta);

               texCoord .push (new Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
               points   .push (new Vector3 (t .imag * radius, y2, t .real * radius));
            }

            const
               t0 = texCoord [0],
               p0 = points [0];

            for (let i = 1, length = points .length - 1; i < length; ++ i)
            {
               const
                  t1 = texCoord [i],
                  t2 = texCoord [i + 1],
                  p1 = points [i],
                  p2 = points [i + 1];

               texCoordArray .push (t0 .x, t0 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p0 .x, p0 .y, p0 .z, 1);

               texCoordArray .push (t1 .x, t1 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p1 .x, p1 .y, p1 .z, 1);

               texCoordArray .push (t2 .x, t2 .y, 0, 1);
               normalArray   .push (0, -1, 0);
               vertexArray   .push (p2 .x, p2 .y, p2 .z, 1);
            }
         }

         this .setSolid (this ._solid .getValue ());
         this .setExtents ();
      },
      setExtents: function ()
      {
         const
            radius = this ._radius .getValue (),
            y1     = this ._height .getValue () / 2,
            y2     = -y1;

         if (! this ._top .getValue () && ! this ._side .getValue () && ! this ._bottom .getValue ())
         {
            this .getMin () .set (0, 0, 0);
            this .getMax () .set (0, 0, 0);
         }

         else if (! this ._top .getValue () && ! this ._side .getValue ())
         {
            this .getMin () .set (-radius, y2, -radius);
            this .getMax () .set ( radius, y2,  radius);
         }

         else if (! this ._bottom .getValue () && ! this ._side .getValue ())
         {
            this .getMin () .set (-radius, y1, -radius);
            this .getMax () .set ( radius, y1,  radius);
         }

         else
         {
            this .getMin () .set (-radius, y2, -radius);
            this .getMax () .set ( radius, y1,  radius);
         }
      },
   });

   return Cylinder;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/ElevationGrid',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DCast,
          X3DConstants,
          Triangle3,
          Vector2,
          Vector3)
{
"use strict";

   function ElevationGrid (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .ElevationGrid);

      this ._xSpacing    .setUnit ("length");
      this ._zSpacing    .setUnit ("length");
      this ._creaseAngle .setUnit ("angle");
      this ._height      .setUnit ("length");

      this .fogCoordNode = null;
      this .colorNode    = null;
      this .texCoordNode = null;
      this .normalNode   = null;
      this .coordNode    = null;
   }

   ElevationGrid .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: ElevationGrid,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_height",      new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "xDimension",      new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "zDimension",      new Fields .SFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "xSpacing",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "zSpacing",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",     new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "height",          new Fields .MFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "ElevationGrid";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DGeometryNode .prototype .initialize .call (this);

         this ._set_height .addFieldInterest (this ._height);
         this ._attrib     .addInterest ("set_attrib__",   this);
         this ._fogCoord   .addInterest ("set_fogCoord__", this);
         this ._color      .addInterest ("set_color__",    this);
         this ._texCoord   .addInterest ("set_texCoord__", this);
         this ._normal     .addInterest ("set_normal__",   this);

         this .set_attrib__ ();
         this .set_fogCoord__ ();
         this .set_color__ ();
         this .set_texCoord__ ();
         this .set_normal__ ();
      },
      set_attrib__: function ()
      {
         const attribNodes = this .getAttrib ();

         for (const attribNode of attribNodes)
         {
            attribNode .removeInterest ("requestRebuild", this);
            attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
         }

         attribNodes .length = 0;

         for (const node of this ._attrib)
         {
            const attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, node);

            if (attribNode)
               attribNodes .push (attribNode);
         }

         for (const attribNode of attribNodes)
         {
            attribNode .addInterest ("requestRebuild", this);
            attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
         }

         this .updateVertexArrays ();
      },
      set_fogCoord__: function ()
      {
         if (this .fogCoordNode)
            this .fogCoordNode .removeInterest ("requestRebuild", this);

         this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this ._fogCoord);

         if (this .fogCoordNode)
            this .fogCoordNode .addInterest ("requestRebuild", this);
      },
      set_color__: function ()
      {
         if (this .colorNode)
         {
            this .colorNode .removeInterest ("requestRebuild", this);
            this .colorNode ._transparent .removeInterest ("set_transparent__", this);
         }

         this .colorNode = X3DCast (X3DConstants .X3DColorNode, this ._color);

         if (this .colorNode)
         {
            this .colorNode .addInterest ("requestRebuild", this);
            this .colorNode ._transparent .addInterest ("set_transparent__", this);

            this .set_transparent__ ();
         }
         else
            this .setTransparent (false);
      },
      set_transparent__: function ()
      {
         this .setTransparent (this .colorNode .getTransparent ());
      },
      set_texCoord__: function ()
      {
         if (this .texCoordNode)
            this .texCoordNode .removeInterest ("requestRebuild", this);

         this .texCoordNode = X3DCast (X3DConstants .X3DTextureCoordinateNode, this ._texCoord);

         if (this .texCoordNode)
            this .texCoordNode .addInterest ("requestRebuild", this);

         this .setTextureCoordinate (this .texCoordNode);
      },
      set_normal__: function ()
      {
         if (this .normalNode)
            this .normalNode .removeInterest ("requestRebuild", this);

         this .normalNode = X3DCast (X3DConstants .X3DNormalNode, this ._normal);

         if (this .normalNode)
            this .normalNode .addInterest ("requestRebuild", this);
      },
      getColor: function ()
      {
         return this .colorNode;
      },
      getTexCoord: function ()
      {
         return this .texCoordNode;
      },
      getNormal: function ()
      {
         return this .normalNode;
      },
      getHeight: function (index)
      {
         if (index < this ._height .length)
            return this ._height [index];

         return 0;
      },
      createTexCoords: function ()
      {
         const
            texCoords  = [ ],
            xDimension = this ._xDimension .getValue (),
            zDimension = this ._zDimension .getValue (),
            xSize      = xDimension - 1,
            zSize      = zDimension - 1;

         for (let z = 0; z < zDimension; ++ z)
         {
            for (let x = 0; x < xDimension; ++ x)
               texCoords .push (new Vector2 (x / xSize, z / zSize));
         }

         return texCoords;
      },
      createNormals: function (points, coordIndex, creaseAngle)
      {
         const
            cw          = ! this ._ccw .getValue (),
            normalIndex = [ ],
            normals     = [ ];

         for (let p = 0, length = points .length; p < length; ++ p)
            normalIndex [p] = [ ];

         for (let c = 0, length = coordIndex .length; c < length; c += 3)
         {
            const
               c0 = coordIndex [c],
               c1 = coordIndex [c + 1],
               c2 = coordIndex [c + 2];

            normalIndex [c0] .push (normals .length);
            normalIndex [c1] .push (normals .length + 1);
            normalIndex [c2] .push (normals .length + 2);

            const normal = Triangle3 .normal (points [c0], points [c1], points [c2], new Vector3 (0, 0, 0));

            if (cw)
               normal .negate ();

            normals .push (normal);
            normals .push (normal);
            normals .push (normal);
         }

         return this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());
      },
      createCoordIndex: function ()
      {
         // p1 - p4
         //  | \ |
         // p2 - p3

         const
            coordIndex = [ ],
            xDimension = this ._xDimension .getValue (),
            zDimension = this ._zDimension .getValue (),
            xSize      = xDimension - 1,
            zSize      = zDimension - 1;

         for (let z = 0; z < zSize; ++ z)
         {
            for (let x = 0; x < xSize; ++ x)
            {
               const
                  i1 =       z * xDimension + x,
                  i2 = (z + 1) * xDimension + x,
                  i3 = (z + 1) * xDimension + (x + 1),
                  i4 =       z * xDimension + (x + 1);

               coordIndex .push (i1); // p1
               coordIndex .push (i2); // p2
               coordIndex .push (i3); // p3

               coordIndex .push (i1); // p1
               coordIndex .push (i3); // p3
               coordIndex .push (i4); // p4
            }
         }

         return coordIndex;
      },
      createPoints: function ()
      {
         const
            points     = [ ],
            xDimension = this ._xDimension .getValue (),
            zDimension = this ._zDimension .getValue (),
            xSpacing   = this ._xSpacing .getValue (),
            zSpacing   = this ._zSpacing .getValue ();

         for (let z = 0; z < zDimension; ++ z)
         {
            for (let x = 0; x < xDimension; ++ x)
            {
               points .push (new Vector3 (xSpacing * x,
                                          this .getHeight (x + z * xDimension),
                                          zSpacing * z));
            }
         }

         return points;
      },
      build: function ()
      {
         if (this ._xDimension .getValue () < 2 || this ._zDimension .getValue () < 2)
            return;

         const
            colorPerVertex     = this ._colorPerVertex .getValue (),
            normalPerVertex    = this ._normalPerVertex .getValue (),
            coordIndex         = this .createCoordIndex (),
            attribNodes        = this .getAttrib (),
            numAttribNodes     = attribNodes .length,
            attribArrays       = this .getAttribs (),
            fogCoordNode       = this .fogCoordNode,
            colorNode          = this .getColor (),
            texCoordNode       = this .getTexCoord (),
            normalNode         = this .getNormal (),
            points             = this .createPoints (),
            fogDepthArray      = this .getFogDepths (),
            colorArray         = this .getColors (),
            multiTexCoordArray = this .getMultiTexCoords (),
            normalArray        = this .getNormals (),
            vertexArray        = this .getVertices ();

         let face = 0;

         if (texCoordNode)
         {
            texCoordNode .init (multiTexCoordArray);
         }
         else
         {
            var
               texCoords     = this .createTexCoords (),
               texCoordArray = this .getTexCoords ();

            multiTexCoordArray .push (texCoordArray);
         }

         // Build geometry

         for (let c = 0, numCoordIndices = coordIndex .length; c < numCoordIndices; ++ face)
         {
            for (let p = 0; p < 6; ++ p, ++ c)
            {
               const
                  index = coordIndex [c],
                  point = points [index];

               for (let a = 0; a < numAttribNodes; ++ a)
                  attribNodes [a] .addValue (index, attribArrays [a]);

               if (fogCoordNode)
                  fogCoordNode .addDepth (index, fogDepthArray);

               if (colorNode)
               {
                  if (colorPerVertex)
                     colorNode .addColor (index, colorArray);
                  else
                     colorNode .addColor (face, colorArray);
               }

               if (texCoordNode)
               {
                  texCoordNode .addTexCoord (index, multiTexCoordArray);
               }
               else
               {
                  const t = texCoords [index];

                  texCoordArray .push (t .x, t .y, 0, 1);
               }

               if (normalNode)
               {
                  if (normalPerVertex)
                     normalNode .addVector (index, normalArray);

                  else
                     normalNode .addVector (face, normalArray);
               }

               vertexArray .push (point .x, point .y, point .z, 1);
            }
         }

         // Add auto-generated normals if needed.

         if (!normalNode)
         {
            const normals = this .createNormals (points, coordIndex);

            for (const normal of normals)
            {
               normalArray .push (normal .x, normal .y, normal .z);
            }
         }

         this .setSolid (this ._solid .getValue ());
         this .setCCW (this ._ccw .getValue ());
      },
   });

   return ElevationGrid;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Extrusion',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Triangle3,
          Vector2,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

   function Extrusion (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Extrusion);

      this ._creaseAngle  .setUnit ("angle");
      this ._crossSection .setUnit ("length");
      this ._spine        .setUnit ("length");
   }

   Extrusion .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Extrusion,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_crossSection", new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_orientation",  new Fields .MFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_scale",        new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_spine",        new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "beginCap",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "endCap",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "convex",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",      new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "crossSection",     new Fields .MFVec2f (new Vector2 (1, 1), new Vector2 (1, -1), new Vector2 (-1, -1), new Vector2 (-1, 1), new Vector2 (1, 1))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "orientation",      new Fields .MFRotation (new Rotation4 ())),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "scale",            new Fields .MFVec2f (new Vector2 (1, 1))),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "spine",            new Fields .MFVec3f (new Vector3 (0, 0, 0), new Vector3 (0, 1, 0))),
      ]),
      getTypeName: function ()
      {
         return "Extrusion";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DGeometryNode .prototype .initialize .call (this);

         this ._set_crossSection .addFieldInterest (this ._crossSection);
         this ._set_orientation  .addFieldInterest (this ._orientation);
         this ._set_scale        .addFieldInterest (this ._scale);
         this ._set_spine        .addFieldInterest (this ._spine);
      },
      getClosedOrientation: function ()
      {
         const orientation = this ._orientation;

         if (orientation .length)
         {
            const
               firstOrientation = orientation [0] .getValue (),
               lastOrientation  = orientation [orientation .length - 1] .getValue ();

            return firstOrientation .equals (lastOrientation);
         }

         return true;
      },
      createPoints: (function ()
      {
         const scale3 = new Vector3 (1, 1, 1);

         return function ()
         {
            const
               crossSection = this ._crossSection,
               orientation  = this ._orientation,
               scale        = this ._scale,
               spine        = this ._spine,
               points       = [ ];

            // calculate SCP rotations

            const rotations = this .createRotations ();

            // calculate vertices.

            for (let i = 0, length = spine .length; i < length; ++ i)
            {
               const matrix = rotations [i];

               if (orientation .length)
                  matrix .rotate (orientation [Math .min (i, orientation .length - 1)] .getValue ());

               if (scale .length)
               {
                  const s = scale [Math .min (i, scale .length - 1)] .getValue ();
                  matrix .scale (scale3 .set (s .x, 1, s .y));
               }

               for (let cs = 0, csLength = crossSection .length; cs < csLength; ++ cs)
               {
                  const vector = crossSection [cs] .getValue ();
                  points .push (matrix .multVecMatrix (new Vector3 (vector .x, 0, vector .y)));
               }
            }

            return points;
         };
      })(),
      createRotations: (function ()
      {
         const rotations = [ ];

         const
            SCPxAxis = new Vector3 (0, 0, 0),
            SCPyAxis = new Vector3 (0, 0, 0),
            SCPzAxis = new Vector3 (0, 0, 0);

            const
            SCPyAxisPrevious = new Vector3 (0, 0, 0),
            SCPzAxisPrevious = new Vector3 (0, 0, 0);

            const
            vector3  = new Vector3 (0, 0, 0),
            rotation = new Rotation4 (0, 0, 1, 0);

         return function ()
         {
            // calculate SCP rotations

            const
               spine       = this ._spine,
               numSpines   = spine .length,
               firstSpine  = spine [0] .getValue (),
               lastSpine   = spine [spine .length - 1] .getValue (),
               closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

            // Extend or shrink static rotations array:
            for (let i = rotations .length; i < numSpines; ++ i)
               rotations [i] = new Matrix4 ();

            rotations .length = numSpines;

            // SCP axes:
            SCPxAxis .set (0, 0, 0);
            SCPyAxis .set (0, 0, 0);
            SCPzAxis .set (0, 0, 0);

            // SCP for the first point:
            if (closedSpine)
            {
               const s = firstSpine;

               // Find first defined Y-axis.
               for (let i = 1, length = numSpines - 2; i < length; ++ i)
               {
                  SCPyAxis .assign (spine [i] .getValue ()) .subtract (s) .normalize ()
                     .subtract (vector3 .assign (spine [length] .getValue ()) .subtract (s) .normalize ())
                     .normalize ();

                  if (! SCPyAxis .equals (Vector3 .Zero))
                     break;
               }

               // Find first defined Z-axis.
               for (let i = 0, length = numSpines - 2; i < length; ++ i)
               {
                  SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
                             .cross (vector3 .assign (spine [length] .getValue ()) .subtract (spine [i] .getValue ()))
                             .normalize ();

                  if (! SCPzAxis .equals (Vector3 .Zero))
                     break;
               }
            }
            else
            {
               // Find first defined Y-axis.
               for (let i = 0, length = numSpines - 1; i < length; ++ i)
               {
                  SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ()) .normalize ();

                  if (! SCPyAxis .equals (Vector3 .Zero))
                     break;
               }

               // Find first defined Z-axis.
               for (let i = 1, length = numSpines - 1; i < length; ++ i)
               {
                  SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
                           .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (spine [i] .getValue ()))
                           .normalize ();

                  if (! SCPzAxis .equals (Vector3 .Zero))
                     break;
               }
            }

            // The entire spine is coincident:
            if (SCPyAxis .equals (Vector3 .Zero))
               SCPyAxis .set (0, 1, 0);

            // The entire spine is collinear:
            if (SCPzAxis .equals (Vector3 .Zero))
               rotation .setFromToVec (Vector3 .yAxis, SCPyAxis) .multVecRot (SCPzAxis .assign (Vector3 .zAxis));

            // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
            SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

            // Get first spine
            const s = firstSpine;

            rotations [0] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                                SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                                SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                                s .x,        s .y,        s .z,        1);

            // For all points other than the first or last:

            SCPyAxisPrevious .assign (SCPyAxis);
            SCPzAxisPrevious .assign (SCPzAxis);

            for (let i = 1, length = numSpines - 1; i < length; ++ i)
            {
               const s = spine [i] .getValue ();

               SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (s) .normalize ()
                        .subtract (vector3 .assign (spine [i - 1] .getValue ()) .subtract (s) .normalize ())
                        .normalize ();
               SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (s)
                        .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (s))
                        .normalize ();

               // g.
               if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
                  SCPzAxis .negate ();

               // The two points used in computing the Y-axis are coincident.
               if (SCPyAxis .equals (Vector3 .Zero))
                  SCPyAxis .assign (SCPyAxisPrevious);
               else
                  SCPyAxisPrevious .assign (SCPyAxis);

               // The three points used in computing the Z-axis are collinear.
               if (SCPzAxis .equals (Vector3 .Zero))
                  SCPzAxis .assign (SCPzAxisPrevious);
               else
                  SCPzAxisPrevious .assign (SCPzAxis);

               // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
               SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

               rotations [i] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                                   SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                                   SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                                   s .x,        s .y,        s .z,        1);
            }

            // SCP for the last point
            if (closedSpine)
            {
               // The SCPs for the first and last points are the same.
               rotations [numSpines - 1] .assign (rotations [0]);
            }
            else
            {
               const s = lastSpine;

               SCPyAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ()) .normalize ();

               if (numSpines > 2)
               {
                  SCPzAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ())
                           .cross (vector3 .assign (spine [numSpines - 3] .getValue ()) .subtract (spine [numSpines - 2] .getValue ()))
                           .normalize ();
               }

               // g.
               if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
                  SCPzAxis .negate ();

               // The two points used in computing the Y-axis are coincident.
               if (SCPyAxis .equals (Vector3 .Zero))
                  SCPyAxis .assign (SCPyAxisPrevious);

               // The three points used in computing the Z-axis are collinear.
               if (SCPzAxis .equals (Vector3 .Zero))
                  SCPzAxis .assign (SCPzAxisPrevious);

               // We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
               SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

               rotations [numSpines - 1] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
                                               SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
                                               SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
                                               s .x,        s .y,        s .z,        1);
            }

            return rotations;
         };
      })(),
      build: (function ()
      {
         const
            min     = new Vector2 (0, 0, 0),
            max     = new Vector2 (0, 0, 0),
            vector2 = new Vector2 (0, 0, 0);

         return function ()
         {
            const
               cw            = ! this ._ccw .getValue (),
               crossSection  = this ._crossSection,
               spine         = this ._spine,
               numSpines     = spine .length,
               texCoordArray = this .getTexCoords ();

            if (numSpines < 2 || crossSection .length < 2)
               return;

            this .getMultiTexCoords () .push (texCoordArray);

            const crossSectionSize = crossSection .length; // This one is used only in the INDEX macro.

            function INDEX (n, k) { return n * crossSectionSize + k; }

            const
               firstSpine  = spine [0] .getValue (),
               lastSpine   = spine [numSpines - 1] .getValue (),
               closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

            const
               firstCrossSection  = crossSection [0] .getValue (),
               lastCrossSection   = crossSection [crossSection .length - 1] .getValue (),
               closedCrossSection = firstCrossSection .equals (lastCrossSection);

            // For caps calculation

            min .assign (crossSection [0] .getValue ());
            max .assign (crossSection [0] .getValue ());

            for (let k = 1, length = crossSection .length; k < length; ++ k)
            {
               min .min (crossSection [k] .getValue ());
               max .max (crossSection [k] .getValue ());
            }

            const
               capSize      = vector2 .assign (max) .subtract (min),
               capMax       = Math .max (capSize .x, capSize .y),
               numCapPoints = closedCrossSection ? crossSection .length - 1 : crossSection .length;

            // Create

            const
               normalIndex = [ ],
               normals     = [ ],
               points      = this .createPoints ();

            for (let p = 0, length = points .length; p < length; ++ p)
               normalIndex [p] = [ ];

            // Build body.

            const
               normalArray = this .getNormals (),
               vertexArray = this .getVertices ();

            const
               numCrossSection_1 = crossSection .length - 1,
               numSpine_1        = numSpines - 1;

            let
               indexLeft  = INDEX (0, 0),
               indexRight = INDEX (0, closedCrossSection ? 0 : numCrossSection_1);

            for (let n = 0; n < numSpine_1; ++ n)
            {
               for (let k = 0; k < numCrossSection_1; ++ k)
               {
                  const
                     n1 = closedSpine && n === numSpines - 2 ? 0 : n + 1,
                     k1 = closedCrossSection && k === crossSection .length - 2 ? 0 : k + 1;

                  // k      k+1
                  //
                  // p4 ----- p3   n+1
                  //  |     / |
                  //  |   /   |
                  //  | /     |
                  // p1 ----- p2   n

                  let
                     i1 = INDEX (n,  k),
                     i2 = INDEX (n,  k1),
                     i3 = INDEX (n1, k1),
                     i4 = INDEX (n1, k),
                     p1 = points [i1],
                     p2 = points [i2],
                     p3 = points [i3],
                     p4 = points [i4],
                     l1 = p2 .distance (p3) >= 1e-7,
                     l2 = p4 .distance (p1) >= 1e-7;

                  if (cw)
                  {
                     var
                        normal1 = Triangle3 .normal (p3, p2, p1, new Vector3 (0, 0, 0)),
                        normal2 = Triangle3 .normal (p4, p3, p1, new Vector3 (0, 0, 0));
                  }
                  else
                  {
                     var
                        normal1 = Triangle3 .normal (p1, p2, p3, new Vector3 (0, 0, 0)),
                        normal2 = Triangle3 .normal (p1, p3, p4, new Vector3 (0, 0, 0));
                  }

                  // Merge points on the left and right side if spine is coincident for better normal generation.

                  if (k == 0)
                  {
                     if (l2)
                     {
                        indexLeft = i1;
                     }
                     else
                     {
                        i1 = indexLeft;
                        p1 = points [i1];
                     }
                  }

                  if (k == crossSection .length - 2)
                  {
                     if (l1)
                     {
                        indexRight = i2;
                     }
                     else
                     {
                        i3 = indexRight;
                        p3 = points [i3];
                     }
                  }

                  // If there are coincident spine points then one length can be zero.

                  // Triangle one

                  if (l1)
                  {
                     // p1
                     if (l2)
                     {
                        texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
                     }
                     else
                     {
                        // Cone case: ((texCoord1 + texCoord4) / 2)
                        const y = (n / numSpine_1 + (n + 1) / numSpine_1) / 2;

                        texCoordArray .push (k / numCrossSection_1, y, 0, 1);
                     }

                     normalIndex [i1] .push (normals .length);
                     normals .push (normal1);
                     vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

                     // p2
                     texCoordArray .push ((k + 1) / numCrossSection_1, n / numSpine_1, 0, 1);
                     normalIndex [i2] .push (normals .length);
                     normals .push (normal1);
                     vertexArray .push (p2 .x, p2 .y, p2 .z, 1);

                     // p3
                     texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                     normalIndex [i3] .push (normals .length);
                     normals .push (normal1);
                     vertexArray .push (p3 .x, p3 .y, p3 .z, 1);
                  }

                  // Triangle two

                  if (l2)
                  {
                     // p1
                     texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
                     normalIndex [i1] .push (normals .length);
                     normals .push (normal2);
                     vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

                     // p3
                     if (l1)
                     {
                        texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                     }
                     else
                     {
                        // Cone case: ((texCoord3 + texCoord2) / 2)
                        const y = ((n + 1) / numSpine_1 + n / numSpine_1) / 2;

                        texCoordArray .push ((k + 1) / numCrossSection_1, y, 0, 1);
                     }

                     normalIndex [i3] .push (normals .length);
                     normals .push (normal2);
                     vertexArray .push (p3 .x, p3 .y, p3 .z, 1);

                     // p4
                     texCoordArray .push (k / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
                     normalIndex [i4] .push (normals .length);
                     normals .push (normal2);
                     vertexArray .push (p4 .x, p4 .y, p4 .z, 1);
                  }
               }
            }

            // Refine body normals and add them.

            const refineNormals = this .refineNormals (normalIndex, normals, this ._creaseAngle .getValue ());

            for (const normal of refineNormals)
            {
               normalArray .push (normal .x, normal .y, normal .z);
            }

            // Build caps

            if (capMax && numCapPoints > 2)
            {
               if (this ._beginCap .getValue ())
               {
                  const
                     j         = 0, // spine
                     polygon   = [ ],
                     triangles = [ ];

                  for (let k = 0; k < numCapPoints; ++ k)
                  {
                     const
                        index = INDEX (j, numCapPoints - 1 - k),
                        point = points [index] .copy ();

                     point .index    = index;
                     point .texCoord = Vector2 .subtract (crossSection [numCapPoints - 1 - k] .getValue (), min) .divide (capMax);
                     polygon .push (point);
                  }

                  if (this ._convex .getValue ())
                     Triangle3 .triangulateConvexPolygon (polygon, triangles);

                  else
                     Triangle3 .triangulatePolygon (polygon, triangles);

                  if (triangles .length >= 3)
                  {
                     const normal = Triangle3 .normal (points [triangles [0] .index],
                                                       points [triangles [1] .index],
                                                       points [triangles [2] .index],
                                                       new Vector3 (0, 0, 0));

                     if (cw)
                        normal .negate ();

                     this .addCap (texCoordArray, normal, points, triangles);
                  }
               }

               if (this ._endCap .getValue ())
               {
                  const
                     j         = numSpines - 1, // spine
                     polygon   = [ ],
                     triangles = [ ];

                  for (let k = 0; k < numCapPoints; ++ k)
                  {
                     const
                        index = INDEX (j, k),
                        point = points [index] .copy ();

                     point .index    = index;
                     point .texCoord = Vector2 .subtract (crossSection [k] .getValue (), min) .divide (capMax);
                     polygon .push (point);
                  }

                  if (this ._convex .getValue ())
                     Triangle3 .triangulateConvexPolygon (polygon, triangles);

                  else
                     Triangle3 .triangulatePolygon (polygon, triangles);

                  if (triangles .length >= 3)
                  {
                     const normal = Triangle3 .normal (points [triangles [0] .index],
                                                       points [triangles [1] .index],
                                                       points [triangles [2] .index],
                                                       new Vector3 (0, 0, 0));

                     if (cw)
                        normal .negate ();

                     this .addCap (texCoordArray, normal, points, triangles);
                  }
               }
            }

            this .setSolid (this ._solid .getValue ());
            this .setCCW (this ._ccw .getValue ());
         };
      })(),
      addCap: function (texCoordArray, normal, vertices, triangles)
      {
         const
            normalArray = this .getNormals (),
            vertexArray = this .getVertices ();

         for (let i = 0, length = triangles .length; i < length; i += 3)
         {
            const
               p0 = vertices [triangles [i]     .index],
               p1 = vertices [triangles [i + 1] .index],
               p2 = vertices [triangles [i + 2] .index],
               t0 = triangles [i]     .texCoord,
               t1 = triangles [i + 1] .texCoord,
               t2 = triangles [i + 2] .texCoord;

            texCoordArray .push (t0 .x, t0 .y, 0, 1);
            texCoordArray .push (t1 .x, t1 .y, 0, 1);
            texCoordArray .push (t2 .x, t2 .y, 0, 1);

            normalArray .push (normal .x, normal .y, normal .z,
                               normal .x, normal .y, normal .z,
                               normal .x, normal .y, normal .z);

            vertexArray .push (p0 .x, p0 .y, p0 .z, 1,
                               p1 .x, p1 .y, p1 .z, 1,
                               p2 .x, p2 .y, p2 .z, 1);
         }
      },
   });

   return Extrusion;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Sphere',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants)
{
"use strict";

   function Sphere (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Sphere);

      this ._radius .setUnit ("length");
   }

   Sphere .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Sphere,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "radius",   new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
      ]),
      getTypeName: function ()
      {
         return "Sphere";
      },
      getComponentName: function ()
      {
         return "Geometry3D";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      set_live__: function ()
      {
         X3DGeometryNode .prototype .set_live__ .call (this);

         if (this .isLive () .getValue ())
            this .getBrowser () .getSphereOptions () .addInterest ("requestRebuild", this);
         else
            this .getBrowser () .getSphereOptions () .removeInterest ("requestRebuild", this);
      },
      build: function ()
      {
         const
            options  = this .getBrowser () .getSphereOptions (),
            geometry = options .getGeometry (),
            radius   = Math .abs (this ._radius .getValue ());

         this .setMultiTexCoords (geometry .getMultiTexCoords ());
         this .setNormals        (geometry .getNormals ());

         if (radius === 1)
         {
            this .setVertices (geometry .getVertices ());

            this .getMin () .assign (geometry .getMin ());
            this .getMax () .assign (geometry .getMax ());
         }
         else
         {
            const
               defaultVertices = geometry .getVertices () .getValue (),
               vertexArray     = this .getVertices ();

            for (let i = 0, length = defaultVertices .length; i < length; i += 4)
            {
               vertexArray .push (radius * defaultVertices [i],
                                  radius * defaultVertices [i + 1],
                                  radius * defaultVertices [i + 2],
                                  1);
            }

            this .getMin () .set (-radius, -radius, -radius);
            this .getMax () .set ( radius,  radius,  radius);
         }

         this .setSolid (this ._solid .getValue ());
      },
   });

   return Sphere;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Geometry3D/Box",
   "x_ite/Components/Geometry3D/Cone",
   "x_ite/Components/Geometry3D/Cylinder",
   "x_ite/Components/Geometry3D/ElevationGrid",
   "x_ite/Components/Geometry3D/Extrusion",
   "x_ite/Components/Geometry3D/IndexedFaceSet",
   "x_ite/Components/Geometry3D/Sphere",
],
function (SupportedNodes,
          Box,
          Cone,
          Cylinder,
          ElevationGrid,
          Extrusion,
          IndexedFaceSet,
          Sphere)
{
"use strict";

   const Types =
   {
      Box:            Box,
      Cone:           Cone,
      Cylinder:       Cylinder,
      ElevationGrid:  ElevationGrid,
      Extrusion:      Extrusion,
      IndexedFaceSet: IndexedFaceSet,
      Sphere:         Sphere,
   };

   const AbstractTypes =
   {
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/StaticGroup',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Grouping/X3DBoundedObject",
   "x_ite/Components/Grouping/Group",
   "x_ite/Base/X3DConstants",
   "x_ite/Rendering/TraverseType",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/ViewVolume",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DBoundedObject,
          Group,
          X3DConstants,
          TraverseType,
          Box3,
          ViewVolume)
{
"use strict";

   // No support for X3DBindableNode nodes, local lights. X3DLocalFog, local ClipPlane nodes, LOD, Billboard, Switch node.

   function StaticGroup (executionContext)
   {
      X3DChildNode     .call (this, executionContext);
      X3DBoundedObject .call (this, executionContext);

      this .addType (X3DConstants .StaticGroup);

      this .group             = new Group (this .getExecutionContext ());
      this .collisionShapes   = null;
      this .depthShapes       = null;
      this .opaqueShapes      = null;
      this .transparentShapes = null;
      this .bbox              = new Box3 ();
      this .shadowBBox        = new Box3 ();
   }

   StaticGroup .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DBoundedObject .prototype,
   {
      constructor: StaticGroup,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",     new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",    new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",  new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "children",    new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "StaticGroup";
      },
      getComponentName: function ()
      {
         return "Grouping";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DChildNode     .prototype .initialize .call (this);
         X3DBoundedObject .prototype .initialize .call (this);

         this ._bboxSize   .addFieldInterest (this .group ._bboxSize);
         this ._bboxCenter .addFieldInterest (this .group ._bboxCenter);
         this ._children   .addFieldInterest (this .group ._children);

         this .group ._bboxSize   = this ._bboxSize;
         this .group ._bboxCenter = this ._bboxCenter;
         this .group ._children   = this ._children;
         this .group .setPrivate (true);
         this .group .setup ();

         // Connect after Group setup.
         this .group ._isCameraObject   .addFieldInterest (this ._isCameraObject);
         this .group ._isPickableObject .addFieldInterest (this ._isPickableObject);
         this .group ._children         .addInterest ("set_children__", this);

         this .setCameraObject   (this .group .getCameraObject ());
         this .setPickableObject (this .group .getPickableObject ());

         this .set_children__ ();
      },
      getBBox: function (bbox, shadow)
      {
         return bbox .assign (shadow ? this .shadowBBox : this .bbox);
      },
      set_children__: function ()
      {
         this .group .getBBox (this .bbox);
         this .group .getBBox (this .shadowBBox, true);

         this .collisionShapes   = null;
         this .depthShapes       = null;
         this .opaqueShapes      = null;
         this .transparentShapes = null;
      },
      traverse: (function ()
      {
         const viewVolume = new ViewVolume ();

         viewVolume .intersectsSphere = function () { return true; };

         return function (type, renderObject)
         {
            switch (type)
            {
               case TraverseType .CAMERA:
               {
                  return;
               }
               case TraverseType .POINTER:
               case TraverseType .COLLISION:
               {
                  if (! this .collisionShapes)
                  {
                     //console .log ("Rebuilding StaticGroup collisionShapes");

                     const
                        viewVolumes         = renderObject .getViewVolumes (),
                        viewport            = renderObject .getViewport (),
                        projectionMatrix    = renderObject .getProjectionMatrix (),
                        modelViewMatrix     = renderObject .getModelViewMatrix (),
                        firstCollisionShape = renderObject .getNumCollisionShapes ();

                     viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                     modelViewMatrix .push ();
                     modelViewMatrix .identity ();

                     this .group .traverse (type, renderObject);

                     modelViewMatrix .pop ();
                     viewVolumes     .pop ();

                     const lastCollisionShape = renderObject .getNumCollisionShapes ();

                     this .collisionShapes = renderObject .getCollisionShapes () .splice (firstCollisionShape, lastCollisionShape - firstCollisionShape);

                     renderObject .setNumCollisionShapes (firstCollisionShape);
                  }

                  const modelViewMatrix = renderObject .getModelViewMatrix ();

                  for (const collisionShape of this .collisionShapes)
                  {
                     modelViewMatrix .push ();
                     modelViewMatrix .multLeft (collisionShape .modelViewMatrix);
                     collisionShape .shapeNode .traverse (type, renderObject);
                     modelViewMatrix .pop ();
                  }

                  return;
               }
               case TraverseType .SHADOW:
               {
                  if (! this .depthShapes)
                  {
                     //console .log ("Rebuilding StaticGroup depthShapes");

                     const
                        viewVolumes      = renderObject .getViewVolumes (),
                        viewport         = renderObject .getViewport (),
                        projectionMatrix = renderObject .getProjectionMatrix (),
                        modelViewMatrix  = renderObject .getModelViewMatrix (),
                        firstDepthShape  = renderObject .getNumDepthShapes ();

                     viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                     modelViewMatrix .push ();
                     modelViewMatrix .identity ();

                     this .group .traverse (type, renderObject);

                     modelViewMatrix .pop ();
                     viewVolumes     .pop ();

                     const lastDepthShape = renderObject .getNumDepthShapes ();

                     this .depthShapes = renderObject .getDepthShapes () .splice (firstDepthShape, lastDepthShape - firstDepthShape);

                     renderObject .setNumDepthShapes (firstDepthShape);
                  }

                  const modelViewMatrix = renderObject .getModelViewMatrix ();

                  for (const depthShape of this .depthShapes)
                  {
                     modelViewMatrix .push ();
                     modelViewMatrix .multLeft (depthShape .modelViewMatrix);
                     depthShape .shapeNode .traverse (type, renderObject);
                     modelViewMatrix .pop ();
                  }

                  return;
               }
               case TraverseType .DISPLAY:
               {
                  if (! this .opaqueShapes)
                  {
                     //console .log ("Rebuilding StaticGroup opaqueShapes and transparentShapes");

                     const
                        viewVolumes           = renderObject .getViewVolumes (),
                        viewport              = renderObject .getViewport (),
                        projectionMatrix      = renderObject .getProjectionMatrix (),
                        modelViewMatrix       = renderObject .getModelViewMatrix (),
                        firstOpaqueShape      = renderObject .getNumOpaqueShapes (),
                        firstTransparentShape = renderObject .getNumTransparentShapes ();

                     viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));

                     modelViewMatrix .push ();
                     modelViewMatrix .identity ();

                     this .group .traverse (type, renderObject);

                     modelViewMatrix .pop ();
                     viewVolumes     .pop ();

                     const
                        lastOpaqueShape      = renderObject .getNumOpaqueShapes (),
                        lastTransparentShape = renderObject .getNumTransparentShapes ();

                     this .opaqueShapes      = renderObject .getOpaqueShapes () .splice (firstOpaqueShape, lastOpaqueShape - firstOpaqueShape);
                     this .transparentShapes = renderObject .getTransparentShapes () .splice (firstTransparentShape, lastTransparentShape - firstTransparentShape);

                     renderObject .setNumOpaqueShapes (firstOpaqueShape);
                     renderObject .setNumTransparentShapes (firstTransparentShape);
                  }

                  const modelViewMatrix = renderObject .getModelViewMatrix ();

                  for (const opaqueShape of this .opaqueShapes)
                  {
                     modelViewMatrix .push ();
                     modelViewMatrix .multLeft (opaqueShape .modelViewMatrix);
                     opaqueShape .shapeNode .traverse (type, renderObject);
                     modelViewMatrix .pop ();
                  }

                  for (const transparentShape of this .transparentShapes)
                  {
                     modelViewMatrix .push ();
                     modelViewMatrix .multLeft (transparentShape .modelViewMatrix);
                     transparentShape .shapeNode .traverse (type, renderObject);
                     modelViewMatrix .pop ();
                  }

                  return;
               }
            }
         };
      })(),
   });

   return StaticGroup;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Switch',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          TraverseType,
          X3DCast,
          X3DConstants)
{
"use strict";

   function Switch (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .Switch);

      if (executionContext .getSpecificationVersion () === "2.0")
         this .addAlias ("choice", this ._children);

      this .childNode     = null;
      this .visibleNode   = null;
      this .boundedObject = null;
   }

   Switch .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: Switch,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "whichChoice",    new Fields .SFInt32 (-1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Switch";
      },
      getComponentName: function ()
      {
         return "Grouping";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DGroupingNode .prototype .initialize .call (this);

         this ._whichChoice .addInterest ("set_child__", this);
         this ._children    .addInterest ("set_child__", this);

         this .set_child__ ();
      },
      getSubBBox: function (bbox, shadow)
      {
         if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
         {
            const boundedObject = X3DCast (X3DConstants .X3DBoundedObject, this .visibleNode);

            if (boundedObject)
               return boundedObject .getBBox (bbox, shadow);

            return bbox .set ();
         }

         return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
      },
      clear: function () { },
      add: function () { },
      remove: function () { },
      set_child__: function ()
      {
         if (this .childNode)
         {
            this .childNode ._isCameraObject   .removeInterest ("set_cameraObject__",     this);
            this .childNode ._isPickableObject .removeInterest ("set_transformSensors__", this);
         }

         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .childNode ._visible     .removeInterest ("set_visible__",     this);
            this .childNode ._bboxDisplay .removeInterest ("set_bboxDisplay__", this);
         }

         const whichChoice = this ._whichChoice .getValue ();

         if (whichChoice >= 0 && whichChoice < this ._children .length)
         {
            this .childNode = X3DCast (X3DConstants .X3DChildNode, this ._children [whichChoice]);

            if (this .childNode)
            {
               this .childNode ._isCameraObject   .addInterest ("set_cameraObject__",     this);
               this .childNode ._isPickableObject .addInterest ("set_transformSensors__", this);

               if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
               {
                  this .childNode ._visible     .addInterest ("set_visible__",     this);
                  this .childNode ._bboxDisplay .addInterest ("set_bboxDisplay__", this);
               }

               delete this .traverse;
            }
         }
         else
         {
            this .childNode = null;

            this .traverse = Function .prototype;
         }

         this .set_transformSensors__ ();
         this .set_visible__ ();
         this .set_bboxDisplay__ ();
      },
      set_cameraObject__: function ()
      {
         if (this .childNode && this .childNode .getCameraObject ())
         {
            if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
            {
               this .setCameraObject (this .childNode ._visible .getValue ());
            }
            else
            {
               this .setCameraObject (true);
            }
         }
         else
         {
            this .setCameraObject (false);
         }
      },
      set_transformSensors__: function ()
      {
         this .setPickableObject (Boolean (this .getTransformSensors () .size || this .childNode && this .childNode .getPickableObject ()));
      },
      set_visible__: function ()
      {
         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .visibleNode = this .childNode ._visible .getValue () ? this .childNode : null;
         }
         else
         {
            this .visibleNode = this .childNode;
         }

         this .set_cameraObject__ ();
      },
      set_bboxDisplay__: function ()
      {
         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .boundedObject = this .childNode ._bboxDisplay .getValue () ? this .childNode : null;
         }
         else
         {
            this .boundedObject = null;
         }
      },
      traverse: function (type, renderObject)
      {
         switch (type)
         {
            case TraverseType .POINTER:
            case TraverseType .CAMERA:
            case TraverseType .SHADOW:
            {
               const visibleNode = this .visibleNode;

               if (visibleNode)
                  visibleNode .traverse (type, renderObject);

               return;
            }
            case TraverseType .PICKING:
            {
               if (this .getTransformSensors () .size)
               {
                  const modelMatrix = renderObject .getModelViewMatrix () .get ();

                  for (const transformSensorNode of this .getTransformSensors ())
                     transformSensorNode .collect (modelMatrix);
               }

               const childNode = this .childNode;

               if (childNode)
               {
                  const
                     browser          = renderObject .getBrowser (),
                     pickingHierarchy = browser .getPickingHierarchy ();

                  pickingHierarchy .push (this);

                  childNode .traverse (type, renderObject);

                  pickingHierarchy .pop ();
               }

               return;
            }
            case TraverseType .COLLISION:
            {
               const childNode = this .childNode;

               if (childNode)
                  childNode .traverse (type, renderObject);

               return;
            }
            case TraverseType .DISPLAY:
            {
               const visibleNode = this .visibleNode;

               if (visibleNode)
                  visibleNode .traverse (type, renderObject);

               const boundedObject = this .boundedObject;

               if (boundedObject)
                  boundedObject .displayBBox (type, renderObject);

               return;
            }
         }
      },
   });

   return Switch;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DTransformMatrix3DNode',[
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
],
function (X3DGroupingNode,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

   function X3DTransformMatrix3DNode (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTransformMatrix3DNode);

      this .matrix   = new Matrix4 ();
      this .getBBox  = this .getGetGroupBBox ();
      this .traverse = this .getGroupTraverse ();
   }

   X3DTransformMatrix3DNode .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: X3DTransformMatrix3DNode,
      setMatrix: function (matrix)
      {
         if (matrix .equals (Matrix4 .Identity))
         {
            this .matrix .identity ();

            this .getBBox  = this .getGetGroupBBox ();
            this .traverse = this .getGroupTraverse ();
         }
         else
         {
            this .matrix .assign (matrix);

            this .getBBox  = this .getGetBBox ();
            this .traverse = this .getTraverse ();
         }
      },
      getMatrix: function ()
      {
         return this .matrix;
      },
      setTransform: function (t, r, s, so, c)
      {
         if (t .equals (Vector3 .Zero) && r .equals (Rotation4 .Identity) && s .equals (Vector3 .One))
         {
            this .matrix .identity ();

            this .getBBox  = this .getGetGroupBBox ();
            this .traverse = this .getGroupTraverse ();
         }
         else
         {
            this .matrix .set (t, r, s, so, c);

            this .getBBox  = this .getGetBBox ();
            this .traverse = this .getTraverse ();
         }
      },
      getGetBBox: (function ()
      {
         function getBBox (bbox, shadow)
         {
            return this .getSubBBox (bbox, shadow) .multRight (this .matrix);
         }

         return function ()
         {
            return getBBox;
         };
      })(),
      getGetGroupBBox: function ()
      {
         return X3DGroupingNode .prototype .getBBox;
      },
      getTraverse: (function ()
      {
         function traverse (type, renderObject)
         {
            const modelViewMatrix = renderObject .getModelViewMatrix ();

            modelViewMatrix .push ();
            modelViewMatrix .multLeft (this .matrix);

            X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

            modelViewMatrix .pop ();
         }

         return function ()
         {
            return traverse;
         };
      })(),
      getGroupTraverse: function ()
      {
         return X3DGroupingNode .prototype .traverse;
      },
   });

   return X3DTransformMatrix3DNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DTransformNode',[
   "x_ite/Components/Grouping/X3DTransformMatrix3DNode",
   "x_ite/Base/X3DConstants",
],
function (X3DTransformMatrix3DNode,
          X3DConstants)
{
"use strict";

   function X3DTransformNode (executionContext)
   {
      X3DTransformMatrix3DNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTransformNode);

      this ._translation .setUnit ("length");
      this ._center      .setUnit ("length");
   }

   X3DTransformNode .prototype = Object .assign (Object .create (X3DTransformMatrix3DNode .prototype),
   {
      constructor: X3DTransformNode,
      initialize: function ()
      {
         X3DTransformMatrix3DNode .prototype .initialize .call (this);

         this .addInterest ("eventsProcessed", this);

         this .eventsProcessed ();
      },
      eventsProcessed: function ()
      {
         this .setTransform (this ._translation      .getValue (),
                             this ._rotation         .getValue (),
                             this ._scale            .getValue (),
                             this ._scaleOrientation .getValue (),
                             this ._center           .getValue ());
      },
   });

   return X3DTransformNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Transform',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DTransformNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTransformNode,
          X3DConstants)
{
"use strict";

   function Transform (executionContext)
   {
      X3DTransformNode .call (this, executionContext);

      this .addType (X3DConstants .Transform);
   }

   Transform .prototype = Object .assign (Object .create (X3DTransformNode .prototype),
   {
      constructor: Transform,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "translation",      new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "rotation",         new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "scale",            new Fields .SFVec3f (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "scaleOrientation", new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "center",           new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",      new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",         new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",       new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",      new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren",   new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",         new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Transform";
      },
      getComponentName: function ()
      {
         return "Grouping";
      },
      getContainerField: function ()
      {
         return "children";
      },
   });

   return Transform;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Grouping/Group",
   "x_ite/Components/Grouping/StaticGroup",
   "x_ite/Components/Grouping/Switch",
   "x_ite/Components/Grouping/Transform",
   "x_ite/Components/Grouping/X3DBoundedObject",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Components/Grouping/X3DTransformMatrix3DNode",
   "x_ite/Components/Grouping/X3DTransformNode",
],
function (SupportedNodes,
          Group,
          StaticGroup,
          Switch,
          Transform,
          X3DBoundedObject,
          X3DGroupingNode,
          X3DTransformMatrix3DNode,
          X3DTransformNode)
{
"use strict";

   const Types =
   {
      Group:       Group,
      StaticGroup: StaticGroup,
      Switch:      Switch,
      Transform:   Transform,
   };

   const AbstractTypes =
   {
      X3DBoundedObject:         X3DBoundedObject,
      X3DGroupingNode:          X3DGroupingNode,
      X3DTransformMatrix3DNode: X3DTransformMatrix3DNode,
      X3DTransformNode:         X3DTransformNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/ColorInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Color3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Color3)
{
"use strict";

   function ColorInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .ColorInterpolator);

      this .hsv = [ ];
   }

   ColorInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: ColorInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFColor ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFColor ()),
      ]),
      getTypeName: function ()
      {
         return "ColorInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const keyValue = this ._keyValue;

         if (keyValue .length < this ._key .length)
            this ._keyValue .resize (this ._key .length, keyValue .length ? keyValue [this ._keyValue .length - 1] : new Fields .SFColor ());

         this .hsv .length = 0;

         for (const value of keyValue)
            this .hsv .push (value .getHSV ([ ]));
      },
      interpolate: (function ()
      {
         const value = [ ];

         return function (index0, index1, weight)
         {
            Color3 .lerp (this .hsv [index0], this .hsv [index1], weight, value);

            this ._value_changed .setHSV (value [0], value [1], value [2]);
         };
      })(),
   });

   return ColorInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/CoordinateInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function CoordinateInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .CoordinateInterpolator);
   }

   CoordinateInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: CoordinateInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "CoordinateInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      set_keyValue__: function () { },
      interpolate: function (index0, index1, weight)
      {
         const keyValue = this ._keyValue .getValue ();

         let size = this ._key .length ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

         this ._value_changed .length = size;

         const value_changed = this ._value_changed .getValue ();

         index0 *= size;
         index1  = index0 + (this ._key .length > 1 ? size : 0);

         index0 *= 3;
         index1 *= 3;
         size   *= 3;

         for (let i0 = 0; i0 < size; i0 += 3)
         {
            const
               i1 = i0 + 1,
               i2 = i0 + 2;

            value_changed [i0] = Algorithm .lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
            value_changed [i1] = Algorithm .lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
            value_changed [i2] = Algorithm .lerp (keyValue [index0 + i2], keyValue [index1 + i2], weight);
         }

         this ._value_changed .addEvent ();
      },
   });

   return CoordinateInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/CoordinateInterpolator2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function CoordinateInterpolator2D (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .CoordinateInterpolator2D);
   }

   CoordinateInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: CoordinateInterpolator2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "CoordinateInterpolator2D";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      set_keyValue__: function () { },
      interpolate: function (index0, index1, weight)
      {
         const keyValue = this ._keyValue .getValue ();

         let size = this ._key .length ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

         this ._value_changed .length = size;

         const value_changed = this ._value_changed .getValue ();

         index0 *= size;
         index1  = index0 + (this ._key .length > 1 ? size : 0);

         index0 *= 2;
         index1 *= 2;
         size   *= 2;

         for (let i0 = 0; i0 < size; i0 += 2)
         {
            const i1 = i0 + 1;

            value_changed [i0] = Algorithm .lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
            value_changed [i1] = Algorithm .lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
         }

         this ._value_changed .addEvent ();
      },
   });

   return CoordinateInterpolator2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/NormalInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Vector3,
          Algorithm)
{
"use strict";

   function NormalInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .NormalInterpolator);
   }

   NormalInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: NormalInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "NormalInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function () { },
      interpolate: (function ()
      {
         const
            keyValue0 = new Vector3 (0, 0, 0),
            keyValue1 = new Vector3 (0, 0, 0);

         return function (index0, index1, weight)
         {
            const keyValue = this ._keyValue .getValue ();

            let size = this ._key .length > 1 ? Math .floor (this ._keyValue .length / this ._key .length) : 0;

            this ._value_changed .length = size;

            const value_changed = this ._value_changed .getValue ();

            index0 *= size;
            index1  = index0 + size;

            index0 *= 3;
            index1 *= 3;
            size   *= 3;

            for (let i0 = 0; i0 < size; i0 += 3)
            {
               try
               {
                  const
                     i1 = i0 + 1,
                     i2 = i0 + 2;

                  keyValue0 .set (keyValue [index0 + i0], keyValue [index0 + i1], keyValue [index0 + i2]);
                  keyValue1 .set (keyValue [index1 + i0], keyValue [index1 + i1], keyValue [index1 + i2]);

                  const value = Algorithm .simpleSlerp (keyValue0, keyValue1, weight);

                  value_changed [i0] = value [0];
                  value_changed [i1] = value [1];
                  value_changed [i2] = value [2];
               }
               catch (error)
               {
                  //console .log (error);
               }
            }

            this ._value_changed .addEvent ();
         };
      })(),
   });

   return NormalInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/PositionInterpolator2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          X3DConstants,
          Vector2)
{
"use strict";

   function PositionInterpolator2D (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .PositionInterpolator2D);
   }

   PositionInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: PositionInterpolator2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "PositionInterpolator2D";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec2f ());
      },
      interpolate:  (function ()
      {
         const keyValue = new Vector2 (0, 0);

         return function (index0, index1, weight)
         {
            this ._value_changed = keyValue .assign (this ._keyValue [index0] .getValue ()) .lerp (this ._keyValue [index1] .getValue (), weight);
         };
      })(),
   });

   return PositionInterpolator2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator',[
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Matrix4",
],
function (Vector4,
          Matrix4)
{
"use strict";

   const
      T  = [ ],
      Fp = [ ],
      Fm = [ ],
      S  = new Vector4 (0, 0, 0, 0);

   const H = new Matrix4 ( 2, -2,  1,  1,
                          -3,  3, -2, -1,
                           0,  0,  1,  0,
                           1,  0,  0,  0);

   function CatmullRomSplineInterpolator ()
   {
      this .T0 = [ ];
      this .T1 = [ ];
   }

   CatmullRomSplineInterpolator .prototype =
   {
      constructor: CatmullRomSplineInterpolator,
      generate: function (closed, key, keyValue, keyVelocity, normalizeVelocity)
      {
         const
            T0 = this .T0,
            T1 = this .T1;

         T0 .length = 0;
         T1 .length = 0;

         T  .length = 0;
         Fp .length = 0;
         Fm .length = 0;

         if (key .length > 1)
         {
            // T

            if (keyVelocity .length === 0)
            {
               if (closed)
                  T .push (this .divide (this .subtract (keyValue [1], keyValue [keyValue .length - 2]), 2));

               else
                  T .push (this .create ());

               for (let i = 1, length = keyValue .length - 1; i < length; ++ i)
                  T .push (this .divide (this .subtract (keyValue [i + 1], keyValue [i - 1]), 2));

               T .push (this .copy (T [0]));
            }
            else
            {
               for (let i = 0, length = keyVelocity .length; i < length; ++ i)
                  T .push (this .copy (keyVelocity [i]));

               if (normalizeVelocity)
               {
                  let Dtot = 0;

                  for (let i = 0, length = keyValue .length - 1; i < length; ++ i)
                     Dtot += this .abs (this .subtract (keyValue [i], keyValue [i + 1]));

                  for (let i = 0, length = T .length - 1; i < length; ++ i)
                  {
                     const Tia = this .abs (T [i]);

                     if (Tia)
                        T [i] = this .multiply (T [i], Dtot / Tia);
                  }
               }
            }

            // Fm, Fp

            if (closed)
            {
               const i_1 = key .length - 1;
               const i_2 = key .length - 2;

               const d = key [1] - key [0] + key [i_1] - key [i_2];

               Fm .push (2 * (key [1]   - key [0])   / d);
               Fp .push (2 * (key [i_1] - key [i_2]) / d);

            }
            else
            {
               Fm .push (1);
               Fp .push (1);
            }

            for (let i = 1, length = key .length - 1; i < length; ++ i)
            {
               const d = key [i + 1] - key [i - 1];

               Fm .push (2 * (key [i + 1] - key [i])     / d);
               Fp .push (2 * (key [i]     - key [i - 1]) / d);
            }

            Fm .push (Fm [0]);
            Fp .push (Fp [0]);

            // T0, T1

            for (let i = 0, length = T .length; i < length; ++ i)
            {
               T0 .push (this .multiply (T [i], Fp [i]));
               T1 .push (this .multiply (T [i], Fm [i]));
            }
         }
         else
         {
            T0 .push (this .create ());
            T1 .push (this .create ());
         }
      },
      interpolate: function (index0, index1, weight, keyValue)
      {
         S .set (Math .pow (weight, 3), Math .pow (weight, 2), weight, 1);

         // Taking dot product from SH and C;

         return this .dot (H .multVecMatrix (S),
                           keyValue [index0],
                           keyValue [index1],
                           this .T0 [index0],
                           this .T1 [index1]);
      },
   };

   return CatmullRomSplineInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate',[
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolator"
],
function (CatmullRomSplineInterpolator)
{
"use strict";

   return function (Type)
   {
      const
         c0 = new Type (0, 0, 0, 0),
         c1 = new Type (0, 0, 0, 0),
         c2 = new Type (0, 0, 0, 0),
         c3 = new Type (0, 0, 0, 0);

      function CatmullRomSplineInterpolatorInstance ()
      {
         this .T0 = [ ];
         this .T1 = [ ];
      }

      CatmullRomSplineInterpolatorInstance .prototype = Object .assign (Object .create (CatmullRomSplineInterpolator .prototype),
      {
         constructor: CatmullRomSplineInterpolatorInstance,
         create: function ()
         {
            return new Type (0, 0, 0, 0);
         },
         copy: function (value)
         {
            return value .copy ();
         },
         subtract: function (lhs, rhs)
         {
            return Type .subtract (lhs, rhs);
         },
         multiply: function (lhs, rhs)
         {
            return Type .multiply (lhs, rhs);
         },
         divide: function (lhs, rhs)
         {
            return Type .divide (lhs, rhs);
         },
         abs: function (value)
         {
            return value .abs ();
         },
         dot: function (SH, C0, C1, C2, C3)
         {
            c0 .assign (C0) .multiply (SH [0]);
            c1 .assign (C1) .multiply (SH [1]);
            c2 .assign (C2) .multiply (SH [2]);
            c3 .assign (C3) .multiply (SH [3]);

            return c0 .add (c1) .add (c2) .add (c3);
         },
      });

      return CatmullRomSplineInterpolatorInstance;
   };
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator3',[
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate",
   "standard/Math/Numbers/Vector3",
],
function (CatmullRomSplineInterpolatorTemplate,
          Vector3)
{
"use strict";

   return CatmullRomSplineInterpolatorTemplate (Vector3);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplinePositionInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolator3",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          CatmullRomSplineInterpolator3,
          X3DConstants)
{
"use strict";

   function SplinePositionInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .SplinePositionInterpolator);

      this .spline = new CatmullRomSplineInterpolator3 ();
   }

   SplinePositionInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: SplinePositionInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "SplinePositionInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue          .addInterest ("set_keyValue__",          this);
         this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
         this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec3f ());

         this .set_keyVelocity__ ();
      },
      set_keyVelocity__: function ()
      {
         if (this ._keyVelocity .length)
         {
            if (this ._keyVelocity .length < this ._key .length)
               this ._keyVelocity .resize (this ._key .length, new Fields .SFVec3f ());
         }

         this .set_normalizeVelocity__ ();
      },
      set_normalizeVelocity__: function ()
      {
         this .spline .generate (this ._closed .getValue (),
                                 this ._key,
                                 this ._keyValue,
                                 this ._keyVelocity,
                                 this ._normalizeVelocity .getValue ());
      },
      interpolate: function (index0, index1, weight)
      {
         this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
      },
   });

   return SplinePositionInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator2',[
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate",
   "standard/Math/Numbers/Vector2",
],
function (CatmullRomSplineInterpolatorTemplate,
          Vector2)
{
"use strict";

   return CatmullRomSplineInterpolatorTemplate (Vector2);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplinePositionInterpolator2D',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolator2",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          CatmullRomSplineInterpolator2,
          X3DConstants)
{
"use strict";

   function SplinePositionInterpolator2D (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .SplinePositionInterpolator2D);

      this .spline = new CatmullRomSplineInterpolator2 ();
   }

   SplinePositionInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: SplinePositionInterpolator2D,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFVec2f ()),
      ]),
      getTypeName: function ()
      {
         return "SplinePositionInterpolator2D";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue          .addInterest ("set_keyValue__",          this);
         this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
         this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec2f ());

         this .set_keyVelocity__ ();
      },
      set_keyVelocity__: function ()
      {
         if (this ._keyVelocity .length)
         {
            if (this ._keyVelocity .length < this ._key .length)
               this ._keyVelocity .resize (this ._key .length, new Fields .SFVec2f ());
         }

         this .set_normalizeVelocity__ ();
      },
      set_normalizeVelocity__: function ()
      {
         this .spline .generate (this ._closed .getValue (),
                                 this ._key,
                                 this ._keyValue,
                                 this ._keyVelocity,
                                 this ._normalizeVelocity .getValue ());
      },
      interpolate: function (index0, index1, weight)
      {
         this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
      },
   });

   return SplinePositionInterpolator2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator1',[
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolator"
],
function (CatmullRomSplineInterpolator)
{
"use strict";

   function CatmullRomSplineInterpolator1 ()
   {
      this .T0 = [ ];
      this .T1 = [ ];
   }

   CatmullRomSplineInterpolator1 .prototype = Object .assign (Object .create (CatmullRomSplineInterpolator .prototype),
   {
      constructor: CatmullRomSplineInterpolator1,
      create: function ()
      {
         return 0;
      },
      copy: function (value)
      {
         return value;
      },
      subtract: function (lhs, rhs)
      {
         return lhs - rhs;
      },
      multiply: function (lhs, rhs)
      {
         return lhs * rhs;
      },
      divide: function (lhs, rhs)
      {
         return lhs / rhs;
      },
      abs: function (value)
      {
         return Math .abs (value);
      },
      dot: function (SH, C0, C1, C2, C3)
      {
         return C0 * SH [0] + C1 * SH [1] + C2 * SH [2] + C3 * SH [3];
      },
   });

   return CatmullRomSplineInterpolator1;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplineScalarInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Browser/Interpolation/CatmullRomSplineInterpolator1",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          CatmullRomSplineInterpolator1,
          X3DConstants)
{
"use strict";

   function SplineScalarInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .SplineScalarInterpolator);

      this .spline = new CatmullRomSplineInterpolator1 ();
   }

   SplineScalarInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: SplineScalarInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "SplineScalarInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue          .addInterest ("set_keyValue__",          this);
         this ._keyVelocity       .addInterest ("set_keyVelocity__",       this);
         this ._normalizeVelocity .addInterest ("set_normalizeVelocity__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFFloat ());

         this .set_keyVelocity__ ();
      },
      set_keyVelocity__: function ()
      {
         if (this ._keyVelocity .length)
         {
            if (this ._keyVelocity .length < this ._key .length)
               this ._keyVelocity .resize (this ._key .length, new Fields .SFFloat ());
         }

         this .set_normalizeVelocity__ ();
      },
      set_normalizeVelocity__: function ()
      {
         this .spline .generate (this ._closed .getValue (),
                                 this ._key,
                                 this ._keyValue,
                                 this ._keyVelocity,
                                 this ._normalizeVelocity .getValue ());
      },
      interpolate: function (index0, index1, weight)
      {
         this ._value_changed = this .spline .interpolate (index0, index1, weight, this ._keyValue);
      },
   });

   return SplineScalarInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/SquatInterpolator',[
   "standard/Math/Numbers/Rotation4",
],
function (Rotation4)
{
"use strict";

   const result = new Rotation4 (0, 0, 1, 0);

   function SquatInterpolator ()
   {
      this .s = [ ];
   }

   SquatInterpolator .prototype =
   {
      constructor: SquatInterpolator,
      generate: function (closed, key, keyValue)
      {
         const s = this .s;

         s .length = 0;

         if (key .length > 1)
         {
            if (closed)
            {
               s .push (Rotation4 .spline (keyValue [key .length - 2] .getValue (),
                                           keyValue [0] .getValue (),
                                           keyValue [1] .getValue ()));
            }
            else
            {
               s .push (keyValue [0] .getValue ());
            }

            for (let i = 1, length = key .length - 1; i < length; ++ i)
            {
               s .push (Rotation4 .spline (keyValue [i - 1] .getValue (),
                                           keyValue [i]     .getValue (),
                                           keyValue [i + 1] .getValue ()));
            }

            if (closed)
            {
               s .push (Rotation4 .spline (keyValue [key .length - 2] .getValue (),
                                           keyValue [key .length - 1] .getValue (),
                                           keyValue [1] .getValue ()));
            }
            else
            {
               s .push (keyValue [key .length - 1] .getValue ());
            }
         }
         else if (key .length > 0)
            s .push (keyValue [0] .getValue () .copy ());
      },
      interpolate: function (index0, index1, weight, keyValue)
      {
         return result .assign (keyValue [index0] .getValue ()) .squad (this .s [index0],
                                                                        this .s [index1],
                                                                        keyValue [index1] .getValue (), weight);
      },
   };

   return SquatInterpolator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SquadOrientationInterpolator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
   "x_ite/Browser/Interpolation/SquatInterpolator",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          SquatInterpolator,
          X3DConstants)
{
"use strict";

   function SquadOrientationInterpolator (executionContext)
   {
      X3DInterpolatorNode .call (this, executionContext);

      this .addType (X3DConstants .SquadOrientationInterpolator);

      this ._keyValue      .setUnit ("angle");
      this ._value_changed .setUnit ("angle");

      this .squad = new SquatInterpolator ();
   }

   SquadOrientationInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
   {
      constructor: SquadOrientationInterpolator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "closed",        new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFRotation ()),
      ]),
      getTypeName: function ()
      {
         return "SquadOrientationInterpolator";
      },
      getComponentName: function ()
      {
         return "Interpolation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DInterpolatorNode .prototype .initialize .call (this);

         this ._keyValue    .addInterest ("set_keyValue__", this);
      },
      set_keyValue__: function ()
      {
         const
            key      = this ._key,
            keyValue = this ._keyValue;

         if (keyValue .length < key .length)
            keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFRotation ());

         this .squad .generate (this ._closed .getValue (),
                                this ._key,
                                this ._keyValue);
      },
      interpolate: function (index0, index1, weight)
      {
         try
         {
            this ._value_changed = this .squad .interpolate (index0, index1, weight, this ._keyValue);
         }
         catch (error)
         {
            console .error (error);
         }
      },
   });

   return SquadOrientationInterpolator;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Interpolation/ColorInterpolator",
   "x_ite/Components/Interpolation/CoordinateInterpolator",
   "x_ite/Components/Interpolation/CoordinateInterpolator2D",
   "x_ite/Components/Interpolation/EaseInEaseOut",
   "x_ite/Components/Interpolation/NormalInterpolator",
   "x_ite/Components/Interpolation/OrientationInterpolator",
   "x_ite/Components/Interpolation/PositionInterpolator",
   "x_ite/Components/Interpolation/PositionInterpolator2D",
   "x_ite/Components/Interpolation/ScalarInterpolator",
   "x_ite/Components/Interpolation/SplinePositionInterpolator",
   "x_ite/Components/Interpolation/SplinePositionInterpolator2D",
   "x_ite/Components/Interpolation/SplineScalarInterpolator",
   "x_ite/Components/Interpolation/SquadOrientationInterpolator",
   "x_ite/Components/Interpolation/X3DInterpolatorNode",
],
function (SupportedNodes,
          ColorInterpolator,
          CoordinateInterpolator,
          CoordinateInterpolator2D,
          EaseInEaseOut,
          NormalInterpolator,
          OrientationInterpolator,
          PositionInterpolator,
          PositionInterpolator2D,
          ScalarInterpolator,
          SplinePositionInterpolator,
          SplinePositionInterpolator2D,
          SplineScalarInterpolator,
          SquadOrientationInterpolator,
          X3DInterpolatorNode)
{
"use strict";

   const Types =
   {
      ColorInterpolator:            ColorInterpolator,
      CoordinateInterpolator:       CoordinateInterpolator,
      CoordinateInterpolator2D:     CoordinateInterpolator2D,
      EaseInEaseOut:                EaseInEaseOut,
      NormalInterpolator:           NormalInterpolator,
      OrientationInterpolator:      OrientationInterpolator,
      PositionInterpolator:         PositionInterpolator,
      PositionInterpolator2D:       PositionInterpolator2D,
      ScalarInterpolator:           ScalarInterpolator,
      SplinePositionInterpolator:   SplinePositionInterpolator,
      SplinePositionInterpolator2D: SplinePositionInterpolator2D,
      SplineScalarInterpolator:     SplineScalarInterpolator,
      SquadOrientationInterpolator: SquadOrientationInterpolator,
   };

   const AbstractTypes =
   {
      X3DInterpolatorNode: X3DInterpolatorNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Layering/Layer",
   "x_ite/Components/Layering/LayerSet",
   "x_ite/Components/Layering/Viewport",
   "x_ite/Components/Layering/X3DLayerNode",
   "x_ite/Components/Layering/X3DViewportNode",
],
function (SupportedNodes,
          Layer,
          LayerSet,
          Viewport,
          X3DLayerNode,
          X3DViewportNode)
{
"use strict";

   const Types =
   {
      Layer:    Layer,
      LayerSet: LayerSet,
      Viewport: Viewport,
   };

   const AbstractTypes =
   {
      X3DLayerNode:    X3DLayerNode,
      X3DViewportNode: X3DViewportNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/PointLight',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Lighting/X3DLightNode",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Camera",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Utility/MatrixStack",
   "standard/Math/Algorithm",
   "standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode,
          X3DGroupingNode,
          TraverseType,
          X3DConstants,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          Matrix4,
          MatrixStack,
          Algorithm,
          ObjectCache)
{
"use strict";

   // Shadow map layout
   // Compact layout:
   //
   // xzXZ		Char: Axis
   // yyYY		Case: Sign

   const orientationMatrices = [
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 1,  0,  0), Vector3 .zAxis)), // left
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 (-1,  0,  0), Vector3 .zAxis)), // right
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  0, -1), Vector3 .zAxis)), // front
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  0,  1), Vector3 .zAxis)), // back
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  1,  0), Vector3 .zAxis)), // bottom
      new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0, -1,  0), Vector3 .zAxis)), // top
   ];

   const viewports = [
      new Vector4 (0,    0.5, 0.25, 0.5), // left
      new Vector4 (0.5,  0.5, 0.25, 0.5), // right
      new Vector4 (0.75, 0.5, 0.25, 0.5), // front
      new Vector4 (0.25, 0.5, 0.25, 0.5), // back
      new Vector4 (0.0,  0,   0.5,  0.5), // bottom
      new Vector4 (0.5,  0,   0.5,  0.5), // top
   ];

   const PointLights = ObjectCache (PointLightContainer);

   function PointLightContainer ()
   {
      this .location                      = new Vector3 (0, 0, 0);
      this .matrixArray                   = new Float32Array (9);
      this .shadowBuffer                  = null;
      this .viewVolume                    = new ViewVolume ();
      this .viewport                      = new Vector4 (0, 0, 0, 0);
      this .projectionMatrix              = new Matrix4 ();
      this .modelViewMatrix               = new MatrixStack (Matrix4);
      this .modelMatrix                   = new Matrix4 ();
      this .invLightSpaceMatrix           = new Matrix4 ();
      this .invLightSpaceProjectionMatrix = new Matrix4 ();
      this .shadowMatrix                  = new Matrix4 ();
      this .shadowMatrixArray             = new Float32Array (16);
      this .rotation                      = new Rotation4 ();
      this .rotationMatrix                = new Matrix4 ();
      this .textureUnit                   = undefined;
   }

   PointLightContainer .prototype =
   {
      constructor: PointLightContainer,
      getModelViewMatrix: function ()
      {
         return this .modelViewMatrix;
      },
      set: function (browser, lightNode, groupNode, modelViewMatrix)
      {
         const shadowMapSize = lightNode .getShadowMapSize ();

         this .browser   = browser;
         this .lightNode = lightNode;
         this .groupNode = groupNode;

         this .matrixArray .set (modelViewMatrix .submatrix .inverse ());

         this .modelViewMatrix .pushMatrix (modelViewMatrix);

         // Get shadow buffer from browser.

         if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
         {
            this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

            if (!this .shadowBuffer)
               console .warn ("Couldn't create shadow buffer.");
         }
      },
      renderShadowMap: function (renderObject)
      {
         if (! this .shadowBuffer)
            return;

         const
            lightNode           = this .lightNode,
            cameraSpaceMatrix   = renderObject .getCameraSpaceMatrix () .get (),
            modelMatrix         = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
            invLightSpaceMatrix = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

         invLightSpaceMatrix .translate (lightNode .getLocation ());
         invLightSpaceMatrix .inverse ();

         const shadowMapSize  = lightNode .getShadowMapSize ();

         this .shadowBuffer .bind ();

         for (let i = 0; i < 6; ++ i)
         {
            const
               v                = viewports [i],
               viewport         = this .viewport .set (v [0] * shadowMapSize, v [1] * shadowMapSize, v [2] * shadowMapSize, v [3] * shadowMapSize),
               projectionMatrix = Camera .perspective2 (Algorithm .radians (90), 0.125, 10000, viewport [2], viewport [3], this .projectionMatrix); // Use higher far value for better precision.

            renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
            renderObject .getProjectionMatrix () .pushMatrix (this .projectionMatrix);
            renderObject .getModelViewMatrix  () .pushMatrix (orientationMatrices [i]);
            renderObject .getModelViewMatrix  () .multLeft (invLightSpaceMatrix);

            renderObject .render (TraverseType .SHADOW, X3DGroupingNode .prototype .traverse, this .groupNode);

            renderObject .getModelViewMatrix  () .pop ();
            renderObject .getProjectionMatrix () .pop ();
            renderObject .getViewVolumes () .pop ();
         }

         this .shadowBuffer .unbind ();

         if (! lightNode .getGlobal ())
            invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

         this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix);
      },
      setGlobalVariables: function (renderObject)
      {
         this .modelViewMatrix .get () .multVecMatrix (this .location .assign (this .lightNode ._location .getValue ()));

         this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
         this .shadowMatrixArray .set (this .shadowMatrix);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const i = shaderObject .numLights ++;

         if (shaderObject .hasLight (i, this))
            return;

         const
            lightNode   = this .lightNode,
            color       = lightNode .getColor (),
            attenuation = lightNode .getAttenuation (),
            location    = this .location;

         gl .uniform1i        (shaderObject .x3d_LightType [i],             2);
         gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
         gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
         gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
         gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
         gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
         gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
         gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

         if (this .shadowBuffer)
         {
            const
               browser     = this .browser,
               shadowColor = lightNode .getShadowColor ();

            gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
            gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
            gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
            gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
            gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());

            this .textureUnit = lightNode .getGlobal ()
               ? this .textureUnit === undefined ? browser .popTexture2DUnit () : this .textureUnit
               : browser .getTexture2DUnit ();

            if (this .textureUnit !== undefined)
            {
               gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

               if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
               else
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

               gl .uniform1i (shaderObject .x3d_ShadowMap [i], this .textureUnit);
            }
            else
            {
               console .warn ("Not enough combined texture units for shadow map available.");
            }
         }
      },
      dispose: function ()
      {
         // Return shadowBuffer and textureUnit.

         this .browser .pushShadowBuffer (this .shadowBuffer);

         if (this .lightNode .getGlobal ())
            this .browser .pushTexture2DUnit (this .textureUnit);

         this .modelViewMatrix .clear ();

         this .browser      = null;
         this .lightNode    = null;
         this .groupNode    = null;
         this .shadowBuffer = null;
         this .textureUnit  = undefined;

         // Return container

         PointLights .push (this);
      },
   };

   function PointLight (executionContext)
   {
      X3DLightNode .call (this, executionContext);

      this .addType (X3DConstants .PointLight);

      this ._location .setUnit ("length");
      this ._radius   .setUnit ("length");
   }

   PointLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
   {
      constructor: PointLight,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attenuation",      new Fields .SFVec3f (1, 0, 0)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "location",         new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "radius",           new Fields .SFFloat (100)),

         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadows",         new  Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat (1)),        // Intensity of shadow color in the range (0, 1).
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
         new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
      ]),
      getTypeName: function ()
      {
         return "PointLight";
      },
      getComponentName: function ()
      {
         return "Lighting";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getAttenuation: function ()
      {
         return this ._attenuation .getValue ();
      },
      getLocation: function ()
      {
         return this ._location .getValue ();
      },
      getRadius: function ()
      {
         return Math .max (0, this ._radius .getValue ());
      },
      getLights: function ()
      {
         return PointLights;
      },
   });

   return PointLight;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/SpotLight',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Lighting/X3DLightNode",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Geometry/Box3",
   "standard/Math/Geometry/Camera",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix3",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Utility/MatrixStack",
   "standard/Math/Algorithm",
   "standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode,
          X3DGroupingNode,
          TraverseType,
          X3DConstants,
          Box3,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          Matrix4,
          MatrixStack,
          Algorithm,
          ObjectCache)
{
"use strict";

   const SpotLights = ObjectCache (SpotLightContainer);

   function SpotLightContainer ()
   {
      this .location                      = new Vector3 (0, 0, 0);
      this .direction                     = new Vector3 (0, 0, 0);
      this .matrixArray                   = new Float32Array (9);
      this .renderShadow                  = true;
      this .shadowBuffer                  = null;
      this .bbox                          = new Box3 ();
      this .viewVolume                    = new ViewVolume ();
      this .viewport                      = new Vector4 (0, 0, 0, 0);
      this .projectionMatrix              = new Matrix4 ();
      this .modelViewMatrix               = new MatrixStack (Matrix4);
      this .modelMatrix                   = new Matrix4 ();
      this .invLightSpaceMatrix           = new Matrix4 ();
      this .invLightSpaceProjectionMatrix = new Matrix4 ();
      this .shadowMatrix                  = new Matrix4 ();
      this .shadowMatrixArray             = new Float32Array (16);
      this .rotation                      = new Rotation4 ();
      this .lightBBoxMin                  = new Vector3 (0, 0, 0);
      this .lightBBoxMax                  = new Vector3 (0, 0, 0);
      this .textureUnit                   = undefined;
   }

   SpotLightContainer .prototype =
   {
      constructor: SpotLightContainer,
      getModelViewMatrix: function ()
      {
         return this .modelViewMatrix;
      },
      set: function (browser, lightNode, groupNode, modelViewMatrix)
      {
         const shadowMapSize = lightNode .getShadowMapSize ();

         this .browser   = browser;
         this .lightNode = lightNode;
         this .groupNode = groupNode;

         this .matrixArray .set (modelViewMatrix .submatrix .inverse ());

         this .modelViewMatrix .pushMatrix (modelViewMatrix);

         // Get shadow buffer from browser.

         if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
         {
            this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

            if (!this .shadowBuffer)
               console .warn ("Couldn't create shadow buffer.");
         }
      },
      renderShadowMap: function (renderObject)
      {
         if (! this .shadowBuffer)
            return;

         const
            lightNode            = this .lightNode,
            cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
            modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
            invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

         invLightSpaceMatrix .translate (lightNode .getLocation ());
         invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Vector3 .zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
         invLightSpaceMatrix .inverse ();

         const
            groupBBox        = this .groupNode .getSubBBox (this .bbox, true),                 // Group bbox.
            lightBBox        = groupBBox .multRight (invLightSpaceMatrix),                     // Group bbox from the perspective of the light.
            lightBBoxExtents = lightBBox .getExtents (this .lightBBoxMin, this .lightBBoxMax), // Result not used, but arguments.
            shadowMapSize    = lightNode .getShadowMapSize (),
            farValue         = Math .min (lightNode .getRadius (), -this .lightBBoxMin .z),
            viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
            projectionMatrix = Camera .perspective (lightNode .getCutOffAngle () * 2, 0.125, Math .max (10000, farValue), shadowMapSize, shadowMapSize, this .projectionMatrix); // Use higher far value for better precision.

         this .renderShadow = farValue > 0;

         this .shadowBuffer .bind ();

         renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
         renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
         renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

         renderObject .render (TraverseType .SHADOW, X3DGroupingNode .prototype .traverse, this .groupNode);

         renderObject .getModelViewMatrix  () .pop ();
         renderObject .getProjectionMatrix () .pop ();
         renderObject .getViewVolumes      () .pop ();

         this .shadowBuffer .unbind ();

         if (! lightNode .getGlobal ())
            invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

         this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
      },
      setGlobalVariables: function (renderObject)
      {
         const
            lightNode       = this .lightNode,
            modelViewMatrix = this .modelViewMatrix .get ();

         modelViewMatrix .multVecMatrix (this .location  .assign (lightNode ._location  .getValue ()));
         modelViewMatrix .multDirMatrix (this .direction .assign (lightNode ._direction .getValue ())) .normalize ();

         this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
         this .shadowMatrixArray .set (this .shadowMatrix);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const i = shaderObject .numLights ++;

         if (shaderObject .hasLight (i, this))
            return;

         const
            lightNode   = this .lightNode,
            color       = lightNode .getColor (),
            attenuation = lightNode .getAttenuation (),
            location    = this .location,
            direction   = this .direction;

         gl .uniform1i        (shaderObject .x3d_LightType [i],             3);
         gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
         gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
         gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
         gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
         gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
         gl .uniform3f        (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);
         gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
         gl .uniform1f        (shaderObject .x3d_LightBeamWidth [i],        lightNode .getBeamWidth ());
         gl .uniform1f        (shaderObject .x3d_LightCutOffAngle [i],      lightNode .getCutOffAngle ());
         gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

         if (this .renderShadow && this .shadowBuffer)
         {
            const
               browser     = this .browser,
               shadowColor = lightNode .getShadowColor ();

            gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
            gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
            gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
            gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
            gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());

            this .textureUnit = lightNode .getGlobal ()
               ? this .textureUnit === undefined ? browser .popTexture2DUnit () : this .textureUnit
               : browser .getTexture2DUnit ();

            if (this .textureUnit !== undefined)
            {
               gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

               if (gl .getVersion () >= 2 || gl .getExtension ("WEBGL_depth_texture"))
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
               else
                  gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

               gl .uniform1i (shaderObject .x3d_ShadowMap [i], this .textureUnit);
            }
            else
            {
               console .warn ("Not enough combined texture units for shadow map available.");
            }
         }
      },
      dispose: function ()
      {
         // Return shadowBuffer and textureUnit.

         this .browser .pushShadowBuffer (this .shadowBuffer);

         if (this .lightNode .getGlobal ())
            this .browser .pushTexture2DUnit (this .textureUnit);

         this .modelViewMatrix .clear ();

         this .browser      = null;
         this .lightNode    = null;
         this .groupNode    = null;
         this .shadowBuffer = null;
         this .textureUnit  = undefined;

         // Return container

         SpotLights .push (this);
      },
   };

   function SpotLight (executionContext)
   {
      X3DLightNode .call (this, executionContext);

      this .addType (X3DConstants .SpotLight);

      switch (executionContext .getSpecificationVersion ())
      {
         case "2.0":
         case "3.0":
         case "3.1":
         case "3.2":
         {
            this ._beamWidth   = 1.5708;
            this ._cutOffAngle = 0.785398;
         }
      }

      this ._location    .setUnit ("length");
      this ._radius      .setUnit ("length");
      this ._beamWidth   .setUnit ("angle");
      this ._cutOffAngle .setUnit ("angle");
   }

   SpotLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
   {
      constructor: SpotLight,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attenuation",      new Fields .SFVec3f (1, 0, 0)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "location",         new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",        new Fields .SFVec3f (0, 0, -1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "radius",           new Fields .SFFloat (100)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "beamWidth",        new Fields .SFFloat (0.785398)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "cutOffAngle",      new Fields .SFFloat (1.5708)),

         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadows",         new  Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat (1)),       // Intensity of shadow color in the range (0, 1).
         new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
         new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
      ]),
      getTypeName: function ()
      {
         return "SpotLight";
      },
      getComponentName: function ()
      {
         return "Lighting";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getAttenuation: function ()
      {
         return this ._attenuation .getValue ();
      },
      getLocation: function ()
      {
         return this ._location .getValue ();
      },
      getRadius: function ()
      {
         return Math .max (0, this ._radius .getValue ());
      },
      getBeamWidth: function ()
      {
         // If the beamWidth is greater than the cutOffAngle, beamWidth is defined to be equal to the cutOffAngle.

         const
            beamWidth   = this ._beamWidth .getValue (),
            cutOffAngle = this .getCutOffAngle ();

         if (beamWidth > cutOffAngle)
            return cutOffAngle;

         return Algorithm .clamp (beamWidth, 0, Math .PI / 2);
      },
      getCutOffAngle: function ()
      {
         return Algorithm .clamp (this ._cutOffAngle .getValue (), 0, Math .PI / 2);
      },
      getLights: function ()
      {
         return SpotLights;
      },
   });

   return SpotLight;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Lighting/DirectionalLight",
   "x_ite/Components/Lighting/PointLight",
   "x_ite/Components/Lighting/SpotLight",
   "x_ite/Components/Lighting/X3DLightNode",
],
function (SupportedNodes,
          DirectionalLight,
          PointLight,
          SpotLight,
          X3DLightNode)
{
"use strict";

   const Types =
   {
      DirectionalLight: DirectionalLight,
      PointLight:       PointLight,
      SpotLight:        SpotLight,
   };

   const AbstractTypes =
   {
      X3DLightNode: X3DLightNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Billboard',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Rendering/TraverseType",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DConstants,
          TraverseType,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

   function Billboard (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .Billboard);

      this .matrix = new Matrix4 ();
   }

   Billboard .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: Billboard,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "axisOfRotation", new Fields .SFVec3f (0, 1, 0)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Billboard";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      getBBox: function (bbox, shadow)
      {
         return X3DGroupingNode .prototype .getBBox .call (this, bbox, shadow) .multRight (this .matrix);
      },
      getMatrix: function ()
      {
         return this .matrix;
      },
      rotate: (function ()
      {
         const
            inverseModelViewMatrix = new Matrix4 (),
            viewerYAxis            = new Vector3 (0, 0, 0),
            y                      = new Vector3 (0, 0, 0),
            N1                     = new Vector3 (0, 0, 0),
            N2                     = new Vector3 (0, 0, 0),
            rotation               = new Rotation4 (0, 0, 1, 0);

         return function (modelViewMatrix)
         {
            // throws domain error

            inverseModelViewMatrix .assign (modelViewMatrix) .inverse ();

            const billboardToViewer = inverseModelViewMatrix .origin .normalize (); // Normalized to get work with Geo

            if (this ._axisOfRotation .getValue () .equals (Vector3 .Zero))
            {
               inverseModelViewMatrix .multDirMatrix (viewerYAxis .assign (Vector3 .yAxis)) .normalize (); // Normalized to get work with Geo

               const x = viewerYAxis .cross (billboardToViewer);
               y .assign (billboardToViewer) .cross (x);
               const z = billboardToViewer;

               // Compose rotation

               x .normalize ();
               y .normalize ();

               this .matrix .set (x .x, x .y, x .z, 0,
                                  y .x, y .y, y .z, 0,
                                  z .x, z .y, z .z, 0,
                                  0,    0,    0,    1);
            }
            else
            {
               N1 .assign (this ._axisOfRotation .getValue ()) .cross (billboardToViewer); // Normal vector of plane as in specification
               N2 .assign (this ._axisOfRotation .getValue ()) .cross (Vector3 .zAxis);    // Normal vector of plane between axisOfRotation and zAxis

               this .matrix .setRotation (rotation .setFromToVec (N2, N1));                // Rotate zAxis in plane
            }

            return this .matrix;
         };
      })(),
      traverse: function (type, renderObject)
      {
         const modelViewMatrix = renderObject .getModelViewMatrix ();

         modelViewMatrix .push ();

         switch (type)
         {
            case TraverseType .CAMERA:
            case TraverseType .PICKING:
            case TraverseType .SHADOW:
               // No clone support for shadow, generated cube map texture, and bbox
               modelViewMatrix .multLeft (this .matrix);
               break;
            default:
               modelViewMatrix .multLeft (this .rotate (modelViewMatrix .get ()));
               break;
         }

         X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

         modelViewMatrix .pop ();
      },
   });

   return Billboard;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Collision',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Components/Core/X3DSensorNode",
   "x_ite/Base/X3DCast",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DSensorNode,
          X3DCast,
          TraverseType,
          X3DConstants)
{
"use strict";

   function Collision (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);
      X3DSensorNode   .call (this, executionContext);

      this .addType (X3DConstants .Collision);

      if (executionContext .getSpecificationVersion () === "2.0")
         this .addAlias ("collide", this ._enabled); // VRML2
   }

   Collision .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
      X3DSensorNode .prototype,
   {
      constructor: Collision,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "enabled",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",       new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "collideTime",    new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",        new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "proxy",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Collision";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DGroupingNode .prototype .initialize .call (this);
         //X3DSensorNode   .prototype .initialize .call (this); // We can only call the base of a *Objects.

         this .isLive () .addInterest ("set_live__", this);
         this ._enabled  .addInterest ("set_live__", this);
         this ._proxy    .addInterest ("set_proxy__", this);

         this .set_live__ ();
         this .set_proxy__ ();
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue () && this ._enabled .getValue ())
            this .getBrowser () .addCollision (this);

         else
            this .getBrowser () .removeCollision (this);
      },
      set_active: function (value)
      {
         if (this ._isActive .getValue () !== value)
         {
            this ._isActive = value;

            if (value)
               this ._collideTime = this .getBrowser () .getCurrentTime ();
         }
      },
      set_proxy__: function ()
      {
         this .proxyNode = X3DCast (X3DConstants .X3DChildNode, this ._proxy);
      },
      traverse: function (type, renderObject)
      {
         switch (type)
         {
            case TraverseType .COLLISION:
            {
               if (this ._enabled .getValue ())
               {
                  const collisions = renderObject .getCollisions ();

                  collisions .push (this);

                  if (this .proxyNode)
                     this .proxyNode .traverse (type, renderObject);

                  else
                     X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

                  collisions .pop ();
               }

               return;
            }
            default:
            {
               X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
               return;
            }
         }
      },
   });

   return Collision;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/LOD',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Base/X3DCast",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DCast,
          TraverseType,
          X3DConstants,
          Matrix4,
          Algorithm)
{
"use strict";

   function LOD (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);

      this .addType (X3DConstants .LOD);

      if (executionContext .getSpecificationVersion () === "2.0")
         this .addAlias ("level", this ._children); // VRML2

      this ._center .setUnit ("length");
      this ._range  .setUnit ("length");

      this .frameRate        = 60;
      this .keepCurrentLevel = false;
      this .childNode        = null;
      this .visibleNode      = null;
      this .boundedObject    = null;
   }

   LOD .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
   {
      constructor: LOD,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "forceTransitions", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "center",           new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "range",            new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "level_changed",    new Fields .SFInt32 (-1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",      new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",         new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",       new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",      new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren",   new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",         new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "LOD";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DGroupingNode .prototype .initialize .call (this);

         this ._children .addInterest ("set_child__", this);
      },
      getSubBBox: function (bbox, shadow)
      {
         if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
         {
            const boundedObject = X3DCast (X3DConstants .X3DBoundedObject, this .visibleNode);

            if (boundedObject)
               return boundedObject .getBBox (bbox, shadow);

            return bbox .set ();
         }

         return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
      },
      clear: function () { },
      add: function () { },
      remove: function () { },
      set_child__: function ()
      {
         this .set_level__ (Math .min (this ._level_changed .getValue (), this ._children .length - 1));
      },
      set_level__: function (level)
      {
         if (this .childNode)
         {
            this .childNode ._isCameraObject   .removeInterest ("set_cameraObject__",     this);
            this .childNode ._isPickableObject .removeInterest ("set_transformSensors__", this);
         }

         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .childNode ._visible     .removeInterest ("set_visible__",     this);
            this .childNode ._bboxDisplay .removeInterest ("set_bboxDisplay__", this);
         }

         if (level >= 0 && level < this ._children .length)
         {
            this .childNode = X3DCast (X3DConstants .X3DChildNode, this ._children [level]);

            if (this .childNode)
            {
               this .childNode ._isCameraObject   .addInterest ("set_cameraObject__",     this);
               this .childNode ._isPickableObject .addInterest ("set_transformSensors__", this);

               if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
               {
                  this .childNode ._visible     .addInterest ("set_visible__",     this);
                  this .childNode ._bboxDisplay .addInterest ("set_bboxDisplay__", this);
               }

               //delete this .traverse;
            }
         }
         else
         {
            this .childNode = null;

            //this .traverse = Function .prototype; // Don't do that.
         }

         this .set_transformSensors__ ();
         this .set_visible__ ();
         this .set_bboxDisplay__ ();
      },
      set_cameraObject__: function ()
      {
         if (this .childNode && this .childNode .getCameraObject ())
         {
            if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
            {
               this .setCameraObject (this .childNode ._visible .getValue ());
            }
            else
            {
               this .setCameraObject (true);
            }
         }
         else
         {
            this .setCameraObject (false);
         }
      },
      set_transformSensors__: function ()
      {
         this .setPickableObject (Boolean (this .getTransformSensors () .size || this .childNode && this .childNode .getPickableObject ()));
      },
      set_visible__: function ()
      {
         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .visibleNode = this .childNode ._visible .getValue () ? this .childNode : null;
         }
         else
         {
            this .visibleNode = this .childNode;
         }

         this .set_cameraObject__ ();
      },
      set_bboxDisplay__: function ()
      {
         if (X3DCast (X3DConstants .X3DBoundedObject, this .childNode))
         {
            this .boundedObject = this .childNode ._bboxDisplay .getValue () ? this .childNode : null;
         }
         else
         {
            this .boundedObject = null;
         }
      },
      getLevel: (function ()
      {
         const
            FRAMES         = 180, // Number of frames after wich a level change takes in affect.
            FRAME_RATE_MIN = 20,  // Lowest level of detail.
            FRAME_RATE_MAX = 55;  // Highest level of detail.

         return function (browser, modelViewMatrix)
         {
            if (this ._range .length === 0)
            {
               this .frameRate = ((FRAMES - 1) * this .frameRate + browser .currentFrameRate) / FRAMES;

               const size = this ._children .length;

               switch (size)
               {
                  case 0:
                     return -1;
                  case 1:
                     return 0;
                  case 2:
                     return +(this .frameRate > FRAME_RATE_MAX);
                  default:
                  {
                     const fraction = 1 - Algorithm .clamp ((this .frameRate - FRAME_RATE_MIN) / (FRAME_RATE_MAX - FRAME_RATE_MIN), 0, 1);

                     return Math .min (Math .floor (fraction * size), size - 1);
                  }
               }
            }

            const distance = modelViewMatrix .translate (this ._center .getValue ()) .origin .abs ();

            return Algorithm .upperBound (this ._range, 0, this ._range .length, distance);
         };
      })(),
      traverse: (function ()
      {
         const modelViewMatrix = new Matrix4 ();

         return function (type, renderObject)
         {
            switch (type)
            {
               case TraverseType .POINTER:
               case TraverseType .CAMERA:
               case TraverseType .SHADOW:
               {
                  const visibleNode = this .visibleNode;

                  if (visibleNode)
                     visibleNode .traverse (type, renderObject);

                  return;
               }
               case TraverseType .PICKING:
               {
                  if (this .getTransformSensors () .size)
                  {
                     const modelMatrix = renderObject .getModelViewMatrix () .get ();

                     for (const transformSensorNode of this .getTransformSensors ())
                        transformSensorNode .collect (modelMatrix);
                  }

                  const childNode = this .childNode;

                  if (childNode)
                  {
                     const
                        browser          = renderObject .getBrowser (),
                        pickingHierarchy = browser .getPickingHierarchy ();

                     pickingHierarchy .push (this);

                     childNode .traverse (type, renderObject);

                     pickingHierarchy .pop ();
                  }

                  return;
               }
               case TraverseType .COLLISION:
               {
                  const childNode = this .childNode;

                  if (childNode)
                     childNode .traverse (type, renderObject);

                  return;
               }
               case TraverseType .DISPLAY:
               {
                  if (! this .keepCurrentLevel)
                  {
                     let
                        level        = this .getLevel (renderObject .getBrowser (), modelViewMatrix .assign (renderObject .getModelViewMatrix () .get ())),
                        currentLevel = this ._level_changed .getValue ();

                     if (this ._forceTransitions .getValue ())
                     {
                        if (level > currentLevel)
                           level = currentLevel + 1;

                        else if (level < currentLevel)
                           level = currentLevel - 1;
                     }

                     if (level !== currentLevel)
                     {
                        this ._level_changed = level;

                        this .set_level__ (Math .min (level, this ._children .length - 1));
                     }
                  }

                  const visibleNode = this .visibleNode;

                  if (visibleNode)
                     visibleNode .traverse (type, renderObject);

                  const boundedObject = this .boundedObject;

                  if (boundedObject)
                     boundedObject .displayBBox (type, renderObject);

                  return;
               }
            }
         };
      })(),
   });

   return LOD;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/ViewpointGroup',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/EnvironmentalSensor/ProximitySensor",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          ProximitySensor,
          TraverseType,
          X3DConstants,
          Vector3)
{
"use strict";

   function ViewpointGroup (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .ViewpointGroup);

      this ._size   .setUnit ("length");
      this ._center .setUnit ("length");

      this .proximitySensor  = new ProximitySensor (executionContext);
      this .cameraObjects    = [ ];
      this .viewpointGroups  = [ ];
   }

   ViewpointGroup .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: ViewpointGroup,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "displayed",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "size",              new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "center",            new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "children",          new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "ViewpointGroup";
      },
      getComponentName: function ()
      {
         return "Navigation";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);

         this .proximitySensor .setup ();

         this ._size   .addFieldInterest (this .proximitySensor ._size);
         this ._center .addFieldInterest (this .proximitySensor ._center);

         this .proximitySensor ._size   = this ._size;
         this .proximitySensor ._center = this ._center;

         this ._displayed .addInterest ("set_displayed__", this);
         this ._size      .addInterest ("set_displayed__", this);
         this ._children  .addInterest ("set_children__", this);

         this .set_displayed__ ();
         this .set_children__ ();
      },
      isActive: function ()
      {
         return this .proximitySensor ._isActive .getValue ();
      },
      set_displayed__: function ()
      {
         var
            proxy     = ! this ._size .getValue () .equals (Vector3 .Zero),
            displayed = this ._displayed .getValue ();

         this .proximitySensor ._enabled = displayed && proxy;

         if (displayed && proxy)
         {
            this .proximitySensor ._isCameraObject   .addFieldInterest (this ._isCameraObject);
            this .proximitySensor ._isPickableObject .addFieldInterest (this ._isPickableObject);

            this .setCameraObject   (this .proximitySensor .getCameraObject ());
            this .setPickableObject (this .proximitySensor .getPickableObject ());

            this .traverse = traverseWithProximitySensor;
         }
         else
         {
            this .proximitySensor ._isCameraObject    .removeFieldInterest (this ._isCameraObject);
            this .proximitySensor ._isPickableObject .removeFieldInterest (this ._isPickableObject);

            this .setCameraObject   (displayed);
            this .setPickableObject (false);

            if (displayed)
               this .traverse = traverse;
            else
               delete this .traverse;
         }
      },
      set_children__: function ()
      {
         this .cameraObjects   .length = 0;
         this .viewpointGroups .length = 0;

         var children = this ._children;

         for (var i = 0, length = children .length; i < length; ++ i)
         {
            try
            {
               var
                  innerNode = children [i] .getValue () .getInnerNode (),
                  type      = innerNode .getType ();

               for (var t = type .length - 1; t >= 0; -- t)
               {
                  switch (type [t])
                  {
                     case X3DConstants .X3DViewpointNode:
                     {
                        this .cameraObjects .push (innerNode);
                        break;
                     }
                     case X3DConstants .ViewpointGroup:
                     {
                        this .cameraObjects   .push (innerNode);
                        this .viewpointGroups .push (innerNode);
                        break;
                     }
                  }
               }
            }
            catch (error)
            { }
         }
      },
      traverse: function () { },
   });

   function traverseWithProximitySensor (type, renderObject)
   {
      switch (type)
      {
         case TraverseType .CAMERA:
         {
            this .proximitySensor .traverse (type, renderObject);

            if (this .proximitySensor ._isActive .getValue ())
            {
               for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
                  this .cameraObjects [i] .traverse (type, renderObject);
            }

            return;
         }
         case TraverseType .DISPLAY:
         {
            this .proximitySensor .traverse (type, renderObject);

            if (this .proximitySensor ._isActive .getValue ())
            {
               for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
                  this .viewpointGroups [i] .traverse (type, renderObject);
            }

            return;
         }
      }
   }

   function traverse (type, renderObject)
   {
      switch (type)
      {
         case TraverseType .CAMERA:
         {
            for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
               this .cameraObjects [i] .traverse (type, renderObject);

            return;
         }
         case TraverseType .DISPLAY:
         {
            for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
               this .viewpointGroups [i] .traverse (type, renderObject);

            return;
         }
      }
   }

   return ViewpointGroup;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Navigation/Billboard",
   "x_ite/Components/Navigation/Collision",
   "x_ite/Components/Navigation/LOD",
   "x_ite/Components/Navigation/NavigationInfo",
   "x_ite/Components/Navigation/OrthoViewpoint",
   "x_ite/Components/Navigation/Viewpoint",
   "x_ite/Components/Navigation/ViewpointGroup",
   "x_ite/Components/Navigation/X3DViewpointNode",
],
function (SupportedNodes,
          Billboard,
          Collision,
          LOD,
          NavigationInfo,
          OrthoViewpoint,
          Viewpoint,
          ViewpointGroup,
          X3DViewpointNode)
{
"use strict";

   const Types =
   {
      Billboard:      Billboard,
      Collision:      Collision,
      LOD:            LOD,
      NavigationInfo: NavigationInfo,
      OrthoViewpoint: OrthoViewpoint,
      Viewpoint:      Viewpoint,
      ViewpointGroup: ViewpointGroup,
   };

   const AbstractTypes =
   {
      X3DViewpointNode: X3DViewpointNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/PointingDeviceSensorContainer',[
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Matrix4",
],
function (Vector4,
          Matrix4)
{
"use strict";

   function PointingDeviceSensorContainer (node, modelViewMatrix, projectionMatrix, viewport)
   {
      this .node             = null;
      this .modelViewMatrix  = new Matrix4 ();
      this .projectionMatrix = new Matrix4 ();
      this .viewport         = new Vector4 (0, 0, 0, 0);

      this .set (node, modelViewMatrix, projectionMatrix, viewport);
   }

   PointingDeviceSensorContainer .prototype =
   {
      set: function (node, modelViewMatrix, projectionMatrix, viewport)
      {
         this .node = node;

         this .modelViewMatrix  .assign (modelViewMatrix);
         this .projectionMatrix .assign (projectionMatrix);
         this .viewport         .assign (viewport);
      },
      set_over__: function (over, hit)
      {
         this .node .set_over__ (over, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
      },
      set_active__: function (active, hit)
      {
         this .node .set_active__ (active, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
      },
      set_motion__: function (hit)
      {
         this .node .set_motion__ (hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
      },
   };

   return PointingDeviceSensorContainer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode',[
   "x_ite/Components/Core/X3DSensorNode",
   "x_ite/Browser/PointingDeviceSensor/PointingDeviceSensorContainer",
   "x_ite/Base/X3DConstants",
],
function (X3DSensorNode,
          PointingDeviceSensorContainer,
          X3DConstants)
{
"use strict";

   function X3DPointingDeviceSensorNode (executionContext)
   {
      X3DSensorNode .call (this, executionContext);

      this .addType (X3DConstants .X3DPointingDeviceSensorNode);
   }

   X3DPointingDeviceSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
   {
      constructor: X3DPointingDeviceSensorNode,
      initialize: function ()
      {
         X3DSensorNode .prototype .initialize .call (this);

         this ._enabled .addInterest ("set_enabled__", this);
      },
      getMatrices: function ()
      {
         return this .matrices;
      },
      set_enabled__: function ()
      {
         if (this ._enabled .getValue ())
            return;

         if (this ._isActive .getValue ())
            this ._isActive = false;

         if (this ._isOver .getValue ())
            this ._isOver = false;
      },
      set_over__: function (over, hit)
      {
         if (over !== this ._isOver .getValue ())
         {
            this ._isOver = over;

            if (over)
               this .getBrowser () .getNotification () ._string = this ._description;
         }
      },
      set_active__: function (active, hit)
      {
         if (active !== this ._isActive .getValue ())
            this ._isActive = active
      },
      set_motion__: function (hit)
      { },
      push: function (renderObject, sensors)
      {
         if (this ._enabled .getValue ())
         {
            sensors .set (this, new PointingDeviceSensorContainer (this,
                                                                   renderObject .getModelViewMatrix  () .get (),
                                                                   renderObject .getProjectionMatrix () .get (),
                                                                   renderObject .getViewVolume () .getViewport ()));
         }
      },
   });

   return X3DPointingDeviceSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode',[
   "x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
   "x_ite/Base/X3DConstants",
],
function (X3DPointingDeviceSensorNode,
          X3DConstants)
{
"use strict";

   function X3DTouchSensorNode (executionContext)
   {
      X3DPointingDeviceSensorNode .call (this, executionContext);

      this .addType (X3DConstants .X3DTouchSensorNode);
   }

   X3DTouchSensorNode .prototype = Object .assign (Object .create (X3DPointingDeviceSensorNode .prototype),
   {
      constructor: X3DTouchSensorNode,
      set_active__: function (active, hit)
      {
         X3DPointingDeviceSensorNode .prototype .set_active__ .call (this, active, hit);

         if (this ._enabled .getValue () && this ._isOver .getValue () && ! active)
            this ._touchTime = this .getBrowser () .getCurrentTime ();
      },
   });

   return X3DTouchSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/TouchSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTouchSensorNode,
          X3DConstants,
          Matrix4)
{
"use strict";

   var invModelViewMatrix = new Matrix4 ();

   function TouchSensor (executionContext)
   {
      X3DTouchSensorNode .call (this, executionContext);

      this .addType (X3DConstants .TouchSensor);

      this ._hitPoint_changed .setUnit ("length");
   }

   TouchSensor .prototype = Object .assign (Object .create (X3DTouchSensorNode .prototype),
   {
      constructor: TouchSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",         new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "hitTexCoord_changed", new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "hitNormal_changed",   new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "hitPoint_changed",    new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",              new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "touchTime",           new Fields .SFTime ()),
      ]),
      getTypeName: function ()
      {
         return "TouchSensor";
      },
      getComponentName: function ()
      {
         return "PointingDeviceSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      set_over__: function (over, hit, modelViewMatrix, projectionMatrix, viewport)
      {
         X3DTouchSensorNode .prototype .set_over__ .call (this, over, hit, modelViewMatrix, projectionMatrix, viewport);

         if (this ._isOver .getValue ())
         {
            var intersection = hit .intersection;

            invModelViewMatrix .assign (modelViewMatrix) .inverse ();

            this ._hitTexCoord_changed = intersection .texCoord;
            this ._hitNormal_changed   = modelViewMatrix .multMatrixDir (intersection .normal .copy ()) .normalize ();
            this ._hitPoint_changed    = invModelViewMatrix .multVecMatrix (intersection .point .copy ());
         }
      },
   });

   return TouchSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/Anchor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Grouping/X3DGroupingNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Components/PointingDeviceSensor/TouchSensor",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/FileLoader",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DUrlObject,
          TouchSensor,
          TraverseType,
          X3DConstants,
          FileLoader)
{
"use strict";

   function Anchor (executionContext)
   {
      X3DGroupingNode .call (this, executionContext);
      X3DUrlObject    .call (this, executionContext);

      this .addType (X3DConstants .Anchor);

      this .touchSensorNode = new TouchSensor (executionContext);
      this .sensors         = new Map ();
   }

   Anchor .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: Anchor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "description",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "parameter",            new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",          new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",             new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",           new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren",       new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "children",             new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Anchor";
      },
      getComponentName: function ()
      {
         return "Networking";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DGroupingNode .prototype .initialize .call (this);
         X3DUrlObject    .prototype .initialize .call (this);

         this ._description .addFieldInterest (this .touchSensorNode ._description);
         this ._load        .addFieldInterest (this .touchSensorNode ._enabled);

         this .touchSensorNode ._description = this ._description;
         this .touchSensorNode ._enabled     = this ._load;
         this .touchSensorNode .setup ();

         // Modify set_active__ to get immediate response to user action (click event), otherwise links are not opened in this window.

         const
            anchor       = this,
            set_active__ = this .touchSensorNode .set_active__;

         this .touchSensorNode .set_active__ = function (active, hit)
         {
            set_active__ .call (this, active, hit);

            if (this ._isOver .getValue () && ! active)
               anchor .requestImmediateLoad ();
         };
      },
      set_load__: function ()
      { },
      set_url__: function ()
      { },
      requestImmediateLoad: function (cache = true)
      {
         this .setCache (cache);
         this .setLoadState (X3DConstants .IN_PROGRESS_STATE, false);

         new FileLoader (this) .createX3DFromURL (this ._url, this ._parameter,
         function (scene)
         {
            if (scene)
            {
               this .getBrowser () .replaceWorld (scene);
               this .setLoadState (X3DConstants .COMPLETE_STATE, false);
            }
            else
               this .setLoadState (X3DConstants .FAILED_STATE, false);
         }
         .bind (this),
         function (viewpointName)
         {
            this .getBrowser () .changeViewpoint (viewpointName);
            this .setLoadState (X3DConstants .COMPLETE_STATE, false);
         }
         .bind (this),
         function (url, target)
         {
            if (target)
               window .open (url, target);
            else
               location = url;

            this .setLoadState (X3DConstants .COMPLETE_STATE, false);
         }
         .bind (this));
      },
      requestUnload ()
      { },
      traverse: function (type, renderObject)
      {
         if (type === TraverseType .POINTER)
         {
            const
               sensorsStack = renderObject .getBrowser () .getSensors (),
               sensors      = this .sensors;

            sensors .clear ();

            this .touchSensorNode .push (renderObject, sensors);

            if (sensors .size)
               sensorsStack .push (sensors);

            X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

            if (sensors .size)
               sensorsStack .pop ();
         }
         else
         {
            X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
         }
      },
   });

   return Anchor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/Inline',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Components/Grouping/X3DBoundedObject",
   "x_ite/Components/Grouping/Group",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "x_ite/InputOutput/FileLoader",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DUrlObject,
          X3DBoundedObject,
          Group,
          TraverseType,
          X3DConstants,
          FileLoader)
{
"use strict";

   function Inline (executionContext)
   {
      X3DChildNode     .call (this, executionContext);
      X3DUrlObject     .call (this, executionContext);
      X3DBoundedObject .call (this, executionContext);

      this .addType (X3DConstants .Inline);

      this .scene = this .getBrowser () .getDefaultScene ();
      this .group = new Group (executionContext);

      this .group .addParent (this);
   }

   Inline .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DUrlObject .prototype,
      X3DBoundedObject .prototype,
   {
      constructor: Inline,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "visible",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "bboxDisplay",          new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",             new Fields .SFVec3f (-1, -1, -1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",           new Fields .SFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "Inline";
      },
      getComponentName: function ()
      {
         return "Networking";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DChildNode     .prototype .initialize .call (this);
         X3DUrlObject     .prototype .initialize .call (this);
         X3DBoundedObject .prototype .initialize .call (this);

         this .group .setPrivate (true);
         this .group .setup ();

         this .group ._isCameraObject   .addFieldInterest (this ._isCameraObject);
         this .group ._isPickableObject .addFieldInterest (this ._isPickableObject);

         this .requestImmediateLoad ();
      },
      getBBox: function (bbox, shadow)
      {
         if (this ._bboxSize .getValue () .equals (this .getDefaultBBoxSize ()))
            return this .group .getBBox (bbox, shadow);

         return bbox .set (this ._bboxSize .getValue (), this ._bboxCenter .getValue ());
      },
      set_live__: function ()
      {
         X3DUrlObject .prototype .set_live__ .call (this);

         if (this .getPrivate ())
            return

         this .scene .setLive (this .isLive () .getValue ());
      },
      unloadNow: function ()
      {
         this .setInternalScene (this .getBrowser () .getDefaultScene ());
      },
      loadNow: function ()
      {
         new FileLoader (this) .createX3DFromURL (this ._url, null, this .setInternalSceneAsync .bind (this));
      },
      setInternalSceneAsync: function (scene)
      {
         if (scene)
         {
            this .setLoadState (X3DConstants .COMPLETE_STATE);
            this .setInternalScene (scene);
         }
         else
         {
            this .setLoadState (X3DConstants .FAILED_STATE);
            this .setInternalScene (this .getBrowser () .getDefaultScene ());
         }
      },
      setInternalScene: function (scene)
      {
         this .scene .setLive (false);
         this .scene .rootNodes .removeFieldInterest (this .group ._children);

         // Set new scene.

         this .scene = scene;
         this .scene .setExecutionContext (this .getExecutionContext ());
         this .scene .setPrivate (this .getExecutionContext () .getPrivate ());

         this .scene .rootNodes .addFieldInterest (this .group ._children);
         this .group ._children = this .scene .rootNodes;

         this .set_live__ ();

         this .getBrowser () .addBrowserEvent ();
      },
      getInternalScene: function ()
      {
         ///  Returns the internal X3DScene of this inline, that is loaded from the url given.
         ///  If the load field was false an empty scene is returned.  This empty scene is the same for all Inline
         ///  nodes (due to performance reasons).

         return this .scene;
      },
      traverse: function (type, renderObject)
      {
         switch (type)
         {
            case TraverseType .PICKING:
            {
               const
                  browser          = renderObject .getBrowser (),
                  pickingHierarchy = browser .getPickingHierarchy ();

               pickingHierarchy .push (this);

               this .group .traverse (type, renderObject);

               pickingHierarchy .pop ();
               return;
            }
            default:
            {
               this .group .traverse (type, renderObject);
               return;
            }
         }
      },
   });

   return Inline;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Networking/Anchor",
   "x_ite/Components/Networking/Inline",
   "x_ite/Components/Networking/LoadSensor",
   "x_ite/Components/Networking/X3DNetworkSensorNode",
   "x_ite/Components/Networking/X3DUrlObject",
],
function (SupportedNodes,
          Anchor,
          Inline,
          LoadSensor,
          X3DNetworkSensorNode,
          X3DUrlObject)
{
"use strict";

   const Types =
   {
      Anchor:     Anchor,
      Inline:     Inline,
      LoadSensor: LoadSensor,
   };

   const AbstractTypes =
   {
      X3DNetworkSensorNode: X3DNetworkSensorNode,
      X3DUrlObject:         X3DUrlObject,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DDragSensorNode',[
   "x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
   "x_ite/Base/X3DConstants",
],
function (X3DPointingDeviceSensorNode,
          X3DConstants)
{
"use strict";

   function X3DDragSensorNode (executionContext)
   {
      X3DPointingDeviceSensorNode .call (this, executionContext);

      this .addType (X3DConstants .X3DDragSensorNode);

      this ._trackPoint_changed .setUnit ("length");
   }

   X3DDragSensorNode .prototype = Object .assign (Object .create (X3DPointingDeviceSensorNode .prototype),
   {
      constructor: X3DDragSensorNode,
   });

   return X3DDragSensorNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Cylinder3',[
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Line3",
],
function (Vector3,
          Rotation4,
          Matrix4,
          Line3)
{
"use strict";

   function Cylinder3 (axis, radius)
   {
      this .axis   = axis .copy ();
      this .radius = radius;
   }

   Cylinder3 .prototype =
   {
      constructor: Cylinder3,
      intersectsLine: function (line, enter, exit)
      {
         ////////////////////////////////////////////////////////////////////////
         //
         // Description:
         //  Intersect given line with this cylinder, returning the
         //  results in enter and exit. Returns TRUE if there was an
         //  intersection (and results are valid).
         //
         // Taken from Inventor SbCylinder.c++

         // The intersection will actually be done on a radius 1 cylinder
         // aligned with the y axis, so we transform the line into that
         // space, then intersect, then transform the results back.

         // rotation to y axis
         const
            rotToYAxis = new Rotation4 (this .axis .direction, new Vector3 (0, 1, 0)),
            mtxToYAxis = Matrix4 .Rotation (rotToYAxis);

         // scale to unit space
         const
            scaleFactor    = 1 / this .radius,
            toUnitCylSpace = new Matrix4 ();

         toUnitCylSpace .scale (new Vector3 (scaleFactor, scaleFactor, scaleFactor));
         toUnitCylSpace .multLeft (mtxToYAxis);

         // find the given line un-translated
         const
            point             = Vector3 .subtract (line .point, this .axis .point),
            noTranslationLine = new Line3 (point, line .direction);

         // find the un-translated line in unit cylinder's space
         const cylLine = noTranslationLine .multLineMatrix (toUnitCylSpace);

         // find the intersection on the unit cylinder
         const intersected = this .unitCylinderIntersectsLine (cylLine, enter, exit);

         if (intersected)
         {
            // transform back to original space
            const fromUnitCylSpace = toUnitCylSpace .inverse ();

            fromUnitCylSpace .multVecMatrix (enter);
            enter .add (this .axis .point);

            fromUnitCylSpace .multVecMatrix (exit);
            exit .add (this .axis .point);
         }

         return intersected;
      },
      unitCylinderIntersectsLine: function (line, enter, exit)
      {
         let t0, t1;

         const
            pos = line .point,
            dir = line .direction;

            const
            A = dir [0] * dir [0] + dir [2] * dir [2],
            B = 2 * (pos [0] * dir [0] + pos [2] * dir [2]),
            C = pos [0] * pos [0] + pos [2] * pos [2] - 1;

         // discriminant = B^2 - 4AC
         const discr = B * B - 4 * A * C;

         // if discriminant is negative, no intersection
         if (discr < 0)
            return false;

            const sqroot = Math .sqrt (discr);

         // magic to stabilize the answer
         if (B > 0)
         {
            t0 = -(2 * C) / (sqroot + B);
            t1 = -(sqroot + B) / (2 * A);
         }
         else
         {
            t0 = (2 * C) / (sqroot - B);
            t1 = (sqroot - B) / (2 * A);
         }

         enter .assign (dir) .multiply (t0) .add (pos);
         exit  .assign (dir) .multiply (t1) .add (pos);

         return true;
      },
      toString: function ()
      {
         return this .axis .toString () + " " + this .radius;
      },
   };

   return Cylinder3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/CylinderSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Line3",
   "standard/Math/Geometry/Plane3",
   "standard/Math/Geometry/Cylinder3",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Line3,
          Plane3,
          Cylinder3,
          Algorithm)
{
"use strict";

   function CylinderSensor (executionContext)
   {
      X3DDragSensorNode .call (this, executionContext);

      this .addType (X3DConstants .CylinderSensor);

      this ._diskAngle .setUnit ("angle");
      this ._minAngle  .setUnit ("angle");
      this ._maxAngle  .setUnit ("angle");
      this ._offset    .setUnit ("angle");
   }

   CylinderSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
   {
      constructor: CylinderSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",        new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "axisRotation",       new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diskAngle",          new Fields .SFFloat (0.261792)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "minAngle",           new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "maxAngle",           new Fields .SFFloat (-1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "offset",             new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed", new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "rotation_changed",   new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",           new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "CylinderSensor";
      },
      getComponentName: function ()
      {
         return "PointingDeviceSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DDragSensorNode .prototype .initialize .call (this);

         this .modelViewMatrix    = new Matrix4 ();
         this .invModelViewMatrix = new Matrix4 ();

         this .cylinder    = new Cylinder3 (new Line3 (new Vector3 (0, 0, 0), new Vector3 (0, 0, 0)), 0);
         this .disk        = false;
         this .yPlane      = null;
         this .zPlane      = null;
         this .sxPlane     = null;
         this .szNormal    = null;
         this .behind      = false;
         this .fromVector  = new Vector3 (0, 0, 0);
         this .startOffset = new Rotation4 (0, 0, 1, 0);
      },
      isBehind: function (hitRay, hitPoint)
      {
         const
            enter = new Vector3 (0, 0 ,0),
            exit  = new Vector3 (0, 0, 0);

         this .cylinder .intersectsLine (hitRay, enter, exit);

         return Vector3 .subtract (hitPoint, enter) .abs () > Vector3 .subtract (hitPoint, exit) .abs ();
      },
      getTrackPoint: function (hitRay, trackPoint)
      {
         const zPoint = new Vector3 (0, 0, 0);

         this .zPlane .intersectsLine (hitRay, zPoint);

         const
            axisPoint = Vector3 .add (zPoint, this .cylinder .axis .getPerpendicularVectorToPoint (zPoint, new Vector3 (0, 0, 0))),
            distance  = this .sxPlane .getDistanceToPoint (zPoint) / this .cylinder .radius,
            section   = Math .floor ((distance + 1) / 2);

         // Use asin on the cylinder and outside linear angle.
         const
            sinp  = Algorithm .interval (distance, -1, 1),
            phi   = section === 0 ? Math .asin (sinp) : sinp * Math .PI / 2,
            angle = phi + section * Math .PI;

         const rotation = new Rotation4 (this .cylinder .axis .direction, angle);

         rotation .multVecRot (trackPoint .assign (this .szNormal) .multiply (this .cylinder .radius));
         trackPoint .add (axisPoint);
      },
      getAngle: function (rotation)
      {
         if (Vector3 .dot (rotation .getAxis (), this .cylinder .axis .direction) > 0)
            return rotation .angle;

         else
            return -rotation .angle;
      },
      set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
      {
         X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

         if (this ._isActive .getValue ())
         {
            this .modelViewMatrix    .assign (modelViewMatrix);
            this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

            const
               hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
               hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

            const
               yAxis      = this ._axisRotation .getValue () .multVecRot (new Vector3 (0, 1, 0)),
               cameraBack = this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize ();

            const
               axis   = new Line3 (new Vector3 (0, 0, 0), yAxis),
               radius = axis .getPerpendicularVectorToPoint (hitPoint, new Vector3 (0, 0, 0)) .abs ();

            this .cylinder = new Cylinder3 (axis, radius);
            this .disk     = Math .abs (Vector3 .dot (cameraBack, yAxis)) > Math .cos (this ._diskAngle .getValue ());
            this .behind   = this .isBehind (hitRay, hitPoint);
            this .yPlane   = new Plane3 (hitPoint, yAxis);             // Sensor aligned y-plane
            this .zPlane   = new Plane3 (hitPoint, cameraBack);        // Screen aligned z-plane

            // Compute normal like in Billboard with yAxis as axis of rotation.
            const
               billboardToViewer = this .invModelViewMatrix .origin,
               sxNormal          = Vector3 .cross (yAxis, billboardToViewer) .normalize ();

            this .sxPlane  = new Plane3 (new Vector3 (0, 0, 0), sxNormal);   // Billboarded special x-plane made parallel to sensors axis.
            this .szNormal = Vector3 .cross (sxNormal, yAxis) .normalize (); // Billboarded special z-normal made parallel to sensors axis.

            const trackPoint = new Vector3 (0, 0, 0);

            if (this .disk)
               this .yPlane .intersectsLine (hitRay, trackPoint);
            else
               this .getTrackPoint (hitRay, trackPoint);

            this .fromVector  = this .cylinder .axis .getPerpendicularVectorToPoint (trackPoint, new Vector3 (0, 0, 0)) .negate ();
            this .startOffset = new Rotation4 (yAxis, this ._offset .getValue ());

            this ._trackPoint_changed = trackPoint;
            this ._rotation_changed   = this .startOffset;

            // For min/max angle.

            this .angle       = this ._offset .getValue ();
            this .startVector = this ._rotation_changed .getValue () .multVecRot (this ._axisRotation .getValue () .multVecRot (new Vector3 (0, 0, 1)));
         }
         else
         {
            if (this ._autoOffset .getValue ())
               this ._offset = this .getAngle (this ._rotation_changed .getValue ());
         }
      },
      set_motion__: function (hit)
      {
         const
            hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
            trackPoint = new Vector3 (0, 0, 0);

         if (this .disk)
            this .yPlane .intersectsLine (hitRay, trackPoint);
         else
            this .getTrackPoint (hitRay, trackPoint);

         this ._trackPoint_changed = trackPoint;

         const
            toVector = this .cylinder .axis .getPerpendicularVectorToPoint (trackPoint, new Vector3 (0, 0, 0)) .negate (),
            rotation = new Rotation4 (this .fromVector, toVector);

         if (this .disk)
         {
            // The trackpoint can swap behind the viewpoint if viewpoint is a Viewpoint node
            // as the viewing volume is not a cube where the picking ray goes straight up.
            // This phenomenon is very clear on the viewport corners.

            const trackPoint_ = this .modelViewMatrix .multVecMatrix (trackPoint .copy ());

            if (trackPoint_ .z > 0)
               rotation .multRight (new Rotation4 (this .yPlane .normal, Math .PI));
         }
         else
         {
            if (this .behind)
               rotation .inverse ();
         }

         rotation .multLeft (this .startOffset);

         if (this ._minAngle .getValue () > this ._maxAngle .getValue ())
         {
            this ._rotation_changed = rotation;
         }
         else
         {
            const
               endVector     = rotation .multVecRot (this ._axisRotation .getValue () .multVecRot (new Vector3 (0, 0, 1))),
               deltaRotation = new Rotation4 (this .startVector, endVector),
               axis          = this ._axisRotation .getValue () .multVecRot (new Vector3 (0, 1, 0)),
               sign          = axis .dot (deltaRotation .getAxis ()) > 0 ? 1 : -1,
               min           = this ._minAngle .getValue (),
               max           = this ._maxAngle .getValue ();

            this .angle += sign * deltaRotation .angle;

            this .startVector .assign (endVector);

            //console .log (this .angle, min, max);

            if (this .angle < min)
               rotation .setAxisAngle (this .cylinder .axis .direction, min);
            else if (this .angle > max)
               rotation .setAxisAngle (this .cylinder .axis .direction, max);
            else
               rotation .setAxisAngle (this .cylinder .axis .direction, this .angle);

            if (! this ._rotation_changed .getValue () .equals (rotation))
               this ._rotation_changed = rotation;
         }
      },
   });

   return CylinderSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/PlaneSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Line3",
   "standard/Math/Geometry/Plane3",
   "standard/Math/Geometry/ViewVolume",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode,
          X3DConstants,
          Rotation4,
          Vector3,
          Vector4,
          Matrix4,
          Line3,
          Plane3,
          ViewVolume,
          Algorithm)
{
"use strict";

   var
      screenLine     = new Line3 (Vector3 .Zero, Vector3 .Zero),
      trackPoint1    = new Vector3 (0, 0, 0),
      trackPointLine = new Line3 (Vector3 .Zero, Vector3 .Zero);

   function PlaneSensor (executionContext)
   {
      X3DDragSensorNode .call (this, executionContext);

      this .addType (X3DConstants .PlaneSensor);

      this ._offset              .setUnit ("length");
      this ._minPosition         .setUnit ("length");
      this ._maxPosition         .setUnit ("length");
      this ._translation_changed .setUnit ("length");
   }

   PlaneSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
   {
      constructor: PlaneSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",         new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "axisRotation",        new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",          new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "offset",              new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "minPosition",         new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "maxPosition",         new Fields .SFVec2f (-1, -1)),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed",  new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "translation_changed", new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",              new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "PlaneSensor";
      },
      getComponentName: function ()
      {
         return "PointingDeviceSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DDragSensorNode .prototype .initialize .call (this);

         this .modelViewMatrix    = new Matrix4 ();
         this .invModelViewMatrix = new Matrix4 ();
         this .projectionMatrix   = new Matrix4 ();
         this .viewport           = new Vector4 ();

         this .planeSensor = true;
         this .plane       = null;
         this .line        = null;
         this .startOffset = new Vector3 (0, 0, 0);
         this .startPoint  = new Vector3 (0, 0, 0);
      },
      getLineTrackPoint: function (hit, line, trackPoint)
      {
         ViewVolume .projectLine (line, this .modelViewMatrix, this .projectionMatrix, this .viewport, screenLine);
         screenLine .getClosestPointToPoint (new Vector3 (hit .pointer .x, hit .pointer .y, 0), trackPoint1);
         ViewVolume .unProjectRay (trackPoint1 .x, trackPoint1 .y, this .modelViewMatrix, this .projectionMatrix, this .viewport, trackPointLine);

         return line .getClosestPointToLine (trackPointLine, trackPoint);
      },
      set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
      {
         X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

         if (this ._isActive .getValue ())
         {
            this .modelViewMatrix    .assign (modelViewMatrix);
            this .projectionMatrix   .assign (projectionMatrix);
            this .viewport           .assign (viewport);
            this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

            var
               hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
               hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

            var axisRotation = this ._axisRotation .getValue ();

            if (this ._minPosition .x === this ._maxPosition .x)
            {
               this .planeSensor = false;

               var direction = axisRotation .multVecRot (new Vector3 (0, Math .abs (this ._maxPosition .y - this ._minPosition .y), 0));

               this .line = new Line3 (hitPoint, direction .normalize ());
            }
            else if (this ._minPosition .y === this ._maxPosition .y)
            {
               this .planeSensor = false;

               var direction = axisRotation .multVecRot (new Vector3 (Math .abs (this ._maxPosition .x - this ._minPosition .x), 0, 0));

               this .line = new Line3 (hitPoint, direction .normalize ());
            }
            else
            {
               this .planeSensor = true;
               this .plane       = new Plane3 (hitPoint, axisRotation .multVecRot (new Vector3 (0, 0, 1)));
            }

            if (this .planeSensor)
            {
               if (this .plane .intersectsLine (hitRay, this .startPoint))
               {
                  this .trackStart (this .startPoint);
               }

//						new Plane3 (new Vector3 (0, 0, 0), this .plane .normal) .intersectsLine (hitRay, trackPoint);
            }
            else
            {
               if (this .getLineTrackPoint (hit, this .line, this .startPoint))
               {
                  var trackPoint = new Vector3 (0, 0, 0);

                  try
                  {
                     this .getLineTrackPoint (hit, new Line3 (this .line .direction, this .line .direction), trackPoint);
                  }
                  catch (error)
                  {
                     //console .error (error);

                     trackPoint = this .startPoint;
                  }

                  this .trackStart (trackPoint);
               }
            }
         }
         else
         {
            if (this ._autoOffset .getValue ())
               this ._offset = this ._translation_changed;
         }
      },
      trackStart: function (trackPoint)
      {
         this .startOffset .assign (this ._offset .getValue ());

         this ._trackPoint_changed  = trackPoint;
         this ._translation_changed = this ._offset .getValue ();
      },
      set_motion__: function (hit)
      {
         try
         {
            if (this .planeSensor)
            {
               var
                  hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
                  endPoint = new Vector3 (0, 0, 0);

               if (this .plane .intersectsLine (hitRay, endPoint))
               {
                  this .track (endPoint, endPoint .copy ());
               }
               else
                  throw new Error ("Plane and line are parallel.");
            }
            else
            {
               var
                  endPoint   = new Vector3 (0, 0, 0),
                  trackPoint = new Vector3 (0, 0, 0);

               if (this .getLineTrackPoint (hit, this .line, endPoint))
               {
                  try
                  {
                     this .getLineTrackPoint (hit, new Line3 (Vector3 .Zero, this .line .direction), trackPoint);
                  }
                  catch (error)
                  {
                     trackPoint .assign (endPoint);
                  }

                  this .track (endPoint, trackPoint);
               }
               else
                  throw new Error ("Lines are parallel.");
            }
         }
         catch (error)
         {
            //console .error (error);

            this ._trackPoint_changed  .addEvent ();
            this ._translation_changed .addEvent ();
         }
      },
      track: function (endPoint, trackPoint)
      {
         var
            axisRotation = this ._axisRotation .getValue (),
            translation  = Rotation4 .inverse (axisRotation) .multVecRot (endPoint .add (this .startOffset) .subtract (this .startPoint));

         // X component

         if (! (this ._minPosition .x > this ._maxPosition .x))
            translation .x = Algorithm .clamp (translation .x, this ._minPosition .x, this ._maxPosition .x);

         // Y component

         if (! (this ._minPosition .y > this ._maxPosition .y))
            translation .y = Algorithm .clamp (translation .y, this ._minPosition .y, this ._maxPosition .y);

         axisRotation .multVecRot (translation);

         if (! this ._trackPoint_changed .getValue () .equals (trackPoint))
            this ._trackPoint_changed = trackPoint;

         if (! this ._translation_changed .getValue () .equals (translation))
            this ._translation_changed = translation;
      },
   });

   return PlaneSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Sphere3',[
   "standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

   function Sphere3 (radius, center)
   {
      this .radius = radius;
      this .center = center .copy ();
   }

   Sphere3 .prototype =
   {
      constructor: Sphere3,
      set: function (radius, center)
      {
         this .radius = radius;
         this .center .assign (center);
      },
      intersectsLine: function (line, enterPoint, exitPoint)
      {
         // https://github.com/Alexpux/Coin3D/blob/master/src/base/SbSphere.cpp

         const
            linepos = line .point,
            linedir = line .direction;

         const
            scenter = this .center,
            r       = this .radius;

         const
            b = 2 * (linepos .dot (linedir) - scenter .dot (linedir)),
            c = (linepos .x * linepos .x + linepos .y * linepos .y + linepos .z * linepos .z) +
                (scenter .x * scenter .x + scenter .y * scenter .y + scenter .z * scenter .z) -
                2 * linepos .dot (scenter) - r * r;

         const core = b * b - 4 * c;

         if (core >= 0)
         {
            let
               t1 = (-b + Math .sqrt (core)) / 2,
               t2 = (-b - Math .sqrt (core)) / 2;

            if (t1 > t2)
            {
               const tmp = t1;
               t1 = t2;
               t2 = tmp;
            }

            enterPoint .assign (linedir) .multiply (t1) .add (linepos);
            exitPoint  .assign (linedir) .multiply (t2) .add (linepos);

            return true;
         }
         else
         {
            return false;
         }
      },
      intersectsTriangle: (function ()
      {
         const
            AB = new Vector3 (0, 0, 0),
            AC = new Vector3 (0, 0, 0),
            BC = new Vector3 (0, 0, 0),
            CA = new Vector3 (0, 0, 0),
            Q1 = new Vector3 (0, 0, 0),
            Q2 = new Vector3 (0, 0, 0),
            Q3 = new Vector3 (0, 0, 0);

         return function (A, B, C)
         {
            const
               P = this .center,
               r = this .radius;

            A .subtract (P);
            B .subtract (P);
            C .subtract (P);

            // Testing if sphere lies outside the triangle plane.

            AB .assign (B) .subtract (A);
            AC .assign (C) .subtract (A);

            const
               rr   = r * r,
               V    = AB .cross (AC),
               d    = Vector3 .dot (A, V),
               e    = Vector3 .dot (V, V),
               sep1 = d * d > rr * e;

            if (sep1)
               return false;

            // Testing if sphere lies outside a triangle vertex.
            const
               aa   = Vector3 .dot (A, A),
               ab   = Vector3 .dot (A, B),
               ac   = Vector3 .dot (A, C),
               bb   = Vector3 .dot (B, B),
               bc   = Vector3 .dot (B, C),
               cc   = Vector3 .dot (C, C),
               sep2 = (aa > rr) && (ab > aa) && (ac > aa),
               sep3 = (bb > rr) && (ab > bb) && (bc > bb),
               sep4 = (cc > rr) && (ac > cc) && (bc > cc);

            if (sep2 || sep3 || sep4)
               return false;

            // Testing if sphere lies outside a triangle edge.

            AB .assign (B) .subtract (A);
            BC .assign (C) .subtract (B);
            CA .assign (A) .subtract (C);

            const
               d1   = ab - aa,
               d2   = bc - bb,
               d3   = ac - cc,
               e1   = Vector3 .dot (AB, AB),
               e2   = Vector3 .dot (BC, BC),
               e3   = Vector3 .dot (CA, CA);

            Q1 .assign (A) .multiply (e1) .subtract (AB .multiply (d1));
            Q2 .assign (B) .multiply (e2) .subtract (BC .multiply (d2));
            Q3 .assign (C) .multiply (e3) .subtract (CA .multiply (d3));

            const
               QC   = C .multiply (e1) .subtract (Q1),
               QA   = A .multiply (e2) .subtract (Q2),
               QB   = B .multiply (e3) .subtract (Q3),
               sep5 = (Vector3 .dot (Q1, Q1) > rr * e1 * e1) && (Vector3 .dot (Q1, QC) > 0),
               sep6 = (Vector3 .dot (Q2, Q2) > rr * e2 * e2) && (Vector3 .dot (Q2, QA) > 0),
               sep7 = (Vector3 .dot (Q3, Q3) > rr * e3 * e3) && (Vector3 .dot (Q3, QB) > 0);

            if (sep5 || sep6 || sep7)
               return false;

            return true;
         };
      })(),
      toString: function ()
      {
         return this .radius + " " + this .center .toString ();
      },
   };

   return Sphere3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/SphereSensor',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Triangle3",
   "standard/Math/Geometry/Line3",
   "standard/Math/Geometry/Plane3",
   "standard/Math/Geometry/Sphere3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Triangle3,
          Line3,
          Plane3,
          Sphere3)
{
"use strict";

   function SphereSensor (executionContext)
   {
      X3DDragSensorNode .call (this, executionContext);

      this .addType (X3DConstants .SphereSensor);
   }

   SphereSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
   {
      constructor: SphereSensor,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",        new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",            new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",         new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "offset",             new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed", new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "rotation_changed",   new Fields .SFRotation ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",           new Fields .SFBool ()),
      ]),
      getTypeName: function ()
      {
         return "SphereSensor";
      },
      getComponentName: function ()
      {
         return "PointingDeviceSensor";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DDragSensorNode .prototype .initialize .call (this);

         this .modelViewMatrix    = new Matrix4 ();
         this .invModelViewMatrix = new Matrix4 ();

         this .sphere      = null;
         this .zPlane      = null;
         this .behind      = false;
         this .fromVector  = new Vector3 (0, 0, 0);
         this .startPoint  = new Vector3 (0, 0, 0);
         this .startOffset = new Rotation4 (0, 0, 1, 0);
      },
      getTrackPoint: function (hitRay, trackPoint, behind)
      {
         var exit = new Vector3 (0, 0, 0);

         if (this .sphere .intersectsLine (hitRay, trackPoint, exit))
         {
            if ((Vector3 .subtract (hitRay .point, exit) .abs () < Vector3 .subtract (hitRay .point, trackPoint) .abs ()) - behind)
               trackPoint .assign (exit);

            return true;
         }

         return false;
      },
      set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
      {
         X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

         if (this ._isActive .getValue ())
         {
            this .modelViewMatrix    .assign (modelViewMatrix);
            this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

            var
               hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ()),
               center   = new Vector3 (0, 0, 0);

            this .zPlane = new Plane3 (center, this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize ()); // Screen aligned Z-plane
            this .sphere = new Sphere3 (hitPoint .abs (), center);
            this .behind = this .zPlane .getDistanceToPoint (hitPoint) < 0;

            this .fromVector  .assign (hitPoint);
            this .startPoint  .assign (hitPoint);
            this .startOffset .assign (this ._offset .getValue ());

            this ._trackPoint_changed = hitPoint;
            this ._rotation_changed   = this ._offset .getValue ();
         }
         else
         {
            if (this ._autoOffset .getValue ())
               this ._offset = this ._rotation_changed;
         }
      },
      set_motion__: function (hit)
      {
         var
            hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
            trackPoint = new Vector3 (0, 0, 0);

         if (this .getTrackPoint (hitRay, trackPoint, this .behind))
         {
            var zAxis = this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize (); // Camera direction
            this .zPlane = new Plane3 (trackPoint, zAxis);                                             // Screen aligned Z-plane
         }
         else
         {
            // Find trackPoint on the plane with sphere

            var tangentPoint = new Vector3 (0, 0, 0);
            this .zPlane .intersectsLine (hitRay, tangentPoint);

            hitRay = new Line3 (tangentPoint, Vector3 .subtract (this .sphere .center, tangentPoint) .normalize ());

            //console .log (hitRay .toString ());

            this .getTrackPoint (hitRay, trackPoint, false);

            // Find trackPoint behind sphere

            var
               triNormal     = Triangle3 .normal (this .sphere .center, trackPoint, this .startPoint, new Vector3 (0, 0, 0)),
               dirFromCenter = Vector3 .subtract (trackPoint, this .sphere .center) .normalize (),
               normal        = Vector3 .cross (triNormal, dirFromCenter) .normalize ();

            var point1 = Vector3 .subtract (trackPoint, normal .multiply (Vector3 .subtract (tangentPoint, trackPoint) .abs ()));

            hitRay = new Line3 (point1, Vector3 .subtract (this .sphere .center, point1) .normalize ());

            this .getTrackPoint (hitRay, trackPoint, false);
         }

         this ._trackPoint_changed = trackPoint;

         var
            toVector = Vector3 .subtract (trackPoint, this .sphere .center),
            rotation = new Rotation4 (this .fromVector, toVector);

         if (this .behind)
            rotation .inverse ();

         this ._rotation_changed = Rotation4 .multRight (this .startOffset, rotation);
      },
   });

   return SphereSensor;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/PointingDeviceSensor/CylinderSensor",
   "x_ite/Components/PointingDeviceSensor/PlaneSensor",
   "x_ite/Components/PointingDeviceSensor/SphereSensor",
   "x_ite/Components/PointingDeviceSensor/TouchSensor",
   "x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
   "x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
   "x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode",
],
function (SupportedNodes,
          CylinderSensor,
          PlaneSensor,
          SphereSensor,
          TouchSensor,
          X3DDragSensorNode,
          X3DPointingDeviceSensorNode,
          X3DTouchSensorNode)
{
"use strict";

   const Types =
   {
      CylinderSensor: CylinderSensor,
      PlaneSensor:    PlaneSensor,
      SphereSensor:   SphereSensor,
      TouchSensor:    TouchSensor,
   };

   const AbstractTypes =
   {
      X3DDragSensorNode:           X3DDragSensorNode,
      X3DPointingDeviceSensorNode: X3DPointingDeviceSensorNode,
      X3DTouchSensorNode:          X3DTouchSensorNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/ClipPlane',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Vector4",
   "standard/Math/Geometry/Plane3",
   "standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DConstants,
          Vector3,
          Vector4,
          Plane3,
          ObjectCache)
{
"use strict";

   const ClipPlanes = ObjectCache (ClipPlaneContainer);

   function ClipPlaneContainer ()
   {
      this .plane = new Plane3 (Vector3 .Zero, Vector3 .Zero);
   }

   ClipPlaneContainer .prototype =
   {
      constructor: ClipPlaneContainer,
      isClipped: function (point)
      {
         return this .plane .getDistanceToPoint (point) < 0;
      },
      set: function (clipPlane, modelViewMatrix)
      {
         const
            plane      = this .plane,
            localPlane = clipPlane .plane;

         plane .normal .assign (localPlane);
         plane .distanceFromOrigin = -localPlane .w;

         plane .multRight (modelViewMatrix);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const
            plane  = this .plane,
            normal = plane .normal;

         gl .uniform4f (shaderObject .x3d_ClipPlane [shaderObject .numClipPlanes ++], normal .x, normal .y, normal .z, plane .distanceFromOrigin);
      },
      dispose: function ()
      {
         ClipPlanes .push (this);
      },
   };

   function ClipPlane (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .ClipPlane);

      this .enabled = false;
      this .plane   = new Vector4 (0, 0, 0, 0);
   }

   ClipPlane .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: ClipPlane,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "plane",    new Fields .SFVec4f (0, 1, 0, 0)),
      ]),
      getTypeName: function ()
      {
         return "ClipPlane";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DChildNode .prototype .initialize .call (this);

         this ._enabled .addInterest ("set_enabled__", this);
         this ._plane   .addInterest ("set_enabled__", this);

         this .set_enabled__ ();
      },
      set_enabled__: function ()
      {
         this .plane .assign (this ._plane .getValue ());

         this .enabled = this ._enabled .getValue () && ! this .plane .equals (Vector4 .Zero);
      },
      push: function (renderObject)
      {
         if (this .enabled)
         {
            const clipPlaneContainer = ClipPlanes .pop ();

            clipPlaneContainer .set (this, renderObject .getModelViewMatrix () .get ());

            renderObject .getLocalObjects () .push (clipPlaneContainer);
         }
      },
      pop: function (renderObject)
      {
         if (this .enabled)
            renderObject .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());
      },
   });

   return ClipPlane;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/ColorRGBA',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DColorNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DColorNode,
          X3DConstants)
{
"use strict";

   function ColorRGBA (executionContext)
   {
      X3DColorNode .call (this, executionContext);

      this .addType (X3DConstants .ColorRGBA);

      this .setTransparent (true);
   }

   ColorRGBA .prototype = Object .assign (Object .create (X3DColorNode .prototype),
   {
      constructor: ColorRGBA,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .MFColorRGBA ()),
      ]),
      getTypeName: function ()
      {
         return "ColorRGBA";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "color";
      },
      addColor: function (index, array)
      {
         if (index >= 0 && index < this .length)
         {
            const color = this .color;

            index *= 4;

            array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
         }
         else if (this .length)
         {
            const color = this .color;

            index = (this .length - 1) * 4;

            array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
         }
         else
         {
            array .push (1, 1, 1, 1);
         }
      },
      addColors: function (array, min)
      {
         if (this .length)
         {
            const color = this .color;

            for (var index = 0, length = Math .min (min, this .length) * 4; index < length; index += 4)
               array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);

            if (this .length < min)
            {
               var index = (this .length - 1) * 4;

               const
                  r = color [index],
                  g = color [index + 1],
                  b = color [index + 2],
                  a = color [index + 2];

               for (var index = length, length = min * 4; index < length; index += 4)
                  array .push (r, g, b, a);
            }
         }
         else
         {
            for (let index = 0; index < min; ++ index)
               array .push (1, 1, 1, 1);
         }

         return array;
      },
   });

   return ColorRGBA;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleFanSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function IndexedTriangleFanSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .IndexedTriangleFanSet);

      this .triangleIndex = [ ];
   }

   IndexedTriangleFanSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: IndexedTriangleFanSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "IndexedTriangleFanSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._set_index .addFieldInterest (this ._index);
         this ._index     .addInterest ("set_index__", this);

         this .set_index__ ();
      },
      set_index__: function ()
      {
         // Build coordIndex

         const
            index         = this ._index,
            triangleIndex = this .triangleIndex;

         triangleIndex .length = 0;

         for (let i = 0, length = index .length; i < length; ++ i)
         {
            const first = index [i];

            if (first < 0)
               continue;

            if (++ i < length)
            {
               let second = index [i];

               if (second < 0)
                  continue;

               for (++ i; i < length; ++ i)
               {
                  const third = index [i];

                  if (third < 0)
                     break;

                  triangleIndex .push (first, second, third);

                  second = third;
               }
            }
         }
      },
      getPolygonIndex: function (index)
      {
         return this .triangleIndex [index];
      },
      build: function ()
      {
         X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
      },
   });

   return IndexedTriangleFanSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function IndexedTriangleSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .IndexedTriangleSet);
   }

   IndexedTriangleSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: IndexedTriangleSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "IndexedTriangleSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      getPolygonIndex: function (i)
      {
         return this ._index [i];
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._set_index .addFieldInterest (this ._index);
      },
      build: function ()
      {
         X3DComposedGeometryNode .prototype .build .call (this, 3, this ._index .length, 3, this ._index .length);
      },
   });

   return IndexedTriangleSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleStripSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function IndexedTriangleStripSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .IndexedTriangleStripSet);

      this .triangleIndex = [ ];
   }

   IndexedTriangleStripSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: IndexedTriangleStripSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "IndexedTriangleStripSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._set_index .addFieldInterest (this ._index);
         this ._index     .addInterest ("set_index__", this);

         this .set_index__ ();
      },
      set_index__: function ()
      {
         // Build coordIndex

         const
            index         = this ._index,
            triangleIndex = this .triangleIndex;

         triangleIndex .length = 0;

         // Build coordIndex

         for (let i = 0, length = index .length; i < length; ++ i)
         {
            let first = index [i];

            if (first < 0)
               continue;

            if (++ i < length)
            {
               let second = index [i];

               if (second < 0)
                  continue;

               ++ i;

               for (let face = 0; i < length; ++ i, ++ face)
               {
                  const third = index [i];

                  if (third < 0)
                     break;

                  triangleIndex .push (first, second, third);

                  if (face & 1)
                     second = third;

                  else
                     first = third;
               }
            }
         }
      },
      getPolygonIndex: function (index)
      {
         return this .triangleIndex [index];
      },
      build: function ()
      {
         X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
      },
   });

   return IndexedTriangleStripSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/LineSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DLineGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLineGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function LineSet (executionContext)
   {
      X3DLineGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .LineSet);

      this .fogCoordNode = null;
      this .colorNode    = null;
      this .coordNode    = null;
   }

   LineSet .prototype = Object .assign (Object .create (X3DLineGeometryNode .prototype),
   {
      constructor: LineSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "vertexCount", new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "attrib",      new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fogCoord",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",       new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "coord",       new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "LineSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DLineGeometryNode .prototype .initialize .call (this);

         this ._attrib   .addInterest ("set_attrib__",   this);
         this ._fogCoord .addInterest ("set_fogCoord__", this);
         this ._color    .addInterest ("set_color__",    this);
         this ._coord    .addInterest ("set_coord__",    this);

         this .set_attrib__ ();
         this .set_fogCoord__ ();
         this .set_color__ ();
         this .set_coord__ ();
      },
      set_attrib__: function ()
      {
         const attribNodes = this .getAttrib ();

         for (const attribNode of attribNodes)
         {
            attribNode .removeInterest ("requestRebuild", this);
            attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
         }

         attribNodes .length = 0;

         for (const node of this ._attrib)
         {
            const attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, node);

            if (attribNode)
               attribNodes .push (attribNode);
         }

         for (const attribNode of attribNodes)
         {
            attribNode .addInterest ("requestRebuild", this);
            attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
         }

         this .updateVertexArrays ();
      },
      set_fogCoord__: function ()
      {
         if (this .fogCoordNode)
            this .fogCoordNode .removeInterest ("requestRebuild", this);

         this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this ._fogCoord);

         if (this .fogCoordNode)
            this .fogCoordNode .addInterest ("requestRebuild", this);
      },
      set_color__: function ()
      {
         if (this .colorNode)
         {
            this .colorNode .removeInterest ("requestRebuild", this);
            this .colorNode ._transparent .removeInterest ("set_transparent__", this);
         }

         this .colorNode = X3DCast (X3DConstants .X3DColorNode, this ._color);

         if (this .colorNode)
         {
            this .colorNode .addInterest ("requestRebuild", this);
            this .colorNode ._transparent .addInterest ("set_transparent__", this);

            this .set_transparent__ ();
         }
         else
            this .setTransparent (false);
      },
      set_transparent__: function ()
      {
         this .setTransparent (this .colorNode .getTransparent ());
      },
      set_coord__: function ()
      {
         if (this .coordNode)
            this .coordNode .removeInterest ("requestRebuild", this);

         this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this ._coord);

         if (this .coordNode)
            this .coordNode .addInterest ("requestRebuild", this);
      },
      build: function ()
      {
         if (! this .coordNode || this .coordNode .isEmpty ())
            return;

         // Fill GeometryNode

         const
            vertexCount    = this ._vertexCount,
            attribNodes    = this .getAttrib (),
            numAttribNodes = attribNodes .length,
            attribArrays   = this .getAttribs (),
            fogCoordNode   = this .fogCoordNode,
            colorNode      = this .colorNode,
            coordNode      = this .coordNode,
            fogDepthArray  = this .getFogDepths (),
            colorArray     = this .getColors (),
            vertexArray    = this .getVertices (),
            size           = coordNode .getSize ();

         let index = 0;

         for (let count of vertexCount)
         {
            if (index + count > size)
               break;

            if (count > 1)
            {
               count = 2 * count - 2; // numVertices for line lines trip

               for (let i = 0; i < count; ++ i, index += i & 1)
               {
                  for (let a = 0; a < numAttribNodes; ++ a)
                     attribNodes [a] .addValue (index, attribArrays [a]);

                  if (fogCoordNode)
                     fogCoordNode .addDepth (index, fogDepthArray);

                  if (colorNode)
                     colorNode .addColor (index, colorArray);

                  coordNode .addPoint (index, vertexArray);
               }

               ++ index;
            }
            else
               index += count;
         }
      },
   });

   return LineSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DNormalNode',[
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
],
function (X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

   function X3DNormalNode (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .X3DNormalNode);
   }

   X3DNormalNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: X3DNormalNode,
   });

   return X3DNormalNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/Normal',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DNormalNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNormalNode,
          X3DConstants,
          Vector3)
{
"use strict";

   function Normal (executionContext)
   {
      X3DNormalNode .call (this, executionContext);

      this .addType (X3DConstants .Normal);
   }

   Normal .prototype = Object .assign (Object .create (X3DNormalNode .prototype),
   {
      constructor: Normal,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "vector",   new Fields .MFVec3f ()),
      ]),
      getTypeName: function ()
      {
         return "Normal";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "normal";
      },
      initialize: function ()
      {
         X3DNormalNode .prototype .initialize .call (this);

         this ._vector .addInterest ("set_vector__", this);

         this .set_vector__ ();
      },
      set_vector__: function ()
      {
         this .vector = this ._vector .getValue ();
         this .length = this ._vector .length;
      },
      set1Vector: function (index, vector)
      {
         this ._vector [index] = vector;
      },
      get1Vector: function (index, result)
      {
         if (index >= 0 && index < this .length)
         {
            const vector = this .vector;

            index *= 3;

            return result .set (vector [index], vector [index + 1], vector [index + 2]);
         }
         else if (index >= 0 && this .length)
         {
            const vector = this .vector;

            index %= this .length;
            index *= 3;

            return result .set (vector [index], vector [index + 1], vector [index + 2]);
         }
         else
         {
            return result .set (0, 0, 0);
         }
      },
      addVector: function (index, array)
      {
         if (index >= 0 && index < this .length)
         {
            const vector = this .vector;

            index *= 3;

            array .push (vector [index], vector [index + 1], vector [index + 2]);
         }
         else if (index >= 0 && this .length)
         {
            const vector = this .vector;

            index %= this .length;
            index *= 3;

            array .push (vector [index], vector [index + 1], vector [index + 2]);
         }
         else
         {
            return array .push (0, 0, 0);
         }
      },
   });

   return Normal;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DPointGeometryNode',[
   "x_ite/Components/Rendering/X3DGeometryNode",
   "standard/Math/Numbers/Vector2",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix4",
],
function (X3DGeometryNode,
          Vector2,
          Vector3,
          Matrix4)
{
"use strict";

   function X3DLineGeometryNode (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      const browser = this .getBrowser ();

      this .setGeometryType (0);
      this .setPrimitiveMode (browser .getContext () .POINTS);
      this .setSolid (false);
      this .setTransparent (true);
   }

   X3DLineGeometryNode .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: X3DLineGeometryNode,
      intersectsLine: (function ()
      {
         const PICK_DISTANCE_FACTOR = 1 / 300;

         const
            point     = new Vector3 (0, 0, 0),
            vector    = new Vector3 (0, 0, 0),
            clipPoint = new Vector3 (0, 0, 0);

         return function (hitRay, clipPlanes, modelViewMatrix, intersections)
         {
            if (this .intersectsBBox (hitRay, 1))
            {
               const vertices = this .getVertices ();

               for (let i = 0, length = vertices .length; i < length; i += 4)
               {
                  point .set (vertices [i + 0], vertices [i + 1], vertices [i + 2]);

                  if (hitRay .getPerpendicularVectorToPoint (point, vector) .abs () < hitRay .point .distance (point) * PICK_DISTANCE_FACTOR)
                  {
                     if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
                        continue;

                     intersections .push ({ texCoord: new Vector2 (0, 0), normal: new Vector3 (0, 0, 0), point: point .copy () });
                     return true;
                  }
               }
            }

            return false;
         };
      })(),
      intersectsBox: function (box, clipPlanes, modelViewMatrix)
      {
         return false;
      },
      buildTexCoords: function ()
      { },
      display: function (gl, context)
      {
         const
            browser        = context .browser,
            appearanceNode = context .shapeNode .getAppearance (),
            shaderNode     = appearanceNode .shaderNode || browser .getPointShader (),
            blendModeNode  = appearanceNode .blendModeNode,
            attribNodes    = this .attribNodes,
            attribBuffers  = this .attribBuffers;

         if (shaderNode .isValid ())
         {
            if (blendModeNode)
               blendModeNode .enable (gl);

            // Setup shader.

            shaderNode .enable (gl);
            shaderNode .setLocalUniforms (gl, context);

            // Setup vertex attributes.

            if (this .vertexArrayObject .enable (gl, shaderNode))
            {
               for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

               if (this .fogCoords)
                  shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

               if (this .colorMaterial)
                  shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

               shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);
            }

            gl .drawArrays (this .primitiveMode, 0, this .vertexCount);

            if (blendModeNode)
               blendModeNode .disable (gl);
         }
      },
      displayParticles: function (gl, context, particleSystem)
      {
         const
            browser        = context .browser,
            appearanceNode = context .shapeNode .getAppearance (),
            shaderNode     = appearanceNode .shaderNode || browser .getPointShader (),
            blendModeNode  = appearanceNode .blendModeNode,
            attribNodes    = this .attribNodes,
            attribBuffers  = this .attribBuffers;

         if (shaderNode .isValid ())
         {
            if (blendModeNode)
               blendModeNode .enable (gl);

            // Setup shader.

            shaderNode .enable (gl);
            shaderNode .setLocalUniforms (gl, context);

            // Setup vertex attributes.

            const outputParticles = particleSystem .outputParticles;

            if (this .updateParticles)
            {
               this .updateParticles = false;

               outputParticles .vertexArrayObject .update ();
            }

            if (outputParticles .vertexArrayObject .enable (gl, shaderNode))
            {
               const particleStride = particleSystem .particleStride;

               shaderNode .enableParticleAttribute (gl, outputParticles, particleStride, particleSystem .particleOffset, 1);
               shaderNode .enableParticleMatrixAttribute (gl, outputParticles, particleStride, particleSystem .matrixOffset, 1);

               for (let i = 0, length = attribNodes .length; i < length; ++ i)
                  attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

               if (this .fogCoords)
                  shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer, 0, 0);

               if (this .colorMaterial)
                  shaderNode .enableColorAttribute (gl, this .colorBuffer, 0, 0);

               shaderNode .enableVertexAttribute (gl, this .vertexBuffer, 0, 0);
            }

            // Wireframes are always solid so only one drawing call is needed.

            gl .drawArraysInstanced (this .primitiveMode, 0, this .vertexCount, particleSystem .numParticles);

            if (blendModeNode)
               blendModeNode .disable (gl);
         }
      },
   });

   return X3DLineGeometryNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/PointSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DPointGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DPointGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function PointSet (executionContext)
   {
      X3DPointGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .PointSet);

      this .fogCoordNode = null;
      this .colorNode    = null;
      this .coordNode    = null;
   }

   PointSet .prototype = Object .assign (Object .create (X3DPointGeometryNode .prototype),
   {
      constructor: PointSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "attrib",   new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "fogCoord", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "coord",    new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "PointSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DPointGeometryNode .prototype .initialize .call (this);

         this ._attrib   .addInterest ("set_attrib__",   this);
         this ._fogCoord .addInterest ("set_fogCoord__", this);
         this ._color    .addInterest ("set_color__",    this);
         this ._coord    .addInterest ("set_coord__",    this);

         this .set_attrib__ ();
         this .set_fogCoord__ ();
         this .set_color__ ();
         this .set_coord__ ();
      },
      getCoord: function ()
      {
         return this .coordNode;
      },
      set_attrib__: function ()
      {
         const attribNodes = this .getAttrib ();

         for (const attribNode of attribNodes)
         {
            attribNode .removeInterest ("requestRebuild", this);
            attribNode ._attribute_changed .removeInterest ("updateVertexArrays", this);
         }

         attribNodes .length = 0;

         for (const node of this ._attrib)
         {
            const attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, node);

            if (attribNode)
               attribNodes .push (attribNode);
         }

         for (const attribNode of attribNodes)
         {
            attribNode .addInterest ("requestRebuild", this);
            attribNode ._attribute_changed .addInterest ("updateVertexArrays", this);
         }

         this .updateVertexArrays ();
      },
      set_fogCoord__: function ()
      {
         if (this .fogCoordNode)
            this .fogCoordNode .removeInterest ("requestRebuild", this);

         this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this ._fogCoord);

         if (this .fogCoordNode)
            this .fogCoordNode .addInterest ("requestRebuild", this);
      },
      set_color__: function ()
      {
         if (this .colorNode)
            this .colorNode .removeInterest ("requestRebuild", this);

         this .colorNode = X3DCast (X3DConstants .X3DColorNode, this ._color);

         if (this .colorNode)
            this .colorNode .addInterest ("requestRebuild", this);
      },
      set_coord__: function ()
      {
         if (this .coordNode)
            this .coordNode .removeInterest ("requestRebuild", this);

         this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this ._coord);

         if (this .coordNode)
            this .coordNode .addInterest ("requestRebuild", this);
      },
      build: function ()
      {
         if (! this .coordNode || this .coordNode .isEmpty ())
            return;

         const
            attribNodes    = this .getAttrib (),
            numAttribNodes = attribNodes .length,
            attribArrays   = this .getAttribs (),
            fogCoordNode   = this .fogCoordNode,
            fogDepthArray  = this .getFogDepths (),
            colorNode      = this .colorNode,
            colorArray     = this .getColors (),
            coordNode      = this .coordNode,
            vertexArray    = this .getVertices (),
            numPoints      = coordNode ._point .length;

         for (let a = 0; a < numAttribNodes; ++ a)
         {
            for (let i = 0; i < numPoints; ++ i)
               attribNodes [a] .addValue (i, attribArrays [a]);
         }

         if (fogCoordNode)
            fogCoordNode .addDepths (fogDepthArray, numPoints);

         if (colorNode)
            colorNode .addColors (colorArray, numPoints);

         coordNode .addPoints (vertexArray, numPoints);
      },
   });

   return PointSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleFanSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function TriangleFanSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .TriangleFanSet);

      this .triangleIndex = [ ];
   }

   TriangleFanSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: TriangleFanSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fanCount",        new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "TriangleFanSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._fanCount .addInterest ("set_fanCount__", this);

         this .set_fanCount__ ();
      },
      set_fanCount__: function ()
      {
         // Build coordIndex

         const
            fanCount      = this ._fanCount,
            triangleIndex = this .triangleIndex;

         triangleIndex .length = 0;

         let index = 0;

         for (const vertexCount of fanCount)
         {
            for (let i = 1, length = vertexCount - 1; i < length; ++ i)
            {
               triangleIndex .push (index, index + i, index + i + 1);
            }

            index += vertexCount;
         }
      },
      getPolygonIndex: function (index)
      {
         return this .triangleIndex [index];
      },
      build: function ()
      {
         X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
      },
   });

   return TriangleFanSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function TriangleSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .TriangleSet);
   }

   TriangleSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: TriangleSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "TriangleSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      build: function ()
      {
         if (! this .getCoord ())
            return;

         X3DComposedGeometryNode .prototype .build .call (this, 3, this .getCoord () .getSize (), 3, this .getCoord () .getSize ());
      },
      createNormals: function (verticesPerPolygon, polygonsSize)
      {
         return this .createFaceNormals (verticesPerPolygon, polygonsSize);
      },
   });

   return TriangleSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleStripSet',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

   function TriangleStripSet (executionContext)
   {
      X3DComposedGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .TriangleStripSet);

      this .triangleIndex = [ ];
   }

   TriangleStripSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
   {
      constructor: TriangleStripSet,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "stripCount",      new Fields .MFInt32 ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "TriangleStripSet";
      },
      getComponentName: function ()
      {
         return "Rendering";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DComposedGeometryNode .prototype .initialize .call (this);

         this ._stripCount .addInterest ("set_stripCount__", this);

         this .set_stripCount__ ();
      },
      set_stripCount__: function ()
      {
         // Build coordIndex

         const
            stripCount    = this ._stripCount,
            triangleIndex = this .triangleIndex;

         triangleIndex .length = 0;

         let index = 0;

         for (const vertexCount of stripCount)
         {
            for (let i = 0, count = vertexCount - 2; i < count; ++ i)
            {
               const is_odd = i & 1;

               triangleIndex .push (index + (is_odd ? i + 1 : i),
                                    index + (is_odd ? i : i + 1),
                                    index + (i + 2));
            }

            index += vertexCount;
         }
      },
      getPolygonIndex: function (index)
      {
         return this .triangleIndex [index];
      },
      build: function ()
      {
         X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
      },
   });

   return TriangleStripSet;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Rendering/ClipPlane",
   "x_ite/Components/Rendering/Color",
   "x_ite/Components/Rendering/ColorRGBA",
   "x_ite/Components/Rendering/Coordinate",
   "x_ite/Components/Rendering/IndexedLineSet",
   "x_ite/Components/Rendering/IndexedTriangleFanSet",
   "x_ite/Components/Rendering/IndexedTriangleSet",
   "x_ite/Components/Rendering/IndexedTriangleStripSet",
   "x_ite/Components/Rendering/LineSet",
   "x_ite/Components/Rendering/Normal",
   "x_ite/Components/Rendering/PointSet",
   "x_ite/Components/Rendering/TriangleFanSet",
   "x_ite/Components/Rendering/TriangleSet",
   "x_ite/Components/Rendering/TriangleStripSet",
   "x_ite/Components/Rendering/X3DColorNode",
   "x_ite/Components/Rendering/X3DComposedGeometryNode",
   "x_ite/Components/Rendering/X3DCoordinateNode",
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Components/Rendering/X3DLineGeometryNode",
   "x_ite/Components/Rendering/X3DNormalNode",
],
function (SupportedNodes,
          ClipPlane,
          Color,
          ColorRGBA,
          Coordinate,
          IndexedLineSet,
          IndexedTriangleFanSet,
          IndexedTriangleSet,
          IndexedTriangleStripSet,
          LineSet,
          Normal,
          PointSet,
          TriangleFanSet,
          TriangleSet,
          TriangleStripSet,
          X3DColorNode,
          X3DComposedGeometryNode,
          X3DCoordinateNode,
          X3DGeometricPropertyNode,
          X3DGeometryNode,
          X3DLineGeometryNode,
          X3DNormalNode)
{
"use strict";

   const Types =
   {
      ClipPlane:               ClipPlane,
      Color:                   Color,
      ColorRGBA:               ColorRGBA,
      Coordinate:              Coordinate,
      IndexedLineSet:          IndexedLineSet,
      IndexedTriangleFanSet:   IndexedTriangleFanSet,
      IndexedTriangleSet:      IndexedTriangleSet,
      IndexedTriangleStripSet: IndexedTriangleStripSet,
      LineSet:                 LineSet,
      Normal:                  Normal,
      PointSet:                PointSet,
      TriangleFanSet:          TriangleFanSet,
      TriangleSet:             TriangleSet,
      TriangleStripSet:        TriangleStripSet,
   };

   const AbstractTypes =
   {
      X3DColorNode:             X3DColorNode,
      X3DComposedGeometryNode:  X3DComposedGeometryNode,
      X3DCoordinateNode:        X3DCoordinateNode,
      X3DGeometricPropertyNode: X3DGeometricPropertyNode,
      X3DGeometryNode:          X3DGeometryNode,
      X3DLineGeometryNode:      X3DLineGeometryNode,
      X3DNormalNode:            X3DNormalNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DVertexAttributeNode',[
   "x_ite/Fields",
   "x_ite/Components/Rendering/X3DGeometricPropertyNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

   function X3DVertexAttributeNode (executionContext)
   {
      X3DGeometricPropertyNode .call (this, executionContext);

      this .addType (X3DConstants .X3DVertexAttributeNode);

      this .addChildObjects ("attribute_changed", new Fields .SFTime ());
   }

   X3DVertexAttributeNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
   {
      constructor: X3DVertexAttributeNode,
      initialize: function ()
      {
         X3DGeometricPropertyNode .prototype .initialize .call (this);

         this ._name  .addInterest ("set_attribute__", this);
         this ._value .addInterest ("set_value__",     this);

         this .set_value__ ();
      },
      set_attribute__: function ()
      {
         this ._attribute_changed = this .getBrowser () .getCurrentTime ();
      },
      set_value__: function ()
      {
         this .value  = this ._value .getValue ();
         this .length = this ._value .length;
      },
   });

   return X3DVertexAttributeNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/FloatVertexAttribute',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DVertexAttributeNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function FloatVertexAttribute (executionContext)
   {
      X3DVertexAttributeNode .call (this, executionContext);

      this .addType (X3DConstants .FloatVertexAttribute);
   }

   FloatVertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
   {
      constructor: FloatVertexAttribute,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",      new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "name",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "numComponents", new Fields .SFInt32 (4)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "value",         new Fields .MFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "FloatVertexAttribute";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "attrib";
      },
      initialize: function ()
      {
         X3DVertexAttributeNode .prototype .initialize .call (this);

         this ._numComponents .addInterest ("set_numComponents__", this);
         this ._numComponents .addInterest ("set_attribute__",     this);

         this .set_numComponents__ ();
      },
      set_numComponents__: function ()
      {
         this .numComponents = Algorithm .clamp (this ._numComponents .getValue (), 1, 4);
      },
      addValue: function (index, array)
      {
         const value = this .value;

         let
            first = index * this .numComponents,
            last  = first + this .numComponents;

         if (last <= this .length)
         {
            for (; first < last; ++ first)
               array .push (value [first]);
         }
         else if (this .numComponents <= this .length)
         {
            last  = value .length;
            first = last - this .numComponents;

            for (; first < last; ++ first)
               array .push (value [first]);
         }
         else
         {
            for (; first < last; ++ first)
               array .push (0);
         }
      },
      enable: function (gl, shaderNode, buffer)
      {
         shaderNode .enableFloatAttrib (gl, this ._name .getValue (), buffer, this .numComponents, 0, 0);
      },
   });

   return FloatVertexAttribute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/Matrix3VertexAttribute',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DVertexAttributeNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Matrix3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants,
          Matrix3)
{
"use strict";

   function Matrix3VertexAttribute (executionContext)
   {
      X3DVertexAttributeNode .call (this, executionContext);

      this .addType (X3DConstants .Matrix3VertexAttribute);
   }

   Matrix3VertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
   {
      constructor: Matrix3VertexAttribute,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "name",     new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "value",    new Fields .MFMatrix3f ()),
      ]),
      getTypeName: function ()
      {
         return "Matrix3VertexAttribute";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "attrib";
      },
      addValue: function (index, array)
      {
         if (index < this .length)
         {
            const value = this .value;

            for (let i = index * 9, l = i + 9; i < l; ++ i)
               array .push (value [i]);
         }
         else if (this .length)
         {
            const value = this .value;

            index = this .length - 1;

            for (let i = index * 9, l = i + 9; i < l; ++ i)
               array .push (value [i]);
         }
         else
         {
            const value = Matrix3 .Identity;

            for (let i = 0; i < 9; ++ i)
               array .push (value [i]);
         }
      },
      enable: function (gl, shaderNode, buffer)
      {
         shaderNode .enableMatrix3Attrib (gl, this ._name .getValue (), buffer, 0, 0);
      },
   });

   return Matrix3VertexAttribute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/Matrix4VertexAttribute',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DVertexAttributeNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants)
{
"use strict";

   function Matrix4VertexAttribute (executionContext)
   {
      X3DVertexAttributeNode .call (this, executionContext);

      this .addType (X3DConstants .Matrix4VertexAttribute);
   }

   Matrix4VertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
   {
      constructor: Matrix4VertexAttribute,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "name",     new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "value",    new Fields .MFMatrix4f ()),
      ]),
      getTypeName: function ()
      {
         return "Matrix4VertexAttribute";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "attrib";
      },
      addValue: function (index, array)
      {
         if (index < this .length)
         {
            const value = this .value;

            for (let i = index * 16, l = i + 16; i < l; ++ i)
               array .push (value [i]);
         }
         else if (this .length)
         {
            const value = this .value;

            index = this .length - 1;

            for (let i = index * 16, l = i + 16; i < l; ++ i)
               array .push (value [i]);
         }
         else
         {
            const value = Matrix4 .Identity;

            for (let i = 0; i < 16; ++ i)
               array .push (value [i]);
         }
      },
      enable: function (gl, shaderNode, buffer)
      {
         shaderNode .enableMatrix4Attrib (gl, this ._name .getValue (), buffer, 0, 0);
      },
   });

   return Matrix4VertexAttribute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/PackagedShader',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DShaderNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Components/Shaders/X3DProgrammableShaderObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShaderNode,
          X3DUrlObject,
          X3DProgrammableShaderObject,
          X3DConstants)
{
"use strict";

   function PackagedShader (executionContext)
   {
      X3DShaderNode               .call (this, executionContext);
      X3DUrlObject                .call (this, executionContext);
      X3DProgrammableShaderObject .call (this, executionContext);

      this .addType (X3DConstants .PackagedShader);
   }

   PackagedShader .prototype = Object .assign (Object .create (X3DShaderNode .prototype),
      X3DUrlObject .prototype,
      X3DProgrammableShaderObject .prototype,
   {
      constructor: PackagedShader,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "activate",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isSelected",           new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isValid",              new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "language",             new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
      ]),
      getTypeName: function ()
      {
         return "PackagedShader";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "shaders";
      },
      getSourceText: function ()
      {
         return this ._url;
      },
      requestImmediateLoad: function (cache = true)
      { },
      requestUnload: function ()
      { },
   });

   return PackagedShader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ProgramShader',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shaders/X3DShaderNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShaderNode,
          X3DConstants)
{
"use strict";

   function ProgramShader (executionContext)
   {
      X3DShaderNode .call (this, executionContext);

      this .addType (X3DConstants .ProgramShader);
   }

   ProgramShader .prototype = Object .assign (Object .create (X3DShaderNode .prototype),
   {
      constructor: ProgramShader,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOnly,      "activate",   new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isSelected", new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isValid",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "language",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "programs",   new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "ProgramShader";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "shaders";
      },
   });

   return ProgramShader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ShaderProgram',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Core/X3DNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Components/Shaders/X3DProgrammableShaderObject",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          X3DUrlObject,
          X3DProgrammableShaderObject,
          X3DConstants)
{
"use strict";

   function ShaderProgram (executionContext)
   {
      X3DNode                     .call (this, executionContext);
      X3DUrlObject                .call (this, executionContext);
      X3DProgrammableShaderObject .call (this, executionContext);

      this .addType (X3DConstants .ShaderProgram);
   }

   ShaderProgram .prototype = Object .assign (Object .create (X3DNode .prototype),
      X3DUrlObject .prototype,
      X3DProgrammableShaderObject .prototype,
   {
      constructor: ShaderProgram,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "type",                 new Fields .SFString ("VERTEX")),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
      ]),
      getTypeName: function ()
      {
         return "ShaderProgram";
      },
      getComponentName: function ()
      {
         return "Shaders";
      },
      getContainerField: function ()
      {
         return "programs";
      },
      getSourceText: function ()
      {
         return this ._url;
      },
      requestImmediateLoad: function (cache = true)
      { },
      requestUnload: function ()
      { },
   });

   return ShaderProgram;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Shaders/ComposedShader",
   "x_ite/Components/Shaders/FloatVertexAttribute",
   "x_ite/Components/Shaders/Matrix3VertexAttribute",
   "x_ite/Components/Shaders/Matrix4VertexAttribute",
   "x_ite/Components/Shaders/PackagedShader",
   "x_ite/Components/Shaders/ProgramShader",
   "x_ite/Components/Shaders/ShaderPart",
   "x_ite/Components/Shaders/ShaderProgram",
   "x_ite/Components/Shaders/X3DProgrammableShaderObject",
   "x_ite/Components/Shaders/X3DShaderNode",
   "x_ite/Components/Shaders/X3DVertexAttributeNode",
],
function (SupportedNodes,
          ComposedShader,
          FloatVertexAttribute,
          Matrix3VertexAttribute,
          Matrix4VertexAttribute,
          PackagedShader,
          ProgramShader,
          ShaderPart,
          ShaderProgram,
          X3DProgrammableShaderObject,
          X3DShaderNode,
          X3DVertexAttributeNode)
{
"use strict";

   const Types =
   {
      ComposedShader:         ComposedShader,
      FloatVertexAttribute:   FloatVertexAttribute,
      Matrix3VertexAttribute: Matrix3VertexAttribute,
      Matrix4VertexAttribute: Matrix4VertexAttribute,
      PackagedShader:         PackagedShader,
      ProgramShader:          ProgramShader,
      ShaderPart:             ShaderPart,
      ShaderProgram:          ShaderProgram,
   };

   const AbstractTypes =
   {
      X3DProgrammableShaderObject: X3DProgrammableShaderObject,
      X3DShaderNode:               X3DShaderNode,
      X3DVertexAttributeNode:      X3DVertexAttributeNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Shape/AcousticProperties',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

   function AcousticProperties (executionContext)
   {
      X3DAppearanceChildNode .call (this, executionContext);

      this .addType (X3DConstants .AcousticProperties);
   }

   AcousticProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
   {
      constructor: AcousticProperties,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",    new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "absorption", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "refraction", new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diffuse",    new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "specular",   new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "AcousticProperties";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "AcousticProperties";
      },
   });

   return AcousticProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Material',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DOneSidedMaterialNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DOneSidedMaterialNode,
          X3DCast,
          X3DConstants,
          Algorithm)
{
"use strict";

   function Material (executionContext)
   {
      X3DOneSidedMaterialNode .call (this, executionContext);

      this .addType (X3DConstants .Material);

      this .diffuseColor  = new Float32Array (3);
      this .specularColor = new Float32Array (3);
      this .shaderNode    = this .getBrowser () .getDefaultShader ();
   }

   Material .prototype = Object .assign (Object .create (X3DOneSidedMaterialNode .prototype),
   {
      constructor: Material,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                 new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "ambientIntensity",         new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "ambientTexture",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "ambientTextureMapping",    new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseColor",             new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseTexture",           new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseTextureMapping",    new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "specularColor",            new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "specularTexture",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "specularTextureMapping",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",            new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTexture",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTextureMapping",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "shininess",                new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "shininessTexture",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "shininessTextureMapping",  new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionStrength",        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionTexture",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionTextureMapping",  new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalScale",              new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTexture",            new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTextureMapping",     new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",             new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "Material";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "material";
      },
      initialize: function ()
      {
         X3DOneSidedMaterialNode .prototype .initialize .call (this);

         this .isLive () .addInterest ("set_live__", this);

         this ._ambientIntensity  .addInterest ("set_ambientIntensity__",  this);
         this ._ambientTexture    .addInterest ("set_ambientTexture__",    this);
         this ._diffuseColor      .addInterest ("set_diffuseColor__",      this);
         this ._diffuseTexture    .addInterest ("set_diffuseTexture__",    this);
         this ._specularColor     .addInterest ("set_specularColor__",     this);
         this ._specularTexture   .addInterest ("set_specularTexture__",   this);
         this ._shininess         .addInterest ("set_shininess__",         this);
         this ._shininessTexture  .addInterest ("set_shininessTexture__",  this);
         this ._occlusionStrength .addInterest ("set_occlusionStrength__", this);
         this ._occlusionTexture  .addInterest ("set_occlusionTexture__",  this);

         this .set_live__ ();
         this .set_ambientIntensity__ ();
         this .set_ambientTexture__ ();
         this .set_diffuseColor__ ();
         this .set_diffuseTexture__ ();
         this .set_specularColor__ ();
         this .set_specularTexture__ ();
         this .set_shininess__ ();
         this .set_shininessTexture__ ();
         this .set_occlusionStrength__ ();
         this .set_occlusionTexture__ ();
         this .set_transparent__ ();
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue ())
            this .getBrowser () .getBrowserOptions () ._Shading .addInterest ("set_shading__", this);
         else
            this .getBrowser () .getBrowserOptions () ._Shading .removeInterest ("set_shading__", this);

         this .set_shading__ ();
      },
      set_ambientIntensity__: function ()
      {
         this .ambientIntensity = Algorithm .clamp (this ._ambientIntensity .getValue (), 0, 1);
      },
      set_ambientTexture__: function ()
      {
         this .ambientTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._ambientTexture);

         this .setTexture (this .getTextureIndices () .AMBIENT_TEXTURE, this .ambientTextureNode);
      },
      set_diffuseColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .diffuseColor .set (this ._diffuseColor .getValue ());

         const
            diffuseColor  = this .diffuseColor,
            diffuseColor_ = this ._diffuseColor .getValue ();

         diffuseColor [0] = diffuseColor_ .r;
         diffuseColor [1] = diffuseColor_ .g;
         diffuseColor [2] = diffuseColor_ .b;
      },
      set_diffuseTexture__: function ()
      {
         if (this .diffuseTextureNode)
            this .diffuseTextureNode ._transparent .removeInterest ("set_transparent__", this);

         this .diffuseTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._diffuseTexture);

         if (this .diffuseTextureNode)
            this .diffuseTextureNode ._transparent .addInterest ("set_transparent__", this);

         this .setTexture (this .getTextureIndices () .DIFFUSE_TEXTURE, this .diffuseTextureNode);
      },
      set_specularColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .specularColor .set (this ._specularColor .getValue ());

         const
            specularColor  = this .specularColor,
            specularColor_ = this ._specularColor .getValue ();

         specularColor [0] = specularColor_ .r;
         specularColor [1] = specularColor_ .g;
         specularColor [2] = specularColor_ .b;
      },
      set_specularTexture__: function ()
      {
         this .specularTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._specularTexture);

         this .setTexture (this .getTextureIndices () .SPECULAR_TEXTURE, this .specularTextureNode);
      },
      set_shininess__: function ()
      {
         this .shininess = Algorithm .clamp (this ._shininess .getValue (), 0, 1);
      },
      set_shininessTexture__: function ()
      {
         this .shininessTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._shininessTexture);

         this .setTexture (this .getTextureIndices () .SHININESS_TEXTURE, this .shininessTextureNode);
      },
      set_occlusionStrength__: function ()
      {
         this .occlusionStrength = Algorithm .clamp (this ._occlusionStrength .getValue (), 0, 1);
      },
      set_occlusionTexture__: function ()
      {
         this .occlusionTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._occlusionTexture);

         this .setTexture (this .getTextureIndices () .OCCLUSION_TEXTURE, this .occlusionTextureNode);
      },
      set_transparent__: function ()
      {
         this .setTransparent (Boolean (this .getTransparency () ||
                               (this .diffuseTextureNode && this .diffuseTextureNode .getTransparent ())));
      },
      set_textures__: function ()
      {
         if (this .getTextures ())
         {
            const
               browser = this .getBrowser (),
               options = ["X3D_MATERIAL_TEXTURES"];

            if (this .ambientTextureNode)
               options .push ("X3D_AMBIENT_TEXTURE", "X3D_AMBIENT_TEXTURE_" + this .ambientTextureNode .getTextureTypeString ());

            if (this .diffuseTextureNode)
               options .push ("X3D_DIFFUSE_TEXTURE", "X3D_DIFFUSE_TEXTURE_" + this .diffuseTextureNode .getTextureTypeString ());

            if (this .specularTextureNode)
               options .push ("X3D_SPECULAR_TEXTURE", "X3D_SPECULAR_TEXTURE_" + this .specularTextureNode .getTextureTypeString ());

            if (this .getEmissiveTexture ())
               options .push ("X3D_EMISSIVE_TEXTURE", "X3D_EMISSIVE_TEXTURE_" + this .getEmissiveTexture () .getTextureTypeString ());

            if (this .shininessTextureNode)
               options .push ("X3D_SHININESS_TEXTURE", "X3D_SHININESS_TEXTURE_" + this .shininessTextureNode .getTextureTypeString ());

            if (this .occlusionTextureNode)
               options .push ("X3D_OCCLUSION_TEXTURE", "X3D_OCCLUSION_TEXTURE_" + this .occlusionTextureNode .getTextureTypeString ());

            if (this .getNormalTexture ())
               options .push ("X3D_NORMAL_TEXTURE", "X3D_NORMAL_TEXTURE_" + this .getNormalTexture () .getTextureTypeString ());

            const shaderNode = browser .createShader ("MaterialTexturesShader", "Phong", options);

            shaderNode ._isValid .addInterest ("set_shader__", this, shaderNode);
         }
         else
         {
            this .set_shading__ ();
         }
      },
      set_shader__: function (shaderNode)
      {
         shaderNode ._isValid .removeInterest ("set_shader__", this);

         this .shaderNode = shaderNode;
      },
      set_shading__: function ()
      {
         if (this .getTextures ())
            return;

         const shaderNode = this .getBrowser () .getDefaultShader ();

         if (shaderNode ._isValid .getValue ())
            this .shaderNode = shaderNode;
         else
            shaderNode ._isValid .addInterest ("set_shader__", this, shaderNode);
      },
      getTextureIndices: (function ()
      {
         const textureIndices = {
            AMBIENT_TEXTURE: 0,
            DIFFUSE_TEXTURE: 1,
            SPECULAR_TEXTURE: 2,
            EMISSIVE_TEXTURE: 3,
            SHININESS_TEXTURE: 4,
            OCCLUSION_TEXTURE: 5,
            NORMAL_TEXTURE: 6,
         };

         return function ()
         {
            return textureIndices;
         };
      })(),
      getShader: function (browser, shadow)
      {
         return shadow ? browser .getShadowShader () : this .shaderNode;
      },
      setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
      {
         X3DOneSidedMaterialNode .prototype .setShaderUniforms .call (this, gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping);

         gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .ambientIntensity);
         gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .diffuseColor);
         gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .specularColor);
         gl .uniform1f  (shaderObject .x3d_Shininess,        this .shininess);

         if (this .getTextures ())
         {
            const
               ambientTexture   = shaderObject .x3d_AmbientTexture,
               diffuseTexture   = shaderObject .x3d_DiffuseTexture,
               specularTexture  = shaderObject .x3d_SpecularTexture,
               shininessTexture = shaderObject .x3d_ShininessTexture,
               occlusionTexture = shaderObject .x3d_OcclusionTexture;

            // Ambient parameters

            if (this .ambientTextureNode)
            {
               this .ambientTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, ambientTexture);

               gl .uniform1i (ambientTexture .textureTransformMapping,  textureTransformMapping  .get (this ._ambientTextureMapping .getValue ()) || 0);
               gl .uniform1i (ambientTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._ambientTextureMapping .getValue ()) || 0);
            }

            // Diffuse parameters

            if (this .diffuseTextureNode)
            {
               this .diffuseTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, diffuseTexture);

               gl .uniform1i (diffuseTexture .textureTransformMapping,  textureTransformMapping  .get (this ._diffuseTextureMapping .getValue ()) || 0);
               gl .uniform1i (diffuseTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._diffuseTextureMapping .getValue ()) || 0);
            }

            // Specular parameters

            if (this .specularTextureNode)
            {
               this .specularTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, specularTexture);

               gl .uniform1i (specularTexture .textureTransformMapping,  textureTransformMapping  .get (this ._specularTextureMapping .getValue ()) || 0);
               gl .uniform1i (specularTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._specularTextureMapping .getValue ()) || 0);
            }

            // Shininess parameters

            if (this .shininessTextureNode)
            {
               this .shininessTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, shininessTexture);

               gl .uniform1i (shininessTexture .textureTransformMapping,  textureTransformMapping  .get (this ._shininessTextureMapping .getValue ()) || 0);
               gl .uniform1i (shininessTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._shininessTextureMapping .getValue ()) || 0);
            }

            // Occlusion parameters

            if (this .occlusionTextureNode)
            {
               gl .uniform1f (shaderObject .x3d_OcclusionStrength, this .occlusionStrength);

               this .occlusionTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, occlusionTexture);

               gl .uniform1i (occlusionTexture .textureTransformMapping,  textureTransformMapping  .get (this ._occlusionTextureMapping .getValue ()) || 0);
               gl .uniform1i (occlusionTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._occlusionTextureMapping .getValue ()) || 0);
            }
         }
      },
   });

   return Material;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


 define ('x_ite/Components/Shape/PhysicalMaterial',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DOneSidedMaterialNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DOneSidedMaterialNode,
          X3DCast,
          X3DConstants,
          Algorithm)
{
"use strict";

   function PhysicalMaterial (executionContext)
   {
      X3DOneSidedMaterialNode .call (this, executionContext);

      this .addType (X3DConstants .PhysicalMaterial);

      this .baseColor = new Float32Array (3);
   }

   PhysicalMaterial .prototype = Object .assign (Object .create (X3DOneSidedMaterialNode .prototype),
   {
      constructor: PhysicalMaterial,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "baseColor",                       new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "baseTexture",                     new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "baseTextureMapping",              new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",                   new Fields .SFColor (0, 0, 0)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTexture",                 new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveTextureMapping",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "metallic",                        new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "roughness",                       new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "metallicRoughnessTexture",        new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "metallicRoughnessTextureMapping", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionStrength",               new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionTexture",                new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "occlusionTextureMapping",         new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalScale",                     new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTexture",                   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "normalTextureMapping",            new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",                    new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "PhysicalMaterial";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "material";
      },
      initialize: function ()
      {
         X3DOneSidedMaterialNode .prototype .initialize .call (this);

         this .shaderNode = this .getBrowser () .getPhysicalMaterialShader ();

         this ._baseColor                .addInterest ("set_baseColor__",                this);
         this ._baseTexture              .addInterest ("set_baseTexture__",              this);
         this ._metallic                 .addInterest ("set_metallic__",                 this);
         this ._roughness                .addInterest ("set_roughness__",                this);
         this ._metallicRoughnessTexture .addInterest ("set_metallicRoughnessTexture__", this);
         this ._occlusionStrength        .addInterest ("set_occlusionStrength__",        this);
         this ._occlusionTexture         .addInterest ("set_occlusionTexture__",         this);

         this .set_baseColor__ ();
         this .set_baseTexture__ ();
         this .set_metallic__ ();
         this .set_roughness__ ();
         this .set_metallicRoughnessTexture__ ();
         this .set_occlusionStrength__ ();
         this .set_occlusionTexture__ ();
         this .set_transparent__ ();
      },
      set_baseColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .baseColor .set (this ._baseColor .getValue ());

         const
            baseColor  = this .baseColor,
            baseColor_ = this ._baseColor .getValue ();

         baseColor [0] = baseColor_ .r;
         baseColor [1] = baseColor_ .g;
         baseColor [2] = baseColor_ .b;
      },
      set_baseTexture__: function ()
      {
         if (this .baseTextureNode)
            this .baseTextureNode ._transparent .removeInterest ("set_transparent__", this);

         this .baseTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._baseTexture);

         this .setTexture (this .getTextureIndices () .BASE_TEXTURE, this .baseTextureNode);

         if (this .baseTextureNode)
            this .baseTextureNode ._transparent .addInterest ("set_transparent__", this);
      },
      set_metallic__: function ()
      {
         this .metallic = Algorithm .clamp (this ._metallic .getValue (), 0, 1);
      },
      set_roughness__: function ()
      {
         this .roughness = Algorithm .clamp (this ._roughness .getValue (), 0, 1);
      },
      set_metallicRoughnessTexture__: function ()
      {
         this .metallicRoughnessTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._metallicRoughnessTexture);

         this .setTexture (this .getTextureIndices () .METALLIC_ROUGHNESS_TEXTURE, this .metallicRoughnessTextureNode);
      },
      set_occlusionStrength__: function ()
      {
         this .occlusionStrength = Algorithm .clamp (this ._occlusionStrength .getValue (), 0, 1);
      },
      set_occlusionTexture__: function ()
      {
         this .occlusionTextureNode = X3DCast (X3DConstants .X3DSingleTextureNode, this ._occlusionTexture);

         this .setTexture (this .getTextureIndices () .OCCLUSION_TEXTURE, this .occlusionTextureNode);
      },
      set_transparent__: function ()
      {
         this .setTransparent (Boolean (this .getTransparency () ||
                               (this .baseTextureNode && this .baseTextureNode .getTransparent ())));
      },
      set_textures__: function ()
      {
         const browser = this .getBrowser ();

         if (this .getTextures ())
         {
            const options = ["X3D_MATERIAL_TEXTURES"];

            if (this .baseTextureNode)
               options .push ("X3D_BASE_TEXTURE", "X3D_BASE_TEXTURE_" + this .baseTextureNode .getTextureTypeString ());

            if (this .getEmissiveTexture ())
               options .push ("X3D_EMISSIVE_TEXTURE", "X3D_EMISSIVE_TEXTURE_" + this .getEmissiveTexture () .getTextureTypeString ());

            if (this .metallicRoughnessTextureNode)
               options .push ("X3D_METALLIC_ROUGHNESS_TEXTURE", "X3D_METALLIC_ROUGHNESS_TEXTURE_" + this .metallicRoughnessTextureNode .getTextureTypeString ());

            if (this .occlusionTextureNode)
               options .push ("X3D_OCCLUSION_TEXTURE", "X3D_OCCLUSION_TEXTURE_" + this .occlusionTextureNode .getTextureTypeString ());

            if (this .getNormalTexture ())
               options .push ("X3D_NORMAL_TEXTURE", "X3D_NORMAL_TEXTURE_" + this .getNormalTexture () .getTextureTypeString ());

            const shaderNode = browser .createShader ("PhysicalMaterialTexturesShader", "PBR", options);

            shaderNode._isValid .addInterest ("set_shader__", this, shaderNode);
         }
         else
         {
            this .shaderNode = browser .getPhysicalMaterialShader ();
         }
      },
      set_shader__: function (shaderNode)
      {
         shaderNode ._isValid .removeInterest ("set_shader__", this);

         this .shaderNode = shaderNode;
      },
      getTextureIndices: (function ()
      {
         const textureIndices = {
            BASE_TEXTURE: 0,
            EMISSIVE_TEXTURE: 1,
            METALLIC_ROUGHNESS_TEXTURE: 2,
            OCCLUSION_TEXTURE: 3,
            NORMAL_TEXTURE: 4,
         };

         return function ()
         {
            return textureIndices;
         };
      })(),
      getShader: function (browser, shadow)
      {
         return this .shaderNode;
      },
      setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping)
      {
         X3DOneSidedMaterialNode .prototype .setShaderUniforms .call (this, gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping);

         gl .uniform3fv (shaderObject .x3d_BaseColor, this .baseColor);
         gl .uniform1f  (shaderObject .x3d_Metallic,  this .metallic);
         gl .uniform1f  (shaderObject .x3d_Roughness, this .roughness);

         if (this .getTextures ())
         {
            const
               baseTexture              = shaderObject .x3d_BaseTexture,
               metallicRoughnessTexture = shaderObject .x3d_MetallicRoughnessTexture,
               occlusionTexture         = shaderObject .x3d_OcclusionTexture;

            // Base parameters

            if (this .baseTextureNode)
            {
               this .baseTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, baseTexture);

               gl .uniform1i (baseTexture .textureTransformMapping,  textureTransformMapping  .get (this ._baseTextureMapping .getValue ()) || 0);
               gl .uniform1i (baseTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._baseTextureMapping .getValue ()) || 0);
            }

            // Metallic roughness parameters

            if (this .metallicRoughnessTextureNode)
            {
               this .metallicRoughnessTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, metallicRoughnessTexture);

               gl .uniform1i (metallicRoughnessTexture .textureTransformMapping,  textureTransformMapping  .get (this ._metallicRoughnessTextureMapping .getValue ()) || 0);
               gl .uniform1i (metallicRoughnessTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._metallicRoughnessTextureMapping .getValue ()) || 0);
            }

            // Occlusion parameters

            if (this .occlusionTextureNode)
            {
               gl .uniform1f (shaderObject .x3d_OcclusionStrength, this .occlusionStrength);

               this .occlusionTextureNode .setShaderUniformsToChannel (gl, shaderObject, renderObject, occlusionTexture);

               gl .uniform1i (occlusionTexture .textureTransformMapping,  textureTransformMapping  .get (this ._occlusionTextureMapping .getValue ()) || 0);
               gl .uniform1i (occlusionTexture .textureCoordinateMapping, textureCoordinateMapping .get (this ._occlusionTextureMapping .getValue ()) || 0);
            }
         }
      },
   });

   return PhysicalMaterial;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/TwoSidedMaterial',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Shape/X3DMaterialNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DMaterialNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function TwoSidedMaterial (executionContext)
   {
      X3DMaterialNode .call (this, executionContext);

      this .addType (X3DConstants .TwoSidedMaterial);

      this .diffuseColor  = new Float32Array (3);
      this .specularColor = new Float32Array (3);
      this .emissiveColor = new Float32Array (3);

      this .backDiffuseColor  = new Float32Array (3);
      this .backSpecularColor = new Float32Array (3);
      this .backEmissiveColor = new Float32Array (3);
   }

   TwoSidedMaterial .prototype = Object .assign (Object .create (X3DMaterialNode .prototype),
   {
      constructor: TwoSidedMaterial,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "separateBackColor",    new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "ambientIntensity",     new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseColor",         new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "specularColor",        new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",        new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "shininess",            new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",         new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backAmbientIntensity", new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backDiffuseColor",     new Fields .SFColor (0.8, 0.8, 0.8)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backSpecularColor",    new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backEmissiveColor",    new Fields .SFColor ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backShininess",        new Fields .SFFloat (0.2)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "backTransparency",     new Fields .SFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "TwoSidedMaterial";
      },
      getComponentName: function ()
      {
         return "Shape";
      },
      getContainerField: function ()
      {
         return "material";
      },
      initialize: function ()
      {
         X3DMaterialNode . prototype .initialize .call (this);

         this ._ambientIntensity .addInterest ("set_ambientIntensity__", this);
         this ._diffuseColor     .addInterest ("set_diffuseColor__",     this);
         this ._specularColor    .addInterest ("set_specularColor__",    this);
         this ._emissiveColor    .addInterest ("set_emissiveColor__",    this);
         this ._shininess        .addInterest ("set_shininess__",        this);
         this ._transparency     .addInterest ("set_transparency__",     this);

         this ._backAmbientIntensity .addInterest ("set_backAmbientIntensity__", this);
         this ._backDiffuseColor     .addInterest ("set_backDiffuseColor__",     this);
         this ._backSpecularColor    .addInterest ("set_backSpecularColor__",    this);
         this ._backEmissiveColor    .addInterest ("set_backEmissiveColor__",    this);
         this ._backShininess        .addInterest ("set_backShininess__",        this);
         this ._backTransparency     .addInterest ("set_backTransparency__",     this);

         this ._separateBackColor .addInterest ("set_transparent__", this);
         this ._transparency      .addInterest ("set_transparent__", this);
         this ._backTransparency  .addInterest ("set_transparent__", this);

         this .set_ambientIntensity__ ();
         this .set_diffuseColor__ ();
         this .set_specularColor__ ();
         this .set_emissiveColor__ ();
         this .set_shininess__ ();
         this .set_transparency__ ();

         this .set_backAmbientIntensity__ ();
         this .set_backDiffuseColor__ ();
         this .set_backSpecularColor__ ();
         this .set_backEmissiveColor__ ();
         this .set_backShininess__ ();
         this .set_backTransparency__ ();

         this .set_transparent__ ();
      },
      set_ambientIntensity__: function ()
      {
         this .ambientIntensity = Math .max (this ._ambientIntensity .getValue (), 0);
      },
      set_diffuseColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .diffuseColor .set (this ._diffuseColor .getValue ());

         const
            diffuseColor  = this .diffuseColor,
            diffuseColor_ = this ._diffuseColor .getValue ();

         diffuseColor [0] = diffuseColor_ .r;
         diffuseColor [1] = diffuseColor_ .g;
         diffuseColor [2] = diffuseColor_ .b;
      },
      set_specularColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .specularColor .set (this ._specularColor .getValue ());

         const
            specularColor  = this .specularColor,
            specularColor_ = this ._specularColor .getValue ();

         specularColor [0] = specularColor_ .r;
         specularColor [1] = specularColor_ .g;
         specularColor [2] = specularColor_ .b;
      },
      set_emissiveColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .emissiveColor .set (this ._emissiveColor .getValue ());

         const
            emissiveColor  = this .emissiveColor,
            emissiveColor_ = this ._emissiveColor .getValue ();

         emissiveColor [0] = emissiveColor_ .r;
         emissiveColor [1] = emissiveColor_ .g;
         emissiveColor [2] = emissiveColor_ .b;
      },
      set_shininess__: function ()
      {
         this .shininess = Algorithm .clamp (this ._shininess .getValue (), 0, 1);
      },
      set_transparency__: function ()
      {
         this .transparency = Algorithm .clamp (this ._transparency .getValue (), 0, 1);
      },
      /*
       * Back Material
       */
      set_backAmbientIntensity__: function ()
      {
         this .backAmbientIntensity = Math .max (this ._backAmbientIntensity .getValue (), 0);
      },
      set_backDiffuseColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .backDiffuseColor .set (this ._backDiffuseColor .getValue ());

         const
            backDiffuseColor  = this .backDiffuseColor,
            backDiffuseColor_ = this ._backDiffuseColor .getValue ();

         backDiffuseColor [0] = backDiffuseColor_ .r;
         backDiffuseColor [1] = backDiffuseColor_ .g;
         backDiffuseColor [2] = backDiffuseColor_ .b;
      },
      set_backSpecularColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .backSpecularColor .set (this ._backSpecularColor .getValue ());

         const
            backSpecularColor  = this .backSpecularColor,
            backSpecularColor_ = this ._backSpecularColor .getValue ();

         backSpecularColor [0] = backSpecularColor_ .r;
         backSpecularColor [1] = backSpecularColor_ .g;
         backSpecularColor [2] = backSpecularColor_ .b;
      },
      set_backEmissiveColor__: function ()
      {
         //We cannot use this in Windows Edge:
         //this .backEmissiveColor .set (this ._backEmissiveColor .getValue ());

         const
            backEmissiveColor  = this .backEmissiveColor,
            backEmissiveColor_ = this ._backEmissiveColor .getValue ();

         backEmissiveColor [0] = backEmissiveColor_ .r;
         backEmissiveColor [1] = backEmissiveColor_ .g;
         backEmissiveColor [2] = backEmissiveColor_ .b;
      },
      set_backShininess__: function ()
      {
         this .backShininess = Algorithm .clamp (this ._backShininess .getValue (), 0, 1);
      },
      set_backTransparency__: function ()
      {
         this .backTransparency = Algorithm .clamp (this ._backTransparency .getValue (), 0, 1);
      },
      set_transparent__: function ()
      {
         this .setTransparent (Boolean (this ._transparency .getValue () || (this ._separateBackColor .getValue () && this ._backTransparency .getValue ())));
      },
      getShader: function (browser, shadow)
      {
         return shadow ? browser .getShadowShader () : browser .getDefaultShader ();
      },
      setShaderUniforms: function (gl, shaderObject, renderObject, textureTransformMapping, textureCoordinateMapping, front)
      {
         if (!front && this ._separateBackColor .getValue ())
         {
            gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .backAmbientIntensity);
            gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .backDiffuseColor);
            gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .backSpecularColor);
            gl .uniform3fv (shaderObject .x3d_EmissiveColor,    this .backEmissiveColor);
            gl .uniform1f  (shaderObject .x3d_Shininess,        this .backShininess);
            gl .uniform1f  (shaderObject .x3d_Transparency,     this .backTransparency);
         }
         else
         {
            gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .ambientIntensity);
            gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .diffuseColor);
            gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .specularColor);
            gl .uniform3fv (shaderObject .x3d_EmissiveColor,    this .emissiveColor);
            gl .uniform1f  (shaderObject .x3d_Shininess,        this .shininess);
            gl .uniform1f  (shaderObject .x3d_Transparency,     this .transparency);
         }
      },
   });

   return TwoSidedMaterial;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Shape/AcousticProperties",
   "x_ite/Components/Shape/Appearance",
   "x_ite/Components/Shape/FillProperties",
   "x_ite/Components/Shape/LineProperties",
   "x_ite/Components/Shape/Material",
   "x_ite/Components/Shape/PhysicalMaterial",
   "x_ite/Components/Shape/PointProperties",
   "x_ite/Components/Shape/Shape",
   "x_ite/Components/Shape/TwoSidedMaterial",
   "x_ite/Components/Shape/UnlitMaterial",
   "x_ite/Components/Shape/X3DAppearanceChildNode",
   "x_ite/Components/Shape/X3DAppearanceNode",
   "x_ite/Components/Shape/X3DMaterialNode",
   "x_ite/Components/Shape/X3DOneSidedMaterialNode",
   "x_ite/Components/Shape/X3DShapeNode",
],
function (SupportedNodes,
          AcousticProperties,
          Appearance,
          FillProperties,
          LineProperties,
          Material,
          PhysicalMaterial,
          PointProperties,
          Shape,
          TwoSidedMaterial,
          UnlitMaterial,
          X3DAppearanceChildNode,
          X3DAppearanceNode,
          X3DMaterialNode,
          X3DOneSidedMaterialNode,
          X3DShapeNode)
{
"use strict";

   const Types =
   {
      AcousticProperties: AcousticProperties,
      Appearance:         Appearance,
      FillProperties:     FillProperties,
      LineProperties:     LineProperties,
      Material:           Material,
      PhysicalMaterial:   PhysicalMaterial,
      PointProperties:    PointProperties,
      Shape:              Shape,
      TwoSidedMaterial:   TwoSidedMaterial,
      UnlitMaterial:      UnlitMaterial,
   };

   const AbstractTypes =
   {
      X3DAppearanceChildNode:  X3DAppearanceChildNode,
      X3DAppearanceNode:       X3DAppearanceNode,
      X3DMaterialNode:         X3DMaterialNode,
      X3DOneSidedMaterialNode: X3DOneSidedMaterialNode,
      X3DShapeNode:            X3DShapeNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/X3DSoundSourceNode',[
   "x_ite/Fields",
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Components/Time/X3DTimeDependentNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DChildNode,
          X3DTimeDependentNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function X3DSoundSourceNode (executionContext)
   {
      X3DChildNode         .call (this, executionContext);
      X3DTimeDependentNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSoundSourceNode);

      this .volume = 0;
      this .media  = null;
   }

   X3DSoundSourceNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
      X3DTimeDependentNode .prototype,
   {
      constructor: X3DSoundSourceNode,
      initialize: function ()
      {
         X3DChildNode         .prototype .initialize .call (this);
         X3DTimeDependentNode .prototype .initialize .call (this);
      },
      set_live__: function ()
      {
         X3DTimeDependentNode .prototype .set_live__ .call (this);

         if (this .getDisabled ())
         {
            this .getBrowser () ._volume .removeInterest ("set_volume__", this);
            this .getBrowser () ._mute   .removeInterest ("set_volume__", this);
         }
         else
         {
            this .getBrowser () ._volume .addInterest ("set_volume__", this);
            this .getBrowser () ._mute   .addInterest ("set_volume__", this);
            this .set_volume__ ();
         }
      },
      setMedia: function (value)
      {
         if (this .media)
         {
            this .media [0] .volume = 0;
            this .media [0] .pause ();
         }

         this .media = value;

         if (value)
         {
            const media = value [0];

            media .loop = this ._loop .getValue ();

            this .setVolume (0);
            this ._duration_changed = media .duration;

            this .resetElapsedTime ();

            if (this ._isActive .getValue ())
            {
               if (this ._isPaused .getValue ())
               {
                  this .set_pause ();
               }
               else
               {
                  if (this .getLiveState ())
                     this .set_start ();
                  else
                     this .set_pause ();
               }
            }
            else
            {
               this .set_stop ();
            }
         }
      },
      getMedia: function ()
      {
         return this .media;
      },
      setVolume: function (volume)
      {
         this .volume = Algorithm .clamp (volume, 0, 1);

         this .set_volume__ ();
      },
      set_loop: function ()
      {
         if (this .media)
            this .media [0] .loop = this ._loop .getValue ();
      },
      set_volume__: function ()
      {
         if (! this .media)
            return;

         const
            mute      = this .getBrowser () ._mute .getValue (),
            intensity = Algorithm .clamp (this .getBrowser () ._volume .getValue (), 0, 1),
            volume    = (! mute) * intensity * this .volume;

         this .media [0] .volume = volume;
      },
      set_speed: function ()
      { },
      set_pitch: function ()
      { },
      set_start: function ()
      {
         if (this .media)
         {
            if (this ._speed .getValue ())
            {
               this .media [0] .currentTime = 0;
               this .media [0] .play ();
            }
         }
      },
      set_pause: function ()
      {
         if (this .media)
            this .media [0] .pause ();
      },
      set_resume: function ()
      {
         if (this .media)
         {
            if (this ._speed .getValue ())
               this .media [0] .play ();
         }
      },
      set_stop: function ()
      {
         if (this .media)
            this .media [0] .pause ();
      },
      set_ended: function ()
      {
         if (this .media)
         {
            const media = this .media [0];

            if (media .currentTime < media .duration)
               return;

            if (!this ._loop .getValue ())
               this .stop ();
         }
      },
      set_time: function ()
      {
         if (this .media)
            this ._elapsedTime = this .getElapsedTime ();

         this .set_ended ();
      },
   });

   return X3DSoundSourceNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/AudioClip',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Sound/X3DSoundSourceNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Base/X3DConstants",
   "x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSoundSourceNode,
          X3DUrlObject,
          X3DConstants,
          DEBUG)
{
"use strict";

   function AudioClip (executionContext)
   {
      X3DSoundSourceNode .call (this, executionContext);
      X3DUrlObject       .call (this, executionContext);

      this .addType (X3DConstants .AudioClip);

      this .addChildObjects ("speed", new Fields .SFFloat (1));

      this .audio    = $("<audio></audio>");
      this .urlStack = new Fields .MFString ();
   }

   AudioClip .prototype = Object .assign (Object .create (X3DSoundSourceNode .prototype),
      X3DUrlObject .prototype,
   {
      constructor: AudioClip,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "autoRefreshTimeLimit", new Fields .SFTime (3600)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "gain",                 new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pitch",                new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "loop",                 new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "startTime",            new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "resumeTime",           new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "pauseTime",            new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "stopTime",             new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isPaused",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "elapsedTime",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,  "duration_changed",     new Fields .SFTime (-1)),
      ]),
      getTypeName: function ()
      {
         return "AudioClip";
      },
      getComponentName: function ()
      {
         return "Sound";
      },
      getContainerField: function ()
      {
         return "source";
      },
      initialize: function ()
      {
         X3DSoundSourceNode .prototype .initialize .call (this);
         X3DUrlObject       .prototype .initialize .call (this);

         this .audio .on ("error", this .setError .bind (this));

         this .audio [0] .preload     = "auto";
         this .audio [0] .volume      = 0;
         this .audio [0] .crossOrigin = "Anonymous";

         this .requestImmediateLoad ();
      },
      getElement: function ()
      {
         return this .audio [0];
      },
      set_live__: function ()
      {
         X3DSoundSourceNode .prototype .set_live__ .call (this);
         X3DUrlObject       .prototype .set_live__ .call (this);
      },
      unloadNow: function ()
      {
         this .setMedia (null);
      },
      loadNow: function ()
      {
         this .setMedia (null);
         this .urlStack .setValue (this ._url);
         this .audio .bind ("canplaythrough", this .setAudio .bind (this));
         this .loadNext ();
      },
      loadNext: function ()
      {
         if (this .urlStack .length === 0)
         {
            this .audio .unbind ("canplaythrough");
            this ._duration_changed = -1;
            this .setLoadState (X3DConstants .FAILED_STATE);
            return;
         }

         // Get URL.

         this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

         if (this .URL .protocol !== "data:")
         {
            if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
               this .URL .searchParams .set ("_", Date .now ());
         }

         this .audio .attr ("src", this .URL .href);
         this .audio .get (0) .load ();
      },
      setError: function ()
      {
         if (this .URL .protocol !== "data:")
            console .warn ("Error loading audio:", decodeURI (this .URL .href));

         this .loadNext ();
      },
      setAudio: function ()
      {
         if (DEBUG)
         {
            if (this .URL .protocol !== "data:")
               console .info ("Done loading audio:", decodeURI (this .URL .href));
         }

         this .audio .unbind ("canplaythrough");
         this .setMedia (this .audio);
         this .setLoadState (X3DConstants .COMPLETE_STATE);
      },
   });

   return AudioClip;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/X3DSoundNode',[
   "x_ite/Components/Core/X3DChildNode",
   "x_ite/Base/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

   function X3DSoundNode (executionContext)
   {
      X3DChildNode .call (this, executionContext);

      this .addType (X3DConstants .X3DSoundNode);
   }

   X3DSoundNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
   {
      constructor: X3DSoundNode,
   });

   return X3DSoundNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/Sound',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Sound/X3DSoundNode",
   "x_ite/Base/X3DCast",
   "x_ite/Rendering/TraverseType",
   "x_ite/Base/X3DConstants",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Rotation4",
   "standard/Math/Numbers/Matrix4",
   "standard/Math/Geometry/Line3",
   "standard/Math/Geometry/Sphere3",
   "standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSoundNode,
          X3DCast,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Line3,
          Sphere3,
          Algorithm)
{
"use strict";

   function Sound (executionContext)
   {
      X3DSoundNode .call (this, executionContext);

      this .addType (X3DConstants .Sound);

      this .addChildObjects ("traversed", new Fields .SFBool (true));

      this ._location .setUnit ("length");
      this ._minBack  .setUnit ("length");
      this ._minFront .setUnit ("length");
      this ._maxBack  .setUnit ("length");
      this ._maxFront .setUnit ("length");

      this .currentTraversed = true;
   }

   Sound .prototype = Object .assign (Object .create (X3DSoundNode .prototype),
   {
      constructor: Sound,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",  new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "spatialize", new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "location",   new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",  new Fields .SFVec3f (0, 0, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "minBack",    new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "minFront",   new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "maxBack",    new Fields .SFFloat (10)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "maxFront",   new Fields .SFFloat (10)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "priority",   new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "source",     new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Sound";
      },
      getComponentName: function ()
      {
         return "Sound";
      },
      getContainerField: function ()
      {
         return "children";
      },
      initialize: function ()
      {
         X3DSoundNode .prototype .initialize .call (this);

         this .isLive ()  .addInterest ("set_live__", this);
         this ._traversed .addInterest ("set_live__", this);

         this ._source .addInterest ("set_source__", this);

         this .set_live__ ();
         this .set_source__ ();
      },
      setTraversed: function (value)
      {
         if (value)
         {
            if (this ._traversed .getValue () === false)
               this ._traversed = true;
         }
         else
         {
            if (this .currentTraversed !== this ._traversed .getValue ())
               this ._traversed = this .currentTraversed;
         }

         this .currentTraversed = value;
      },
      getTraversed: function ()
      {
         return this .currentTraversed;
      },
      set_live__: function ()
      {
         if (this .isLive () .getValue () && this ._traversed .getValue ())
         {
            this .getBrowser () .sensorEvents () .addInterest ("update", this);
         }
         else
         {
            this .getBrowser () .sensorEvents () .removeInterest ("update", this);
         }
      },
      set_source__: function ()
      {
         if (this .sourceNode)
            this .sourceNode .setVolume (0);

         this .sourceNode = X3DCast (X3DConstants .X3DSoundSourceNode, this ._source);
      },
      update: function ()
      {
         if (! this .getTraversed ())
         {
            if (this .sourceNode)
               this .sourceNode .setVolume (0);
         }

         this .setTraversed (false);
      },
      traverse: (function ()
      {
         const
            min = { distance: 0, intersection: new Vector3 (0, 0, 0) },
            max = { distance: 0, intersection: new Vector3 (0, 0, 0) };

         return function (type, renderObject)
         {
            if (type !== TraverseType .DISPLAY)
               return;

            if (! this .sourceNode)
               return;

            if (! this .sourceNode ._isActive .getValue () || this .sourceNode ._isPaused .getValue ())
               return;

            this .setTraversed (true);

            const modelViewMatrix = renderObject .getModelViewMatrix () .get ();

            this .getEllipsoidParameter (modelViewMatrix,
                                          Math .max (this ._maxBack  .getValue (), 0),
                                          Math .max (this ._maxFront .getValue (), 0),
                                          max);

            if (max .distance < 1) // Sphere radius is 1
            {
               this .getEllipsoidParameter (modelViewMatrix,
                                             Math .max (this ._minBack  .getValue (), 0),
                                             Math .max (this ._minFront .getValue (), 0),
                                             min);

               if (min .distance < 1) // Sphere radius is 1
               {
                  this .sourceNode .setVolume (this ._intensity .getValue ());
               }
               else
               {
                  const
                     d1        = max .intersection .abs (), // Viewer is here at (0, 0, 0)
                     d2        = max .intersection .distance (min .intersection),
                     d         = Math .min (d1 / d2, 1),
                     intensity = Algorithm .clamp (this ._intensity .getValue (), 0, 1),
                     volume    = intensity * d;

                  this .sourceNode .setVolume (volume);
               }
            }
            else
            {
               this .sourceNode .setVolume (0);
            }
         };
      })(),
      getEllipsoidParameter: (function ()
      {
         const
            location        = new Vector3 (0, 0, 0),
            sphereMatrix    = new Matrix4 (),
            invSphereMatrix = new Matrix4 (),
            rotation        = new Rotation4 (),
            scale           = new Vector3 (1, 1, 1),
            sphere          = new Sphere3 (1, Vector3 .Zero),
            normal          = new Vector3 (0, 0, 0),
            line            = new Line3 (Vector3 .Zero, Vector3 .zAxis),
            enterPoint      = new Vector3 (0, 0, 0),
            exitPoint       = new Vector3 (0, 0, 0);

         return function (modelViewMatrix, back, front, value)
         {
            /*
             * http://de.wikipedia.org/wiki/Ellipse
             *
             * The ellipsoid is transformed to a sphere for easier calculation and then the viewer position is
             * transformed into this coordinate system. The radius and distance can then be obtained.
             *
             * throws Error
             */

            if (back == 0 || front == 0)
            {
               sphereMatrix .multVecMatrix (value .intersection .assign (this ._location .getValue ()));
               value .distance = 1;
               return;
            }

            const
               a = (back + front) / 2,
               e = a - back,
               b = Math .sqrt (a * a - e * e);

            location .set (0, 0, e);
            scale    .set (b, b, a);
            rotation .setFromToVec (Vector3 .zAxis, this ._direction .getValue ());

            sphereMatrix
               .assign (modelViewMatrix)
               .translate (this ._location .getValue ())
               .rotate (rotation)
               .translate (location)
               .scale (scale);

            invSphereMatrix .assign (sphereMatrix) .inverse ();

            const viewer = invSphereMatrix .origin;
            location .negate () .divVec (scale);

            normal .assign (location) .subtract (viewer) .normalize ();
            line .set (viewer, normal);
            sphere .intersectsLine (line, enterPoint, exitPoint);

            value .intersection .assign (sphereMatrix .multVecMatrix (enterPoint));
            value .distance = viewer .abs ();
         };
      })(),
   });

   return Sound;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Sound/AudioClip",
   "x_ite/Components/Sound/Sound",
   "x_ite/Components/Sound/X3DSoundNode",
   "x_ite/Components/Sound/X3DSoundSourceNode",
],
function (SupportedNodes,
          AudioClip,
          Sound,
          X3DSoundNode,
          X3DSoundSourceNode)
{
"use strict";

   const Types =
   {
      AudioClip: AudioClip,
      Sound:     Sound,
   };

   const AbstractTypes =
   {
      X3DSoundNode:       X3DSoundNode,
      X3DSoundSourceNode: X3DSoundSourceNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/Text',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Rendering/X3DGeometryNode",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

   function Text (executionContext)
   {
      X3DGeometryNode .call (this, executionContext);

      this .addType (X3DConstants .Text);

      this ._length     .setUnit ("length");
      this ._maxExtent  .setUnit ("length");
      this ._origin     .setUnit ("length");
      this ._textBounds .setUnit ("length");
      this ._lineBounds .setUnit ("length");
   }

   Text .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
   {
      constructor: Text,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "string",     new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "length",     new Fields .MFFloat ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "maxExtent",  new Fields .SFFloat ()),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",      new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "origin",     new Fields .SFVec3f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "textBounds", new Fields .SFVec2f ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "lineBounds", new Fields .MFVec2f ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "fontStyle",  new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "Text";
      },
      getComponentName: function ()
      {
         return "Text";
      },
      getContainerField: function ()
      {
         return "geometry";
      },
      initialize: function ()
      {
         X3DGeometryNode .prototype .initialize .call (this);

         this ._fontStyle .addInterest ("set_fontStyle__", this);

         this .set_fontStyle__ ();
      },
      getMatrix: function ()
      {
         return this .textGeometry .getMatrix ();
      },
      getLength: function (index)
      {
         if (index < this ._length .length)
            return Math .max (0, this ._length [index]);

         return 0;
      },
      set_live__: function ()
      {
          X3DGeometryNode .prototype .set_live__ .call (this);

         if (this .isLive () .getValue ())
            this .getBrowser () .getBrowserOptions () ._PrimitiveQuality .addInterest ("requestRebuild", this);
         else
            this .getBrowser () .getBrowserOptions () ._PrimitiveQuality .removeInterest ("requestRebuild", this);
      },
      set_fontStyle__: function ()
      {
         if (this .fontStyleNode)
            this .fontStyleNode .removeInterest ("requestRebuild", this);

         this .fontStyleNode = X3DCast (X3DConstants .X3DFontStyleNode, this ._fontStyle);

         if (! this .fontStyleNode)
            this .fontStyleNode = this .getBrowser () .getDefaultFontStyle ();

         this .fontStyleNode .addInterest ("requestRebuild", this);

         this .textGeometry = this .fontStyleNode .getTextGeometry (this);

         this .setTransparent (this .textGeometry .getTransparent ());
      },
      build: function ()
      {
         this .textGeometry .update ();
         this .textGeometry .build ();

         this .setSolid (this ._solid .getValue ());
      },
      traverse: function (type, renderObject)
      {
         this .textGeometry .traverse (type, renderObject);

         X3DGeometryNode .prototype .traverse .call (this, type, renderObject);
      },
      display: function (gl, context)
      {
         this .textGeometry .display (gl, context);

         X3DGeometryNode .prototype .display .call (this, gl, context);
      },
      transformLine: function (line)
      {
         // Apply sceen nodes transformation in place here.
         return this .textGeometry .transformLine (line);
      },
      transformMatrix: function (matrix)
      {
         // Apply sceen nodes transformation in place here.
         return this .textGeometry .transformMatrix (matrix);
      },
   });

   return Text;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Text/FontStyle",
   "x_ite/Components/Text/Text",
   "x_ite/Components/Text/X3DFontStyleNode",
],
function (SupportedNodes,
          FontStyle,
          Text,
          X3DFontStyleNode)
{
"use strict";

   const Types =
   {
      FontStyle: FontStyle,
      Text: Text,
   };

   const AbstractTypes =
   {
      X3DFontStyleNode: X3DFontStyleNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MovieTexture',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTexture2DNode",
   "x_ite/Components/Sound/X3DSoundSourceNode",
   "x_ite/Components/Networking/X3DUrlObject",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
   "x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DSoundSourceNode,
          X3DUrlObject,
          X3DConstants,
          Algorithm,
          DEBUG)
{
"use strict";

   function MovieTexture (executionContext)
   {
      X3DTexture2DNode   .call (this, executionContext);
      X3DSoundSourceNode .call (this, executionContext);
      X3DUrlObject       .call (this, executionContext);

      this .addType (X3DConstants .MovieTexture);

      this .canvas   = $("<canvas></canvas>");
      this .video    = $("<video></video>");
      this .urlStack = new Fields .MFString ();
   }

   MovieTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
      X3DSoundSourceNode .prototype,
      X3DUrlObject .prototype,
   {
      constructor: MovieTexture,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",             new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "description",          new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "enabled",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "load",                 new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "url",                  new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefresh",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "autoRefreshTimeLimit", new Fields .SFTime (3600)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "gain",                 new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "speed",                new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "pitch",                new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "loop",                 new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "startTime",            new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "resumeTime",           new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "pauseTime",            new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "stopTime",             new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isPaused",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",             new Fields .SFBool ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "elapsedTime",          new Fields .SFTime ()),
         new X3DFieldDefinition (X3DConstants .outputOnly,     "duration_changed",     new Fields .SFTime (-1)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",              new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties",    new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "MovieTexture";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texture";
      },
      initialize: function ()
      {
         X3DTexture2DNode   .prototype .initialize .call (this);
         X3DSoundSourceNode .prototype .initialize .call (this);
         X3DUrlObject       .prototype .initialize .call (this);

         this .video .on ("error", this .setError .bind (this));

         this .video [0] .preload     = "auto";
         this .video [0] .volume      = 0;
         this .video [0] .crossOrigin = "Anonymous";

         this .requestImmediateLoad ();
      },
      getElement: function ()
      {
         return this .video [0];
      },
      set_live__: function ()
      {
         X3DSoundSourceNode .prototype .set_live__ .call (this);
         X3DUrlObject       .prototype .set_live__ .call (this);
      },
      unloadNow: function ()
      {
         this .clearTexture ();
      },
      loadNow: function ()
      {
         this .setMedia (null);
         this .urlStack .setValue (this ._url);
         this .video .bind ("canplaythrough", this .setVideo .bind (this));
         this .loadNext ();
      },
      loadNext: function ()
      {
         if (this .urlStack .length === 0)
         {
            this .video .unbind ("canplaythrough");
            this ._duration_changed = -1;
            this .clearTexture ();
            this .setLoadState (X3DConstants .FAILED_STATE);
            return;
         }

         // Get URL.

         this .URL = new URL (this .urlStack .shift (), this .getExecutionContext () .getWorldURL ());

         if (this .URL .protocol !== "data:")
         {
            if (!this .getBrowser () .getBrowserOptions () .getCache () || !this .getCache ())
               this .URL .searchParams .set ("_", Date .now ());
         }

         this .video .attr ("src", this .URL .href);
         this .video .get (0) .load ();
      },
      setError: function ()
      {
         if (this .URL .protocol !== "data:")
            console .warn ("Error loading movie:", decodeURI (this .URL .href));

         this .loadNext ();
      },
      setVideo: function ()
      {
         if (DEBUG)
         {
            if (this .URL .protocol !== "data:")
               console .info ("Done loading movie:", decodeURI (this .URL .href));
         }

         try
         {
            this .video .unbind ("canplaythrough");

            const
               video  = this .video [0],
               width  = video .videoWidth,
               height = video .videoHeight,
               canvas = this .canvas [0],
               cx     = canvas .getContext ("2d");

            if (! Algorithm .isPowerOfTwo (width) || ! Algorithm .isPowerOfTwo (height))
               throw new Error ("The movie texture is a non power-of-two texture.");

            canvas .width  = width;
            canvas .height = height;

            cx .drawImage (video, 0, 0);

            const data = cx .getImageData (0, 0, width, height) .data;

            this .setMedia (this .video);
            this .setTexture (width, height, false, new Uint8Array (data .buffer), true);
            this .setLoadState (X3DConstants .COMPLETE_STATE);
         }
         catch (error)
         {
            // Catch security error from cross origin requests.
            console .log (error .message);
            this .setError ();
         }
      },
      set_time: function ()
      {
         X3DSoundSourceNode .prototype .set_time .call (this);

         if (this .checkLoadState () === X3DConstants .COMPLETE_STATE)
            this .updateTexture (this .getMedia () [0], true);
      },
      traverse: X3DTexture2DNode .prototype .traverse,
   });

   return MovieTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTexture',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTextureNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/X3DCast",
   "x_ite/Browser/Texturing/MultiTextureModeType",
   "x_ite/Browser/Texturing/MultiTextureSourceType",
   "x_ite/Browser/Texturing/MultiTextureFunctionType",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureNode,
          X3DConstants,
          X3DCast,
          ModeType,
          SourceType,
          FunctionType)
{
"use strict";

   function MultiTexture (executionContext)
   {
      X3DTextureNode .call (this, executionContext);

      this .addType (X3DConstants .MultiTexture);

      this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));

      this .color        = new Float32Array (4);
      this .modes        = [ ];
      this .alphaModes   = [ ];
      this .sources      = [ ];
      this .functions    = [ ];
      this .textureNodes = [ ];
   }

   MultiTexture .prototype = Object .assign (Object .create (X3DTextureNode .prototype),
   {
      constructor: MultiTexture,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "description", new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "color",       new Fields .SFColor (1, 1, 1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "alpha",       new Fields .SFFloat (1)),
         new X3DFieldDefinition (X3DConstants .inputOutput, "mode",        new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "source",      new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "function",    new Fields .MFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "texture",     new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "MultiTexture";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texture";
      },
      initialize: function ()
      {
         X3DTextureNode .prototype .initialize .call (this);

         this ._color    .addInterest ("set_color__",    this);
         this ._alpha    .addInterest ("set_alpha__",    this);
         this ._mode     .addInterest ("set_mode__",     this);
         this ._source   .addInterest ("set_source__",   this);
         this ._function .addInterest ("set_function__", this);
         this ._texture  .addInterest ("set_texture__",  this);

         this .set_color__ ();
         this .set_alpha__ ();
         this .set_mode__ ();
         this .set_source__ ();
         this .set_function__ ();
         this .set_texture__ ();

         this ._loadState = X3DConstants .COMPLETE_STATE;
      },
      getMode: function (index)
      {
         if (index < this .modes .length)
            return this .modes [index];

         return ModeType .MODULATE;
      },
      getAlphaMode: function (index)
      {
         if (index < this .alphaModes .length)
            return this .alphaModes [index];

         return ModeType .MODULATE;
      },
      getSource: function (index)
      {
         if (index < this .sources .length)
            return this .sources [index];

         return SourceType .DEFAULT;
      },
      getFunction: function (index)
      {
         if (index < this .functions .length)
            return this .functions [index];

         return FunctionType .DEFAULT;
      },
      set_color__: function ()
      {
         this .color [0] = this ._color .r;
         this .color [1] = this ._color .g;
         this .color [2] = this ._color .b;
      },
      set_alpha__: function ()
      {
         this .color [3] = this ._alpha;
      },
      set_mode__: (function ()
      {
         const modeTypes = new Map ([
            ["REPLACE",                   ModeType .REPLACE],
            ["MODULATE",                  ModeType .MODULATE],
            ["MODULATE2X",                ModeType .MODULATE2X],
            ["MODULATE4X",                ModeType .MODULATE4X],
            ["ADD",                       ModeType .ADD],
            ["ADDSIGNED",                 ModeType .ADDSIGNED],
            ["ADDSIGNED2X",               ModeType .ADDSIGNED2X],
            ["ADDSMOOTH",                 ModeType .ADDSMOOTH],
            ["SUBTRACT",                  ModeType .SUBTRACT],
            ["BLENDDIFFUSEALPHA",         ModeType .BLENDDIFFUSEALPHA],
            ["BLENDTEXTUREALPHA",         ModeType .BLENDTEXTUREALPHA],
            ["BLENDFACTORALPHA",          ModeType .BLENDFACTORALPHA],
            ["BLENDCURRENTALPHA",         ModeType .BLENDCURRENTALPHA],
            ["MODULATEALPHA_ADDCOLOR",    ModeType .MODULATEALPHA_ADDCOLOR],
            ["MODULATEINVALPHA_ADDCOLOR", ModeType .MODULATEINVALPHA_ADDCOLOR],
            ["MODULATEINVCOLOR_ADDALPHA", ModeType .MODULATEINVCOLOR_ADDALPHA],
            ["DOTPRODUCT3",               ModeType .DOTPRODUCT3],
            ["SELECTARG1",                ModeType .SELECTARG1],
            ["SELECTARG2",                ModeType .SELECTARG2],
            ["OFF",                       ModeType .OFF],
         ]);

         return function ()
         {
            this .modes      .length = 0;
            this .alphaModes .length = 0;

            for (const modes of this ._mode)
            {
               const mode = modes .split (",");

               for (let m = 0, l = mode .length; m < l; ++ m)
                  mode [m] = mode [m] .trim ();

               if (mode .length === 0)
                  mode .push ("MODULATE");

               if (mode .length < 2)
                  mode .push (mode [0]);

               // RGB

               const modeType = modeTypes .get (mode [0]);

               if (modeType !== undefined)
                  this .modes .push (modeType);
               else
                  this .modes .push (ModeType .MODULATE);

               // Alpha

               const alphaModeType = modeTypes .get (mode [1]);

               if (alphaModeType !== undefined)
                  this .alphaModes .push (alphaModeType);
               else
                  this .alphaModes .push (ModeType .MODULATE);
            }
         };
      })(),
      set_source__: (function ()
      {
         const sourceTypes = new Map ([
            ["DIFFUSE",  SourceType .DIFFUSE],
            ["SPECULAR", SourceType .SPECULAR],
            ["FACTOR",   SourceType .FACTOR],
         ]);

         return function ()
         {
            this .sources .length = 0;

            for (const source of this ._source)
            {
               const sourceType = sourceTypes .get (source);

               if (sourceType !== undefined)
                  this .sources .push (sourceType);
               else
                  this .sources .push (SourceType .DEFAULT);
            }
         };
      })(),
      set_function__: (function ()
      {
         const functionsTypes = new Map ([
            ["COMPLEMENT",     FunctionType .COMPLEMENT],
            ["ALPHAREPLICATE", FunctionType .ALPHAREPLICATE],
         ]);

         return function ()
         {
            this .functions .length = 0;

            for (const func of this ._function)
            {
               const functionsType = functionsTypes .get (func);

               if (functionsType !== undefined)
                  this .functions .push (functionsType);
               else
                  this .functions .push (FunctionType .DEFAULT);
            }
         };
      })(),
      set_texture__: function ()
      {
         this .textureNodes .length = 0;

         for (const node of this ._texture)
         {
            const textureNode = X3DCast (X3DConstants .X3DSingleTextureNode, node);

            if (textureNode)
               this .textureNodes .push (textureNode);
         }
      },
      traverse: function (type, renderObject)
      {
         for (const textureNode of this .textureNodes)
            textureNode .traverse (type, renderObject);
      },
      setShaderUniforms: function (gl, shaderObject, renderObject)
      {
         const
            textureNodes = this .textureNodes,
            channels     = Math .min (shaderObject .getBrowser () .getMaxTextures (), textureNodes .length);

         gl .uniform1i  (shaderObject .x3d_NumTextures,       channels);
         gl .uniform4fv (shaderObject .x3d_MultiTextureColor, this .color);

         for (let i = 0; i < channels; ++ i)
         {
            textureNodes [i] .setShaderUniformsToChannel (gl, shaderObject, renderObject, shaderObject .x3d_Textures [i]);

            gl .uniform1i  (shaderObject .x3d_MultiTextureMode [i],      this .getMode (i));
            gl .uniform1i  (shaderObject .x3d_MultiTextureAlphaMode [i], this .getAlphaMode (i));
            gl .uniform1i  (shaderObject .x3d_MultiTextureSource [i],    this .getSource (i));
            gl .uniform1i  (shaderObject .x3d_MultiTextureFunction [i],  this .getFunction (i));
         }
      },
   });

   return MultiTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTextureCoordinate',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTextureCoordinateNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/X3DCast",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureCoordinateNode,
          X3DConstants,
          X3DCast)
{
"use strict";

   function MultiTextureCoordinate (executionContext)
   {
      X3DTextureCoordinateNode .call (this, executionContext);

      this .addType (X3DConstants .MultiTextureCoordinate);

      this .textureCoordinateNodes = [ ];
   }

   MultiTextureCoordinate .prototype = Object .assign (Object .create (X3DTextureCoordinateNode .prototype),
   {
      constructor: MultiTextureCoordinate,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "texCoord", new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "MultiTextureCoordinate";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texCoord";
      },
      initialize: function ()
      {
         X3DTextureCoordinateNode .prototype .initialize .call (this);

         this ._texCoord .addInterest ("set_texCoord__", this);

         this .set_texCoord__ ();
      },
      set_texCoord__: function ()
      {
         const textureCoordinateNodes = this .textureCoordinateNodes;

         for (const textureCoordinateNode of textureCoordinateNodes)
            textureCoordinateNode .removeInterest ("addNodeEvent", this);

         textureCoordinateNodes .length = 0;

         for (const node of this ._texCoord)
         {
            const textureCoordinateNode = X3DCast (X3DConstants .X3DSingleTextureCoordinateNode, node);

            if (textureCoordinateNode)
               textureCoordinateNodes .push (textureCoordinateNode);
         }

         for (const textureCoordinateNode of textureCoordinateNodes)
            textureCoordinateNode .addInterest ("addNodeEvent", this);
      },
      isEmpty: function ()
      {
         return true;
      },
      getSize: function ()
      {
         return 0;
      },
      get1Point: function (index, vector)
      {
         for (const textureCoordinateNode of this .textureCoordinateNodes)
            return textureCoordinateNode .get1Point (index, vector);

         return vector .set (0, 0, 0, 1);
      },
      init: function (multiArray)
      {
         for (const textureCoordinateNode of this .textureCoordinateNodes)
            textureCoordinateNode .init (multiArray);
      },
      addTexCoord: function (index, multiArray)
      {
         const textureCoordinateNodes = this .textureCoordinateNodes;

         for (let i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
            textureCoordinateNodes [i] .addTexCoordToChannel (index, multiArray [i]);
      },
      addTexCoordToChannel: function (index, array)
      { },
      getTexCoord: function (array)
      {
         for (const textureCoordinateNode of this .textureCoordinateNodes)
            return textureCoordinateNode .getTexCoord (array);

         return array;
      },
      getTextureMapping: function (textureCoordinateMapping)
      {
         const
            textureCoordinateNodes = this .textureCoordinateNodes,
            length                 = Math .min (this .getBrowser () .getMaxTextures (), textureCoordinateNodes .length);

         for (let i = 0; i < length; ++ i)
            textureCoordinateNodes [i] .getTextureMapping (textureCoordinateMapping, i);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const
            textureCoordinateNodes = this .textureCoordinateNodes,
            length                 = Math .min (shaderObject .x3d_MaxTextures, textureCoordinateNodes .length);

         for (let i = 0; i < length; ++ i)
            textureCoordinateNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

         const last = length ? textureCoordinateNodes .at (-1) : this;

         for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
            last .setShaderUniformsToChannel (gl, shaderObject, i);
      },
   });

   return MultiTextureCoordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTextureTransform',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTextureTransformNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Base/X3DCast",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureTransformNode,
          X3DConstants,
          X3DCast)
{
"use strict";

   function MultiTextureTransform (executionContext)
   {
      X3DTextureTransformNode .call (this, executionContext);

      this .addType (X3DConstants .MultiTextureTransform);

      this .textureTransformNodes = [ ];
   }

   MultiTextureTransform .prototype = Object .assign (Object .create (X3DTextureTransformNode .prototype),
   {
      constructor: MultiTextureTransform,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "textureTransform", new Fields .MFNode ()),
      ]),
      getTypeName: function ()
      {
         return "MultiTextureTransform";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "textureTransform";
      },
      initialize: function ()
      {
         X3DTextureTransformNode .prototype .initialize .call (this);

         this ._textureTransform .addInterest ("set_textureTransform__", this);

         this .set_textureTransform__ ();
      },
      set_textureTransform__: function ()
      {
         const textureTransformNodes = this .textureTransformNodes;

         textureTransformNodes .length = 0;

         for (const node of this ._textureTransform)
         {
            const textureTransformNode = X3DCast (X3DConstants .X3DSingleTextureTransformNode, node);

            if (textureTransformNode)
               textureTransformNodes .push (textureTransformNode);
         }
      },
      getTextureMapping: function (textureTransformMapping)
      {
         const
            textureTransformNodes = this .textureTransformNodes,
            length                = Math .min (this .getBrowser () .getMaxTextures (), textureTransformNodes .length);

         for (let i = 0; i < length; ++ i)
            textureTransformNodes [i] .getTextureMapping (textureTransformMapping, i);
      },
      setShaderUniforms: function (gl, shaderObject)
      {
         const
            textureTransformNodes = this .textureTransformNodes,
            length                = Math .min (shaderObject .x3d_MaxTextures, textureTransformNodes .length);

         for (let i = 0; i < length; ++ i)
            textureTransformNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

         const last = length ? textureTransformNodes .at (-1) : this;

         for (let i = length, l = shaderObject .x3d_MaxTextures; i < l; ++ i)
            last .setShaderUniformsToChannel (gl, shaderObject, i);
      },
   });

   return MultiTextureTransform;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/PixelTexture',[
   "jquery",
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DTexture2DNode",
   "x_ite/Base/X3DConstants",
   "standard/Math/Algorithm",
   "standard/Math/Numbers/Vector3",
   "standard/Math/Numbers/Matrix3",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DConstants,
          Algorithm)
{
"use strict";

   function PixelTexture (executionContext)
   {
      X3DTexture2DNode .call (this, executionContext);

      this .addType (X3DConstants .PixelTexture);

      this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));
   }

   PixelTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
   {
      constructor: PixelTexture,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "description",       new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput,    "image",             new Fields .SFImage (0, 0, 0, new Fields .MFInt32 ())),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",           new Fields .SFBool (true)),
         new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties", new Fields .SFNode ()),
      ]),
      getTypeName: function ()
      {
         return "PixelTexture";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texture";
      },
      initialize: function ()
      {
         X3DTexture2DNode .prototype .initialize .call (this);

         this ._image .addInterest ("set_image__", this);

         this .canvas1 = $("<canvas></canvas>");
         this .canvas2 = $("<canvas></canvas>");

         this .set_image__ ();
      },
      checkLoadState: function ()
      {
         return this ._loadState .getValue ();
      },
      convert: function (data, comp, array, length)
      {
         switch (comp)
         {
            case 1:
            {
               for (let i = 0, index = 0; i < length; ++ i, index += 4)
               {
                  const pixel = array [i];

                  data [index]     =
                  data [index + 1] =
                  data [index + 2] = pixel & 255;
                  data [index + 3] = 255;
               }

               break;
            }
            case 2:
            {
               for (let i = 0, index = 0; i < length; ++ i, index += 4)
               {
                  const pixel = array [i];

                  data [index]     =
                  data [index + 1] =
                  data [index + 2] = (pixel >>> 8) & 255;
                  data [index + 3] = pixel & 255;
               }

               break;
            }
            case 3:
            {
               for (let i = 0, index = 0; i < length; ++ i, index += 4)
               {
                  const pixel = array [i];

                  data [index]     = (pixel >>> 16) & 255;
                  data [index + 1] = (pixel >>>  8) & 255;
                  data [index + 2] = pixel & 255;
                  data [index + 3] = 255;
               }

               break;
            }
            case 4:
            {
               for (let i = 0, index = 0; i < length; ++ i, index += 4)
               {
                  const pixel = array [i];

                  data [index]     = (pixel >>> 24);
                  data [index + 1] = (pixel >>> 16) & 255;
                  data [index + 2] = (pixel >>>  8) & 255;
                  data [index + 3] = pixel & 255;
               }

               break;
            }
         }
      },
      resize: function (input, inputWidth, inputHeight, outputWidth, outputHeight)
      {
         // Nearest neighbor scaling algorithm for very small images.

         const
            output = new Uint8Array (outputWidth * outputHeight * 4),
            scaleX = outputWidth / inputWidth,
            scaleY = outputHeight / inputHeight;

         for (let y = 0; y < outputHeight; ++ y)
         {
            const
               inputW  = Math .floor (y / scaleY) * inputWidth,
               outputW = y * outputWidth;

            for (let x = 0; x < outputWidth; ++ x)
            {
               const
                  index       = (inputW + Math.floor (x / scaleX)) * 4,
                  indexScaled = (outputW + x) * 4;

               output [indexScaled]     = input [index];
               output [indexScaled + 1] = input [index + 1];
               output [indexScaled + 2] = input [index + 2];
               output [indexScaled + 3] = input [index + 3];
            }
         }

         return output;
      },
      set_image__: function ()
      {
         const
            gl          = this .getBrowser () .getContext (),
            comp        = this ._image .comp,
            array       = this ._image .array,
            transparent = !(comp % 2);

         let
            width  = this ._image .width,
            height = this ._image .height,
            data   = null;

         if (width > 0 && height > 0 && comp > 0 && comp < 5)
         {
            if (gl .getVersion () >= 2 || (Algorithm .isPowerOfTwo (width) && Algorithm .isPowerOfTwo (height)))
            {
               data = new Uint8Array (width * height * 4);

               this .convert (data, comp, array .getValue (), array .length);
            }
            else if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! this ._textureProperties .getValue ())
            {
               data = new Uint8Array (width * height * 4);

               this .convert (data, comp, array .getValue (), array .length);

               const
                  inputWidth  = width,
                  inputHeight = height;

               width  = Algorithm .nextPowerOfTwo (inputWidth)  * 4;
               height = Algorithm .nextPowerOfTwo (inputHeight) * 4;
               data   = this .resize (data, inputWidth, inputHeight, width, height);
            }
            else
            {
               const
                  canvas1   = this .canvas1 [0],
                  canvas2   = this .canvas2 [0],
                  cx1       = canvas1 .getContext("2d"),
                  cx2       = canvas2 .getContext("2d"),
                  imageData = cx1 .createImageData (width, height);

               canvas1 .width  = width;
               canvas1 .height = height;

               this .convert (imageData .data, comp, array, array .length);
               cx1 .putImageData (imageData, 0, 0);

               width  = Algorithm .nextPowerOfTwo (width);
               height = Algorithm .nextPowerOfTwo (height);

               canvas2 .width  = width;
               canvas2 .height = height;

               cx2 .clearRect (0, 0, width, height);
               cx2 .drawImage (canvas1, 0, 0, canvas1 .width, canvas1 .height, 0, 0, width, height);

               data = cx2 .getImageData (0, 0, width, height) .data;
            }

            this .setTexture (width, height, transparent, new Uint8Array (data .buffer), false);
            this ._loadState = X3DConstants .COMPLETE_STATE;
         }
         else
         {
            this .clearTexture ();
            this ._loadState = X3DConstants .FAILED_STATE;
         }
      },
   });

   return PixelTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureCoordinateGenerator',[
   "x_ite/Fields",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Components/Texturing/X3DSingleTextureCoordinateNode",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSingleTextureCoordinateNode,
          X3DConstants,
          ModeType)
{
"use strict";

   function TextureCoordinateGenerator (executionContext)
   {
      X3DSingleTextureCoordinateNode .call (this, executionContext);

      this .addType (X3DConstants .TextureCoordinateGenerator);

      this .mode      = ModeType .SPHERE;
      this .parameter = new Float32Array (6);
   }

   TextureCoordinateGenerator .prototype = Object .assign (Object .create (X3DSingleTextureCoordinateNode .prototype),
   {
      constructor: TextureCoordinateGenerator,
      [Symbol .for ("X_ITE.X3DBaseNode.fieldDefinitions")]: new FieldDefinitionArray ([
         new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "mapping",   new Fields .SFString ()),
         new X3DFieldDefinition (X3DConstants .inputOutput, "mode",      new Fields .SFString ("SPHERE")),
         new X3DFieldDefinition (X3DConstants .inputOutput, "parameter", new Fields .MFFloat ()),
      ]),
      getTypeName: function ()
      {
         return "TextureCoordinateGenerator";
      },
      getComponentName: function ()
      {
         return "Texturing";
      },
      getContainerField: function ()
      {
         return "texCoord";
      },
      initialize: function ()
      {
         X3DSingleTextureCoordinateNode .prototype .initialize .call (this);

         this ._mode      .addInterest ("set_mode__",      this);
         this ._parameter .addInterest ("set_parameter__", this);

         this .set_mode__ ();
         this .set_parameter__ ();
      },
      set_mode__: (function ()
      {
         const modes = new Map ([
            ["SPHERE",                      ModeType .SPHERE],
            ["CAMERASPACENORMAL",           ModeType .CAMERASPACENORMAL],
            ["CAMERASPACEPOSITION",         ModeType .CAMERASPACEPOSITION],
            ["CAMERASPACEREFLECTIONVECTOR", ModeType .CAMERASPACEREFLECTIONVECTOR],
            ["SPHERE-LOCAL",                ModeType .SPHERE_LOCAL],
            ["COORD",                       ModeType .COORD],
            ["COORD-EYE",                   ModeType .COORD_EYE],
            ["NOISE",                       ModeType .NOISE],
            ["NOISE-EYE",                   ModeType .NOISE_EYE],
            ["SPHERE-REFLECT",              ModeType .SPHERE_REFLECT],
            ["SPHERE-REFLECT-LOCAL",        ModeType .SPHERE_REFLECT_LOCAL],
         ]);

         return function ()
         {
            this .mode = modes .get (this ._mode .getValue ());

            if (this .mode === undefined)
               this .mode = ModeType .SPHERE;
         };
      })(),
      set_parameter__: function ()
      {
         const length = Math .min (this .parameter .length, this ._parameter .length)

         for (let i = 0; i < length; ++ i)
            this .parameter [i] = this ._parameter [i];

         this .parameter .fill (0, length);
      },
      get1Point: function (index, vector)
      {
         return vector;
      },
      addTexCoordToChannel: function (index, array)
      {
         array .push (0, 0, 0, 1);
      },
      getTexCoord: function (array)
      {
         return arrray;
      },
      setShaderUniformsToChannel: function (gl, shaderObject, channel)
      {
         gl .uniform1i  (shaderObject .x3d_TextureCoordinateGeneratorMode [channel],      this .mode);
         gl .uniform1fv (shaderObject .x3d_TextureCoordinateGeneratorParameter [channel], this .parameter);
      },
   });

   return TextureCoordinateGenerator;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Texturing/ImageTexture",
   "x_ite/Components/Texturing/MovieTexture",
   "x_ite/Components/Texturing/MultiTexture",
   "x_ite/Components/Texturing/MultiTextureCoordinate",
   "x_ite/Components/Texturing/MultiTextureTransform",
   "x_ite/Components/Texturing/PixelTexture",
   "x_ite/Components/Texturing/TextureCoordinate",
   "x_ite/Components/Texturing/TextureCoordinateGenerator",
   "x_ite/Components/Texturing/TextureProperties",
   "x_ite/Components/Texturing/TextureTransform",
   "x_ite/Components/Texturing/X3DSingleTextureCoordinateNode",
   "x_ite/Components/Texturing/X3DSingleTextureNode",
   "x_ite/Components/Texturing/X3DSingleTextureTransformNode",
   "x_ite/Components/Texturing/X3DTexture2DNode",
   "x_ite/Components/Texturing/X3DTextureCoordinateNode",
   "x_ite/Components/Texturing/X3DTextureNode",
   "x_ite/Components/Texturing/X3DTextureTransformNode",
],
function (SupportedNodes,
          ImageTexture,
          MovieTexture,
          MultiTexture,
          MultiTextureCoordinate,
          MultiTextureTransform,
          PixelTexture,
          TextureCoordinate,
          TextureCoordinateGenerator,
          TextureProperties,
          TextureTransform,
          X3DSingleTextureCoordinateNode,
          X3DSingleTextureNode,
          X3DSingleTextureTransformNode,
          X3DTexture2DNode,
          X3DTextureCoordinateNode,
          X3DTextureNode,
          X3DTextureTransformNode)
{
"use strict";

   const Types =
   {
      ImageTexture:               ImageTexture,
      MovieTexture:               MovieTexture,
      MultiTexture:               MultiTexture,
      MultiTextureCoordinate:     MultiTextureCoordinate,
      MultiTextureTransform:      MultiTextureTransform,
      PixelTexture:               PixelTexture,
      TextureCoordinate:          TextureCoordinate,
      TextureCoordinateGenerator: TextureCoordinateGenerator,
      TextureProperties:          TextureProperties,
      TextureTransform:           TextureTransform,
   };

   const AbstractTypes =
   {
      X3DSingleTextureCoordinateNode: X3DSingleTextureCoordinateNode,
      X3DSingleTextureNode:           X3DSingleTextureNode,
      X3DSingleTextureTransformNode:  X3DSingleTextureTransformNode,
      X3DTexture2DNode:               X3DTexture2DNode,
      X3DTextureCoordinateNode:       X3DTextureCoordinateNode,
      X3DTextureNode:                 X3DTextureNode,
      X3DTextureTransformNode:        X3DTextureTransformNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time',[
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Time/TimeSensor",
   "x_ite/Components/Time/X3DTimeDependentNode",
],
function (SupportedNodes,
          TimeSensor,
          X3DTimeDependentNode)
{
"use strict";

   const Types =
   {
      TimeSensor: TimeSensor,
   };

   const AbstractTypes =
   {
      X3DTimeDependentNode: X3DTimeDependentNode,
   };

   for (const typeName in Types)
      SupportedNodes .addType (typeName, Types [typeName]);

   for (const typeName in AbstractTypes)
      SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components',[
   "x_ite/DEBUG",
   "x_ite/Browser/X3DBrowserContext",
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Components/Core",
   "x_ite/Components/EnvironmentalEffects",
   "x_ite/Components/EnvironmentalSensor",
   "x_ite/Components/Followers",
   "x_ite/Components/Geometry3D",
   "x_ite/Components/Grouping",
   "x_ite/Components/Interpolation",
   "x_ite/Components/Layering",
   "x_ite/Components/Lighting",
   "x_ite/Components/Navigation",
   "x_ite/Components/Networking",
   "x_ite/Components/PointingDeviceSensor",
   "x_ite/Components/Rendering",
   "x_ite/Components/Shaders",
   "x_ite/Components/Shape",
   "x_ite/Components/Sound",
   "x_ite/Components/Text",
   "x_ite/Components/Texturing",
   "x_ite/Components/Time",
],
function (DEBUG,
          X3DBrowserContext,
          SupportedNodes)
{
"use strict";

   function Components () { }

   Components .prototype =
   {
      addComponent: function (component)
      {
         if (component .types)
         {
            for (const typeName in component .types)
               SupportedNodes .addType (typeName, component .types [typeName]);
         }

         if (component .abstractTypes)
         {
            for (const typeName in component .abstractTypes)
               SupportedNodes .addAbstractType (typeName, component .abstractTypes [typeName]);
         }

         if (component .context)
            X3DBrowserContext .addContext (component .context);

         if (component .name)
         {
            if (DEBUG)
               console .log ("Done loading external component '" + component .name + "'.");
         }
      },
   };

   return new Components ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ProfileInfo',[
   "x_ite/Base/X3DObject",
],
function (X3DObject)
{
"use strict";

   function ProfileInfo (name, title, providerUrl, components)
   {
      this .name        = name;
      this .title       = title;
      this .providerUrl = providerUrl;
      this .components  = components;
   }

   ProfileInfo .prototype = Object .assign (Object .create (X3DObject .prototype),
   {
      constructor: ProfileInfo,
      getTypeName: function ()
      {
         return "ProfileInfo";
      },
      toVRMLStream: function (stream)
      {
         stream .string += "PROFILE";
         stream .string += " ";
         stream .string += this .name;
      },
      toXMLStream: function (stream)
      {
         stream .string += this .name;
      },
   });

   for (const key of Reflect .ownKeys (ProfileInfo .prototype))
      Object .defineProperty (ProfileInfo .prototype, key, { enumerable: false });

   return ProfileInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ProfileInfoArray',[
   "x_ite/Configuration/ComponentInfoArray",
   "x_ite/Configuration/ProfileInfo",
   "x_ite/Base/X3DInfoArray",
],
function (ComponentInfoArray,
          ProfileInfo,
          X3DInfoArray)
{
"use strict";

   function ProfileInfoArray (values)
   {
      return X3DInfoArray .call (this, values);
   }

   ProfileInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
   {
      constructor: ProfileInfoArray,
      getTypeName: function ()
      {
         return "ProfileInfoArray";
      },
      addProfile: function (profile)
      {
         this .add (profile .name, new ProfileInfo (profile .name,
                                                    profile .title,
                                                    profile .providerUrl,
                                                    new ComponentInfoArray (profile .components)));
      },
   });

   for (const key of Reflect .ownKeys (ProfileInfoArray .prototype))
      Object .defineProperty (ProfileInfoArray .prototype, key, { enumerable: false });

   return ProfileInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedComponents',[
   "x_ite/Configuration/ComponentInfoArray",
   "x_ite/Browser/Networking/urls",
],
function (ComponentInfoArray,
          urls)
{
"use strict";

   const SupportedComponents = new ComponentInfoArray ([ ]);

   SupportedComponents .addComponent (
   {
      title:      "Annotation",
      name:       "Annotation",
      level:       2,
      providerUrl: urls .getProviderUrl ("annotation"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Computer-Aided Design (CAD) model geometry",
      name:       "CADGeometry",
      level:       2,
      providerUrl: urls .getProviderUrl ("cad-geometry"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Core",
      name:       "Core",
      level:       2,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Cube map environmental texturing",
      name:       "CubeMapTexturing",
      level:       3,
      providerUrl: urls .getProviderUrl ("cube-map-texturing"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Distributed interactive simulation (DIS)",
      name:       "DIS",
      level:       2,
      providerUrl: urls .getProviderUrl ("dis"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Environmental effects",
      name:       "EnvironmentalEffects",
      level:       4,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Environmental sensor",
      name:       "EnvironmentalSensor",
      level:       4,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Event utilities",
      name:       "EventUtilities",
      level:       4,
      providerUrl: urls .getProviderUrl ("event-utilities"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Followers",
      name:       "Followers",
      level:       4,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Geometry2D",
      name:       "Geometry2D",
      level:       2,
      providerUrl: urls .getProviderUrl ("geometry2d"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Geometry3D",
      name:       "Geometry3D",
      level:       4,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Geospatial",
      name:       "Geospatial",
      level:       2,
      providerUrl: urls .getProviderUrl ("geospatial"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Grouping",
      name:       "Grouping",
      level:       3,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Humanoid animation (HAnim)",
      name:       "HAnim",
      level:       3,
      providerUrl: urls .getProviderUrl ("h-anim"),
   });

   SupportedComponents .addAlias ("H-Anim", "HAnim");

   SupportedComponents .addComponent (
   {
      title:      "Interpolation",
      name:       "Interpolation",
      level:       5,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Key device sensor",
      name:       "KeyDeviceSensor",
      level:       2,
      providerUrl: urls .getProviderUrl ("key-device-sensor"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Layering",
      name:       "Layering",
      level:       1,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Layout",
      name:       "Layout",
      level:       2,
      providerUrl: urls .getProviderUrl ("layout"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Lighting",
      name:       "Lighting",
      level:       3,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Navigation",
      name:       "Navigation",
      level:       3,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Networking",
      name:       "Networking",
      level:       4,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Non-uniform Rational B-Spline (NURBS)",
      name:       "NURBS",
      level:       4,
      providerUrl: urls .getProviderUrl ("nurbs"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Particle systems",
      name:       "ParticleSystems",
      level:       3,
      providerUrl: urls .getProviderUrl ("particle-systems"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Picking sensor",
      name:       "Picking",
      level:       3,
      providerUrl: urls .getProviderUrl ("picking"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Pointing device sensor",
      name:       "PointingDeviceSensor",
      level:       1,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Projective Texture Mapping",
      name:       "ProjectiveTextureMapping",
      level:       2,
      providerUrl: urls .getProviderUrl ("projective-texture-mapping"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Programmable shaders",
      name:       "Shaders",
      level:       1,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Rendering",
      name:       "Rendering",
      level:       5,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Rigid body physics",
      name:       "RigidBodyPhysics",
      level:       5,
      providerUrl: urls .getProviderUrl ("rigid-body-physics"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Scripting",
      name:       "Scripting",
      level:       1,
      providerUrl: urls .getProviderUrl ("scripting"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Shape",
      name:       "Shape",
      level:       5,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Sound",
      name:       "Sound",
      level:       1,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Text",
      name:       "Text",
      level:       1,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Texturing",
      name:       "Texturing",
      level:       3,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Texturing3D",
      name:       "Texturing3D",
      level:       3,
      providerUrl: urls .getProviderUrl ("texturing-3d"),
   });

   SupportedComponents .addComponent (
   {
      title:      "Time",
      name:       "Time",
      level:       2,
      providerUrl: urls .getProviderUrl (),
   });

   SupportedComponents .addComponent (
   {
      title:      "Volume rendering",
      name:       "VolumeRendering",
      level:       2,
      providerUrl: urls .getProviderUrl ("volume-rendering"),
   });

   SupportedComponents .addComponent (
   {
      title:      "X_ITE",
      name:       "X_ITE",
      level:       1,
      providerUrl: urls .getProviderUrl ("x_ite"),
   });

   return SupportedComponents;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedProfiles',[
   "x_ite/Configuration/ProfileInfo",
   "x_ite/Configuration/ProfileInfoArray",
   "x_ite/Configuration/ComponentInfoArray",
   "x_ite/Configuration/SupportedComponents",
   "x_ite/Browser/Networking/urls",
],
function (ProfileInfo,
          ProfileInfoArray,
          ComponentInfoArray,
          SupportedComponents,
          urls)
{
"use strict";

   const SupportedProfiles = new ProfileInfoArray ();

   SupportedProfiles .addProfile ({
      title: "Computer-Aided Design (CAD) interchange",
      name: "CADInterchange",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("CADGeometry"),
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Shaders"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Texturing"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Core",
      name: "Core",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Full",
      name: "Full",
      providerUrl: urls .getProviderUrl (),
      components: [
         //SupportedComponents .get ("Annotation"),
         SupportedComponents .get ("CADGeometry"),
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("CubeMapTexturing"),
         SupportedComponents .get ("DIS"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("EnvironmentalSensor"),
         SupportedComponents .get ("EventUtilities"),
         SupportedComponents .get ("Followers"),
         SupportedComponents .get ("Geometry2D"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Geospatial"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("HAnim"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("KeyDeviceSensor"),
         SupportedComponents .get ("Layering"),
         SupportedComponents .get ("Layout"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("NURBS"),
         SupportedComponents .get ("ParticleSystems"),
         SupportedComponents .get ("Picking"),
         SupportedComponents .get ("PointingDeviceSensor"),
         SupportedComponents .get ("ProjectiveTextureMapping"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("RigidBodyPhysics"),
         SupportedComponents .get ("Scripting"),
         SupportedComponents .get ("Shaders"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Sound"),
         SupportedComponents .get ("Text"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Texturing3D"),
         SupportedComponents .get ("Time"),
         SupportedComponents .get ("VolumeRendering"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Immersive",
      name: "Immersive",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("EnvironmentalSensor"),
         SupportedComponents .get ("EventUtilities"),
         SupportedComponents .get ("Geometry2D"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("KeyDeviceSensor"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("PointingDeviceSensor"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Scripting"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Sound"),
         SupportedComponents .get ("Text"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Time"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Interactive",
      name: "Interactive",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("EnvironmentalSensor"),
         SupportedComponents .get ("EventUtilities"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("KeyDeviceSensor"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("PointingDeviceSensor"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Time"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Interchange",
      name: "Interchange",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Time"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "Medical interchange",
      name: "MedicalInterchange",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("EventUtilities"),
         SupportedComponents .get ("Geometry2D"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Text"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Texturing3D"),
         SupportedComponents .get ("Time"),
         SupportedComponents .get ("VolumeRendering"),
      ],
   });

   SupportedProfiles .addProfile ({
      title: "MPEG-4 interactive",
      name: "MPEG-4",
      providerUrl: urls .getProviderUrl (),
      components: [
         SupportedComponents .get ("Core"),
         SupportedComponents .get ("EnvironmentalEffects"),
         SupportedComponents .get ("EnvironmentalSensor"),
         SupportedComponents .get ("Geometry3D"),
         SupportedComponents .get ("Grouping"),
         SupportedComponents .get ("Interpolation"),
         SupportedComponents .get ("Lighting"),
         SupportedComponents .get ("Navigation"),
         SupportedComponents .get ("Networking"),
         SupportedComponents .get ("PointingDeviceSensor"),
         SupportedComponents .get ("Rendering"),
         SupportedComponents .get ("Shape"),
         SupportedComponents .get ("Texturing"),
         SupportedComponents .get ("Time"),
      ],
   });

   return SupportedProfiles;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/X3DBrowser',[
   "jquery",
   "x_ite/Browser/VERSION",
   "x_ite/Fields",
   "x_ite/Components",
   "x_ite/Components/Layering/X3DLayerNode",
   "x_ite/Browser/X3DBrowserContext",
   "x_ite/Configuration/ProfileInfo",
   "x_ite/Configuration/ComponentInfo",
   "x_ite/Configuration/SupportedProfiles",
   "x_ite/Configuration/SupportedComponents",
   "x_ite/Configuration/SupportedNodes",
   "x_ite/Execution/Scene",
   "x_ite/Execution/X3DScene",
   "x_ite/InputOutput/FileLoader",
   "x_ite/Parser/XMLParser",
   "x_ite/Parser/JSONParser",
   "x_ite/Base/X3DCast",
   "x_ite/Base/X3DConstants",
   "standard/Utility/MapUtilities",
   "locale/gettext",
],
function ($,
          VERSION,
          Fields,
          Components,
          X3DLayerNode,
          X3DBrowserContext,
          ProfileInfo,
          ComponentInfo,
          SupportedProfiles,
          SupportedComponents,
          SupportedNodes,
          Scene,
          X3DScene,
          FileLoader,
          XMLParser,
          JSONParser,
          X3DCast,
          X3DConstants,
          MapUtilities,
          _)
{
"use strict";

   const
      _loader           = Symbol (),
      _browserCallbacks = Symbol ();

   function X3DBrowser (element)
   {
      X3DBrowserContext .call (this, element);

      this [_browserCallbacks] = new Map ();

      this .replaceWorld (this .createScene ());
   };

   X3DBrowser .prototype = Object .assign (Object .create (X3DBrowserContext .prototype),
   {
      constructor: X3DBrowser,
      getTypeName: function ()
      {
         return "X3DBrowser";
      },
      getComponentName: function ()
      {
         return "X_ITE";
      },
      getContainerField: function ()
      {
         return "browser";
      },
      initialize: function ()
      {
         X3DBrowserContext .prototype .initialize .call (this);

         let urlCharacters = this .getElement () .attr ("src");

         if (urlCharacters)
            urlCharacters = '"' + urlCharacters + '"';
         else
            urlCharacters = this .getElement () .attr ("url");

         if (urlCharacters)
         {
            this .initialized () .set (this .getCurrentTime ());

            this .load (urlCharacters);
         }
         else
         {
            this .initialized () .setValue (this .getCurrentTime ());
            this .callBrowserCallbacks (X3DConstants .INITIALIZED_EVENT);
            this .callBrowserEventHandler ("onload");
         }

         // Print welcome message.

         if (this .getNumber () > 1) return;

         this .print ("Welcome to " + this .name + " X3D Browser " + this .version + ":\n" +
                      "   Current Graphics Renderer\n" +
                      "      Name: " + this .getVendor () + " " + this .getRenderer () + "\n" +
                      "      WebGL version: " + this .getWebGLVersion () + "\n" +
                      "      Shading language: " + this .getShadingLanguageVersion () + "\n" +
                      "   Rendering Properties\n" +
                      "      Antialiased: " + this .getAntialiased () + "\n" +
                      "      Depth size: " + this .getDepthSize () + " bits\n" +
                      "      Color depth: " + this .getColorDepth () + " bits\n" +
                      "      Max clip planes: " + this .getMaxClipPlanes () + "\n" +
                      "      Max global lights: " + this .getMaxLights () + "\n" +
                      "      Max textures: " + this .getMaxTextures () + "\n" +
                      "      Texture units: " + this .getMaxCombinedTextureUnits () + "\n" +
                      "      Max texture size: " + this .getMaxTextureSize () + " × " + this .getMaxTextureSize () + " pixel\n" +
                      "      Texture memory: " + this .getTextureMemory () + "\n" +
                      "      Max vertex uniform vectors: " + this .getMaxVertexUniformVectors () + "\n" +
                      "      Max fragment uniform vectors: " + this .getMaxFragmentUniformVectors () + "\n" +
                      "      Max vertex attribs: " + this .getMaxVertexAttribs () + "\n");
      },
      getName: function ()
      {
         return "X_ITE";
      },
      getVersion: function ()
      {
         return VERSION;
      },
      getDescription: function ()
      {
         return this .getNotification () ._string .getValue ()
      },
      setDescription: function (value)
      {
         this .getNotification () ._string = value;
      },
      getWorldURL: function ()
      {
         return this .currentScene .worldURL;
      },
      getProfile: function (name)
      {
         name = String (name);

         const profile = SupportedProfiles .get (name);

         if (profile)
            return profile;

         throw Error ("Profile '" + name + "' is not supported.");
      },
      getSupportedProfiles: function ()
      {
         return SupportedProfiles;
      },
      getComponent: function (name, level)
      {
         name  = String (name);
         level = ~~level;

         const component = SupportedComponents .get (name);

         if (component)
         {
            if (level <= component .level || true)
               return new ComponentInfo (name, level, component .title, component. providerUrl);
         }

         throw Error ("Component '" + name + "' at level '" + level + "' is not supported.");
      },
      getSupportedComponents: function ()
      {
         return SupportedComponents;
      },
      getSupportedNode: function (typeName)
      {
         return SupportedNodes .getType (String (typeName));
      },
      getSupportedNodes: function ()
      {
         return SupportedNodes .getTypes ();
      },
      createScene: function (profile, component1 /*, ...*/)
      {
         const scene = new Scene (this);

         if (arguments .length)
         {
            if (!(profile instanceof ProfileInfo))
               throw new Error ("Couldn't create scene: profile must be of type ProfileInfo.");

            scene .setProfile (profile);

            for (let i = 1, length = arguments .length; i < length; ++ i)
            {
               const component = arguments [i];

               if (!(component instanceof ComponentInfo))
                  throw new Error ("Couldn't create scene: component must be of type ComponentInfo.");

               scene .addComponent (component);
            }
         }

         scene .setup ();

         return scene;
      },
      replaceWorld: function (scene)
      {
         // Cancel any loading.

         this ._loadCount       .removeInterest ("set_loadCount__", this);
         this .prepareEvents () .removeInterest ("bind", this);

         if (this [_loader])
            this [_loader] .abort ();

         // Remove world.

         if (this .getWorld ())
         {
            this .getExecutionContext () .setLive (false);
            this .shutdown () .processInterests ();
            this .callBrowserCallbacks (X3DConstants .SHUTDOWN_EVENT);
            this .callBrowserEventHandler ("onshutdown");
         }

         // Replace world.

         if (scene instanceof Fields .MFNode)
         {
            // VRML version of replaceWorld has a MFNode value as argument.

            const rootNodes = scene;

            scene = this .createScene ();

            for (const rootNode of rootNodes)
               scene .isLive () .addInterest (rootNode .getValue () .getExecutionContext () .isLive ());

            scene .setRootNodes (rootNodes);
         }

         if (!(scene instanceof X3DScene))
            scene = this .createScene ();

         // Detach scene from parent.

         scene .getExecutionContext () .isLive () .removeInterest ("setLive", scene);
         scene .setExecutionContext (scene);

         // Replace.

         this .description = "";

         this .getBrowserOptions () .configure ();
         this .setBrowserLoading (true);
         this ._loadCount .addInterest ("set_loadCount__", this);
         this .prepareEvents () .removeInterest ("bind", this);

         for (const object of scene .getLoadingObjects ())
            this .addLoadCount (object);

         this .setExecutionContext (scene);
         this .getWorld () .bind ();

         scene .setLive (this .isLive () .getValue ());
      },
      set_loadCount__: function (loadCount)
      {
         if (loadCount .getValue ())
            return;

         this ._loadCount .removeInterest ("set_loadCount__", this);

         this .prepareEvents () .addInterest ("bind", this);
         this .addBrowserEvent ();
      },
      bind: function ()
      {
         this .prepareEvents () .removeInterest ("bind", this);

         this .setBrowserLoading (false);

         if (this .initialized () .getValue ())
         {
            this .initialized () .setValue (this .getCurrentTime ());
            this .callBrowserCallbacks (X3DConstants .INITIALIZED_EVENT);
            this .callBrowserEventHandler ("onload");
         }
      },
      createVrmlFromString: function (vrmlSyntax)
      {
         return this .createX3DFromString (vrmlSyntax) .rootNodes;
      },
      createX3DFromString: function (x3dSyntax)
      {
         x3dSyntax = String (x3dSyntax);

         const
            currentScene = this .currentScene,
            external     = this .isExternal (),
            fileLoader   = new FileLoader (this .getWorld ()),
            scene        = fileLoader .createX3DFromString (currentScene .getWorldURL (), x3dSyntax);

         if (!external)
         {
            currentScene .isLive () .addInterest ("setLive", scene);
            scene .setExecutionContext (currentScene);
            scene .setLive (currentScene .getLive ());
         }

         return scene;
      },
      createVrmlFromURL: function (url, node, event)
      {
         node  = X3DCast (X3DConstants .X3DNode, node, false);
         event = String (event);

         if (!(url instanceof Fields .MFString))
            throw new Error ("Browser.createVrmlFromURL: url must be of type MFString.");

         if (!node)
            throw new Error ("Browser.createVrmlFromURL: node must be of type X3DNode.");

         const field = node .getField (event);

         if (!field .isInput ())
            throw new Error ("Browser.createVrmlFromURL: event named '" + event + "' must be a input field.");

         if (field .getType () !== X3DConstants .MFNode)
            throw new Error ("Browser.createVrmlFromURL: event named '" + event + "' must be of type MFNode.");

         const
            currentScene = this .currentScene,
            external     = this .isExternal (),
            loader       = new FileLoader (this .getWorld ());

         this .addLoadCount (loader);

         loader .createX3DFromURL (url, null,
         function (scene)
         {
            this .removeLoadCount (loader);

            if (scene)
            {
               // Handle isLive for script scenes here:

               if (! external)
               {
                  currentScene .isLive () .addInterest ("setLive", scene);
                  scene .setExecutionContext (currentScene);
                  scene .setLive (currentScene .getLive ());
               }

               // Wait until scene is completely loaded, scene ._loadCount must be 0.
               field .setValue (scene .rootNodes);
            }
         }
         .bind (this));
      },
      createX3DFromURL: function (url, node, event)
      {
         if (arguments .length === 3)
            return this .createVrmlFromURL (url, node, event);

         // arguments .length === 1

         if (! (url instanceof Fields .MFString))
            throw new Error ("Browser.createX3DFromURL: url must be of type MFString.");

         const
            currentScene = this .currentScene,
            external     = this .isExternal (),
            fileLoader   = new FileLoader (this .getWorld ()),
            scene        = fileLoader .createX3DFromURL (url, null);

         if (! external)
         {
            currentScene .isLive () .addInterest ("setLive", scene);
            scene .setExecutionContext (currentScene);
            scene .setLive (currentScene .getLive ());
         }

         return scene;
      },
      loadURL: function (url, parameter = new Fields .MFString ())
      {
         return new Promise (function (resolve, reject)
         {
            if (!(url instanceof Fields .MFString))
               throw new Error ("Browser.loadURL: url must be of type MFString.");

            if (!(parameter instanceof Fields .MFString))
               throw new Error ("Browser.loadURL: parameter must be of type MFString.");

            // Cancel any loading.

            this ._loadCount       .removeInterest ("set_loadCount__", this);
            this .prepareEvents () .removeInterest ("bind", this);

            if (this [_loader])
               this [_loader] .abort ();

            // Start loading.

            this .setBrowserLoading (true);
            this .addLoadCount (this);

            const loader = this [_loader] = new FileLoader (this .getWorld ());

            loader .createX3DFromURL (url, parameter,
            function (scene)
            {
               if (loader !== this [_loader])
               {
                  reject ("Loading of X3D file aborted.");
                  return;
               }

               if (! this .getBrowserOptions () .getSplashScreen ())
                  this .getCanvas () .show ();

               if (scene)
               {
                  this .replaceWorld (scene);
                  this .removeLoadCount (this);

                  resolve ();
               }
               else
               {
                  this .callBrowserCallbacks (X3DConstants .CONNECTION_ERROR);
                  this .callBrowserEventHandler ("onerror");

                  setTimeout (function () { this .getSplashScreen () .find (".x_ite-private-spinner-text") .text (_ ("Failed loading world.")); } .bind (this), 31);

                  reject ("Couldn't load X3D file.");
               }
            }
            .bind (this),
            function (fragment)
            {
               if (loader !== this [_loader])
               {
                  reject ("Change viewpoint aborted.");
                  return;
               }

               this .changeViewpoint (fragment);
               this .removeLoadCount (this);
               this .setBrowserLoading (false);

               resolve ();
            }
            .bind (this),
            function (url, target)
            {
               if (loader !== this [_loader])
               {
                  reject ("Loading of file aborted.");
                  return;
               }

               if (target)
                  window .open (url, target);
               else
                  location = url;

               this .removeLoadCount (this);
               this .setBrowserLoading (false);

               resolve ();
            }
            .bind (this));
         }
         .bind (this));
      },
      addBrowserListener: function (callback, object)
      {
         // The string describes the name of the callback function to be called within the current ECMAScript context.
      },
      removeBrowserListener: function (callback)
      {
         // The string describes the name of the callback function to be called within the current ECMAScript context.
      },
      addBrowserCallback: function (key, object)
      {
         this [_browserCallbacks] .set (key, object);
      },
      removeBrowserCallback: function (key)
      {
         this [_browserCallbacks] .delete (key);
      },
      getBrowserCallbacks: function ()
      {
         return this [_browserCallbacks];
      },
      callBrowserCallbacks: (function ()
      {
         const browserCallbacks = [ ];

         return function (browserEvent)
         {
            if (this [_browserCallbacks] .size)
            {
               for (const browserCallback of MapUtilities .values (browserCallbacks, this [_browserCallbacks]))
               {
                  browserCallback (browserEvent);
               }
            }
         };
      })(),
      importDocument: function (dom, success, error)
      {
         const
            currentScene = this .currentScene,
            scene        = this .createScene (),
            external     = this .isExternal ();

         if (!external)
         {
            currentScene .isLive () .addInterest ("setLive", scene);
            scene .setExecutionContext (currentScene);
            scene .setLive (currentScene .getLive ());
         }

         const parser = new XMLParser (scene);

         parser .setInput (dom)
         parser .parseIntoScene (success, error);

         if (arguments .length === 1)
            return scene;
      },
      importJS: function (json, success, error)
      {
         const
            currentScene = this .currentScene,
            scene        = this .createScene (),
            external     = this .isExternal ();

         if (!external)
         {
            currentScene .isLive () .addInterest ("setLive", scene);
            scene .setExecutionContext (currentScene);
            scene .setLive (currentScene .getLive ());
         }

         const parser = new JSONParser (scene);

         parser .setInput (json);
         parser .parseIntoScene (success, error);

         if (arguments .length === 1)
            return scene;
      },
      getBrowserProperty: function (name)
      {
         return this .getBrowserProperties () .getField (name) .getValue ();
      },
      setBrowserOption: function (name, value)
      {
         this .getBrowserOptions () .getField (name) .setValue (value);
      },
      getBrowserOption: function (name)
      {
         return this .getBrowserOptions () .getField (name) .getValue ();
      },
      getRenderingProperty: function (name)
      {
         return this .getRenderingProperties () .getField (name) .getValue ();
      },
      firstViewpoint: function (layerNode)
      {
         layerNode = X3DCast (X3DConstants .X3DLayerNode, layerNode, false);

         if (!layerNode)
            layerNode = this .getActiveLayer ();

         const viewpoints = layerNode .getUserViewpoints ();

         if (viewpoints .length)
            this .bindViewpoint (layerNode, viewpoints [0]);
      },
      previousViewpoint: function (layerNode)
      {
         layerNode = X3DCast (X3DConstants .X3DLayerNode, layerNode, false);

         if (!layerNode)
            layerNode = this .getActiveLayer ();

         const viewpoints = layerNode .getUserViewpoints ();

         if (viewpoints .length === 0)
            return;

         for (var i = 0, length = viewpoints .length; i < length; ++ i)
         {
            if (viewpoints [i] ._isBound .getValue ())
               break;
         }

         if (i < viewpoints .length)
         {
            if (i === 0)
               this .bindViewpoint (layerNode, viewpoints .at (-1));

            else
               this .bindViewpoint (layerNode, viewpoints [i - 1]);
         }
         else
            this .bindViewpoint (layerNode, viewpoints .at (-1));
      },
      nextViewpoint: function (layerNode)
      {
         layerNode = X3DCast (X3DConstants .X3DLayerNode, layerNode, false);

         if (!layerNode)
            layerNode = this .getActiveLayer ();

         const viewpoints = layerNode .getUserViewpoints ();

         if (viewpoints .length === 0)
            return;

         for (var i = 0, length = viewpoints .length; i < length; ++ i)
         {
            if (viewpoints [i] ._isBound .getValue ())
               break;
         }

         if (i < viewpoints .length)
         {
            if (i === viewpoints .length - 1)
               this .bindViewpoint (layerNode, viewpoints [0]);

            else
               this .bindViewpoint (layerNode, viewpoints [i + 1]);
         }
         else
            this .bindViewpoint (layerNode, viewpoints [0]);
      },
      lastViewpoint: function (layerNode)
      {
         layerNode = X3DCast (X3DConstants .X3DLayerNode, layerNode, false);

         if (!layerNode)
            layerNode = this .getActiveLayer ();

         const viewpoints = layerNode .getUserViewpoints ();

         if (viewpoints .length)
            this .bindViewpoint (layerNode, viewpoints .at (-1));
      },
      changeViewpoint: function (layerNode, name)
      {
         if (arguments .length === 1)
         {
            name      = String (layerNode);
            layerNode = this .getActiveLayer ();
         }

         layerNode = X3DCast (X3DConstants .X3DLayerNode, layerNode, false);

         if (!layerNode)
            layerNode = this .getActiveLayer ();

         if (layerNode instanceof X3DLayerNode)
         {
            for (const viewpointNode of layerNode .getViewpoints () .get ())
            {
               if (viewpointNode .getName () === name)
               {
                  this .bindViewpoint (layerNode, viewpointNode);
                  break;
               }
            }
         }
      },
      bindViewpoint: function (layerNode, viewpointNode)
      {
         layerNode     = X3DCast (X3DConstants .X3DLayerNode,     layerNode,     false);
         viewpointNode = X3DCast (X3DConstants .X3DViewpointNode, viewpointNode, false);

         if (!layerNode)
            throw new Error ("Browser.bindViewpoint: layerNode must be of type X3DLayerNode.")

         if (!viewpointNode)
            throw new Error ("Browser.bindViewpoint: viewpointNode must be of type X3DViewpointNode.")

         viewpointNode .setVRMLTransition (true);

         if (viewpointNode ._isBound .getValue ())
            viewpointNode .transitionStart (layerNode, viewpointNode, viewpointNode);

         else
            viewpointNode ._set_bind = true;
      },
      addRoute: function (fromNode, fromEventOut, toNode, toEventIn)
      {
         this .currentScene .addRoute (fromNode, fromEventOut, toNode, toEventIn);
      },
      deleteRoute: function (fromNode, fromEventOut, toNode, toEventIn)
      {
         try
         {
            const route = this .currentScene .getRoute (fromNode, fromEventOut, toNode, toEventIn);

            if (route)
               this .currentScene .deleteRoute (route);
         }
         catch (error)
         {
            console .error (error);
         }
      },
      beginUpdate: function ()
      {
         this .setLive (true);
         this .getExecutionContext () .setLive (true);
         this .advanceTime (performance .now ());
         this .addBrowserEvent ();
      },
      endUpdate: function ()
      {
         this .setLive (false);
         this .getExecutionContext () .setLive (false);
      },
      print: function ()
      {
         const string = Array .prototype .join .call (arguments, "");

         console .log (string);

         const element = $(".x_ite-console");

         if (element .length)
            element .append (document .createTextNode (string));
      },
      println: function ()
      {
         const string = Array .prototype .join .call (arguments, "");

         console .log (string);

         const element = $(".x_ite-console");

         if (element .length)
            element .append (document .createTextNode (string + "\n"));
      },
      toVRMLStream: function (stream)
      {
         this .currentScene .toVRMLStream (stream);
      },
      toXMLStream: function (stream)
      {
         this .currentScene .toXMLStream (stream);
      },
      toJSONStream: function (stream)
      {
         this .currentScene .toJSONStream (stream);
      },
   });

   for (const key of Reflect .ownKeys (X3DBrowser .prototype))
      Object .defineProperty (X3DBrowser .prototype, key, { enumerable: false });

   Object .defineProperty (X3DBrowser .prototype, "name",
   {
      get: function () { return this .getName (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "version",
   {
      get: function () { return this .getVersion (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "currentFrameRate",
   {
      get: function () { return this .getCurrentFrameRate (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "currentSpeed",
   {
      get: function () { return this .getCurrentSpeed (); },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "description",
   {
      get: function ()
      {
         return this .getDescription ();
      },
      set: function (value)
      {
         this .setDescription (value);
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "currentScene",
   {
      get: function ()
      {
         return this .getScriptStack () .at (-1) .getExecutionContext ();
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "supportedProfiles",
   {
      get: function ()
      {
         return SupportedProfiles;
      },
      enumerable: true,
      configurable: false
   });

   Object .defineProperty (X3DBrowser .prototype, "supportedComponents",
   {
      get: function ()
      {
         return SupportedComponents;
      },
      enumerable: true,
      configurable: false
   });

   return X3DBrowser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fallback',[
   "jquery",
],
function ($)
{
"use strict";

   // Everything went wrong when the Error function is called.

   const Fallback =
   {
      error: function (error, fallbacks)
      {
         $(function ()
         {
            const elements = $("x3d-canvas, X3DCanvas");

            this .show (elements, error);

            for (const fallback of fallbacks)
            {
               if (typeof fallback === "function")
                  fallback (elements, error);
            }
         }
         .bind (this));
      },
      show: function (elements, error)
      {
         console .error (error);

         const consoleElement = $(".x_ite-console");

         if (consoleElement .length)
            consoleElement .append (document .createTextNode (error));

         // X3DCanvas
         elements .children (".x_ite-private-browser") .hide ();
         elements .children (":not(.x_ite-private-browser)") .show ();

         // x3d-canvas
         elements .each (function (i, e)
         {
            if (e .shadowRoot)
               e .shadowRoot .appendChild (document .createElement ("slot"));
         });
      },
   };

   return Fallback;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Time/MicroTime',[],function ()
{
"use strict";

   // Return a pseudo accurate timestamp.

   performance .now = (function ()
   {
      const now = performance .now;

      let
         offset = 0,
         last   = 0;

      return function ()
      {
         const current = now .call (this);

         if (current > last)
         {
            offset = 0;
            last   = current;

            return current;
         }
         else
         {
            return last = current + (++ offset / 1000);
         }
      };
   })();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/X3D',[
   "jquery",
   "x_ite/Base/X3DBaseNode",
   "x_ite/Base/X3DFieldDefinition",
   "x_ite/Base/FieldDefinitionArray",
   "x_ite/Base/X3DField",
   "x_ite/Base/X3DArrayField",
   "x_ite/Fields",
   "x_ite/Browser/X3DBrowser",
   "x_ite/Configuration/ComponentInfo",
   "x_ite/Configuration/ComponentInfoArray",
   "x_ite/Configuration/ProfileInfo",
   "x_ite/Configuration/ProfileInfoArray",
   "x_ite/Configuration/UnitInfo",
   "x_ite/Configuration/UnitInfoArray",
   "x_ite/Execution/X3DExecutionContext",
   "x_ite/Execution/X3DScene",
   "x_ite/Execution/X3DImportedNode",
   "x_ite/Execution/X3DExportedNode",
   "x_ite/Prototype/ExternProtoDeclarationArray",
   "x_ite/Prototype/ProtoDeclarationArray",
   "x_ite/Prototype/X3DExternProtoDeclaration",
   "x_ite/Prototype/X3DProtoDeclaration",
   "x_ite/Prototype/X3DProtoDeclarationNode",
   "x_ite/Routing/RouteArray",
   "x_ite/Routing/X3DRoute",
   "x_ite/Base/X3DConstants",
   "x_ite/Browser/Networking/urls",
   "x_ite/Fallback",
   "standard/Time/MicroTime",
],
function ($,
          X3DBaseNode,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DField,
          X3DArrayField,
          Fields,
          X3DBrowser,
          ComponentInfo,
          ComponentInfoArray,
          ProfileInfo,
          ProfileInfoArray,
          UnitInfo,
          UnitInfoArray,
          X3DExecutionContext,
          X3DScene,
          X3DImportedNode,
          X3DExportedNode,
          ExternProtoDeclarationArray,
          ProtoDeclarationArray,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          X3DProtoDeclarationNode,
          RouteArray,
          X3DRoute,
          X3DConstants,
          urls,
          Fallback,
          microtime)
{
"use strict";

   $ .noConflict (true);

   // X3D

   function getComponentUrl (name)
   {
      const url = urls .getProviderUrl (name);

      if (typeof __global_require__ === "function" && typeof __filename === "string")
         __global_require__ (__global_require__ ("url") .fileURLToPath (url));

      return url;
   }

   function createBrowser (url, parameter)
   {
      const element = $("<x3d-canvas></x3d-canvas>");

      if (url instanceof Fields .MFString)
          element .attr ("url", url .toString ())

      return element .get (0);
   }

   function getBrowser (element)
   {
      return $(element || "x3d-canvas, X3DCanvas") .data ("browser");
   }

   function createBrowserFromElement (element)
   {
      try
      {
         element = $(element);

         if (element .find (".x_ite-private-browser") .length)
            return;

         const browser = new X3DBrowser (element);

         element .data ("browser", browser);

         browser .setup ();

         setTimeout (function () { callbacks .resolve (); }, 1);

         return browser;
      }
      catch (error)
      {
         Fallback .show ($("x3d-canvas, X3DCanvas"), error);
         fallbacks .resolve (error);
      }
   }

   const
      callbacks = $.Deferred (),
      fallbacks = $.Deferred ();

   let initialized = false;

   function X3D (callback, fallback)
   {
      if (typeof callback === "function")
         callbacks .done (callback);

      if (typeof fallback === "function")
         fallbacks .done (fallback);

      if (initialized)
         return;

      initialized = true;

      $(function ()
      {
         const elements = $("X3DCanvas");

         if (elements .length)
            console .warn ("Use of <X3DCanvas> element is depreciated, please use <x3d-canvas> element instead.");

         $.map (elements, createBrowserFromElement);
      });
   }

   require .getComponentUrl = getComponentUrl;

   Object .assign (X3D,
   {
      hidden: [
         "hidden",
         "createBrowserFromElement",
      ],

      require:                     require,
      define:                      define,

      getBrowser:                  getBrowser,
      createBrowser:               createBrowser,
      createBrowserFromElement:    createBrowserFromElement,

      X3DConstants:                X3DConstants,
      X3DBrowser:                  X3DBrowser,
      X3DExecutionContext:         X3DExecutionContext,
      X3DScene:                    X3DScene,
      ComponentInfo:               ComponentInfo,
      ComponentInfoArray:          ComponentInfoArray,
      ProfileInfo:                 ProfileInfo,
      ProfileInfoArray:            ProfileInfoArray,
      UnitInfo:                    UnitInfo,
      UnitInfoArray:               UnitInfoArray,
      ExternProtoDeclarationArray: ExternProtoDeclarationArray,
      ProtoDeclarationArray:       ProtoDeclarationArray,
      X3DExternProtoDeclaration:   X3DExternProtoDeclaration,
      X3DProtoDeclaration:         X3DProtoDeclaration,
      RouteArray:                  RouteArray,
      X3DRoute:                    X3DRoute,

      // Additional classes
      X3DBaseNode:                 X3DBaseNode,
      X3DExportedNode:             X3DExportedNode,
      X3DImportedNode:             X3DImportedNode,
      X3DProtoDeclarationNode:     X3DProtoDeclarationNode,

      X3DFieldDefinition:          X3DFieldDefinition,
      FieldDefinitionArray:        FieldDefinitionArray,

      X3DField:                    X3DField,
      X3DArrayField:               X3DArrayField,

      SFColor:                     Fields .SFColor,
      SFColorRGBA:                 Fields .SFColorRGBA,
      SFImage:                     Fields .SFImage,
      SFMatrix3d:                  Fields .SFMatrix3d,
      SFMatrix3f:                  Fields .SFMatrix3f,
      SFMatrix4d:                  Fields .SFMatrix4d,
      SFMatrix4f:                  Fields .SFMatrix4f,
      SFNode:                      Fields .SFNode,
      SFRotation:                  Fields .SFRotation,
      SFVec2d:                     Fields .SFVec2d,
      SFVec2f:                     Fields .SFVec2f,
      SFVec3d:                     Fields .SFVec3d,
      SFVec3f:                     Fields .SFVec3f,
      SFVec4d:                     Fields .SFVec4d,
      SFVec4f:                     Fields .SFVec4f,
      VrmlMatrix:                  Fields .VrmlMatrix,

      MFBool:                      Fields .MFBool,
      MFColor:                     Fields .MFColor,
      MFColorRGBA:                 Fields .MFColorRGBA,
      MFDouble:                    Fields .MFDouble,
      MFFloat:                     Fields .MFFloat,
      MFImage:                     Fields .MFImage,
      MFInt32:                     Fields .MFInt32,
      MFMatrix3d:                  Fields .MFMatrix3d,
      MFMatrix3f:                  Fields .MFMatrix3f,
      MFMatrix4d:                  Fields .MFMatrix4d,
      MFMatrix4f:                  Fields .MFMatrix4f,
      MFNode:                      Fields .MFNode,
      MFRotation:                  Fields .MFRotation,
      MFString:                    Fields .MFString,
      MFTime:                      Fields .MFTime,
      MFVec2d:                     Fields .MFVec2d,
      MFVec2f:                     Fields .MFVec2f,
      MFVec3d:                     Fields .MFVec3d,
      MFVec3f:                     Fields .MFVec3f,
      MFVec4d:                     Fields .MFVec4d,
      MFVec4f:                     Fields .MFVec4f,
   });

   return X3D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

require .config ({
   "waitSeconds": 0, //The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.
});

define .show = function ()
{
   this   .define = window .define;
   window .define = this;
};

define .hide = function ()
{
   if (this .define === undefined)
      delete window .define;
   else
      window .define = this .define;

   delete this .define;
};

const getScriptURL = (function ()
{
   if (document .currentScript)
      var src = document .currentScript .src;
   else if (typeof __global_require__ === "function" && typeof __filename === "string")
      var src = __global_require__ ("url") .pathToFileURL (__filename) .href;

   return function ()
   {
      return src;
   };
})();

(function ()
{
"use strict";

   /**
    *
    * @param {function?} callback
    * @param {function?} fallback
    * @returns {Promise<void>} Promise
    */
   function X_ITE (callback, fallback)
   {
      return new Promise (function (resolve, reject)
      {
         require (["x_ite/X3D"], function (X3D)
         {
            X3D (callback, fallback);
            X3D (resolve, reject);
         },
         function () { if (typeof fallback === "function") fallback (); reject (); });
      });
   }

   function noConflict ()
   {
      if (window .X3D === X_ITE)
      {
         if (X3D_ === undefined)
            delete window .X3D;
         else
            window .X3D = X3D_;
      }

      return X_ITE;
   }

   X_ITE .noConflict = noConflict;
   X_ITE .require    = require;
   X_ITE .define     = define;

   // Save existing X3D object.
   const X3D_ = window .X3D;

   // Now assign our X3D.
   window .X3D                        = X_ITE;
   window [Symbol .for ("X_ITE.X3D-6.0.0")] = X_ITE;

   if (typeof __global_module__ === "object" && typeof __global_module__ .exports === "object")
      __global_module__ .exports = X_ITE;

   // Define custom element.

   // IE fix.
   document .createElement ("X3DCanvas");

   class X3DCanvas extends HTMLElement
   {
      constructor ()
      {
         super ();

         const
            shadow = this .attachShadow ({ mode: "open" }),
            link   = document .createElement ("link");

         shadow .loaded = new Promise (function (resolve, reject)
         {
            link .onload  = resolve;
            link .onerror = reject;
         });

         link .setAttribute ("rel", "stylesheet");
         link .setAttribute ("type", "text/css");
         link .setAttribute ("href", new URL ("x_ite.css", getScriptURL ()) .href);

         shadow .appendChild (link);

         require ([ "x_ite/X3D" ], function (X3D)
         {
            X3D .createBrowserFromElement (this);
         }
         .bind (this));
      }
   }

   customElements .define ("x3d-canvas", X3DCanvas);

   X_ITE .X3DCanvas = X3DCanvas;

   // Assign functions to X_ITE and init.

   require (["x_ite/X3D"], function (X3D)
   {
      Object .assign (X_ITE, X3D);

      for (const key of X3D .hidden)
         delete X_ITE [key];

      X3D ();
   });
})();

(function ()
{
   // Added at February 2022
   // https://github.com/tc39/proposal-relative-indexing-method#polyfill

   function at (n)
   {
      // ToInteger() abstract op
      n = Math.trunc(n) || 0;
      // Allow negative indexing from the end
      if (n < 0) n += this.length;
      // OOB access is guaranteed to return undefined
      if (n < 0 || n >= this.length) return undefined;
      // Otherwise, this is just normal property access
      return this[n];
   }

   const TypedArray = Reflect .getPrototypeOf (Int8Array);
   for (const C of [Array, String, TypedArray])
   {
      if (C .prototype .at === undefined)
      {
         Object .defineProperty (C .prototype, "at",
         {
            value: at,
            writable: true,
            enumerable: false,
            configurable: true,
         });
      }
   }
})();

define("x_ite", function(){});


define ('x_ite/Browser/Shaders/ShaderSource',[
],
function ()
{
"use strict";

	return {
		get: function (gl, source)
		{
			return source;
		},
	};
});

})));
